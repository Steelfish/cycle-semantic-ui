/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 215);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var symbol_observable_1 = __webpack_require__(171);
var NO = {};
exports.NO = NO;
function noop() { }
function cp(a) {
    var l = a.length;
    var b = Array(l);
    for (var i = 0; i < l; ++i)
        b[i] = a[i];
    return b;
}
function and(f1, f2) {
    return function andFn(t) {
        return f1(t) && f2(t);
    };
}
function _try(c, t, u) {
    try {
        return c.f(t);
    }
    catch (e) {
        u._e(e);
        return NO;
    }
}
var NO_IL = {
    _n: noop,
    _e: noop,
    _c: noop,
};
exports.NO_IL = NO_IL;
// mutates the input
function internalizeProducer(producer) {
    producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
    };
    producer._stop = producer.stop;
}
var StreamSub = (function () {
    function StreamSub(_stream, _listener) {
        this._stream = _stream;
        this._listener = _listener;
    }
    StreamSub.prototype.unsubscribe = function () {
        this._stream.removeListener(this._listener);
    };
    return StreamSub;
}());
var Observer = (function () {
    function Observer(_listener) {
        this._listener = _listener;
    }
    Observer.prototype.next = function (value) {
        this._listener._n(value);
    };
    Observer.prototype.error = function (err) {
        this._listener._e(err);
    };
    Observer.prototype.complete = function () {
        this._listener._c();
    };
    return Observer;
}());
var FromObservable = (function () {
    function FromObservable(observable) {
        this.type = 'fromObservable';
        this.ins = observable;
        this.active = false;
    }
    FromObservable.prototype._start = function (out) {
        this.out = out;
        this.active = true;
        this._sub = this.ins.subscribe(new Observer(out));
        if (!this.active)
            this._sub.unsubscribe();
    };
    FromObservable.prototype._stop = function () {
        if (this._sub)
            this._sub.unsubscribe();
        this.active = false;
    };
    return FromObservable;
}());
var Merge = (function () {
    function Merge(insArr) {
        this.type = 'merge';
        this.insArr = insArr;
        this.out = NO;
        this.ac = 0;
    }
    Merge.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var L = s.length;
        this.ac = L;
        for (var i = 0; i < L; i++)
            s[i]._add(this);
    };
    Merge.prototype._stop = function () {
        var s = this.insArr;
        var L = s.length;
        for (var i = 0; i < L; i++)
            s[i]._remove(this);
        this.out = NO;
    };
    Merge.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    Merge.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Merge.prototype._c = function () {
        if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
                return;
            u._c();
        }
    };
    return Merge;
}());
var CombineListener = (function () {
    function CombineListener(i, out, p) {
        this.i = i;
        this.out = out;
        this.p = p;
        p.ils.push(this);
    }
    CombineListener.prototype._n = function (t) {
        var p = this.p, out = this.out;
        if (out === NO)
            return;
        if (p.up(t, this.i))
            out._n(p.vals);
    };
    CombineListener.prototype._e = function (err) {
        var out = this.out;
        if (out === NO)
            return;
        out._e(err);
    };
    CombineListener.prototype._c = function () {
        var p = this.p;
        if (p.out === NO)
            return;
        if (--p.Nc === 0)
            p.out._c();
    };
    return CombineListener;
}());
var Combine = (function () {
    function Combine(insArr) {
        this.type = 'combine';
        this.insArr = insArr;
        this.out = NO;
        this.ils = [];
        this.Nc = this.Nn = 0;
        this.vals = [];
    }
    Combine.prototype.up = function (t, i) {
        var v = this.vals[i];
        var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
        this.vals[i] = t;
        return Nn === 0;
    };
    Combine.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var n = this.Nc = this.Nn = s.length;
        var vals = this.vals = new Array(n);
        if (n === 0) {
            out._n([]);
            out._c();
        }
        else {
            for (var i = 0; i < n; i++) {
                vals[i] = NO;
                s[i]._add(new CombineListener(i, out, this));
            }
        }
    };
    Combine.prototype._stop = function () {
        var s = this.insArr;
        var n = s.length;
        var ils = this.ils;
        for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
        this.out = NO;
        this.ils = [];
        this.vals = [];
    };
    return Combine;
}());
var FromArray = (function () {
    function FromArray(a) {
        this.type = 'fromArray';
        this.a = a;
    }
    FromArray.prototype._start = function (out) {
        var a = this.a;
        for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
        out._c();
    };
    FromArray.prototype._stop = function () {
    };
    return FromArray;
}());
var FromPromise = (function () {
    function FromPromise(p) {
        this.type = 'fromPromise';
        this.on = false;
        this.p = p;
    }
    FromPromise.prototype._start = function (out) {
        var prod = this;
        this.on = true;
        this.p.then(function (v) {
            if (prod.on) {
                out._n(v);
                out._c();
            }
        }, function (e) {
            out._e(e);
        }).then(noop, function (err) {
            setTimeout(function () { throw err; });
        });
    };
    FromPromise.prototype._stop = function () {
        this.on = false;
    };
    return FromPromise;
}());
var Periodic = (function () {
    function Periodic(period) {
        this.type = 'periodic';
        this.period = period;
        this.intervalID = -1;
        this.i = 0;
    }
    Periodic.prototype._start = function (out) {
        var self = this;
        function intervalHandler() { out._n(self.i++); }
        this.intervalID = setInterval(intervalHandler, this.period);
    };
    Periodic.prototype._stop = function () {
        if (this.intervalID !== -1)
            clearInterval(this.intervalID);
        this.intervalID = -1;
        this.i = 0;
    };
    return Periodic;
}());
var Debug = (function () {
    function Debug(ins, arg) {
        this.type = 'debug';
        this.ins = ins;
        this.out = NO;
        this.s = noop;
        this.l = '';
        if (typeof arg === 'string')
            this.l = arg;
        else if (typeof arg === 'function')
            this.s = arg;
    }
    Debug.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Debug.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Debug.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var s = this.s, l = this.l;
        if (s !== noop) {
            try {
                s(t);
            }
            catch (e) {
                u._e(e);
            }
        }
        else if (l)
            console.log(l + ':', t);
        else
            console.log(t);
        u._n(t);
    };
    Debug.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Debug.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Debug;
}());
var Drop = (function () {
    function Drop(max, ins) {
        this.type = 'drop';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.dropped = 0;
    }
    Drop.prototype._start = function (out) {
        this.out = out;
        this.dropped = 0;
        this.ins._add(this);
    };
    Drop.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Drop.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        if (this.dropped++ >= this.max)
            u._n(t);
    };
    Drop.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Drop.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Drop;
}());
var EndWhenListener = (function () {
    function EndWhenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    EndWhenListener.prototype._n = function () {
        this.op.end();
    };
    EndWhenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    EndWhenListener.prototype._c = function () {
        this.op.end();
    };
    return EndWhenListener;
}());
var EndWhen = (function () {
    function EndWhen(o, ins) {
        this.type = 'endWhen';
        this.ins = ins;
        this.out = NO;
        this.o = o;
        this.oil = NO_IL;
    }
    EndWhen.prototype._start = function (out) {
        this.out = out;
        this.o._add(this.oil = new EndWhenListener(out, this));
        this.ins._add(this);
    };
    EndWhen.prototype._stop = function () {
        this.ins._remove(this);
        this.o._remove(this.oil);
        this.out = NO;
        this.oil = NO_IL;
    };
    EndWhen.prototype.end = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    EndWhen.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    EndWhen.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    EndWhen.prototype._c = function () {
        this.end();
    };
    return EndWhen;
}());
var Filter = (function () {
    function Filter(passes, ins) {
        this.type = 'filter';
        this.ins = ins;
        this.out = NO;
        this.f = passes;
    }
    Filter.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Filter.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Filter.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO || !r)
            return;
        u._n(t);
    };
    Filter.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Filter.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Filter;
}());
var FlattenListener = (function () {
    function FlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    FlattenListener.prototype._n = function (t) {
        this.out._n(t);
    };
    FlattenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    FlattenListener.prototype._c = function () {
        this.op.inner = NO;
        this.op.less();
    };
    return FlattenListener;
}());
var Flatten = (function () {
    function Flatten(ins) {
        this.type = 'flatten';
        this.ins = ins;
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    }
    Flatten.prototype._start = function (out) {
        this.out = out;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
        this.ins._add(this);
    };
    Flatten.prototype._stop = function () {
        this.ins._remove(this);
        if (this.inner !== NO)
            this.inner._remove(this.il);
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    };
    Flatten.prototype.less = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (!this.open && this.inner === NO)
            u._c();
    };
    Flatten.prototype._n = function (s) {
        var u = this.out;
        if (u === NO)
            return;
        var _a = this, inner = _a.inner, il = _a.il;
        if (inner !== NO && il !== NO_IL)
            inner._remove(il);
        (this.inner = s)._add(this.il = new FlattenListener(u, this));
    };
    Flatten.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Flatten.prototype._c = function () {
        this.open = false;
        this.less();
    };
    return Flatten;
}());
var Fold = (function () {
    function Fold(f, seed, ins) {
        var _this = this;
        this.type = 'fold';
        this.ins = ins;
        this.out = NO;
        this.f = function (t) { return f(_this.acc, t); };
        this.acc = this.seed = seed;
    }
    Fold.prototype._start = function (out) {
        this.out = out;
        this.acc = this.seed;
        out._n(this.acc);
        this.ins._add(this);
    };
    Fold.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.acc = this.seed;
    };
    Fold.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(this.acc = r);
    };
    Fold.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Fold.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Fold;
}());
var Last = (function () {
    function Last(ins) {
        this.type = 'last';
        this.ins = ins;
        this.out = NO;
        this.has = false;
        this.val = NO;
    }
    Last.prototype._start = function (out) {
        this.out = out;
        this.has = false;
        this.ins._add(this);
    };
    Last.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.val = NO;
    };
    Last.prototype._n = function (t) {
        this.has = true;
        this.val = t;
    };
    Last.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Last.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (this.has) {
            u._n(this.val);
            u._c();
        }
        else
            u._e(new Error('last() failed because input stream completed'));
    };
    return Last;
}());
var MapFlattenListener = (function () {
    function MapFlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    MapFlattenListener.prototype._n = function (r) {
        this.out._n(r);
    };
    MapFlattenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    MapFlattenListener.prototype._c = function () {
        this.op.inner = NO;
        this.op.less();
    };
    return MapFlattenListener;
}());
var MapFlatten = (function () {
    function MapFlatten(mapOp) {
        this.type = mapOp.type + "+flatten";
        this.ins = mapOp.ins;
        this.out = NO;
        this.mapOp = mapOp;
        this.inner = NO;
        this.il = NO_IL;
        this.open = true;
    }
    MapFlatten.prototype._start = function (out) {
        this.out = out;
        this.inner = NO;
        this.il = NO_IL;
        this.open = true;
        this.mapOp.ins._add(this);
    };
    MapFlatten.prototype._stop = function () {
        this.mapOp.ins._remove(this);
        if (this.inner !== NO)
            this.inner._remove(this.il);
        this.out = NO;
        this.inner = NO;
        this.il = NO_IL;
    };
    MapFlatten.prototype.less = function () {
        if (!this.open && this.inner === NO) {
            var u = this.out;
            if (u === NO)
                return;
            u._c();
        }
    };
    MapFlatten.prototype._n = function (v) {
        var u = this.out;
        if (u === NO)
            return;
        var _a = this, inner = _a.inner, il = _a.il;
        var s = _try(this.mapOp, v, u);
        if (s === NO)
            return;
        if (inner !== NO && il !== NO_IL)
            inner._remove(il);
        (this.inner = s)._add(this.il = new MapFlattenListener(u, this));
    };
    MapFlatten.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    MapFlatten.prototype._c = function () {
        this.open = false;
        this.less();
    };
    return MapFlatten;
}());
var MapOp = (function () {
    function MapOp(project, ins) {
        this.type = 'map';
        this.ins = ins;
        this.out = NO;
        this.f = project;
    }
    MapOp.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    MapOp.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    MapOp.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(r);
    };
    MapOp.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    MapOp.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return MapOp;
}());
var FilterMapFusion = (function (_super) {
    __extends(FilterMapFusion, _super);
    function FilterMapFusion(passes, project, ins) {
        var _this = _super.call(this, project, ins) || this;
        _this.type = 'filter+map';
        _this.passes = passes;
        return _this;
    }
    FilterMapFusion.prototype._n = function (t) {
        if (!this.passes(t))
            return;
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(r);
    };
    return FilterMapFusion;
}(MapOp));
var Remember = (function () {
    function Remember(ins) {
        this.type = 'remember';
        this.ins = ins;
        this.out = NO;
    }
    Remember.prototype._start = function (out) {
        this.out = out;
        this.ins._add(out);
    };
    Remember.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return Remember;
}());
var ReplaceError = (function () {
    function ReplaceError(replacer, ins) {
        this.type = 'replaceError';
        this.ins = ins;
        this.out = NO;
        this.f = replacer;
    }
    ReplaceError.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    ReplaceError.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    ReplaceError.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    ReplaceError.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
        }
        catch (e) {
            u._e(e);
        }
    };
    ReplaceError.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return ReplaceError;
}());
var StartWith = (function () {
    function StartWith(ins, val) {
        this.type = 'startWith';
        this.ins = ins;
        this.out = NO;
        this.val = val;
    }
    StartWith.prototype._start = function (out) {
        this.out = out;
        this.out._n(this.val);
        this.ins._add(out);
    };
    StartWith.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return StartWith;
}());
var Take = (function () {
    function Take(max, ins) {
        this.type = 'take';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.taken = 0;
    }
    Take.prototype._start = function (out) {
        this.out = out;
        this.taken = 0;
        if (this.max <= 0)
            out._c();
        else
            this.ins._add(this);
    };
    Take.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Take.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var m = ++this.taken;
        if (m < this.max)
            u._n(t);
        else if (m === this.max) {
            u._n(t);
            u._c();
        }
    };
    Take.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Take.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Take;
}());
var Stream = (function () {
    function Stream(producer) {
        this._prod = producer || NO;
        this._ils = [];
        this._stopID = NO;
        this._dl = NO;
        this._d = false;
        this._target = NO;
        this._err = NO;
    }
    Stream.prototype._n = function (t) {
        var a = this._ils;
        var L = a.length;
        if (this._d)
            this._dl._n(t);
        if (L == 1)
            a[0]._n(t);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._n(t);
        }
    };
    Stream.prototype._e = function (err) {
        if (this._err !== NO)
            return;
        this._err = err;
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._e(err);
        if (L == 1)
            a[0]._e(err);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._e(err);
        }
        if (!this._d && L == 0)
            throw this._err;
    };
    Stream.prototype._c = function () {
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._c();
        if (L == 1)
            a[0]._c();
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._c();
        }
    };
    Stream.prototype._x = function () {
        if (this._ils.length === 0)
            return;
        if (this._prod !== NO)
            this._prod._stop();
        this._err = NO;
        this._ils = [];
    };
    Stream.prototype._stopNow = function () {
        // WARNING: code that calls this method should
        // first check if this._prod is valid (not `NO`)
        this._prod._stop();
        this._err = NO;
        this._stopID = NO;
    };
    Stream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1)
            return;
        if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    Stream.prototype._remove = function (il) {
        var _this = this;
        var ta = this._target;
        if (ta !== NO)
            return ta._remove(il);
        var a = this._ils;
        var i = a.indexOf(il);
        if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
                this._err = NO;
                this._stopID = setTimeout(function () { return _this._stopNow(); });
            }
            else if (a.length === 1) {
                this._pruneCycles();
            }
        }
    };
    // If all paths stemming from `this` stream eventually end at `this`
    // stream, then we remove the single listener of `this` stream, to
    // force it to end its execution and dispose resources. This method
    // assumes as a precondition that this._ils has just one listener.
    Stream.prototype._pruneCycles = function () {
        if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
    };
    // Checks whether *there is no* path starting from `x` that leads to an end
    // listener (sink) in the stream graph, following edges A->B where B is a
    // listener of A. This means these paths constitute a cycle somehow. Is given
    // a trace of all visited nodes so far.
    Stream.prototype._hasNoSinks = function (x, trace) {
        if (trace.indexOf(x) !== -1)
            return true;
        else if (x.out === this)
            return true;
        else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
        else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
                if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                    return false;
            return true;
        }
        else
            return false;
    };
    Stream.prototype.ctor = function () {
        return this instanceof MemoryStream ? MemoryStream : Stream;
    };
    /**
     * Adds a Listener to the Stream.
     *
     * @param {Listener} listener
     */
    Stream.prototype.addListener = function (listener) {
        listener._n = listener.next || noop;
        listener._e = listener.error || noop;
        listener._c = listener.complete || noop;
        this._add(listener);
    };
    /**
     * Removes a Listener from the Stream, assuming the Listener was added to it.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.removeListener = function (listener) {
        this._remove(listener);
    };
    /**
     * Adds a Listener to the Stream returning a Subscription to remove that
     * listener.
     *
     * @param {Listener} listener
     * @returns {Subscription}
     */
    Stream.prototype.subscribe = function (listener) {
        this.addListener(listener);
        return new StreamSub(this, listener);
    };
    /**
     * Add interop between most.js and RxJS 5
     *
     * @returns {Stream}
     */
    Stream.prototype[symbol_observable_1.default] = function () {
        return this;
    };
    /**
     * Creates a new Stream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {Stream}
     */
    Stream.create = function (producer) {
        if (producer) {
            if (typeof producer.start !== 'function'
                || typeof producer.stop !== 'function')
                throw new Error('producer requires both start and stop functions');
            internalizeProducer(producer); // mutates the input
        }
        return new Stream(producer);
    };
    /**
     * Creates a new MemoryStream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {MemoryStream}
     */
    Stream.createWithMemory = function (producer) {
        if (producer)
            internalizeProducer(producer); // mutates the input
        return new MemoryStream(producer);
    };
    /**
     * Creates a Stream that does nothing when started. It never emits any event.
     *
     * Marble diagram:
     *
     * ```text
     *          never
     * -----------------------
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.never = function () {
        return new Stream({ _start: noop, _stop: noop });
    };
    /**
     * Creates a Stream that immediately emits the "complete" notification when
     * started, and that's it.
     *
     * Marble diagram:
     *
     * ```text
     * empty
     * -|
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.empty = function () {
        return new Stream({
            _start: function (il) { il._c(); },
            _stop: noop,
        });
    };
    /**
     * Creates a Stream that immediately emits an "error" notification with the
     * value you passed as the `error` argument when the stream starts, and that's
     * it.
     *
     * Marble diagram:
     *
     * ```text
     * throw(X)
     * -X
     * ```
     *
     * @factory true
     * @param error The error event to emit on the created stream.
     * @return {Stream}
     */
    Stream.throw = function (error) {
        return new Stream({
            _start: function (il) { il._e(error); },
            _stop: noop,
        });
    };
    /**
     * Creates a stream from an Array, Promise, or an Observable.
     *
     * @factory true
     * @param {Array|Promise|Observable} input The input to make a stream from.
     * @return {Stream}
     */
    Stream.from = function (input) {
        if (typeof input[symbol_observable_1.default] === 'function')
            return Stream.fromObservable(input);
        else if (typeof input.then === 'function')
            return Stream.fromPromise(input);
        else if (Array.isArray(input))
            return Stream.fromArray(input);
        throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    };
    /**
     * Creates a Stream that immediately emits the arguments that you give to
     * *of*, then completes.
     *
     * Marble diagram:
     *
     * ```text
     * of(1,2,3)
     * 123|
     * ```
     *
     * @factory true
     * @param a The first value you want to emit as an event on the stream.
     * @param b The second value you want to emit as an event on the stream. One
     * or more of these values may be given as arguments.
     * @return {Stream}
     */
    Stream.of = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        return Stream.fromArray(items);
    };
    /**
     * Converts an array to a stream. The returned stream will emit synchronously
     * all the items in the array, and then complete.
     *
     * Marble diagram:
     *
     * ```text
     * fromArray([1,2,3])
     * 123|
     * ```
     *
     * @factory true
     * @param {Array} array The array to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromArray = function (array) {
        return new Stream(new FromArray(array));
    };
    /**
     * Converts a promise to a stream. The returned stream will emit the resolved
     * value of the promise, and then complete. However, if the promise is
     * rejected, the stream will emit the corresponding error.
     *
     * Marble diagram:
     *
     * ```text
     * fromPromise( ----42 )
     * -----------------42|
     * ```
     *
     * @factory true
     * @param {Promise} promise The promise to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromPromise = function (promise) {
        return new Stream(new FromPromise(promise));
    };
    /**
     * Converts an Observable into a Stream.
     *
     * @factory true
     * @param {any} observable The observable to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromObservable = function (obs) {
        if (obs.endWhen)
            return obs;
        return new Stream(new FromObservable(obs));
    };
    /**
     * Creates a stream that periodically emits incremental numbers, every
     * `period` milliseconds.
     *
     * Marble diagram:
     *
     * ```text
     *     periodic(1000)
     * ---0---1---2---3---4---...
     * ```
     *
     * @factory true
     * @param {number} period The interval in milliseconds to use as a rate of
     * emission.
     * @return {Stream}
     */
    Stream.periodic = function (period) {
        return new Stream(new Periodic(period));
    };
    Stream.prototype._map = function (project) {
        var p = this._prod;
        var ctor = this.ctor();
        if (p instanceof Filter)
            return new ctor(new FilterMapFusion(p.f, project, p.ins));
        return new ctor(new MapOp(project, this));
    };
    /**
     * Transforms each event from the input Stream through a `project` function,
     * to get a Stream that emits those transformed events.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7------
     *    map(i => i * 10)
     * --10--30-50----70-----
     * ```
     *
     * @param {Function} project A function of type `(t: T) => U` that takes event
     * `t` of type `T` from the input Stream and produces an event of type `U`, to
     * be emitted on the output Stream.
     * @return {Stream}
     */
    Stream.prototype.map = function (project) {
        return this._map(project);
    };
    /**
     * It's like `map`, but transforms each input event to always the same
     * constant value on the output Stream.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7-----
     *       mapTo(10)
     * --10--10-10----10----
     * ```
     *
     * @param projectedValue A value to emit on the output Stream whenever the
     * input Stream emits any value.
     * @return {Stream}
     */
    Stream.prototype.mapTo = function (projectedValue) {
        var s = this.map(function () { return projectedValue; });
        var op = s._prod;
        op.type = op.type.replace('map', 'mapTo');
        return s;
    };
    /**
     * Only allows events that pass the test given by the `passes` argument.
     *
     * Each event from the input stream is given to the `passes` function. If the
     * function returns `true`, the event is forwarded to the output stream,
     * otherwise it is ignored and not forwarded.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2--3-----4-----5---6--7-8--
     *     filter(i => i % 2 === 0)
     * ------2--------4---------6----8--
     * ```
     *
     * @param {Function} passes A function of type `(t: T) +> boolean` that takes
     * an event from the input stream and checks if it passes, by returning a
     * boolean.
     * @return {Stream}
     */
    Stream.prototype.filter = function (passes) {
        var p = this._prod;
        if (p instanceof Filter)
            return new Stream(new Filter(and(p.f, passes), p.ins));
        return new Stream(new Filter(passes, this));
    };
    /**
     * Lets the first `amount` many events from the input stream pass to the
     * output stream, then makes the output stream complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *    take(3)
     * --a---b--c|
     * ```
     *
     * @param {number} amount How many events to allow from the input stream
     * before completing the output stream.
     * @return {Stream}
     */
    Stream.prototype.take = function (amount) {
        return new (this.ctor())(new Take(amount, this));
    };
    /**
     * Ignores the first `amount` many events from the input stream, and then
     * after that starts forwarding events from the input stream to the output
     * stream.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *       drop(3)
     * --------------d---e--
     * ```
     *
     * @param {number} amount How many events to ignore from the input stream
     * before forwarding all events from the input stream to the output stream.
     * @return {Stream}
     */
    Stream.prototype.drop = function (amount) {
        return new Stream(new Drop(amount, this));
    };
    /**
     * When the input stream completes, the output stream will emit the last event
     * emitted by the input stream, and then will also complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c--d----|
     *       last()
     * -----------------d|
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.last = function () {
        return new Stream(new Last(this));
    };
    /**
     * Prepends the given `initial` value to the sequence of events emitted by the
     * input stream. The returned stream is a MemoryStream, which means it is
     * already `remember()`'d.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3---
     *   startWith(0)
     * 0--1---2-----3---
     * ```
     *
     * @param initial The value or event to prepend.
     * @return {MemoryStream}
     */
    Stream.prototype.startWith = function (initial) {
        return new MemoryStream(new StartWith(this, initial));
    };
    /**
     * Uses another stream to determine when to complete the current stream.
     *
     * When the given `other` stream emits an event or completes, the output
     * stream will complete. Before that happens, the output stream will behaves
     * like the input stream.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3--4----5----6---
     *   endWhen( --------a--b--| )
     * ---1---2-----3--4--|
     * ```
     *
     * @param other Some other stream that is used to know when should the output
     * stream of this operator complete.
     * @return {Stream}
     */
    Stream.prototype.endWhen = function (other) {
        return new (this.ctor())(new EndWhen(other, this));
    };
    /**
     * "Folds" the stream onto itself.
     *
     * Combines events from the past throughout
     * the entire execution of the input stream, allowing you to accumulate them
     * together. It's essentially like `Array.prototype.reduce`. The returned
     * stream is a MemoryStream, which means it is already `remember()`'d.
     *
     * The output stream starts by emitting the `seed` which you give as argument.
     * Then, when an event happens on the input stream, it is combined with that
     * seed value through the `accumulate` function, and the output value is
     * emitted on the output stream. `fold` remembers that output value as `acc`
     * ("accumulator"), and then when a new input event `t` happens, `acc` will be
     * combined with that to produce the new `acc` and so forth.
     *
     * Marble diagram:
     *
     * ```text
     * ------1-----1--2----1----1------
     *   fold((acc, x) => acc + x, 3)
     * 3-----4-----5--7----8----9------
     * ```
     *
     * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that
     * takes the previous accumulated value `acc` and the incoming event from the
     * input stream and produces the new accumulated value.
     * @param seed The initial accumulated value, of type `R`.
     * @return {MemoryStream}
     */
    Stream.prototype.fold = function (accumulate, seed) {
        return new MemoryStream(new Fold(accumulate, seed, this));
    };
    /**
     * Replaces an error with another stream.
     *
     * When (and if) an error happens on the input stream, instead of forwarding
     * that error to the output stream, *replaceError* will call the `replace`
     * function which returns the stream that the output stream will replicate.
     * And, in case that new stream also emits an error, `replace` will be called
     * again to get another stream to start replicating.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2-----3--4-----X
     *   replaceError( () => --10--| )
     * --1---2-----3--4--------10--|
     * ```
     *
     * @param {Function} replace A function of type `(err) => Stream` that takes
     * the error that occurred on the input stream or on the previous replacement
     * stream and returns a new stream. The output stream will behave like the
     * stream that this function returns.
     * @return {Stream}
     */
    Stream.prototype.replaceError = function (replace) {
        return new (this.ctor())(new ReplaceError(replace, this));
    };
    /**
     * Flattens a "stream of streams", handling only one nested stream at a time
     * (no concurrency).
     *
     * If the input stream is a stream that emits streams, then this operator will
     * return an output stream which is a flat stream: emits regular events. The
     * flattening happens without concurrency. It works like this: when the input
     * stream emits a nested stream, *flatten* will start imitating that nested
     * one. However, as soon as the next nested stream is emitted on the input
     * stream, *flatten* will forget the previous nested one it was imitating, and
     * will start imitating the new nested one.
     *
     * Marble diagram:
     *
     * ```text
     * --+--------+---------------
     *   \        \
     *    \       ----1----2---3--
     *    --a--b----c----d--------
     *           flatten
     * -----a--b------1----2---3--
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.flatten = function () {
        var p = this._prod;
        return new Stream(p instanceof MapOp && !(p instanceof FilterMapFusion) ?
            new MapFlatten(p) :
            new Flatten(this));
    };
    /**
     * Passes the input stream to a custom operator, to produce an output stream.
     *
     * *compose* is a handy way of using an existing function in a chained style.
     * Instead of writing `outStream = f(inStream)` you can write
     * `outStream = inStream.compose(f)`.
     *
     * @param {function} operator A function that takes a stream as input and
     * returns a stream as well.
     * @return {Stream}
     */
    Stream.prototype.compose = function (operator) {
        return operator(this);
    };
    /**
     * Returns an output stream that behaves like the input stream, but also
     * remembers the most recent event that happens on the input stream, so that a
     * newly added listener will immediately receive that memorised event.
     *
     * @return {MemoryStream}
     */
    Stream.prototype.remember = function () {
        return new MemoryStream(new Remember(this));
    };
    /**
     * Returns an output stream that identically behaves like the input stream,
     * but also runs a `spy` function fo each event, to help you debug your app.
     *
     * *debug* takes a `spy` function as argument, and runs that for each event
     * happening on the input stream. If you don't provide the `spy` argument,
     * then *debug* will just `console.log` each event. This helps you to
     * understand the flow of events through some operator chain.
     *
     * Please note that if the output stream has no listeners, then it will not
     * start, which means `spy` will never run because no actual event happens in
     * that case.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3-----4--
     *         debug
     * --1----2-----3-----4--
     * ```
     *
     * @param {function} labelOrSpy A string to use as the label when printing
     * debug information on the console, or a 'spy' function that takes an event
     * as argument, and does not need to return anything.
     * @return {Stream}
     */
    Stream.prototype.debug = function (labelOrSpy) {
        return new (this.ctor())(new Debug(this, labelOrSpy));
    };
    /**
     * *imitate* changes this current Stream to emit the same events that the
     * `other` given Stream does. This method returns nothing.
     *
     * This method exists to allow one thing: **circular dependency of streams**.
     * For instance, let's imagine that for some reason you need to create a
     * circular dependency where stream `first$` depends on stream `second$`
     * which in turn depends on `first$`:
     *
     * <!-- skip-example -->
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var first$ = second$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * ```
     *
     * However, that is invalid JavaScript, because `second$` is undefined
     * on the first line. This is how *imitate* can help solve it:
     *
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var secondProxy$ = xs.create();
     * var first$ = secondProxy$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * secondProxy$.imitate(second$);
     * ```
     *
     * We create `secondProxy$` before the others, so it can be used in the
     * declaration of `first$`. Then, after both `first$` and `second$` are
     * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell
     * that they are "the same". `imitate` will not trigger the start of any
     * stream, it just binds `secondProxy$` and `second$` together.
     *
     * The following is an example where `imitate()` is important in Cycle.js
     * applications. A parent component contains some child components. A child
     * has an action stream which is given to the parent to define its state:
     *
     * <!-- skip-example -->
     * ```js
     * const childActionProxy$ = xs.create();
     * const parent = Parent({...sources, childAction$: childActionProxy$});
     * const childAction$ = parent.state$.map(s => s.child.action$).flatten();
     * childActionProxy$.imitate(childAction$);
     * ```
     *
     * Note, though, that **`imitate()` does not support MemoryStreams**. If we
     * would attempt to imitate a MemoryStream in a circular dependency, we would
     * either get a race condition (where the symptom would be "nothing happens")
     * or an infinite cyclic emission of values. It's useful to think about
     * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to
     * define a spreadsheet cell `A1` with a formula that depends on `B1` and
     * cell `B1` defined with a formula that depends on `A1`.
     *
     * If you find yourself wanting to use `imitate()` with a
     * MemoryStream, you should rework your code around `imitate()` to use a
     * Stream instead. Look for the stream in the circular dependency that
     * represents an event stream, and that would be a candidate for creating a
     * proxy Stream which then imitates the target Stream.
     *
     * @param {Stream} target The other stream to imitate on the current one. Must
     * not be a MemoryStream.
     */
    Stream.prototype.imitate = function (target) {
        if (target instanceof MemoryStream)
            throw new Error('A MemoryStream was given to imitate(), but it only ' +
                'supports a Stream. Read more about this restriction here: ' +
                'https://github.com/staltz/xstream#faq');
        this._target = target;
        for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
        this._ils = [];
    };
    /**
     * Forces the Stream to emit the given value to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param value The "next" value you want to broadcast to all listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendNext = function (value) {
        this._n(value);
    };
    /**
     * Forces the Stream to emit the given error to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param {any} error The error you want to broadcast to all the listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendError = function (error) {
        this._e(error);
    };
    /**
     * Forces the Stream to emit the "completed" event to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     */
    Stream.prototype.shamefullySendComplete = function () {
        this._c();
    };
    /**
     * Adds a "debug" listener to the stream. There can only be one debug
     * listener, that's why this is 'setDebugListener'. To remove the debug
     * listener, just call setDebugListener(null).
     *
     * A debug listener is like any other listener. The only difference is that a
     * debug listener is "stealthy": its presence/absence does not trigger the
     * start/stop of the stream (or the producer inside the stream). This is
     * useful so you can inspect what is going on without changing the behavior
     * of the program. If you have an idle stream and you add a normal listener to
     * it, the stream will start executing. But if you set a debug listener on an
     * idle stream, it won't start executing (not until the first normal listener
     * is added).
     *
     * As the name indicates, we don't recommend using this method to build app
     * logic. In fact, in most cases the debug operator works just fine. Only use
     * this one if you know what you're doing.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.setDebugListener = function (listener) {
        if (!listener) {
            this._d = false;
            this._dl = NO;
        }
        else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
        }
    };
    return Stream;
}());
/**
 * Blends multiple streams together, emitting events from all of them
 * concurrently.
 *
 * *merge* takes multiple streams as arguments, and creates a stream that
 * behaves like each of the argument streams, in parallel.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2-----3--------4---
 * ----a-----b----c---d------
 *            merge
 * --1-a--2--b--3-c---d--4---
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to merge together with other streams.
 * @param {Stream} stream2 A stream to merge together with other streams. Two
 * or more streams may be given as arguments.
 * @return {Stream}
 */
Stream.merge = function merge() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new Stream(new Merge(streams));
};
/**
 * Combines multiple input streams together to return a stream whose events
 * are arrays that collect the latest events from each input stream.
 *
 * *combine* internally remembers the most recent event from each of the input
 * streams. When any of the input streams emits an event, that event together
 * with all the other saved events are combined into an array. That array will
 * be emitted on the output stream. It's essentially a way of joining together
 * the events from multiple streams.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2-----3--------4---
 * ----a-----b-----c--d------
 *          combine
 * ----1a-2a-2b-3b-3c-3d-4d--
 * ```
 *
 * Note: to minimize garbage collection, *combine* uses the same array
 * instance for each emission.  If you need to compare emissions over time,
 * cache the values with `map` first:
 *
 * ```js
 * import pairwise from 'xstream/extra/pairwise'
 *
 * const stream1 = xs.of(1);
 * const stream2 = xs.of(2);
 *
 * xs.combine(stream1, stream2).map(
 *   combinedEmissions => ([ ...combinedEmissions ])
 * ).compose(pairwise)
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to combine together with other streams.
 * @param {Stream} stream2 A stream to combine together with other streams.
 * Multiple streams, not just two, may be given as arguments.
 * @return {Stream}
 */
Stream.combine = function combine() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new Stream(new Combine(streams));
};
exports.Stream = Stream;
var MemoryStream = (function (_super) {
    __extends(MemoryStream, _super);
    function MemoryStream(producer) {
        var _this = _super.call(this, producer) || this;
        _this._has = false;
        return _this;
    }
    MemoryStream.prototype._n = function (x) {
        this._v = x;
        this._has = true;
        _super.prototype._n.call(this, x);
    };
    MemoryStream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1) {
            if (this._has)
                il._n(this._v);
            return;
        }
        if (this._stopID !== NO) {
            if (this._has)
                il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else if (this._has)
            il._n(this._v);
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    MemoryStream.prototype._stopNow = function () {
        this._has = false;
        _super.prototype._stopNow.call(this);
    };
    MemoryStream.prototype._x = function () {
        this._has = false;
        _super.prototype._x.call(this);
    };
    MemoryStream.prototype.map = function (project) {
        return this._map(project);
    };
    MemoryStream.prototype.mapTo = function (projectedValue) {
        return _super.prototype.mapTo.call(this, projectedValue);
    };
    MemoryStream.prototype.take = function (amount) {
        return _super.prototype.take.call(this, amount);
    };
    MemoryStream.prototype.endWhen = function (other) {
        return _super.prototype.endWhen.call(this, other);
    };
    MemoryStream.prototype.replaceError = function (replace) {
        return _super.prototype.replaceError.call(this, replace);
    };
    MemoryStream.prototype.remember = function () {
        return this;
    };
    MemoryStream.prototype.debug = function (labelOrSpy) {
        return _super.prototype.debug.call(this, labelOrSpy);
    };
    return MemoryStream;
}(Stream));
exports.MemoryStream = MemoryStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Stream;
//# sourceMappingURL=index.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var thunk = __webpack_require__(167);
exports.thunk = thunk;
/**
 * A factory for the DOM driver function.
 *
 * Takes a `container` to define the target on the existing DOM which this
 * driver will operate on, and an `options` object as the second argument. The
 * input to this driver is a stream of virtual DOM objects, or in other words,
 * Snabbdom "VNode" objects. The output of this driver is a "DOMSource": a
 * collection of Observables queried with the methods `select()` and `events()`.
 *
 * `DOMSource.select(selector)` returns a new DOMSource with scope restricted to
 * the element(s) that matches the CSS `selector` given.
 *
 * `DOMSource.events(eventType, options)` returns a stream of events of
 * `eventType` happening on the elements that match the current DOMSource. The
 * event object contains the `ownerTarget` property that behaves exactly like
 * `currentTarget`. The reason for this is that some browsers doesn't allow
 * `currentTarget` property to be mutated, hence a new property is created. The
 * returned stream is an *xstream* Stream if you use `@cycle/xstream-run` to run
 * your app with this driver, or it is an RxJS Observable if you use
 * `@cycle/rxjs-run`, and so forth. The `options` parameter can have the
 * property `useCapture`, which is by default `false`, except it is `true` for
 * event types that do not bubble. Read more here
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * about the `useCapture` and its purpose.
 *
 * `DOMSource.elements()` returns a stream of the DOM element(s) matched by the
 * selectors in the DOMSource. Also, `DOMSource.select(':root').elements()`
 * returns a stream of DOM element corresponding to the root (or container) of
 * the app on the DOM.
 *
 * @param {(String|HTMLElement)} container the DOM selector for the element
 * (or the element itself) to contain the rendering of the VTrees.
 * @param {DOMDriverOptions} options an object with two optional properties:
 *
 *   - `modules: array` overrides `@cycle/dom`'s default Snabbdom modules as
 *     as defined in [`src/modules.ts`](./src/modules.ts).
 *   - `transposition: boolean` enables/disables transposition of inner streams
 *     in the virtual DOM tree.
 * @return {Function} the DOM driver function. The function expects a stream of
 * VNode as input, and outputs the DOMSource object.
 * @function makeDOMDriver
 */
var makeDOMDriver_1 = __webpack_require__(76);
exports.makeDOMDriver = makeDOMDriver_1.makeDOMDriver;
/**
 * A factory for the HTML driver function.
 *
 * Takes an `effect` callback function and an `options` object as arguments. The
 * input to this driver is a stream of virtual DOM objects, or in other words,
 * Snabbdom "VNode" objects. The output of this driver is a "DOMSource": a
 * collection of Observables queried with the methods `select()` and `events()`.
 *
 * The HTML Driver is supplementary to the DOM Driver. Instead of producing
 * elements on the DOM, it generates HTML as strings and does a side effect on
 * those HTML strings. That side effect is described by the `effect` callback
 * function. So, if you want to use the HTML Driver on the server-side to render
 * your application as HTML and send as a response (which is the typical use
 * case for the HTML Driver), you need to pass something like the
 * `html => response.send(html)` function as the `effect` argument. This way,
 * the driver knows what side effect to cause based on the HTML string it just
 * rendered.
 *
 * The HTML driver is useful only for that side effect in the `effect` callback.
 * It can be considered a sink-only driver. However, in order to serve as a
 * transparent replacement to the DOM Driver when rendering from the server, the
 * HTML driver returns a source object that behaves just like the DOMSource.
 * This helps reuse the same application that is written for the DOM Driver.
 * This fake DOMSource returns empty streams when you query it, because there
 * are no user events on the server.
 *
 * `DOMSource.select(selector)` returns a new DOMSource with scope restricted to
 * the element(s) that matches the CSS `selector` given.
 *
 * `DOMSource.events(eventType, options)` returns an empty stream. The returned
 * stream is an *xstream* Stream if you use `@cycle/xstream-run` to run your app
 * with this driver, or it is an RxJS Observable if you use `@cycle/rxjs-run`,
 * and so forth.
 *
 * `DOMSource.elements()` returns the stream of HTML string rendered from your
 * sink virtual DOM stream.
 *
 * @param {Function} effect a callback function that takes a string of rendered
 * HTML as input and should run a side effect, returning nothing.
 * @param {HTMLDriverOptions} options an object with one optional property:
 * `transposition: boolean` enables/disables transposition of inner streams in
 * the virtual DOM tree.
 * @return {Function} the HTML driver function. The function expects a stream of
 * VNode as input, and outputs the DOMSource object.
 * @function makeHTMLDriver
 */
var makeHTMLDriver_1 = __webpack_require__(77);
exports.makeHTMLDriver = makeHTMLDriver_1.makeHTMLDriver;
/**
 * A factory function to create mocked DOMSource objects, for testing purposes.
 *
 * Takes a `streamAdapter` and a `mockConfig` object as arguments, and returns
 * a DOMSource that can be given to any Cycle.js app that expects a DOMSource in
 * the sources, for testing.
 *
 * The `streamAdapter` parameter is a package such as `@cycle/xstream-adapter`,
 * `@cycle/rxjs-adapter`, etc. Import it as `import a from '@cycle/rx-adapter`,
 * then provide it to `mockDOMSource. This is important so the DOMSource created
 * knows which stream library should it use to export its streams when you call
 * `DOMSource.events()` for instance.
 *
 * The `mockConfig` parameter is an object specifying selectors, eventTypes and
 * their streams. Example:
 *
 * ```js
 * const domSource = mockDOMSource(RxAdapter, {
 *   '.foo': {
 *     'click': Rx.Observable.of({target: {}}),
 *     'mouseover': Rx.Observable.of({target: {}}),
 *   },
 *   '.bar': {
 *     'scroll': Rx.Observable.of({target: {}}),
 *     elements: Rx.Observable.of({tagName: 'div'}),
 *   }
 * });
 *
 * // Usage
 * const click$ = domSource.select('.foo').events('click');
 * const element$ = domSource.select('.bar').elements();
 * ```
 *
 * The mocked DOM Source supports isolation. It has the functions `isolateSink`
 * and `isolateSource` attached to it, and performs simple isolation using
 * classNames. *isolateSink* with scope `foo` will append the class `___foo` to
 * the stream of virtual DOM nodes, and *isolateSource* with scope `foo` will
 * perform a conventional `mockedDOMSource.select('.__foo')` call.
 *
 * @param {Object} mockConfig an object where keys are selector strings
 * and values are objects. Those nested objects have `eventType` strings as keys
 * and values are streams you created.
 * @return {Object} fake DOM source object, with an API containing `select()`
 * and `events()` and `elements()` which can be used just like the DOM Driver's
 * DOMSource.
 *
 * @function mockDOMSource
 */
var mockDOMSource_1 = __webpack_require__(78);
exports.mockDOMSource = mockDOMSource_1.mockDOMSource;
/**
 * The hyperscript function `h()` is a function to create virtual DOM objects,
 * also known as VNodes. Call
 *
 * ```js
 * h('div.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * to create a VNode that represents a `DIV` element with className `myClass`,
 * styled with red color, and no children because the `[]` array was passed. The
 * API is `h(tagOrSelector, optionalData, optionalChildrenOrText)`.
 *
 * However, usually you should use "hyperscript helpers", which are shortcut
 * functions based on hyperscript. There is one hyperscript helper function for
 * each DOM tagName, such as `h1()`, `h2()`, `div()`, `span()`, `label()`,
 * `input()`. For instance, the previous example could have been written
 * as:
 *
 * ```js
 * div('.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * There are also SVG helper functions, which apply the appropriate SVG
 * namespace to the resulting elements. `svg()` function creates the top-most
 * SVG element, and `svg.g`, `svg.polygon`, `svg.circle`, `svg.path` are for
 * SVG-specific child elements. Example:
 *
 * ```js
 * svg({width: 150, height: 150}, [
 *   svg.polygon({
 *     attrs: {
 *       class: 'triangle',
 *       points: '20 0 20 150 150 20'
 *     }
 *   })
 * ])
 * ```
 *
 * @function h
 */
var hyperscript_1 = __webpack_require__(24);
exports.h = hyperscript_1.h;
var hyperscript_helpers_1 = __webpack_require__(73);
exports.svg = hyperscript_helpers_1.default.svg;
exports.a = hyperscript_helpers_1.default.a;
exports.abbr = hyperscript_helpers_1.default.abbr;
exports.address = hyperscript_helpers_1.default.address;
exports.area = hyperscript_helpers_1.default.area;
exports.article = hyperscript_helpers_1.default.article;
exports.aside = hyperscript_helpers_1.default.aside;
exports.audio = hyperscript_helpers_1.default.audio;
exports.b = hyperscript_helpers_1.default.b;
exports.base = hyperscript_helpers_1.default.base;
exports.bdi = hyperscript_helpers_1.default.bdi;
exports.bdo = hyperscript_helpers_1.default.bdo;
exports.blockquote = hyperscript_helpers_1.default.blockquote;
exports.body = hyperscript_helpers_1.default.body;
exports.br = hyperscript_helpers_1.default.br;
exports.button = hyperscript_helpers_1.default.button;
exports.canvas = hyperscript_helpers_1.default.canvas;
exports.caption = hyperscript_helpers_1.default.caption;
exports.cite = hyperscript_helpers_1.default.cite;
exports.code = hyperscript_helpers_1.default.code;
exports.col = hyperscript_helpers_1.default.col;
exports.colgroup = hyperscript_helpers_1.default.colgroup;
exports.dd = hyperscript_helpers_1.default.dd;
exports.del = hyperscript_helpers_1.default.del;
exports.dfn = hyperscript_helpers_1.default.dfn;
exports.dir = hyperscript_helpers_1.default.dir;
exports.div = hyperscript_helpers_1.default.div;
exports.dl = hyperscript_helpers_1.default.dl;
exports.dt = hyperscript_helpers_1.default.dt;
exports.em = hyperscript_helpers_1.default.em;
exports.embed = hyperscript_helpers_1.default.embed;
exports.fieldset = hyperscript_helpers_1.default.fieldset;
exports.figcaption = hyperscript_helpers_1.default.figcaption;
exports.figure = hyperscript_helpers_1.default.figure;
exports.footer = hyperscript_helpers_1.default.footer;
exports.form = hyperscript_helpers_1.default.form;
exports.h1 = hyperscript_helpers_1.default.h1;
exports.h2 = hyperscript_helpers_1.default.h2;
exports.h3 = hyperscript_helpers_1.default.h3;
exports.h4 = hyperscript_helpers_1.default.h4;
exports.h5 = hyperscript_helpers_1.default.h5;
exports.h6 = hyperscript_helpers_1.default.h6;
exports.head = hyperscript_helpers_1.default.head;
exports.header = hyperscript_helpers_1.default.header;
exports.hgroup = hyperscript_helpers_1.default.hgroup;
exports.hr = hyperscript_helpers_1.default.hr;
exports.html = hyperscript_helpers_1.default.html;
exports.i = hyperscript_helpers_1.default.i;
exports.iframe = hyperscript_helpers_1.default.iframe;
exports.img = hyperscript_helpers_1.default.img;
exports.input = hyperscript_helpers_1.default.input;
exports.ins = hyperscript_helpers_1.default.ins;
exports.kbd = hyperscript_helpers_1.default.kbd;
exports.keygen = hyperscript_helpers_1.default.keygen;
exports.label = hyperscript_helpers_1.default.label;
exports.legend = hyperscript_helpers_1.default.legend;
exports.li = hyperscript_helpers_1.default.li;
exports.link = hyperscript_helpers_1.default.link;
exports.main = hyperscript_helpers_1.default.main;
exports.map = hyperscript_helpers_1.default.map;
exports.mark = hyperscript_helpers_1.default.mark;
exports.menu = hyperscript_helpers_1.default.menu;
exports.meta = hyperscript_helpers_1.default.meta;
exports.nav = hyperscript_helpers_1.default.nav;
exports.noscript = hyperscript_helpers_1.default.noscript;
exports.object = hyperscript_helpers_1.default.object;
exports.ol = hyperscript_helpers_1.default.ol;
exports.optgroup = hyperscript_helpers_1.default.optgroup;
exports.option = hyperscript_helpers_1.default.option;
exports.p = hyperscript_helpers_1.default.p;
exports.param = hyperscript_helpers_1.default.param;
exports.pre = hyperscript_helpers_1.default.pre;
exports.progress = hyperscript_helpers_1.default.progress;
exports.q = hyperscript_helpers_1.default.q;
exports.rp = hyperscript_helpers_1.default.rp;
exports.rt = hyperscript_helpers_1.default.rt;
exports.ruby = hyperscript_helpers_1.default.ruby;
exports.s = hyperscript_helpers_1.default.s;
exports.samp = hyperscript_helpers_1.default.samp;
exports.script = hyperscript_helpers_1.default.script;
exports.section = hyperscript_helpers_1.default.section;
exports.select = hyperscript_helpers_1.default.select;
exports.small = hyperscript_helpers_1.default.small;
exports.source = hyperscript_helpers_1.default.source;
exports.span = hyperscript_helpers_1.default.span;
exports.strong = hyperscript_helpers_1.default.strong;
exports.style = hyperscript_helpers_1.default.style;
exports.sub = hyperscript_helpers_1.default.sub;
exports.sup = hyperscript_helpers_1.default.sup;
exports.table = hyperscript_helpers_1.default.table;
exports.tbody = hyperscript_helpers_1.default.tbody;
exports.td = hyperscript_helpers_1.default.td;
exports.textarea = hyperscript_helpers_1.default.textarea;
exports.tfoot = hyperscript_helpers_1.default.tfoot;
exports.th = hyperscript_helpers_1.default.th;
exports.thead = hyperscript_helpers_1.default.thead;
exports.title = hyperscript_helpers_1.default.title;
exports.tr = hyperscript_helpers_1.default.tr;
exports.u = hyperscript_helpers_1.default.u;
exports.ul = hyperscript_helpers_1.default.ul;
exports.video = hyperscript_helpers_1.default.video;
//# sourceMappingURL=index.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var counter = 0;
function newScope() {
    return "cycle" + ++counter;
}
function checkIsolateArgs(dataflowComponent, scope) {
    if (typeof dataflowComponent !== "function") {
        throw new Error("First argument given to isolate() must be a " +
            "'dataflowComponent' function");
    }
    if (scope === null) {
        throw new Error("Second argument given to isolate() must not be null");
    }
}
function isolateAllSources(sources, scope) {
    var scopedSources = {};
    for (var key in sources) {
        if (sources.hasOwnProperty(key) && sources[key]
            && typeof sources[key].isolateSource === "function") {
            scopedSources[key] = sources[key].isolateSource(sources[key], scope);
        }
        else if (sources.hasOwnProperty(key)) {
            scopedSources[key] = sources[key];
        }
    }
    return scopedSources;
}
function isolateAllSinks(sources, sinks, scope) {
    var scopedSinks = {};
    for (var key in sinks) {
        if (sinks.hasOwnProperty(key)
            && sources[key]
            && typeof sources[key].isolateSink === "function") {
            scopedSinks[key] = sources[key].isolateSink(sinks[key], scope);
        }
        else if (sinks.hasOwnProperty(key)) {
            scopedSinks[key] = sinks[key];
        }
    }
    return scopedSinks;
}
/**
 * Takes a `dataflowComponent` function and an optional `scope` string, and
 * returns a scoped version of the `dataflowComponent` function.
 *
 * When the scoped dataflow component is invoked, each source provided to the
 * scoped dataflowComponent is isolated to the scope using
 * `source.isolateSource(source, scope)`, if possible. Likewise, the sinks
 * returned from the scoped dataflow component are isolate to the scope using
 * `source.isolateSink(sink, scope)`.
 *
 * If the `scope` is not provided, a new scope will be automatically created.
 * This means that while **`isolate(dataflowComponent, scope)` is pure**
 * (referentially transparent), **`isolate(dataflowComponent)` is impure**
 * (not referentially transparent). Two calls to `isolate(Foo, bar)` will
 * generate two indistinct dataflow components. But, two calls to `isolate(Foo)`
 * will generate two distinct dataflow components.
 *
 * Note that both `isolateSource()` and `isolateSink()` are static members of
 * `source`. The reason for this is that drivers produce `source` while the
 * application produces `sink`, and it's the driver's responsibility to
 * implement `isolateSource()` and `isolateSink()`.
 *
 * @param {Function} dataflowComponent a function that takes `sources` as input
 * and outputs a collection of `sinks`.
 * @param {String} scope an optional string that is used to isolate each
 * `sources` and `sinks` when the returned scoped dataflow component is invoked.
 * @return {Function} the scoped dataflow component function that, as the
 * original `dataflowComponent` function, takes `sources` and returns `sinks`.
 * @function isolate
 */
function isolate(component, scope) {
    if (scope === void 0) { scope = newScope(); }
    checkIsolateArgs(component, scope);
    var convertedScope = typeof scope === 'string' ? scope : scope.toString();
    return function scopedComponent(sources) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var scopedSources = isolateAllSources(sources, convertedScope);
        var sinks = component.apply(void 0, [scopedSources].concat(rest));
        var scopedSinks = isolateAllSinks(sources, sinks, convertedScope);
        return scopedSinks;
    };
}
isolate.reset = function () { return counter = 0; };
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = isolate;
//# sourceMappingURL=index.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(203));
var Size;
(function (Size) {
    Size[Size["Mini"] = 0] = "Mini";
    Size[Size["Tiny"] = 1] = "Tiny";
    Size[Size["Small"] = 2] = "Small";
    Size[Size["Medium"] = 3] = "Medium";
    Size[Size["Large"] = 4] = "Large";
    Size[Size["Big"] = 5] = "Big";
    Size[Size["Huge"] = 6] = "Huge";
    Size[Size["Massive"] = 7] = "Massive";
    Size[Size["Fluid"] = 8] = "Fluid";
})(Size = exports.Size || (exports.Size = {}));
(function (Size) {
    function ToClassname(size) {
        switch (size) {
            case Size.Mini: return " mini";
            case Size.Tiny: return " tiny";
            case Size.Small: return " small";
            case Size.Medium: return " medium";
            case Size.Large: return " large";
            case Size.Big: return " big";
            case Size.Huge: return " huge";
            case Size.Massive: return " massive";
            case Size.Fluid: return " fluid";
            default: return "";
        }
    }
    Size.ToClassname = ToClassname;
})(Size = exports.Size || (exports.Size = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = 0] = "Top";
    VerticalAlignment[VerticalAlignment["Middle"] = 1] = "Middle";
    VerticalAlignment[VerticalAlignment["Bottom"] = 2] = "Bottom";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
(function (VerticalAlignment) {
    function ToClassname(alignment) {
        switch (alignment) {
            case VerticalAlignment.Top: return " top aligned";
            case VerticalAlignment.Middle: return " middle aligned";
            case VerticalAlignment.Bottom: return " bottom aligned";
            default: return "";
        }
    }
    VerticalAlignment.ToClassname = ToClassname;
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
var TextAlignment;
(function (TextAlignment) {
    TextAlignment[TextAlignment["Left"] = 0] = "Left";
    TextAlignment[TextAlignment["Right"] = 1] = "Right";
    TextAlignment[TextAlignment["Center"] = 2] = "Center";
    TextAlignment[TextAlignment["Justified"] = 3] = "Justified";
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
(function (TextAlignment) {
    function ToClassname(alignment) {
        switch (alignment) {
            case TextAlignment.Left: return " left aligned.";
            case TextAlignment.Right: return " right aligned.";
            case TextAlignment.Center: return " center aligned";
            case TextAlignment.Justified: return " justified";
            default: return "";
        }
    }
    TextAlignment.ToClassname = ToClassname;
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
var Float;
(function (Float) {
    Float[Float["None"] = 0] = "None";
    Float[Float["Right"] = 1] = "Right";
    Float[Float["Left"] = 2] = "Left";
})(Float = exports.Float || (exports.Float = {}));
(function (Float) {
    function ToClassname(float) {
        switch (float) {
            case Float.Left: return " left floated";
            case Float.Right: return " right floated";
            default: return "";
        }
    }
    Float.ToClassname = ToClassname;
})(Float = exports.Float || (exports.Float = {}));
var Attachment;
(function (Attachment) {
    Attachment[Attachment["None"] = 0] = "None";
    Attachment[Attachment["Top"] = 1] = "Top";
    Attachment[Attachment["TopRight"] = 2] = "TopRight";
    Attachment[Attachment["TopLeft"] = 3] = "TopLeft";
    Attachment[Attachment["Bottom"] = 4] = "Bottom";
    Attachment[Attachment["BottomLeft"] = 5] = "BottomLeft";
    Attachment[Attachment["BottomRight"] = 6] = "BottomRight";
    Attachment[Attachment["Right"] = 7] = "Right";
    Attachment[Attachment["Left"] = 8] = "Left";
})(Attachment = exports.Attachment || (exports.Attachment = {}));
(function (Attachment) {
    function ToClassname(attachment) {
        switch (attachment) {
            case Attachment.None: return " attached";
            case Attachment.Top: return " top attached";
            case Attachment.Bottom: return " bottom attached";
            case Attachment.Left: return " left attached";
            case Attachment.Right: return " right attached";
            case Attachment.TopRight: return " top right attached";
            case Attachment.TopLeft: return " top left attached";
            case Attachment.BottomLeft: return " bottom left attached";
            case Attachment.BottomRight: return " bottom right attached";
            default: return "";
        }
    }
    Attachment.ToClassname = ToClassname;
})(Attachment = exports.Attachment || (exports.Attachment = {}));
var Color;
(function (Color) {
    Color[Color["None"] = 0] = "None";
    Color[Color["Primary"] = 1] = "Primary";
    Color[Color["Secondary"] = 2] = "Secondary";
    Color[Color["Success"] = 3] = "Success";
    Color[Color["Info"] = 4] = "Info";
    Color[Color["Warning"] = 5] = "Warning";
    Color[Color["Error"] = 6] = "Error";
})(Color = exports.Color || (exports.Color = {}));
(function (Color) {
    function ToClassname(color) {
        switch (color) {
            case Color.Primary: return " primaryColored";
            case Color.Secondary: return " secondaryColored";
            case Color.Success: return " successColored";
            case Color.Info: return " infoColored";
            case Color.Warning: return " warningColored";
            case Color.Error: return " errorColored ";
            default: return "";
        }
    }
    Color.ToClassname = ToClassname;
})(Color = exports.Color || (exports.Color = {}));
var Animation;
(function (Animation) {
    Animation[Animation["Browse"] = 0] = "Browse";
    Animation[Animation["Drop"] = 1] = "Drop";
    Animation[Animation["Fade"] = 2] = "Fade";
    Animation[Animation["Flip"] = 3] = "Flip";
    Animation[Animation["Scale"] = 4] = "Scale";
    Animation[Animation["Fly"] = 5] = "Fly";
    Animation[Animation["Slide"] = 6] = "Slide";
    Animation[Animation["Swing"] = 7] = "Swing";
    Animation[Animation["Flash"] = 8] = "Flash";
    Animation[Animation["Shake"] = 9] = "Shake";
    Animation[Animation["Bounce"] = 10] = "Bounce";
    Animation[Animation["Tada"] = 11] = "Tada";
    Animation[Animation["Pulse"] = 12] = "Pulse";
    Animation[Animation["Jiggle"] = 13] = "Jiggle";
    Animation[Animation["None"] = 14] = "None";
})(Animation = exports.Animation || (exports.Animation = {}));
(function (Animation) {
    function ToClassname(anim) {
        switch (anim) {
            case Animation.Browse: return " browse";
            case Animation.Drop: return " drop";
            case Animation.Fade: return " fade";
            case Animation.Flip: return " flip";
            case Animation.Scale: return " scale";
            case Animation.Fly: return " fly";
            case Animation.Slide: return " slide";
            case Animation.Swing: return " swing";
            case Animation.Flash: return " flash";
            case Animation.Shake: return " shake";
            case Animation.Bounce: return " bounce";
            case Animation.Tada: return " tada";
            case Animation.Pulse: return " pulse";
            case Animation.Jiggle: return " jiggle";
        }
    }
    Animation.ToClassname = ToClassname;
    function isStatic(anim) {
        var staticAnimations = [Animation.Flash, Animation.Shake,
            Animation.Bounce, Animation.Tada, Animation.Pulse, Animation.Jiggle];
        return staticAnimations.indexOf(anim) !== -1;
    }
    Animation.isStatic = isStatic;
    function isDirectional(anim) {
        var directionAnimations = [Animation.Browse, Animation.Fade,
            Animation.Fly, Animation.Slide, Animation.Swing];
        return directionAnimations.indexOf(anim) !== -1;
    }
    Animation.isDirectional = isDirectional;
})(Animation = exports.Animation || (exports.Animation = {}));
var Direction;
(function (Direction) {
    Direction[Direction["In"] = 0] = "In";
    Direction[Direction["Out"] = 1] = "Out";
    Direction[Direction["None"] = 2] = "None";
})(Direction = exports.Direction || (exports.Direction = {}));
(function (Direction) {
    function ToClassname(direction) {
        return direction === Direction.In ? " in" : " out";
    }
    Direction.ToClassname = ToClassname;
})(Direction = exports.Direction || (exports.Direction = {}));
var AnimationDirection;
(function (AnimationDirection) {
    AnimationDirection[AnimationDirection["Up"] = 0] = "Up";
    AnimationDirection[AnimationDirection["Down"] = 1] = "Down";
    AnimationDirection[AnimationDirection["Left"] = 2] = "Left";
    AnimationDirection[AnimationDirection["Right"] = 3] = "Right";
})(AnimationDirection = exports.AnimationDirection || (exports.AnimationDirection = {}));
(function (AnimationDirection) {
    function ToClassname(dir) {
        switch (dir) {
            case AnimationDirection.Up: return " up";
            case AnimationDirection.Down: return " down";
            case AnimationDirection.Left: return " left";
            case AnimationDirection.Right: return " right";
            default: return "";
        }
    }
    AnimationDirection.ToClassname = ToClassname;
})(AnimationDirection = exports.AnimationDirection || (exports.AnimationDirection = {}));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDOMContent(content) {
    if (!content) {
        return false;
    }
    if (typeof (content) === "string") {
        return true;
    }
    if (content instanceof (Array)) {
        if (content.length === 0) {
            return true;
        }
        else {
            return content[0].sel !== undefined;
        }
        ;
    }
    return false;
}
exports.isDOMContent = isDOMContent;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var XStreamAdapter = {
    adapt: function (originStream, originStreamSubscribe) {
        if (XStreamAdapter.isValidStream(originStream)) {
            return originStream;
        }
        ;
        var dispose = null;
        return xstream_1.default.create({
            start: function (out) {
                var observer = out;
                dispose = originStreamSubscribe(originStream, observer);
            },
            stop: function () {
                if (typeof dispose === 'function') {
                    dispose();
                }
            },
        });
    },
    makeSubject: function () {
        var stream = xstream_1.default.create();
        var observer = {
            next: function (x) { stream.shamefullySendNext(x); },
            error: function (err) { stream.shamefullySendError(err); },
            complete: function () { stream.shamefullySendComplete(); },
        };
        return { observer: observer, stream: stream };
    },
    remember: function (stream) {
        return stream.remember();
    },
    isValidStream: function (stream) {
        return (typeof stream.addListener === 'function' &&
            typeof stream.shamefullySendNext === 'function');
    },
    streamSubscribe: function (stream, observer) {
        stream.addListener(observer);
        return function () { return stream.removeListener(observer); };
    },
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = XStreamAdapter;
//# sourceMappingURL=index.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPath = exports.parsePath = exports.getQueryStringValueFromPath = exports.stripQueryStringValueFromPath = exports.addQueryStringValueToPath = exports.isAbsolutePath = undefined;

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isAbsolutePath = exports.isAbsolutePath = function isAbsolutePath(path) {
  return typeof path === 'string' && path.charAt(0) === '/';
};

var addQueryStringValueToPath = exports.addQueryStringValueToPath = function addQueryStringValueToPath(path, key, value) {
  var _parsePath = parsePath(path);

  var pathname = _parsePath.pathname;
  var search = _parsePath.search;
  var hash = _parsePath.hash;


  return createPath({
    pathname: pathname,
    search: search + (search.indexOf('?') === -1 ? '?' : '&') + key + '=' + value,
    hash: hash
  });
};

var stripQueryStringValueFromPath = exports.stripQueryStringValueFromPath = function stripQueryStringValueFromPath(path, key) {
  var _parsePath2 = parsePath(path);

  var pathname = _parsePath2.pathname;
  var search = _parsePath2.search;
  var hash = _parsePath2.hash;


  return createPath({
    pathname: pathname,
    search: search.replace(new RegExp('([?&])' + key + '=[a-zA-Z0-9]+(&?)'), function (match, prefix, suffix) {
      return prefix === '?' ? prefix : suffix;
    }),
    hash: hash
  });
};

var getQueryStringValueFromPath = exports.getQueryStringValueFromPath = function getQueryStringValueFromPath(path, key) {
  var _parsePath3 = parsePath(path);

  var search = _parsePath3.search;

  var match = search.match(new RegExp('[?&]' + key + '=([a-zA-Z0-9]+)'));
  return match && match[1];
};

var extractPath = function extractPath(string) {
  var match = string.match(/^(https?:)?\/\/[^\/]*/);
  return match == null ? string : string.substring(match[0].length);
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = extractPath(path);
  var search = '';
  var hash = '';

  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(path === pathname, 'A path must be pathname + search + hash only, not a full URL like "%s"', path) : void 0;

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substring(hashIndex);
    pathname = pathname.substring(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substring(searchIndex);
    pathname = pathname.substring(0, searchIndex);
  }

  if (pathname === '') pathname = '/';

  return {
    pathname: pathname,
    search: search,
    hash: hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  if (location == null || typeof location === 'string') return location;

  var basename = location.basename;
  var pathname = location.pathname;
  var search = location.search;
  var hash = location.hash;

  var path = (basename || '') + pathname;

  if (search && search !== '?') path += search;

  if (hash) path += hash;

  return path;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var flattenConcurrently_1 = __webpack_require__(214);
function patchClassList(target, classes, classesToAdd) {
    var className = "";
    if (target.data) {
        var props = target.data.props ? target.data.props : { className: target.sel.split(".").join(" ") };
        var classList = props.className.split(" ");
        classList.forEach(function (item) {
            if (classes.indexOf(item) === -1) {
                className += item + " ";
            }
        });
    }
    className += classesToAdd;
    return Object.assign({}, target.data, {
        "props": {
            className: className
        }
    });
}
exports.patchClassList = patchClassList;
/**
 * Adds one VNode to another and handles updates for stream by replacing based on the identifier class.
 * @param  {VNode}  element    The element to be added.
 * @param  {VNode}  target     The target for the element
 * @param  {string} identifier The identifying class for the element to be added.
 * @return {Array} The target element's children with the element added.
 */
function addElement(element, target, identifier) {
    var c = [];
    if (target.children) {
        c = target.children;
    }
    if (target.text) {
        c.push(target.text);
    }
    for (var i = 0; i < c.length; i++) {
        var child = c[i];
        var cProps = child.data ? child.data.props ? child.data.props : {} : {};
        if (typeof (child) !== "undefined" && typeof (cProps.className) !== "undefined") {
            var classList = child.data.props.className.split(" ");
            for (var _i = 0, classList_1 = classList; _i < classList_1.length; _i++) {
                var s = classList_1[_i];
                if (s === identifier) {
                    c.splice(i, 1);
                }
            }
        }
    }
    c.push(element);
    return c;
}
exports.addElement = addElement;
/**
 * Converts anything to a stream
 * @param  {any} obj - The object.
 * @return {Stream<any>} The object as a stream.
 */
function asStream(obj) {
    if (typeof (obj) !== "undefined") {
        if (typeof (obj.addListener) === "function") {
            return obj;
        }
        if (Object.prototype.toString.call(obj) === "[object Array]") {
            var isStreams = true;
            for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
                var subobj = obj_1[_i];
                if (typeof (subobj.addListener) !== "function") {
                    isStreams = false;
                }
            }
            if (isStreams) {
                return xstream_1.default.combine.apply(this, obj);
            }
        }
        return xstream_1.default.of(obj);
    }
    return xstream_1.default.of("");
}
exports.asStream = asStream;
/**
 * Converts a number of objects to a stream of an Array.
 * @param  {any} ...objs   The objects to include in the stream
 * @return {Stream<any[]>} The objects as a stream of an array.
 */
function asArrayStream() {
    var objs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objs[_i] = arguments[_i];
    }
    var streams = Array.from(arguments);
    streams = streams.map(function (obj) { return asStream(obj); });
    return xstream_1.default.combine.apply(this, streams);
}
exports.asArrayStream = asArrayStream;
/**
 * Flattens a stream of an array of streams into a stream of an array.
 * @param  {Stream<Stream<any>[]>} stream The stream to flatten
 * @return {Stream<any[]>}                The flattened stream.
 */
function flattenStreamArray(stream) {
    var _this = this;
    return flattenConcurrently_1.default(stream.map(function (children) { return xstream_1.default.combine.apply(_this, children); }));
}
exports.flattenStreamArray = flattenStreamArray;
/**
 * Converts a natural number between 1-16 to text.
 * @param  {number} num The number to convert.
 * @return {string}     That number as text.
 */
function numToText(num) {
    switch (num) {
        case 1: return " one";
        case 2: return " two";
        case 3: return " three";
        case 4: return " four";
        case 5: return " five";
        case 6: return " six";
        case 7: return " seven";
        case 8: return " eight";
        case 9: return " nine";
        case 10: return " ten";
        case 11: return " eleven";
        case 12: return " twelve";
        case 13: return " thirteen";
        case 14: return " fourteen";
        case 15: return " fifteen";
        case 16: return " sixteen";
    }
}
exports.numToText = numToText;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign        = __webpack_require__(26)
  , normalizeOpts = __webpack_require__(108)
  , isCallable    = __webpack_require__(102)
  , contains      = __webpack_require__(46)

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.statesAreEqual = exports.createLocation = exports.createQuery = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _PathUtils = __webpack_require__(8);

var _Actions = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createQuery = exports.createQuery = function createQuery(props) {
  return _extends(Object.create(null), props);
};

var createLocation = exports.createLocation = function createLocation() {
  var input = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var object = typeof input === 'string' ? (0, _PathUtils.parsePath)(input) : input;

  var pathname = object.pathname || '/';
  var search = object.search || '';
  var hash = object.hash || '';
  var state = object.state;

  return {
    pathname: pathname,
    search: search,
    hash: hash,
    state: state,
    action: action,
    key: key
  };
};

var isDate = function isDate(object) {
  return Object.prototype.toString.call(object) === '[object Date]';
};

var statesAreEqual = exports.statesAreEqual = function statesAreEqual(a, b) {
  if (a === b) return true;

  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (typeofA !== typeofB) return false;

  !(typeofA !== 'function') ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store functions in location state') : (0, _invariant2.default)(false) : void 0;

  // Not the same object, but same type.
  if (typeofA === 'object') {
    !!(isDate(a) && isDate(b)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store Date objects in location state') : (0, _invariant2.default)(false) : void 0;

    if (!Array.isArray(a)) return Object.keys(a).every(function (key) {
      return statesAreEqual(a[key], b[key]);
    });

    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return statesAreEqual(item, b[index]);
    });
  }

  // All other serializable types (string, number, boolean)
  // should be strict equal.
  return false;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.key === b.key &&
  // a.action === b.action && // Different action !== location change.
  a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && statesAreEqual(a.state, b.state);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var dom_1 = __webpack_require__(1);
var isolate_1 = __webpack_require__(2);
var Transition;
(function (Transition) {
    /**
     * A transition wrapper for animating dom content.
     * Accepts the following targets: VNode
     * Expects the following arguments: {} of
     *   animation: Animation - The animation to use.
     *   direction?: Direction - Wether to animate to visible or invisible.
     *   animationDirection?: AnimationDirection - The direction for the animation.
     * Disregards any content.
     */
    function run(sources) {
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".transition").events(type); };
            sources.args$ = sources.args$ ? sources.args$ : xstream_1.default.of({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var animationEnd$ = evt("animationend").map(function (evt) { return ({
                animation: enums_1.Animation.None,
                direction: evt.currentTarget.classList.contains("out") ? enums_1.Direction.Out : enums_1.Direction.In
            }); });
            var animation$ = xstream_1.default.merge(sources.args$, animationEnd$);
            var vTree$ = xstream_1.default.combine(animation$, sources.target$).map(function (_a) {
                var transition = _a[0], target = _a[1];
                return render(target, transition);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".transition").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Transition.run = run;
    /**
     * A transition wrapper for animating dom content.
     * Accepts the following targets: VNode
     * Expects the following arguments: {} of
     *   animation: Animation - The animation to use.
     *   direction?: Direction - Wether to animate to visible or invisible.
     *   animationDirection?: AnimationDirection - The direction for the animation.
     * Disregards any content.
     */
    function render(target, args) {
        if (args === void 0) { args = { animation: enums_1.Animation.None }; }
        var className = "", c;
        if (target.data) {
            var classList = target.data.props.className.split(" ");
            classList.forEach(function (item) {
                if (["hidden", "visible", "animating", "transition"].indexOf(item) === -1) {
                    className += item + " ";
                }
            });
        }
        className += getClassName(args);
        var data = Object.assign({}, target.data, {
            "props": {
                className: className
            }
        });
        if (target.children) {
            c = target.children;
        }
        if (target.text) {
            c = target.text;
        }
        return dom_1.h(target.sel, data, c);
    }
    Transition.render = render;
    function getClassName(transition) {
        if (transition.animation === enums_1.Animation.None) {
            return transition.direction === enums_1.Direction.Out ? "transition hidden" : "transition visible";
        }
        var animation = enums_1.Animation.ToClassname(transition.animation);
        if (enums_1.Animation.isStatic(transition.animation)) {
            return "visible animating transition " + animation;
        }
        var direction = enums_1.Direction.ToClassname(transition.direction);
        if (enums_1.Animation.isDirectional(transition.animation)) {
            animation += enums_1.AnimationDirection.ToClassname(transition.animationDirection);
        }
        return "visible transition animating " + direction + animation;
    }
})(Transition = exports.Transition || (exports.Transition = {}));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isElement(obj) {
    return typeof HTMLElement === "object" ?
        obj instanceof HTMLElement || obj instanceof DocumentFragment :
        obj && typeof obj === "object" && obj !== null &&
            (obj.nodeType === 1 || obj.nodeType === 11) &&
            typeof obj.nodeName === "string";
}
exports.SCOPE_PREFIX = "$$CYCLEDOM$$-";
function getElement(selectors) {
    var domElement = typeof selectors === 'string' ?
        document.querySelector(selectors) :
        selectors;
    if (typeof selectors === 'string' && domElement === null) {
        throw new Error("Cannot render into unknown element `" + selectors + "`");
    }
    else if (!isElement(domElement)) {
        throw new Error("Given container is not a DOM element neither a " +
            "selector string.");
    }
    return domElement;
}
exports.getElement = getElement;
function getScope(namespace) {
    return namespace
        .filter(function (c) { return c.indexOf(exports.SCOPE_PREFIX) > -1; })
        .map(function (c) { return c.replace(exports.SCOPE_PREFIX, ''); })
        .join("-");
}
exports.getScope = getScope;
function getSelectors(namespace) {
    return namespace.filter(function (c) { return c.indexOf(exports.SCOPE_PREFIX) === -1; }).join(" ");
}
exports.getSelectors = getSelectors;
//# sourceMappingURL=utils.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(122)() ? Symbol : __webpack_require__(124);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(44)()
	? Object.setPrototypeOf
	: __webpack_require__(45);


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Indicates that navigation was caused by a call to history.push.
 */
var PUSH = exports.PUSH = 'PUSH';

/**
 * Indicates that navigation was caused by a call to history.replace.
 */
var REPLACE = exports.REPLACE = 'REPLACE';

/**
 * Indicates that navigation was caused by some other action such
 * as using a browser's back/forward buttons and/or manually manipulating
 * the URL in a browser's location bar. This is the default.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
 * for more information.
 */
var POP = exports.POP = 'POP';

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = {
  array: Array.isArray,
  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Icon;
(function (Icon) {
    /**
     * An icon component for displaying icons.
     * Accepts the following properties in props$:
     *  button?: boolean - Styles the icon to display well on buttons
     * 	bordered?: boolean - Adds a border around the icon.
     * 	circular?: boolean - Styles the icon to appear circular.
     * 	disabled?: boolean - Styles the icon to appear disabled.
     * 	loading?: boolean - Rotates the icon to allow it to be used for loaders.
     * 	fitted?: boolean - Styles the icon for tight fits.
     * 	link?: boolean - Styles the icon to appear clickable.
     * 	flipped?: boolean - Flips the icon.
     * 	rotated?: boolean - Rotates the icon.
     * 	inverted?: boolean - Styles the icon to appear on dark background.
     * 	color?: Color - The color of the icon.
     * 	size?: Size - The size of the icon.
     * Accepts the following type of content in content$: IconType
     * @param  {ComponentSources} sources - The component's sources.
     * @return {ComponentSinks} The Icon component.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ type: "" });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of(0);
            return {
                DOM: xstream_1.default.combine(sources.props$, sources.content$)
                    .map(function (_a) {
                    var props = _a[0], content = _a[1];
                    return render(props, content);
                }),
                Events: function (type) { return sources.DOM.select(".icon").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Icon.run = run;
    /**
     * An icon component for displaying icons.
     * Accepts the following properties:
     *  button?: boolean - Styles the icon to display well on buttons
     * 	bordered?: boolean - Adds a border around the icon.
     * 	circular?: boolean - Styles the icon to appear circular.
     * 	disabled?: boolean - Styles the icon to appear disabled.
     * 	loading?: boolean - Rotates the icon to allow it to be used for loaders.
     * 	fitted?: boolean - Styles the icon for tight fits.
     * 	link?: boolean - Styles the icon to appear clickable.
     * 	flipped?: boolean - Flips the icon.
     * 	rotated?: boolean - Rotates the icon.
     * 	inverted?: boolean - Styles the icon to appear on dark background.
     * 	color?: Color - The color of the icon.
     * 	size?: Size - The size of the icon.
     * Accepts the following type of content: IconType
     * @param  {ComponentSources} sources - The component's sources.
     * @return {ComponentSinks} The Icon component.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = -1; }
        var props = isProps(pOrC) ? pOrC : {};
        var content = isProps(pOrC) ? c : pOrC;
        var className = getClassname(props, content);
        return className !== "ui icon" ? dom_1.i({ props: { className: className } }) : "";
    }
    Icon.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.button) {
            className += " button";
        }
        if (props.bordered) {
            className += " bordered";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.link) {
            className += " link";
        }
        if (props.flipped) {
            className += " flipped";
        }
        if (props.rotated) {
            className += " rotated";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += enums_1.IconType.ToClassname(content);
        return className + " icon";
    }
    function isProps(props) {
        return typeof (props) === "object";
    }
})(Icon = exports.Icon || (exports.Icon = {}));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
function fromEvent(element, eventName, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    return xstream_1.Stream.create({
        element: element,
        next: null,
        start: function start(listener) {
            this.next = function next(event) { listener.next(event); };
            this.element.addEventListener(eventName, this.next, useCapture);
        },
        stop: function stop() {
            this.element.removeEventListener(eventName, this.next, useCapture);
        },
    });
}
exports.fromEvent = fromEvent;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var is = __webpack_require__(21);
var vnode = __webpack_require__(35);
function isGenericStream(x) {
    return !Array.isArray(x) && typeof x.map === "function";
}
function mutateStreamWithNS(vNode) {
    addNS(vNode.data, vNode.children, vNode.sel);
    return vNode;
}
function addNS(data, children, selector) {
    data.ns = "http://www.w3.org/2000/svg";
    if (selector !== "text" && selector !== "foreignObject" &&
        typeof children !== 'undefined' && is.array(children)) {
        for (var i = 0; i < children.length; ++i) {
            if (isGenericStream(children[i])) {
                children[i] = children[i].map(mutateStreamWithNS);
            }
            else {
                addNS(children[i].data, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {};
    var children;
    var text;
    if (arguments.length === 3) {
        data = b;
        if (is.array(c)) {
            children = c;
        }
        else if (is.primitive(c)) {
            text = c;
        }
    }
    else if (arguments.length === 2) {
        if (is.array(b)) {
            children = b;
        }
        else if (is.primitive(b)) {
            text = b;
        }
        else {
            data = b;
        }
    }
    if (is.array(children)) {
        children = children.filter(function (x) { return x; });
        for (var i = 0; i < children.length; ++i) {
            if (is.primitive(children[i])) {
                children[i] = vnode(undefined, undefined, undefined, children[i]);
            }
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
        addNS(data, children, sel);
    }
    return vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
//# sourceMappingURL=hyperscript.js.map

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = Object.prototype.toString

  , id = toString.call((function () { return arguments; }()));

module.exports = function (x) { return (toString.call(x) === id); };


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(97)()
	? Object.assign
	: __webpack_require__(98);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = Object.prototype.toString

  , id = toString.call('');

module.exports = function (x) {
	return (typeof x === 'string') || (x && (typeof x === 'object') &&
		((x instanceof String) || (toString.call(x) === id))) || false;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear    = __webpack_require__(43)
  , assign   = __webpack_require__(26)
  , callable = __webpack_require__(11)
  , value    = __webpack_require__(7)
  , d        = __webpack_require__(10)
  , autoBind = __webpack_require__(89)
  , Symbol   = __webpack_require__(16)

  , defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) return new Iterator(list, context);
	defineProperties(this, {
		__list__: d('w', value(list)),
		__context__: d('w', context),
		__nextIndex__: d('w', 0)
	});
	if (!context) return;
	callable(context.on);
	context.on('_add', this._onAdd);
	context.on('_delete', this._onDelete);
	context.on('_clear', this._onClear);
};

defineProperties(Iterator.prototype, assign({
	constructor: d(Iterator),
	_next: d(function () {
		var i;
		if (!this.__list__) return;
		if (this.__redo__) {
			i = this.__redo__.shift();
			if (i !== undefined) return i;
		}
		if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
		this._unBind();
	}),
	next: d(function () { return this._createResult(this._next()); }),
	_createResult: d(function (i) {
		if (i === undefined) return { done: true, value: undefined };
		return { done: false, value: this._resolve(i) };
	}),
	_resolve: d(function (i) { return this.__list__[i]; }),
	_unBind: d(function () {
		this.__list__ = null;
		delete this.__redo__;
		if (!this.__context__) return;
		this.__context__.off('_add', this._onAdd);
		this.__context__.off('_delete', this._onDelete);
		this.__context__.off('_clear', this._onClear);
		this.__context__ = null;
	}),
	toString: d(function () { return '[object Iterator]'; })
}, autoBind({
	_onAdd: d(function (index) {
		if (index >= this.__nextIndex__) return;
		++this.__nextIndex__;
		if (!this.__redo__) {
			defineProperty(this, '__redo__', d('c', [index]));
			return;
		}
		this.__redo__.forEach(function (redo, i) {
			if (redo >= index) this.__redo__[i] = ++redo;
		}, this);
		this.__redo__.push(index);
	}),
	_onDelete: d(function (index) {
		var i;
		if (index >= this.__nextIndex__) return;
		--this.__nextIndex__;
		if (!this.__redo__) return;
		i = this.__redo__.indexOf(index);
		if (i !== -1) this.__redo__.splice(i, 1);
		this.__redo__.forEach(function (redo, i) {
			if (redo > index) this.__redo__[i] = --redo;
		}, this);
	}),
	_onClear: d(function () {
		if (this.__redo__) clear.call(this.__redo__);
		this.__nextIndex__ = 0;
	})
})));

defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
	return this;
}));
defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.go = exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getUserConfirmation = exports.getCurrentLocation = undefined;

var _LocationUtils = __webpack_require__(12);

var _DOMUtils = __webpack_require__(17);

var _DOMStateStorage = __webpack_require__(49);

var _PathUtils = __webpack_require__(8);

/* eslint-disable no-alert */


var PopStateEvent = 'popstate';

var _createLocation = function _createLocation(historyState) {
  var key = historyState && historyState.key;

  return (0, _LocationUtils.createLocation)({
    pathname: window.location.pathname,
    search: window.location.search,
    hash: window.location.hash,
    state: key ? (0, _DOMStateStorage.readState)(key) : undefined
  }, undefined, key);
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  var historyState = void 0;
  try {
    historyState = window.history.state || {};
  } catch (error) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/mjackson/history/pull/289
    historyState = {};
  }

  return _createLocation(historyState);
};

var getUserConfirmation = exports.getUserConfirmation = function getUserConfirmation(message, callback) {
  return callback(window.confirm(message));
};

var startListener = exports.startListener = function startListener(listener) {
  var handlePopState = function handlePopState(event) {
    if (event.state !== undefined) // Ignore extraneous popstate events in WebKit
      listener(_createLocation(event.state));
  };

  (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);
  };
};

var updateLocation = function updateLocation(location, updateState) {
  var state = location.state;
  var key = location.key;


  if (state !== undefined) (0, _DOMStateStorage.saveState)(key, state);

  updateState({ key: key }, (0, _PathUtils.createPath)(location));
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.pushState(state, null, path);
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.replaceState(state, null, path);
  });
};

var go = exports.go = function go(n) {
  if (n) window.history.go(n);
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AsyncUtils = __webpack_require__(127);

var _PathUtils = __webpack_require__(8);

var _runTransitionHook = __webpack_require__(32);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _Actions = __webpack_require__(20);

var _LocationUtils = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var createHistory = function createHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var getCurrentLocation = options.getCurrentLocation;
  var getUserConfirmation = options.getUserConfirmation;
  var pushLocation = options.pushLocation;
  var replaceLocation = options.replaceLocation;
  var go = options.go;
  var keyLength = options.keyLength;


  var currentLocation = void 0;
  var pendingLocation = void 0;
  var beforeListeners = [];
  var listeners = [];
  var allKeys = [];

  var getCurrentIndex = function getCurrentIndex() {
    if (pendingLocation && pendingLocation.action === _Actions.POP) return allKeys.indexOf(pendingLocation.key);

    if (currentLocation) return allKeys.indexOf(currentLocation.key);

    return -1;
  };

  var updateLocation = function updateLocation(nextLocation) {
    currentLocation = nextLocation;

    var currentIndex = getCurrentIndex();

    if (currentLocation.action === _Actions.PUSH) {
      allKeys = [].concat(_toConsumableArray(allKeys.slice(0, currentIndex + 1)), [currentLocation.key]);
    } else if (currentLocation.action === _Actions.REPLACE) {
      allKeys[currentIndex] = currentLocation.key;
    }

    listeners.forEach(function (listener) {
      return listener(currentLocation);
    });
  };

  var listenBefore = function listenBefore(listener) {
    beforeListeners.push(listener);

    return function () {
      return beforeListeners = beforeListeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var listen = function listen(listener) {
    listeners.push(listener);

    return function () {
      return listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, callback) {
    (0, _AsyncUtils.loopAsync)(beforeListeners.length, function (index, next, done) {
      (0, _runTransitionHook2.default)(beforeListeners[index], location, function (result) {
        return result != null ? done(result) : next();
      });
    }, function (message) {
      if (getUserConfirmation && typeof message === 'string') {
        getUserConfirmation(message, function (ok) {
          return callback(ok !== false);
        });
      } else {
        callback(message !== false);
      }
    });
  };

  var transitionTo = function transitionTo(nextLocation) {
    if (currentLocation && (0, _LocationUtils.locationsAreEqual)(currentLocation, nextLocation) || pendingLocation && (0, _LocationUtils.locationsAreEqual)(pendingLocation, nextLocation)) return; // Nothing to do

    pendingLocation = nextLocation;

    confirmTransitionTo(nextLocation, function (ok) {
      if (pendingLocation !== nextLocation) return; // Transition was interrupted during confirmation

      pendingLocation = null;

      if (ok) {
        // Treat PUSH to same path like REPLACE to be consistent with browsers
        if (nextLocation.action === _Actions.PUSH) {
          var prevPath = (0, _PathUtils.createPath)(currentLocation);
          var nextPath = (0, _PathUtils.createPath)(nextLocation);

          if (nextPath === prevPath && (0, _LocationUtils.statesAreEqual)(currentLocation.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
        }

        if (nextLocation.action === _Actions.POP) {
          updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.PUSH) {
          if (pushLocation(nextLocation) !== false) updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.REPLACE) {
          if (replaceLocation(nextLocation) !== false) updateLocation(nextLocation);
        }
      } else if (currentLocation && nextLocation.action === _Actions.POP) {
        var prevIndex = allKeys.indexOf(currentLocation.key);
        var nextIndex = allKeys.indexOf(nextLocation.key);

        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL
      }
    });
  };

  var push = function push(input) {
    return transitionTo(createLocation(input, _Actions.PUSH));
  };

  var replace = function replace(input) {
    return transitionTo(createLocation(input, _Actions.REPLACE));
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength || 6);
  };

  var createHref = function createHref(location) {
    return (0, _PathUtils.createPath)(location);
  };

  var createLocation = function createLocation(location, action) {
    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
    return (0, _LocationUtils.createLocation)(location, action, key);
  };

  return {
    getCurrentLocation: getCurrentLocation,
    listenBefore: listenBefore,
    listen: listen,
    transitionTo: transitionTo,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    createKey: createKey,
    createPath: _PathUtils.createPath,
    createHref: createHref,
    createLocation: createLocation
  };
};

exports.default = createHistory;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var runTransitionHook = function runTransitionHook(hook, location, callback) {
  var result = hook(location, callback);

  if (hook.length < 2) {
    // Assume the hook runs synchronously and automatically
    // call the callback with the return value.
    callback(result);
  } else {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(result === undefined, 'You should not "return" in a transition hook with a callback argument; ' + 'call the callback instead') : void 0;
  }
};

exports.default = runTransitionHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal ||
  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
    freeSelf || thisGlobal || Function('return this')();

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = root;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module), __webpack_require__(37)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var proto = Element.prototype;
var vendor = proto.matches
  || proto.matchesSelector
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function(sel, data, children, text, elm) {
  var key = data === undefined ? undefined : data.key;
  return {sel: sel, data: data, children: children,
          text: text, elm: elm, key: key};
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var xstream_1 = __webpack_require__(0);
var enums_1 = __webpack_require__(3);
var dom_1 = __webpack_require__(1);
var transition_1 = __webpack_require__(13);
var utils_1 = __webpack_require__(9);
;
var Dimmer;
(function (Dimmer) {
    /**
     * A dimmer wrapper to show extra hidden content on an element.
     * Accepts the following type of target:
     *   VNode - The element to attach the dimmer to.
     *   "Page" - Creates a dimmer for the entire page.
     * Expects the following type of args: Boolean
     * Expects the following type of content: DOMContent
     * @param  {ComponentSources} sources The Component's sources.
     * @return {ComponentSinks} The Dimmer Component.
     */
    function run(sources, invert$) {
        if (invert$ === void 0) { invert$ = xstream_1.default.of(false); }
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".dimmable").events(type); };
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.args$ = sources.args$ ? sources.args$ : onHover(evt);
            var target$ = sources.target$.remember();
            var active$ = sources.args$.remember();
            var transition$ = active$
                .fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? ({ animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out })
                : { animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out
                }; }, ({ animation: enums_1.Animation.None, direction: enums_1.Direction.None }));
            var content$ = xstream_1.default.combine(sources.content$, target$, invert$)
                .map(function (_a) {
                var content = _a[0], target = _a[1], inverted = _a[2];
                return render(content, target, inverted);
            });
            var animatedContent = transition_1.Transition.run({ DOM: sources.DOM, args$: transition$, target$: content$ });
            var vTree$ = xstream_1.default.combine(target$, animatedContent.DOM, active$)
                .map(function (_a) {
                var target = _a[0], content = _a[1], active = _a[2];
                return dimElement(target, content, active);
            });
            return {
                DOM: vTree$,
                Events: animatedContent.Events,
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Dimmer.run = run;
    function render(content, target, inverted) {
        if (content === void 0) { content = ""; }
        if (target === void 0) { target = "page"; }
        if (inverted === void 0) { inverted = false; }
        return target === "page"
            ? dom_1.div({ props: { className: "ui " + (inverted ? "inverted " : "") + "dimmer modals page dimmer" } }, content)
            : dom_1.div({ props: { className: "ui " + (inverted ? "inverted " : "") + "targetted dimmer" } }, [
                dom_1.div({ props: { className: "content" } }, [
                    dom_1.div({ props: { className: "center" } }, content)
                ])
            ]);
    }
    Dimmer.render = render;
    function onHover(events) {
        return xstream_1.default.merge(events("mouseenter"), events("mouseleave"))
            .map(function (evt) { return evt.type === "mouseenter"; }).startWith(false);
    }
    function dimElement(targetOrString, content, active) {
        var isPage = typeof (targetOrString) === "string";
        var target = isPage ? content : targetOrString;
        var className = isPage ? "" : "dimmable", c;
        if (active) {
            className += isPage ? "active" : " dimmed";
        }
        var data = utils_1.patchClassList(target, ["dimmable", "dimmed", "inverted", "active"], className);
        if (isPage) {
            if (target.children) {
                c = target.children;
            }
            else if (target.text) {
                c = target.text;
            }
        }
        else {
            c = utils_1.addElement(content, target, "targetted");
        }
        return dom_1.h(target.sel, data, c);
    }
})(Dimmer = exports.Dimmer || (exports.Dimmer = {}));


/***/ }),
/* 37 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker = (function () {
    function ScopeChecker(scope, isolateModule) {
        this.scope = scope;
        this.isolateModule = isolateModule;
    }
    ScopeChecker.prototype.isStrictlyInRootScope = function (leaf) {
        for (var el = leaf; el; el = el.parentElement) {
            var scope = this.isolateModule.isIsolatedElement(el);
            if (scope && scope !== this.scope) {
                return false;
            }
            if (scope) {
                return true;
            }
        }
        return true;
    };
    return ScopeChecker;
}());
exports.ScopeChecker = ScopeChecker;
//# sourceMappingURL=ScopeChecker.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var xstream_1 = __webpack_require__(0);
function createVTree(vnode, children) {
    return {
        sel: vnode.sel,
        data: vnode.data,
        text: vnode.text,
        elm: vnode.elm,
        key: vnode.key,
        children: children,
    };
}
function makeTransposeVNode(runStreamAdapter) {
    function internalTransposeVNode(vnode) {
        if (!vnode) {
            return null;
        }
        else if (vnode && vnode.data && vnode.data.static) {
            return xstream_1.default.of(vnode);
        }
        else if (runStreamAdapter.isValidStream(vnode)) {
            var xsStream = xstream_adapter_1.default.adapt(vnode, runStreamAdapter.streamSubscribe);
            return xsStream.map(internalTransposeVNode).flatten();
        }
        else if (typeof vnode === "object") {
            if (!vnode.children || vnode.children.length === 0) {
                return xstream_1.default.of(vnode);
            }
            var vnodeChildren = vnode.children
                .map(internalTransposeVNode)
                .filter(function (x) { return x !== null; });
            if (vnodeChildren.length === 0) {
                return xstream_1.default.of(createVTree(vnode, []));
            }
            else {
                return xstream_1.default.combine.apply(xstream_1.default, vnodeChildren)
                    .map(function (children) { return createVTree(vnode, children.slice()); });
            }
        }
        else {
            throw new Error("Unhandled vTree Value");
        }
    }
    ;
    return function transposeVNode(vnode) {
        return internalTransposeVNode(vnode);
    };
}
exports.makeTransposeVNode = makeTransposeVNode;
//# sourceMappingURL=transposition.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * History driver factory
 *
 * This is a function which, when called, returns a History Driver for Cycle.js
 * apps. The driver is also a function, and it takes a stream of new locations
 * (strings representing pathnames or location objects) as input, and outputs
 * another stream of locations that were applied.
 *
 * @param {History} history the History object created by the history library.
 * This object is usually created through `createBrowserHistory()` or
 * `createHashHistory()` or `createMemoryHistory()` from the `history` library.
 * Alternatively, you may use `createServerHistory` from this library.
 * @param {object} options an object with some options specific to this driver.
 * Options may be: `capture`, a boolean to indicate whether the driver should
 * intercept and handle any click event that leads to a link, like on an `<a>`
 * element; `onError`, a callback function that takes an error as argument and
 * handles it, use this to configure what to do with driver errors.
 * @return {Function} the History Driver function
 * @function makeHistoryDriver
 */
var makeHistoryDriver_1 = __webpack_require__(81);
exports.makeHistoryDriver = makeHistoryDriver_1.makeHistoryDriver;
/**
 * Creates a "ServerHistory" object similar to the History objects that the
 * `history` library can create. Use this when you want to support server-side
 * rendering.
 *
 * @param {string|object} location this may be either a string representing the
 * pathname, or a location object with fields like `pathname`, `search`,
 * `query`, `state`, `action`, `key`, `hash`, etc.
 * @return {object} a History object.
 * @function createServerHistory
 */
var serverHistory_1 = __webpack_require__(82);
exports.createServerHistory = serverHistory_1.createServerHistory;
var util_1 = __webpack_require__(41);
exports.supportsHistory = util_1.supportsHistory;
exports.createLocation = util_1.createLocation;
//# sourceMappingURL=index.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var objectAssign = __webpack_require__(55);
function supportsHistory() {
    if (typeof navigator === 'undefined') {
        return false;
    }
    var ua = navigator.userAgent;
    if ((ua.indexOf('Android 2.') !== -1 ||
        ua.indexOf('Android 4.0') !== -1) &&
        ua.indexOf('Mobile Safari') !== -1 &&
        ua.indexOf('Chrome') === -1 &&
        ua.indexOf('Windows Phone') === -1) {
        return false;
    }
    if (typeof window !== 'undefined') {
        return window.history && 'pushState' in window.history;
    }
    else {
        return false;
    }
}
exports.supportsHistory = supportsHistory;
var locationDefaults = {
    pathname: '/',
    action: 'POP',
    hash: '',
    search: '',
    state: undefined,
    key: null,
    query: null,
};
function createLocation(location) {
    if (typeof location === 'string') {
        return objectAssign({}, locationDefaults, { pathname: location });
    }
    return objectAssign({}, locationDefaults, location);
}
exports.createLocation = createLocation;
//# sourceMappingURL=util.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports) {

/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear



var value = __webpack_require__(7);

module.exports = function () {
	value(this).length = 0;
	return this;
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = Object.create, getPrototypeOf = Object.getPrototypeOf
  , x = {};

module.exports = function (/*customCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf
	  , customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== 'function') return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554



var isObject      = __webpack_require__(103)
  , value         = __webpack_require__(7)

  , isPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty = Object.defineProperty
  , nullDesc = { configurable: true, enumerable: false, writable: true,
		value: undefined }
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if ((prototype === null) || isObject(prototype)) return obj;
	throw new TypeError('Prototype must be null or an object');
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, 'level', { configurable: false,
		enumerable: false, writable: false, value: status.level });
}((function () {
	var x = Object.create(null), y = {}, set
	  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');

	if (desc) {
		try {
			set = desc.set; // Opera crashes at this point
			set.call(x, y);
		} catch (ignore) { }
		if (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };
	}

	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 2 };

	x = {};
	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 1 };

	return false;
}())));

__webpack_require__(100);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(110)()
	? String.prototype.contains
	: __webpack_require__(111);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isIterable = __webpack_require__(115);

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(117)() ? Map : __webpack_require__(121);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readState = exports.saveState = undefined;

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR']; /* eslint-disable no-empty */


var SecurityError = 'SecurityError';
var KeyPrefix = '@@History/';

var createKey = function createKey(key) {
  return KeyPrefix + key;
};

var saveState = exports.saveState = function saveState(key, state) {
  if (!window.sessionStorage) {
    // Session storage is not available or hidden.
    // sessionStorage is undefined in Internet Explorer when served via file protocol.
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available') : void 0;
    return;
  }

  try {
    if (state == null) {
      window.sessionStorage.removeItem(createKey(key));
    } else {
      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
    }
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available due to security settings') : void 0;

      return;
    }

    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
      // Safari "private mode" throws QuotaExceededError.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : void 0;

      return;
    }

    throw error;
  }
};

var readState = exports.readState = function readState(key) {
  var json = void 0;
  try {
    json = window.sessionStorage.getItem(createKey(key));
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to read state; sessionStorage is not available due to security settings') : void 0;

      return undefined;
    }
  }

  if (json) {
    try {
      return JSON.parse(json);
    } catch (error) {
      // Ignore invalid JSON.
    }
  }

  return undefined;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 50 */
/***/ (function(module, exports) {

/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeHtmlChar(chr) {
  return htmlEscapes[chr];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value.
 * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
 * for more details.
 *
 * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
 * to reduce XSS vectors.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFor = __webpack_require__(138),
    bindCallback = __webpack_require__(141),
    keys = __webpack_require__(146);

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

/**
 * Creates a function for `_.forOwn` or `_.forOwnRight`.
 *
 * @private
 * @param {Function} objectFunc The function to iterate over an object.
 * @returns {Function} Returns the new each function.
 */
function createForOwn(objectFunc) {
  return function(object, iteratee, thisArg) {
    if (typeof iteratee != 'function' || thisArg !== undefined) {
      iteratee = bindCallback(iteratee, thisArg, 3);
    }
    return objectFunc(object, iteratee);
  };
}

/**
 * Iterates over own enumerable properties of an object invoking `iteratee`
 * for each property. The `iteratee` is bound to `thisArg` and invoked with
 * three arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => logs 'a' and 'b' (iteration order is not guaranteed)
 */
var forOwn = createForOwn(baseForOwn);

module.exports = forOwn;


/***/ }),
/* 53 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isArguments;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = selectorParser;

var _browserSplit = __webpack_require__(42);

var _browserSplit2 = _interopRequireDefault(_browserSplit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

function selectorParser() {
  var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

  var tagName = void 0;
  var id = '';
  var classes = [];

  var tagParts = (0, _browserSplit2.default)(selector, classIdSplit);

  if (notClassId.test(tagParts[1]) || selector === '') {
    tagName = 'div';
  }

  var part = void 0;
  var type = void 0;
  var i = void 0;

  for (i = 0; i < tagParts.length; i++) {
    part = tagParts[i];

    if (!part) {
      continue;
    }

    type = part.charAt(0);

    if (!tagName) {
      tagName = part;
    } else if (type === '.') {
      classes.push(part.substring(1, part.length));
    } else if (type === '#') {
      id = part.substring(1, part.length);
    }
  }

  return {
    tagName: tagName,
    id: id,
    className: classes.join(' ')
  };
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {


// https://github.com/Matt-Esch/virtual-dom/blob/master/virtual-hyperscript/parse-tag.js

var split = __webpack_require__(42);

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

module.exports = function parseSelector(selector, upper) {
  selector = selector || '';
  var tagName;
  var id = '';
  var classes = [];

  var tagParts = split(selector, classIdSplit);

  if (notClassId.test(tagParts[1]) || selector === '') {
    tagName = 'div';
  }

  var part, type, i;

  for (i = 0; i < tagParts.length; i++) {
    part = tagParts[i];

    if (!part) {
      continue;
    }

    type = part.charAt(0);

    if (!tagName) {
      tagName = part;
    } else if (type === '.') {
      classes.push(part.substring(1, part.length));
    } else if (type === '#') {
      id = part.substring(1, part.length);
    }
  }

  return {
    tagName: upper === true ? tagName.toUpperCase() : tagName,
    id: id,
    className: classes.join(' ')
  };
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(204));


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var Menu;
(function (Menu) {
    /**
     * A menu component for displaying an assortment of items.
     * Accepts the following properties:
     * 	secondary?: boolean - Styles the menu to de-emphasize its content.
     * 	pointing?: boolean - Styles the menu to be pointing to nearby content.
     * 	tabular?: boolean - Styles the menu to be suited for tabs.
     * 	text?: boolean - Styles the menu for text content.
     * 	vertical?: boolean - Styles the menu to display its content vertically.
     * 	pagination?: boolean - Formats the menu content to present links to pages of content.
     * 	fixed?: boolean - Styles the menu to appear fixed to its context.
     * 	stackable?: boolean - Ensures the menu content stacks on mobile resolutions.
     * 	inverted?: boolean - Styles the menu to have its colors inverted.
     * 	icon?: boolean - Styles the menu for icon content.
     * 	labelled?: boolean - Styles the menu for labelled icon content.
     * 	compact?: boolean - Styles the menu so that it takes only the amount of space neccesary.
     * 	evenlyDivided?: boolean - Styles the menu so that its content is evenly divided.
     * 	borderless?: boolean - Styles the menu so that there are no borders between its content.
     * 	color?: Color - The color of the menu.
     * 	attachment?: Attachment - The attachment of the menu.
     * 	size?: Size - The size of the menu.
     * Expects the following type of content: Array of {}
     * 	link?: boolean - Styles the item to appear clickable.
     * 	down?: boolean - Styles the item to appear pressed.
     * 	active?: boolean - Styles the item to be more pronounced.
     * 	disabled?: boolean - Styles the item to appear disabled.
     * 	header?: boolean - Styles the item text to be more pronounced.
     * 	fitted?: boolean - Removes the padding of the item.
     *         icon?: boolean - Styles the item for icon content.
     * 	color?: Color - The color of the item.
     * 	float? Float - The alignment of the item.
     * 	href?: string - The link for the item.
     * 	body: DOMContent - The content of the item.
     */
    function run(sources) {
        function main(sources) {
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            var click$ = sources.DOM.select(".ui.menu > .item").events("click");
            var items$ = sources.content$.remember();
            var clickedId$ = click$.map(function (ev) { return parseInt(ev.currentTarget.id); })
                .filter(function (n) { return !isNaN(n) && typeof (n) !== "undefined"; });
            var clickedItem$ = items$.map(function (items) { return clickedId$.map(function (id) { return items[id]; }); }).flatten()
                .filter(function (item) { return !item.disabled; });
            var vtree$ = xstream_1.default.combine(sources.props$, items$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vtree$,
                Events: function (type) { return sources.DOM.select(".menu").events(type); },
                value$: clickedItem$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Menu.run = run;
    /**
     * A menu component for displaying an assortment of items.
     * Accepts the following properties:
     * 	secondary?: boolean - Styles the menu to de-emphasize its content.
     * 	pointing?: boolean - Styles the menu to be pointing to nearby content.
     * 	tabular?: boolean - Styles the menu to be suited for tabs.
     * 	text?: boolean - Styles the menu for text content.
     * 	vertical?: boolean - Styles the menu to display its content vertically.
     * 	pagination?: boolean - Formats the menu content to present links to pages of content.
     * 	fixed?: boolean - Styles the menu to appear fixed to its context.
     * 	stackable?: boolean - Ensures the menu content stacks on mobile resolutions.
     * 	inverted?: boolean - Styles the menu to have its colors inverted.
     * 	icon?: boolean - Styles the menu for icon content.
     * 	labelled?: boolean - Styles the menu for labelled icon content.
     * 	compact?: boolean - Styles the menu so that it takes only the amount of space neccesary.
     * 	evenlyDivided?: boolean - Styles the menu so that its content is evenly divided.
     * 	borderless?: boolean - Styles the menu so that there are no borders between its content.
     * 	color?: Color - The color of the menu.
     * 	attachment?: Attachment - The attachment of the menu.
     * 	size?: Size - The size of the menu.
     * Expects the following type of content: Array of {}
     * 	link?: boolean - Styles the item to appear clickable.
     * 	down?: boolean - Styles the item to appear pressed.
     * 	active?: boolean - Styles the item to be more pronounced.
     * 	disabled?: boolean - Styles the item to appear disabled.
     * 	header?: boolean - Styles the item text to be more pronounced.
     * 	fitted?: boolean - Removes the padding of the item.
     *  icon?: boolean - Styles the item for icon content.
     * 	color?: Color - The color of the item.
     * 	float? Float - The alignment of the item.
     * 	href?: string - The link for the item.
     * 	body: DOMContent - The content of the item.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        var items = content.map(function (item) { return item.href
            ? dom_1.a({ props: { className: getItemClassname(item), id: content.indexOf(item), href: item.href } }, item.body)
            : dom_1.div({ props: { className: getItemClassname(item), id: content.indexOf(item) } }, item.body); });
        return dom_1.div({ props: { className: getClassname(props, content.length) } }, items);
    }
    Menu.render = render;
    function getClassname(props, length) {
        var className;
        if (!props.submenu) {
            className = "ui";
        }
        if (props.secondary) {
            className += " secondary";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (props.tabular) {
            className += " tabular";
        }
        if (props.text) {
            className += " text";
        }
        if (props.vertical) {
            className += " vertical";
        }
        if (props.pagination) {
            className += " pagination";
        }
        if (props.fixed) {
            className += " fixed";
        }
        if (props.stackable) {
            className += " stackable";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.labelled) {
            className += " labelled icon";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.borderless) {
            className += " borderless";
        }
        if (props.evenlyDivided) {
            className += utils_1.numToText(length) + " item";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " menu";
        return className;
    }
    function getItemClassname(item) {
        var className = "";
        if (item.down) {
            className += " down";
        }
        if (item.active) {
            className += " active";
        }
        if (item.header) {
            className += " header";
        }
        if (item.fitted) {
            className += " vertically fitted";
        }
        if (item.link) {
            className += " link";
        }
        if (item.icon) {
            className += " icon";
        }
        if (item.disabled) {
            className += " disabled";
        }
        if (typeof (item.float) !== "undefined") {
            className += enums_1.Float.ToClassname(item.float);
        }
        if (typeof (item.color) !== "undefined") {
            className += enums_1.Color.ToClassname(item.color);
        }
        className += " item";
        return className;
    }
})(Menu = exports.Menu || (exports.Menu = {}));


/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var DebounceOperator = (function () {
    function DebounceOperator(dt, ins) {
        this.dt = dt;
        this.ins = ins;
        this.type = 'debounce';
        this.out = null;
        this.id = null;
    }
    DebounceOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DebounceOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
        this.id = null;
    };
    DebounceOperator.prototype.clearInterval = function () {
        var id = this.id;
        if (id !== null) {
            clearInterval(id);
        }
        this.id = null;
    };
    DebounceOperator.prototype._n = function (t) {
        var _this = this;
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        this.id = setInterval(function () {
            _this.clearInterval();
            u._n(t);
        }, this.dt);
    };
    DebounceOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        u._e(err);
    };
    DebounceOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        u._c();
    };
    return DebounceOperator;
}());
/**
 * Delays events until a certain amount of silence has passed. If that timespan
 * of silence is not met the event is dropped.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2--3--4----5|
 *     debounce(60)
 * -----1----------4--|
 * ```
 *
 * Example:
 *
 * ```js
 * import fromDiagram from 'xstream/extra/fromDiagram'
 * import debounce from 'xstream/extra/debounce'
 *
 * const stream = fromDiagram('--1----2--3--4----5|')
 *  .compose(debounce(60))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1
 * > 4
 * > completed
 * ```
 *
 * @param {number} period The amount of silence required in milliseconds.
 * @return {Stream}
 */
function debounce(period) {
    return function debounceOperator(ins) {
        return new index_1.Stream(new DebounceOperator(period, ins));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = debounce;
//# sourceMappingURL=debounce.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var DelayOperator = (function () {
    function DelayOperator(dt, ins) {
        this.dt = dt;
        this.ins = ins;
        this.type = 'delay';
        this.out = null;
    }
    DelayOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DelayOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
    };
    DelayOperator.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._n(t);
            clearInterval(id);
        }, this.dt);
    };
    DelayOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._e(err);
            clearInterval(id);
        }, this.dt);
    };
    DelayOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._c();
            clearInterval(id);
        }, this.dt);
    };
    return DelayOperator;
}());
/**
 * Delays periodic events by a given time period.
 *
 * Marble diagram:
 *
 * ```text
 * 1----2--3--4----5|
 *     delay(60)
 * ---1----2--3--4----5|
 * ```
 *
 * Example:
 *
 * ```js
 * import fromDiagram from 'xstream/extra/fromDiagram'
 * import delay from 'xstream/extra/delay'
 *
 * const stream = fromDiagram('1----2--3--4----5|')
 *  .compose(delay(60))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1  (after 60 ms)
 * > 2  (after 160 ms)
 * > 3  (after 220 ms)
 * > 4  (after 280 ms)
 * > 5  (after 380 ms)
 * > completed
 * ```
 *
 * @param {number} period The amount of silence required in milliseconds.
 * @return {Stream}
 */
function delay(period) {
    return function delayOperator(ins) {
        return new index_1.Stream(new DelayOperator(period, ins));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = delay;
//# sourceMappingURL=delay.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var empty = {};
var DropRepeatsOperator = (function () {
    function DropRepeatsOperator(ins, fn) {
        this.ins = ins;
        this.fn = fn;
        this.type = 'dropRepeats';
        this.out = null;
        this.v = empty;
    }
    DropRepeatsOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DropRepeatsOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
        this.v = empty;
    };
    DropRepeatsOperator.prototype.isEq = function (x, y) {
        return this.fn ? this.fn(x, y) : x === y;
    };
    DropRepeatsOperator.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        var v = this.v;
        if (v !== empty && this.isEq(t, v))
            return;
        this.v = Array.isArray(t) ? t.slice() : t;
        u._n(t);
    };
    DropRepeatsOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    DropRepeatsOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        u._c();
    };
    return DropRepeatsOperator;
}());
exports.DropRepeatsOperator = DropRepeatsOperator;
/**
 * Drops consecutive duplicate values in a stream.
 *
 * Marble diagram:
 *
 * ```text
 * --1--2--1--1--1--2--3--4--3--3|
 *     dropRepeats
 * --1--2--1--------2--3--4--3---|
 * ```
 *
 * Example:
 *
 * ```js
 * import dropRepeats from 'xstream/extra/dropRepeats'
 *
 * const stream = xs.of(1, 2, 1, 1, 1, 2, 3, 4, 3, 3)
 *   .compose(dropRepeats())
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1
 * > 2
 * > 1
 * > 2
 * > 3
 * > 4
 * > 3
 * > completed
 * ```
 *
 * Example with a custom isEqual function:
 *
 * ```js
 * import dropRepeats from 'xstream/extra/dropRepeats'
 *
 * const stream = xs.of('a', 'b', 'a', 'A', 'B', 'b')
 *   .compose(dropRepeats((x, y) => x.toLowerCase() === y.toLowerCase()))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > a
 * > b
 * > a
 * > B
 * > completed
 * ```
 *
 * @param {Function} isEqual An optional function of type
 * `(x: T, y: T) => boolean` that takes an event from the input stream and
 * checks if it is equal to previous event, by returning a boolean.
 * @return {Stream}
 */
function dropRepeats(isEqual) {
    if (isEqual === void 0) { isEqual = void 0; }
    return function dropRepeatsOperator(ins) {
        return new index_1.Stream(new DropRepeatsOperator(ins, isEqual));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = dropRepeats;
//# sourceMappingURL=dropRepeats.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_run_1 = __webpack_require__(83);
var dom_1 = __webpack_require__(1);
var cyclic_router_1 = __webpack_require__(86);
var history_1 = __webpack_require__(133);
var xstream_1 = __webpack_require__(0);
var switch_path_1 = __webpack_require__(169);
var router_1 = __webpack_require__(177);
var routes_1 = __webpack_require__(178);
var layout_1 = __webpack_require__(175);
var history = cyclic_router_1.supportsHistory()
    ? [history_1.createHistory(), switch_path_1.default]
    : [history_1.createHashHistory(), switch_path_1.default];
function app(drivers) {
    var page = router_1.default(Object.assign({}, drivers, { routes: routes_1.default }));
    var layout = layout_1.Layout.run(drivers, page);
    var sinks = {
        DOM: layout.DOM,
        router: xstream_1.default.merge(page.router, layout.router),
    };
    return sinks;
}
xstream_run_1.run(app, {
    DOM: dom_1.makeDOMDriver(".app"),
    router: cyclic_router_1.makeRouterDriver.apply(null, history),
});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var fromEvent_1 = __webpack_require__(23);
var BodyDOMSource = (function () {
    function BodyDOMSource(_runStreamAdapter, _name) {
        this._runStreamAdapter = _runStreamAdapter;
        this._name = _name;
    }
    BodyDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    BodyDOMSource.prototype.elements = function () {
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(xstream_1.default.of(document.body), xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    BodyDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        var stream;
        if (options && typeof options.useCapture === 'boolean') {
            stream = fromEvent_1.fromEvent(document.body, eventType, options.useCapture);
        }
        else {
            stream = fromEvent_1.fromEvent(document.body, eventType);
        }
        var out = this._runStreamAdapter.adapt(stream, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    return BodyDOMSource;
}());
exports.BodyDOMSource = BodyDOMSource;
//# sourceMappingURL=BodyDOMSource.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var fromEvent_1 = __webpack_require__(23);
var DocumentDOMSource = (function () {
    function DocumentDOMSource(_runStreamAdapter, _name) {
        this._runStreamAdapter = _runStreamAdapter;
        this._name = _name;
    }
    DocumentDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    DocumentDOMSource.prototype.elements = function () {
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(xstream_1.default.of(document), xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    DocumentDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        var stream;
        if (options && typeof options.useCapture === 'boolean') {
            stream = fromEvent_1.fromEvent(document, eventType, options.useCapture);
        }
        else {
            stream = fromEvent_1.fromEvent(document, eventType);
        }
        var out = this._runStreamAdapter.adapt(stream, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    return DocumentDOMSource;
}());
exports.DocumentDOMSource = DocumentDOMSource;
//# sourceMappingURL=DocumentDOMSource.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker_1 = __webpack_require__(38);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(34);
}
catch (e) {
    matchesSelector = Function.prototype;
}
function toElArray(input) {
    return Array.prototype.slice.call(input);
}
var ElementFinder = (function () {
    function ElementFinder(namespace, isolateModule) {
        this.namespace = namespace;
        this.isolateModule = isolateModule;
    }
    ElementFinder.prototype.call = function (rootElement) {
        var namespace = this.namespace;
        if (namespace.join("") === "") {
            return rootElement;
        }
        var scope = utils_1.getScope(namespace);
        var scopeChecker = new ScopeChecker_1.ScopeChecker(scope, this.isolateModule);
        var selector = utils_1.getSelectors(namespace);
        var topNode = rootElement;
        var topNodeMatches = [];
        if (scope.length > 0) {
            topNode = this.isolateModule.getIsolatedElement(scope) || rootElement;
            if (selector && matchesSelector(topNode, selector)) {
                topNodeMatches.push(topNode);
            }
        }
        return toElArray(topNode.querySelectorAll(selector))
            .filter(scopeChecker.isStrictlyInRootScope, scopeChecker)
            .concat(topNodeMatches);
    };
    return ElementFinder;
}());
exports.ElementFinder = ElementFinder;
//# sourceMappingURL=ElementFinder.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker_1 = __webpack_require__(38);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(34);
}
catch (e) {
    matchesSelector = Function.prototype;
}
var gDestinationId = 0;
function findDestinationId(arr, searchId) {
    var minIndex = 0;
    var maxIndex = arr.length - 1;
    var currentIndex;
    var currentElement;
    while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0; // tslint:disable-line:no-bitwise
        currentElement = arr[currentIndex];
        var currentId = currentElement.destinationId;
        if (currentId < searchId) {
            minIndex = currentIndex + 1;
        }
        else if (currentId > searchId) {
            maxIndex = currentIndex - 1;
        }
        else {
            return currentIndex;
        }
    }
    return -1;
}
/**
 * Attaches an actual event listener to the DOM root element,
 * handles "destinations" (interested DOMSource output subjects), and bubbling.
 */
var EventDelegator = (function () {
    function EventDelegator(topElement, eventType, useCapture, isolateModule) {
        var _this = this;
        this.topElement = topElement;
        this.eventType = eventType;
        this.useCapture = useCapture;
        this.isolateModule = isolateModule;
        this.destinations = [];
        this.roof = topElement.parentElement;
        if (useCapture) {
            this.domListener = function (ev) { return _this.capture(ev); };
        }
        else {
            this.domListener = function (ev) { return _this.bubble(ev); };
        }
        topElement.addEventListener(eventType, this.domListener, useCapture);
    }
    EventDelegator.prototype.bubble = function (rawEvent) {
        if (!this.topElement.contains(rawEvent.currentTarget)) {
            return;
        }
        var ev = this.patchEvent(rawEvent);
        for (var el = ev.target; el && el !== this.roof; el = el.parentElement) {
            if (!this.topElement.contains(el)) {
                ev.stopPropagation();
            }
            if (ev.propagationHasBeenStopped) {
                return;
            }
            this.matchEventAgainstDestinations(el, ev);
        }
    };
    EventDelegator.prototype.matchEventAgainstDestinations = function (el, ev) {
        for (var i = 0, n = this.destinations.length; i < n; i++) {
            var dest = this.destinations[i];
            if (!dest.scopeChecker.isStrictlyInRootScope(el)) {
                continue;
            }
            if (matchesSelector(el, dest.selector)) {
                this.mutateEventCurrentTarget(ev, el);
                dest.subject._n(ev);
            }
        }
    };
    EventDelegator.prototype.capture = function (ev) {
        for (var i = 0, n = this.destinations.length; i < n; i++) {
            var dest = this.destinations[i];
            if (matchesSelector(ev.target, dest.selector)) {
                dest.subject._n(ev);
            }
        }
    };
    EventDelegator.prototype.addDestination = function (subject, namespace, destinationId) {
        var scope = utils_1.getScope(namespace);
        var selector = utils_1.getSelectors(namespace);
        var scopeChecker = new ScopeChecker_1.ScopeChecker(scope, this.isolateModule);
        this.destinations.push({ subject: subject, scopeChecker: scopeChecker, selector: selector, destinationId: destinationId });
    };
    EventDelegator.prototype.createDestinationId = function () {
        return gDestinationId++;
    };
    EventDelegator.prototype.removeDestinationId = function (destinationId) {
        var i = findDestinationId(this.destinations, destinationId);
        if (i >= 0) {
            this.destinations.splice(i, 1);
        }
    };
    EventDelegator.prototype.patchEvent = function (event) {
        var pEvent = event;
        pEvent.propagationHasBeenStopped = false;
        var oldStopPropagation = pEvent.stopPropagation;
        pEvent.stopPropagation = function stopPropagation() {
            oldStopPropagation.call(this);
            this.propagationHasBeenStopped = true;
        };
        return pEvent;
    };
    EventDelegator.prototype.mutateEventCurrentTarget = function (event, currentTargetElement) {
        try {
            Object.defineProperty(event, "currentTarget", {
                value: currentTargetElement,
                configurable: true,
            });
        }
        catch (err) {
            console.log("please use event.ownerTarget");
        }
        event.ownerTarget = currentTargetElement;
    };
    EventDelegator.prototype.updateTopElement = function (newTopElement) {
        this.topElement.removeEventListener(this.eventType, this.domListener, this.useCapture);
        newTopElement.addEventListener(this.eventType, this.domListener, this.useCapture);
        this.topElement = newTopElement;
    };
    return EventDelegator;
}());
exports.EventDelegator = EventDelegator;
//# sourceMappingURL=EventDelegator.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var HTMLSource = (function () {
    function HTMLSource(html$, runSA, _name) {
        this.runSA = runSA;
        this._name = _name;
        this._html$ = html$;
        this._empty$ = runSA.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
    }
    HTMLSource.prototype.elements = function () {
        var out = this.runSA.adapt(this._html$, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    HTMLSource.prototype.select = function (selector) {
        return new HTMLSource(xstream_1.default.empty(), this.runSA, this._name);
    };
    HTMLSource.prototype.events = function (eventType, options) {
        var out = this._empty$;
        out._isCycleSource = this._name;
        return out;
    };
    return HTMLSource;
}());
exports.HTMLSource = HTMLSource;
//# sourceMappingURL=HTMLSource.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var DocumentDOMSource_1 = __webpack_require__(67);
var BodyDOMSource_1 = __webpack_require__(66);
var xstream_1 = __webpack_require__(0);
var ElementFinder_1 = __webpack_require__(68);
var fromEvent_1 = __webpack_require__(23);
var isolate_1 = __webpack_require__(74);
var EventDelegator_1 = __webpack_require__(69);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(34);
}
catch (e) {
    matchesSelector = Function.prototype;
}
var eventTypesThatDontBubble = [
    "blur",
    "canplay",
    "canplaythrough",
    "change",
    "durationchange",
    "emptied",
    "ended",
    "focus",
    "load",
    "loadeddata",
    "loadedmetadata",
    "mouseenter",
    "mouseleave",
    "pause",
    "play",
    "playing",
    "ratechange",
    "reset",
    "scroll",
    "seeked",
    "seeking",
    "stalled",
    "submit",
    "suspend",
    "timeupdate",
    "unload",
    "volumechange",
    "waiting",
];
function determineUseCapture(eventType, options) {
    var result = false;
    if (typeof options.useCapture === 'boolean') {
        result = options.useCapture;
    }
    if (eventTypesThatDontBubble.indexOf(eventType) !== -1) {
        result = true;
    }
    return result;
}
function filterBasedOnIsolation(domSource, scope) {
    return function filterBasedOnIsolationOperator(rootElement$) {
        return rootElement$
            .fold(function shouldPass(state, element) {
            var hasIsolated = !!domSource._isolateModule.getIsolatedElement(scope);
            var shouldPass = hasIsolated && !state.hadIsolatedMutable;
            return { hadIsolatedMutable: hasIsolated, shouldPass: shouldPass, element: element };
        }, { hadIsolatedMutable: false, shouldPass: false, element: null })
            .drop(1)
            .filter(function (s) { return s.shouldPass; })
            .map(function (s) { return s.element; });
    };
}
var MainDOMSource = (function () {
    function MainDOMSource(_rootElement$, _sanitation$, _runStreamAdapter, _namespace, _isolateModule, _delegators, _name) {
        var _this = this;
        if (_namespace === void 0) { _namespace = []; }
        this._rootElement$ = _rootElement$;
        this._sanitation$ = _sanitation$;
        this._runStreamAdapter = _runStreamAdapter;
        this._namespace = _namespace;
        this._isolateModule = _isolateModule;
        this._delegators = _delegators;
        this._name = _name;
        this.__JANI_EVAKALLIO_WE_WILL_MISS_YOU_PLEASE_COME_BACK_EVENTUALLY = false;
        this.__JANI_EVAKALLIO_WE_WILL_MISS_YOU_PLEASE_COME_BACK_EVENTUALLY = true;
        this.isolateSource = isolate_1.isolateSource;
        this.isolateSink = function (sink, scope) {
            var existingScope = utils_1.getScope(_this._namespace);
            var deeperScope = [existingScope, scope].filter(function (x) { return !!x; }).join('-');
            return isolate_1.isolateSink(sink, deeperScope);
        };
    }
    MainDOMSource.prototype.elements = function () {
        var output$;
        if (this._namespace.length === 0) {
            output$ = this._rootElement$;
        }
        else {
            var elementFinder_1 = new ElementFinder_1.ElementFinder(this._namespace, this._isolateModule);
            output$ = this._rootElement$.map(function (el) { return elementFinder_1.call(el); });
        }
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(output$, xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    Object.defineProperty(MainDOMSource.prototype, "namespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    MainDOMSource.prototype.select = function (selector) {
        if (typeof selector !== 'string') {
            throw new Error("DOM driver's select() expects the argument to be a " +
                "string as a CSS selector");
        }
        if (selector === 'document') {
            return new DocumentDOMSource_1.DocumentDOMSource(this._runStreamAdapter, this._name);
        }
        if (selector === 'body') {
            return new BodyDOMSource_1.BodyDOMSource(this._runStreamAdapter, this._name);
        }
        var trimmedSelector = selector.trim();
        var childNamespace = trimmedSelector === ":root" ?
            this._namespace :
            this._namespace.concat(trimmedSelector);
        return new MainDOMSource(this._rootElement$, this._sanitation$, this._runStreamAdapter, childNamespace, this._isolateModule, this._delegators, this._name);
    };
    MainDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        if (typeof eventType !== "string") {
            throw new Error("DOM driver's events() expects argument to be a " +
                "string representing the event type to listen for.");
        }
        var useCapture = determineUseCapture(eventType, options);
        var namespace = this._namespace;
        var scope = utils_1.getScope(namespace);
        var keyParts = [eventType, useCapture];
        if (scope) {
            keyParts.push(scope);
        }
        var key = keyParts.join('~');
        var domSource = this;
        var rootElement$;
        if (scope) {
            rootElement$ = this._rootElement$
                .compose(filterBasedOnIsolation(domSource, scope));
        }
        else {
            rootElement$ = this._rootElement$.take(2);
        }
        var event$ = rootElement$
            .map(function setupEventDelegatorOnTopElement(rootElement) {
            // Event listener just for the root element
            if (!namespace || namespace.length === 0) {
                return fromEvent_1.fromEvent(rootElement, eventType, useCapture);
            }
            // Event listener on the top element as an EventDelegator
            var delegators = domSource._delegators;
            var top = domSource._isolateModule.getIsolatedElement(scope) || rootElement;
            var delegator;
            if (delegators.has(key)) {
                delegator = delegators.get(key);
                delegator.updateTopElement(top);
            }
            else {
                delegator = new EventDelegator_1.EventDelegator(top, eventType, useCapture, domSource._isolateModule);
                delegators.set(key, delegator);
            }
            if (scope) {
                domSource._isolateModule.addEventDelegator(scope, delegator);
            }
            var destinationId = delegator.createDestinationId();
            var subject = xstream_1.default.create({
                start: function () { },
                stop: function () {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(function () {
                            delegator.removeDestinationId(destinationId);
                        });
                    }
                    else {
                        delegator.removeDestinationId(destinationId);
                    }
                },
            });
            delegator.addDestination(subject, namespace, destinationId);
            return subject;
        })
            .flatten();
        var out = this._runStreamAdapter.adapt(event$, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = domSource._name;
        return out;
    };
    MainDOMSource.prototype.dispose = function () {
        this._sanitation$.shamefullySendNext('');
        this._isolateModule.reset();
    };
    return MainDOMSource;
}());
exports.MainDOMSource = MainDOMSource;
//# sourceMappingURL=MainDOMSource.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hyperscript_1 = __webpack_require__(24);
var classNameFromVNode_1 = __webpack_require__(151);
var selectorParser_1 = __webpack_require__(56);
var VNodeWrapper = (function () {
    function VNodeWrapper(rootElement) {
        this.rootElement = rootElement;
    }
    VNodeWrapper.prototype.call = function (vnode) {
        var _a = selectorParser_1.default(vnode.sel), selectorTagName = _a.tagName, selectorId = _a.id;
        var vNodeClassName = classNameFromVNode_1.default(vnode);
        var vNodeData = vnode.data || {};
        var vNodeDataProps = vNodeData.props || {};
        var _b = vNodeDataProps.id, vNodeId = _b === void 0 ? selectorId : _b;
        var isVNodeAndRootElementIdentical = vNodeId.toUpperCase() === this.rootElement.id.toUpperCase() &&
            selectorTagName.toUpperCase() === this.rootElement.tagName.toUpperCase() &&
            vNodeClassName.toUpperCase() === this.rootElement.className.toUpperCase();
        if (isVNodeAndRootElementIdentical) {
            return vnode;
        }
        var _c = this.rootElement, tagName = _c.tagName, id = _c.id, className = _c.className;
        var elementId = id ? "#" + id : "";
        var elementClassName = className ?
            "." + className.split(" ").join(".") : "";
        return hyperscript_1.h("" + tagName.toLowerCase() + elementId + elementClassName, {}, [
            vnode,
        ]);
    };
    return VNodeWrapper;
}());
exports.VNodeWrapper = VNodeWrapper;
//# sourceMappingURL=VNodeWrapper.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hyperscript_1 = __webpack_require__(24);
function isValidString(param) {
    return typeof param === 'string' && param.length > 0;
}
function isSelector(param) {
    return isValidString(param) && (param[0] === '.' || param[0] === '#');
}
function createTagFunction(tagName) {
    return function hyperscript(first, b, c) {
        if (isSelector(first)) {
            if (typeof b !== 'undefined' && typeof c !== 'undefined') {
                return hyperscript_1.h(tagName + first, b, c);
            }
            else if (typeof b !== 'undefined') {
                return hyperscript_1.h(tagName + first, b);
            }
            else {
                return hyperscript_1.h(tagName + first, {});
            }
        }
        else if (!!b) {
            return hyperscript_1.h(tagName, first, b);
        }
        else if (!!first) {
            return hyperscript_1.h(tagName, first);
        }
        else {
            return hyperscript_1.h(tagName, {});
        }
    };
}
var SVG_TAG_NAMES = [
    'a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
    'animateMotion', 'animateTransform', 'circle', 'clipPath', 'colorProfile',
    'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
    'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting',
    'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB',
    'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',
    'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting',
    'feSpotlight', 'feTile', 'feTurbulence', 'filter', 'font', 'fontFace',
    'fontFaceFormat', 'fontFaceName', 'fontFaceSrc', 'fontFaceUri',
    'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line',
    'linearGradient', 'marker', 'mask', 'metadata', 'missingGlyph', 'mpath',
    'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script',
    'set', 'stop', 'style', 'switch', 'symbol', 'text', 'textPath', 'title',
    'tref', 'tspan', 'use', 'view', 'vkern',
];
var svg = createTagFunction('svg');
SVG_TAG_NAMES.forEach(function (tag) {
    svg[tag] = createTagFunction(tag);
});
var TAG_NAMES = [
    'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base',
    'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption',
    'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'dir', 'div', 'dl',
    'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html',
    'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend',
    'li', 'link', 'main', 'map', 'mark', 'menu', 'meta', 'nav', 'noscript',
    'object', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'progress', 'q',
    'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small',
    'source', 'span', 'strong', 'style', 'sub', 'sup', 'table', 'tbody', 'td',
    'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'u', 'ul', 'video',
];
var exported = { SVG_TAG_NAMES: SVG_TAG_NAMES, TAG_NAMES: TAG_NAMES, svg: svg, isSelector: isSelector, createTagFunction: createTagFunction };
TAG_NAMES.forEach(function (n) {
    exported[n] = createTagFunction(n);
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exported;
//# sourceMappingURL=hyperscript-helpers.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils_1 = __webpack_require__(15);
function isolateSource(source, scope) {
    return source.select(utils_1.SCOPE_PREFIX + scope);
}
exports.isolateSource = isolateSource;
function isolateSink(sink, scope) {
    return sink.map(function (vTree) {
        if (vTree.data && vTree.data.isolate) {
            var existingScope = vTree.data.isolate.replace(/(cycle|\-)/g, '');
            var _scope = scope.replace(/(cycle|\-)/g, '');
            if (isNaN(parseInt(existingScope))
                || isNaN(parseInt(_scope))
                || existingScope > _scope) {
                return vTree;
            }
        }
        vTree.data = vTree.data || {};
        vTree.data.isolate = scope;
        if (typeof vTree.key === 'undefined') {
            vTree.key = utils_1.SCOPE_PREFIX + scope;
        }
        return vTree;
    });
}
exports.isolateSink = isolateSink;
//# sourceMappingURL=isolate.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MapPolyfill = __webpack_require__(48);
var IsolateModule = (function () {
    function IsolateModule(isolatedElements) {
        this.isolatedElements = isolatedElements;
        this.eventDelegators = new MapPolyfill();
    }
    IsolateModule.prototype.setScope = function (elm, scope) {
        this.isolatedElements.set(scope, elm);
    };
    IsolateModule.prototype.removeScope = function (scope) {
        this.isolatedElements.delete(scope);
    };
    IsolateModule.prototype.cleanupVNode = function (_a) {
        var data = _a.data, elm = _a.elm;
        data = data || {};
        var scope = data.isolate || '';
        var isCurrentElm = this.isolatedElements.get(scope) === elm;
        if (scope && isCurrentElm) {
            this.removeScope(scope);
            if (this.eventDelegators.get(scope)) {
                this.eventDelegators.set(scope, []);
            }
        }
    };
    IsolateModule.prototype.getIsolatedElement = function (scope) {
        return this.isolatedElements.get(scope);
    };
    IsolateModule.prototype.isIsolatedElement = function (elm) {
        var iterator = this.isolatedElements.entries();
        for (var result = iterator.next(); !!result.value; result = iterator.next()) {
            var _a = result.value, scope = _a[0], element = _a[1];
            if (elm === element) {
                return scope;
            }
        }
        return false;
    };
    IsolateModule.prototype.addEventDelegator = function (scope, eventDelegator) {
        var delegators = this.eventDelegators.get(scope);
        if (!delegators) {
            delegators = [];
            this.eventDelegators.set(scope, delegators);
        }
        delegators[delegators.length] = eventDelegator;
    };
    IsolateModule.prototype.reset = function () {
        this.isolatedElements.clear();
    };
    IsolateModule.prototype.createModule = function () {
        var self = this;
        return {
            create: function (oldVNode, vNode) {
                var _a = oldVNode.data, oldData = _a === void 0 ? {} : _a;
                var elm = vNode.elm, _b = vNode.data, data = _b === void 0 ? {} : _b;
                var oldScope = oldData.isolate || "";
                var scope = data.isolate || "";
                if (scope) {
                    if (oldScope) {
                        self.removeScope(oldScope);
                    }
                    self.setScope(elm, scope);
                    var delegators = self.eventDelegators.get(scope);
                    if (delegators) {
                        for (var i = 0, len = delegators.length; i < len; ++i) {
                            delegators[i].updateTopElement(elm);
                        }
                    }
                    else if (delegators === void 0) {
                        self.eventDelegators.set(scope, []);
                    }
                }
                if (oldScope && !scope) {
                    self.removeScope(scope);
                }
            },
            update: function (oldVNode, vNode) {
                var _a = oldVNode.data, oldData = _a === void 0 ? {} : _a;
                var elm = vNode.elm, _b = vNode.data, data = _b === void 0 ? {} : _b;
                var oldScope = oldData.isolate || "";
                var scope = data.isolate || "";
                if (scope && scope !== oldScope) {
                    if (oldScope) {
                        self.removeScope(oldScope);
                    }
                    self.setScope(elm, scope);
                }
                if (oldScope && !scope) {
                    self.removeScope(scope);
                }
            },
            remove: function (vNode, cb) {
                self.cleanupVNode(vNode);
                cb();
            },
            destroy: function (vNode) {
                self.cleanupVNode(vNode);
            },
        };
    };
    return IsolateModule;
}());
exports.IsolateModule = IsolateModule;
//# sourceMappingURL=isolateModule.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var snabbdom_1 = __webpack_require__(166);
var xstream_1 = __webpack_require__(0);
var MainDOMSource_1 = __webpack_require__(71);
var VNodeWrapper_1 = __webpack_require__(72);
var utils_1 = __webpack_require__(15);
var modules_1 = __webpack_require__(79);
var isolateModule_1 = __webpack_require__(75);
var transposition_1 = __webpack_require__(39);
var xstream_adapter_1 = __webpack_require__(6);
var MapPolyfill = __webpack_require__(48);
function makeDOMDriverInputGuard(modules) {
    if (!Array.isArray(modules)) {
        throw new Error("Optional modules option must be " +
            "an array for snabbdom modules");
    }
}
function domDriverInputGuard(view$) {
    if (!view$
        || typeof view$.addListener !== "function"
        || typeof view$.fold !== "function") {
        throw new Error("The DOM driver function expects as input a Stream of " +
            "virtual DOM elements");
    }
}
function makeDOMDriver(container, options) {
    if (!options) {
        options = {};
    }
    var transposition = options.transposition || false;
    var modules = options.modules || modules_1.default;
    var isolateModule = new isolateModule_1.IsolateModule((new MapPolyfill()));
    var patch = snabbdom_1.init([isolateModule.createModule()].concat(modules));
    var rootElement = utils_1.getElement(container);
    var vnodeWrapper = new VNodeWrapper_1.VNodeWrapper(rootElement);
    var delegators = new MapPolyfill();
    makeDOMDriverInputGuard(modules);
    function DOMDriver(vnode$, runStreamAdapter, name) {
        domDriverInputGuard(vnode$);
        var transposeVNode = transposition_1.makeTransposeVNode(runStreamAdapter);
        var preprocessedVNode$ = (transposition ? vnode$.map(transposeVNode).flatten() : vnode$);
        var sanitation$ = xstream_1.default.create();
        var rootElement$ = xstream_1.default.merge(preprocessedVNode$.endWhen(sanitation$), sanitation$)
            .map(function (vnode) { return vnodeWrapper.call(vnode); })
            .fold(patch, rootElement)
            .drop(1)
            .map(function unwrapElementFromVNode(vnode) { return vnode.elm; })
            .compose(function (stream) { return xstream_1.default.merge(stream, xstream_1.default.never()); }) // don't complete this stream
            .startWith(rootElement);
        rootElement$.addListener({ next: function () { }, error: function () { }, complete: function () { } });
        return new MainDOMSource_1.MainDOMSource(rootElement$, sanitation$, runStreamAdapter, [], isolateModule, delegators, name);
    }
    ;
    DOMDriver.streamAdapter = xstream_adapter_1.default;
    return DOMDriver;
}
exports.makeDOMDriver = makeDOMDriver;
//# sourceMappingURL=makeDOMDriver.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var transposition_1 = __webpack_require__(39);
var HTMLSource_1 = __webpack_require__(70);
var toHTML = __webpack_require__(153);
var noop = function () { };
function makeHTMLDriver(effect, options) {
    if (!options) {
        options = {};
    }
    var transposition = options.transposition || false;
    function htmlDriver(vnode$, runStreamAdapter, name) {
        var transposeVNode = transposition_1.makeTransposeVNode(runStreamAdapter);
        var preprocessedVNode$ = (transposition ? vnode$.map(transposeVNode).flatten() : vnode$);
        var html$ = preprocessedVNode$.map(toHTML);
        html$.addListener({
            next: effect || noop,
            error: noop,
            complete: noop,
        });
        return new HTMLSource_1.HTMLSource(html$, runStreamAdapter, name);
    }
    ;
    htmlDriver.streamAdapter = xstream_adapter_1.default;
    return htmlDriver;
}
exports.makeHTMLDriver = makeHTMLDriver;
//# sourceMappingURL=makeHTMLDriver.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var xstream_1 = __webpack_require__(0);
var SCOPE_PREFIX = '___';
var MockedDOMSource = (function () {
    function MockedDOMSource(_streamAdapter, _mockConfig) {
        this._streamAdapter = _streamAdapter;
        this._mockConfig = _mockConfig;
        if (_mockConfig.elements) {
            this._elements = _mockConfig.elements;
        }
        else {
            this._elements = _streamAdapter.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
        }
    }
    MockedDOMSource.prototype.elements = function () {
        var out = this._elements;
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.events = function (eventType, options) {
        var mockConfig = this._mockConfig;
        var keys = Object.keys(mockConfig);
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
            var key = keys[i];
            if (key === eventType) {
                var out_1 = mockConfig[key];
                out_1._isCycleSource = 'MockedDOM';
                return out_1;
            }
        }
        var out = this._streamAdapter.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.select = function (selector) {
        var mockConfig = this._mockConfig;
        var keys = Object.keys(mockConfig);
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
            var key = keys[i];
            if (key === selector) {
                return new MockedDOMSource(this._streamAdapter, mockConfig[key]);
            }
        }
        return new MockedDOMSource(this._streamAdapter, {});
    };
    MockedDOMSource.prototype.isolateSource = function (source, scope) {
        return source.select('.' + SCOPE_PREFIX + scope);
    };
    MockedDOMSource.prototype.isolateSink = function (sink, scope) {
        return sink.map(function (vnode) {
            if (vnode.sel && vnode.sel.indexOf(SCOPE_PREFIX + scope) !== -1) {
                return vnode;
            }
            else {
                vnode.sel += "." + SCOPE_PREFIX + scope;
                return vnode;
            }
        });
    };
    return MockedDOMSource;
}());
exports.MockedDOMSource = MockedDOMSource;
function mockDOMSource(streamAdapter, mockConfig) {
    return new MockedDOMSource(streamAdapter, mockConfig);
}
exports.mockDOMSource = mockDOMSource;
//# sourceMappingURL=mockDOMSource.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ClassModule = __webpack_require__(161);
exports.ClassModule = ClassModule;
var PropsModule = __webpack_require__(164);
exports.PropsModule = PropsModule;
var AttrsModule = __webpack_require__(160);
exports.AttrsModule = AttrsModule;
var EventsModule = __webpack_require__(162);
exports.EventsModule = EventsModule;
var StyleModule = __webpack_require__(165);
exports.StyleModule = StyleModule;
var HeroModule = __webpack_require__(163);
exports.HeroModule = HeroModule;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = [StyleModule, ClassModule, PropsModule, AttrsModule];
//# sourceMappingURL=modules.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var clickEvent = 'undefined' !== typeof document && document.ontouchstart ?
    'touchstart' : 'click';
function which(ev) {
    if (typeof window === 'undefined') {
        return false;
    }
    var e = ev || window.event;
    return e.which === null ? e.button : e.which;
}
function sameOrigin(href) {
    if (typeof window === 'undefined') {
        return false;
    }
    return href && href.indexOf(window.location.origin) === 0;
}
function makeClickListener(push) {
    return function clickListener(event) {
        if (which(event) !== 1) {
            return;
        }
        if (event.metaKey || event.ctrlKey || event.shiftKey) {
            return;
        }
        if (event.defaultPrevented) {
            return;
        }
        var element = event.target;
        while (element && element.nodeName !== 'A') {
            element = element.parentNode;
        }
        if (!element || element.nodeName !== 'A') {
            return;
        }
        if (element.hasAttribute('download') ||
            element.getAttribute('rel') === 'external') {
            return;
        }
        if (element.target) {
            return;
        }
        var link = element.getAttribute('href');
        if (link && link.indexOf('mailto:') > -1 || link.charAt(0) === '#') {
            return;
        }
        if (!sameOrigin(element.href)) {
            return;
        }
        event.preventDefault();
        var pathname = element.pathname, search = element.search, _a = element.hash, hash = _a === void 0 ? '' : _a;
        push(pathname + search + hash);
    };
}
function captureClicks(push) {
    var listener = makeClickListener(push);
    if (typeof window !== 'undefined') {
        document.addEventListener(clickEvent, listener, false);
    }
}
exports.captureClicks = captureClicks;
//# sourceMappingURL=captureClicks.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var captureClicks_1 = __webpack_require__(80);
function makeUpdateHistory(history) {
    return function updateHistory(location) {
        if (typeof location === 'string') {
            history.push(history.createLocation(location));
        }
        else if (typeof location === 'object') {
            // suport things like history.replace()
            var _a = location.type, type = _a === void 0 ? 'push' : _a;
            if (type === 'go') {
                history[type](location);
            }
            else {
                history[type](location);
            }
        }
        else {
            throw new Error('History Driver input must be a string or an ' +
                'object but received ${typeof url}');
        }
    };
}
function defaultOnErrorFn(err) {
    if (console && console.error !== void 0) {
        console.error(err);
    }
}
function makeHistoryDriver(history, options) {
    if (!history || typeof history !== 'object'
        || typeof history.createLocation !== 'function'
        || typeof history.createHref !== 'function'
        || typeof history.listen !== 'function'
        || typeof history.push !== 'function') {
        throw new TypeError('makeHistoryDriver requires an valid history object ' +
            'containing createLocation(), createHref(), push(), and listen() methods');
    }
    var capture = options && options.capture || false;
    var onError = options && options.onError || defaultOnErrorFn;
    return function historyDriver(sink$, runSA) {
        var _a = runSA.makeSubject(), observer = _a.observer, stream = _a.stream;
        var history$ = runSA.remember(stream
            .startWith(history.getCurrentLocation())
            .filter(Boolean));
        var unlisten = history.listen(function (location) {
            observer.next(location);
        });
        if (typeof history.addCompleteCallback === 'function'
            && typeof history.complete === 'function') {
            history.addCompleteCallback(function () {
                observer.complete();
            });
        }
        runSA.streamSubscribe(sink$, {
            next: makeUpdateHistory(history),
            error: onError,
            complete: function () {
                unlisten();
                observer.complete();
            },
        });
        if (capture) {
            captureClicks_1.captureClicks(function (pathname) {
                var location = history.createLocation(pathname);
                history.push(location);
            });
        }
        history$.createHref = function (href) { return history.createHref(href); };
        history$.createLocation = function (location) { return history.createLocation(location); };
        return history$;
    };
}
exports.makeHistoryDriver = makeHistoryDriver;
//# sourceMappingURL=makeHistoryDriver.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util_1 = __webpack_require__(41);
var ServerHistory = (function () {
    function ServerHistory(currentLocation) {
        this.currentLocation = currentLocation;
        this.listeners = [];
    }
    ServerHistory.prototype.listen = function (listener) {
        this.listeners.push(listener);
        return function noop() { return void 0; };
    };
    ServerHistory.prototype.push = function (location) {
        var length = this.listeners.length;
        if (length === 0) {
            throw new Error('Must be given at least one listener before pushing');
        }
        for (var i = 0; i < length; ++i) {
            this.listeners[i](util_1.createLocation(location));
        }
    };
    ServerHistory.prototype.replace = function (location) {
        this.push(location);
    };
    ServerHistory.prototype.createHref = function (path) {
        return path;
    };
    ServerHistory.prototype.createLocation = function (location) {
        return util_1.createLocation(location);
    };
    ServerHistory.prototype.getCurrentLocation = function () {
        return this.currentLocation;
    };
    ServerHistory.prototype.addCompleteCallback = function (complete) {
        this._completeCallback = complete;
    };
    ServerHistory.prototype.complete = function () {
        this._completeCallback();
    };
    return ServerHistory;
}());
function createServerHistory(loc) {
    return new ServerHistory(loc ? util_1.createLocation(loc) : null);
}
exports.createServerHistory = createServerHistory;
//# sourceMappingURL=serverHistory.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var base_1 = __webpack_require__(84);
var xstream_adapter_1 = __webpack_require__(6);
/**
 * Takes a `main` function and circularly connects it to the given collection
 * of driver functions.
 *
 * **Example:**
 * ```js
 * import {run} from '@cycle/xstream-run';
 * const dispose = run(main, drivers);
 * // ...
 * dispose();
 * ```
 *
 * The `main` function expects a collection of "source" streams (returned from
 * drivers) as input, and should return a collection of "sink" streams (to be
 * given to drivers). A "collection of streams" is a JavaScript object where
 * keys match the driver names registered by the `drivers` object, and values
 * are the streams. Refer to the documentation of each driver to see more
 * details on what types of sources it outputs and sinks it receives.
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Function} a dispose function, used to terminate the execution of the
 * Cycle.js program, cleaning up resources used.
 * @function run
 */
function run(main, drivers) {
    var _a = base_1.default(main, drivers, { streamAdapter: xstream_adapter_1.default }), run = _a.run, sinks = _a.sinks;
    if (typeof window !== 'undefined' && window['CyclejsDevTool_startGraphSerializer']) {
        window['CyclejsDevTool_startGraphSerializer'](sinks);
    }
    return run();
}
exports.run = run;
/**
 * A function that prepares the Cycle application to be executed. Takes a `main`
 * function and prepares to circularly connects it to the given collection of
 * driver functions. As an output, `Cycle()` returns an object with three
 * properties: `sources`, `sinks` and `run`. Only when `run()` is called will
 * the application actually execute. Refer to the documentation of `run()` for
 * more details.
 *
 * **Example:**
 * ```js
 * import Cycle from '@cycle/xstream-run';
 * const {sources, sinks, run} = Cycle(main, drivers);
 * // ...
 * const dispose = run(); // Executes the application
 * // ...
 * dispose();
 * ```
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Object} an object with three properties: `sources`, `sinks` and
 * `run`. `sources` is the collection of driver sources, `sinks` is the
 * collection of driver sinks, these can be used for debugging or testing. `run`
 * is the function that once called will execute the application.
 * @function Cycle
 */
var Cycle = function (main, drivers) {
    var out = base_1.default(main, drivers, { streamAdapter: xstream_adapter_1.default });
    if (typeof window !== 'undefined' && window['CyclejsDevTool_startGraphSerializer']) {
        window['CyclejsDevTool_startGraphSerializer'](out.sinks);
    }
    return out;
};
Cycle.run = run;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Cycle;
//# sourceMappingURL=index.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function logToConsoleError(err) {
    var target = err.stack || err;
    if (console && console.error) {
        console.error(target);
    }
    else if (console && console.log) {
        console.log(target);
    }
}
function makeSinkProxies(drivers, streamAdapter) {
    var sinkProxies = {};
    for (var name_1 in drivers) {
        if (drivers.hasOwnProperty(name_1)) {
            var subject = streamAdapter.makeSubject();
            var driverStreamAdapter = drivers[name_1].streamAdapter || streamAdapter;
            var stream = driverStreamAdapter.adapt(subject.stream, streamAdapter.streamSubscribe);
            sinkProxies[name_1] = {
                stream: stream,
                observer: subject.observer,
            };
        }
    }
    return sinkProxies;
}
function callDrivers(drivers, sinkProxies, streamAdapter) {
    var sources = {};
    for (var name_2 in drivers) {
        if (drivers.hasOwnProperty(name_2)) {
            var driverOutput = drivers[name_2](sinkProxies[name_2].stream, streamAdapter, name_2);
            var driverStreamAdapter = drivers[name_2].streamAdapter;
            if (driverStreamAdapter && driverStreamAdapter.isValidStream(driverOutput)) {
                sources[name_2] = streamAdapter.adapt(driverOutput, driverStreamAdapter.streamSubscribe);
            }
            else {
                sources[name_2] = driverOutput;
            }
            if (sources[name_2] && typeof sources[name_2] === 'object') {
                sources[name_2]._isCycleSource = name_2;
            }
        }
    }
    return sources;
}
function replicateMany(sinks, sinkProxies, streamAdapter) {
    var sinkNames = Object.keys(sinks).filter(function (name) { return !!sinkProxies[name]; });
    var buffers = {};
    var replicators = {};
    sinkNames.forEach(function (name) {
        buffers[name] = { next: [], error: [], complete: [] };
        replicators[name] = {
            next: function (x) { return buffers[name].next.push(x); },
            error: function (x) { return buffers[name].error.push(x); },
            complete: function (x) { return buffers[name].complete.push(x); },
        };
    });
    var subscriptions = sinkNames.map(function (name) {
        return streamAdapter.streamSubscribe(sinks[name], {
            next: function (x) {
                replicators[name].next(x);
            },
            error: function (err) {
                logToConsoleError(err);
                replicators[name].error(err);
            },
            complete: function (x) {
                replicators[name].complete(x);
            },
        });
    });
    var disposeFunctions = subscriptions
        .filter(function (fn) { return typeof fn === 'function'; });
    sinkNames.forEach(function (name) {
        var observer = sinkProxies[name].observer;
        var next = observer.next;
        var error = observer.error;
        var complete = observer.complete;
        buffers[name].next.forEach(next);
        buffers[name].error.forEach(error);
        buffers[name].complete.forEach(complete);
        replicators[name].next = next;
        replicators[name].error = error;
        replicators[name].complete = complete;
    });
    return function () {
        disposeFunctions.forEach(function (dispose) { return dispose(); });
    };
}
function disposeSources(sources) {
    for (var k in sources) {
        if (sources.hasOwnProperty(k) && sources[k]
            && typeof sources[k].dispose === 'function') {
            sources[k].dispose();
        }
    }
}
var isObjectEmpty = function (obj) { return Object.keys(obj).length === 0; };
function Cycle(main, drivers, options) {
    if (typeof main !== "function") {
        throw new Error("First argument given to Cycle must be the 'main' " +
            "function.");
    }
    if (typeof drivers !== "object" || drivers === null) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with driver functions as properties.");
    }
    if (isObjectEmpty(drivers)) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with at least one driver function declared as a property.");
    }
    var streamAdapter = options.streamAdapter;
    if (!streamAdapter || isObjectEmpty(streamAdapter)) {
        throw new Error("Third argument given to Cycle must be an options object " +
            "with the streamAdapter key supplied with a valid stream adapter.");
    }
    var sinkProxies = makeSinkProxies(drivers, streamAdapter);
    var sources = callDrivers(drivers, sinkProxies, streamAdapter);
    var sinks = main(sources);
    if (typeof window !== 'undefined') {
        window.Cyclejs = { sinks: sinks };
    }
    var run = function () {
        var disposeReplication = replicateMany(sinks, sinkProxies, streamAdapter);
        return function () {
            disposeSources(sources);
            disposeReplication();
        };
    };
    return { sinks: sinks, sources: sources, run: run };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Cycle;
//# sourceMappingURL=index.js.map

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(88);
function isStrictlyInScope(namespace, path) {
    var pathParts = util.splitPath(path);
    return namespace.every(function (v, i) {
        return pathParts[i] === v;
    });
}
function getFilteredPath(namespace, path) {
    var pathParts = util.splitPath(path);
    return '/' + util.filterPath(pathParts, namespace);
}
var RouterSource = (function () {
    function RouterSource(history$, _namespace, _createHref, _runSA, _routeMatcher) {
        this.history$ = history$;
        this._namespace = _namespace;
        this._createHref = _createHref;
        this._runSA = _runSA;
        this._routeMatcher = _routeMatcher;
    }
    RouterSource.prototype.path = function (pathname) {
        var scopedNamespace = this._namespace.concat(util.splitPath(pathname));
        var scopedHistory$ = this._runSA.remember(this.history$
            .filter(function (_a) {
            var _path = _a.pathname;
            return isStrictlyInScope(scopedNamespace, _path);
        }));
        var createHref = this._createHref;
        return new RouterSource(scopedHistory$, scopedNamespace, createHref, this._runSA, this._routeMatcher);
    };
    RouterSource.prototype.define = function (routes, routeMatcher) {
        var _this = this;
        var namespace = this._namespace;
        var _createHref = this._createHref;
        var createHref = util.makeCreateHref(namespace, _createHref);
        var match$ = this._runSA.remember(this.history$
            .map(function (location) {
            var matcher = routeMatcher || _this._routeMatcher;
            var filteredPath = getFilteredPath(namespace, location.pathname);
            var _a = matcher(filteredPath, routes), path = _a.path, value = _a.value;
            return { path: path, value: value, location: location, createHref: createHref };
        }));
        match$.createHref = createHref;
        return match$;
    };
    RouterSource.prototype.createHref = function (path) {
        return util.makeCreateHref(this._namespace, this._createHref)(path);
    };
    return RouterSource;
}());
exports.RouterSource = RouterSource;
//# sourceMappingURL=RouterSource.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var makeRouterDriver_1 = __webpack_require__(87);
exports.makeRouterDriver = makeRouterDriver_1.makeRouterDriver;
var history_1 = __webpack_require__(40);
exports.supportsHistory = history_1.supportsHistory;
exports.createLocation = history_1.createLocation;
exports.createServerHistory = history_1.createServerHistory;
//# sourceMappingURL=index.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var history_1 = __webpack_require__(40);
var RouterSource_1 = __webpack_require__(85);
/**
 * Instantiates an new router driver function using the same arguments required
 * by @cycle/history.
 * @public
 * @method makeRouterDriver
 * @return {routerDriver} The router driver function
 */
function makeRouterDriver(history, routeMatcher, options) {
    var historyDriver = history_1.makeHistoryDriver(history, options);
    /**
     * The actual router driver.
     * @public
     * @typedef {routerDriver}
     * @name routerDriver
     * @method routerDriver
     * @param  {Stream<string|Location>} sink$ - This is the same input that the
     * history driver would expect.
     * @return {routerAPI}
     */
    return function routerDriver(sink$, runSA) {
        var history$ = runSA.remember(historyDriver(sink$, runSA));
        return new RouterSource_1.RouterSource(history$, [], history.createHref, runSA, routeMatcher);
    };
}
exports.makeRouterDriver = makeRouterDriver;
//# sourceMappingURL=makeRouterDriver.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function splitPath(path) {
    return path.split('/').filter(function (p) { return p.length > 0; });
}
exports.splitPath = splitPath;
function filterPath(pathParts, namespace) {
    return pathParts.filter(function (part) { return namespace.indexOf(part) < 0; }).join('/');
}
exports.filterPath = filterPath;
var startsWith = function (param, value) { return param[0] === value; };
var startsWith2 = function (param, value1, value2) {
    return param[0] === value1 && param[1] === value2;
};
function makeCreateHref(namespace, _createHref) {
    /**
     * Function used to create HREFs that are properly namespaced
     * @typedef {createHref}
     * @name createHref
     * @method createHref
     * @param  {string} path - the HREF that will be appended to the current
     * namespace
     * @return {string} a fully qualified HREF composed from the current
     * namespace and the path provided
     */
    return function createHref(path) {
        var fullPath = "" + namespace.join('/') + path;
        return startsWith(fullPath, '/') || startsWith2(fullPath, '#', '/')
            ? _createHref(fullPath)
            : _createHref('/' + fullPath);
    };
}
exports.makeCreateHref = makeCreateHref;
//# sourceMappingURL=util.js.map

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copy       = __webpack_require__(99)
  , map        = __webpack_require__(107)
  , callable   = __webpack_require__(11)
  , validValue = __webpack_require__(7)

  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, bindTo) {
	var value = validValue(desc) && callable(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, bindTo*/) {
	var bindTo = arguments[1];
	return map(props, function (desc, name) {
		return define(name, desc, bindTo);
	});
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toPosInt = __webpack_require__(95)
  , value    = __webpack_require__(7)

  , indexOf = Array.prototype.indexOf
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , abs = Math.abs, floor = Math.floor;

module.exports = function (searchElement/*, fromIndex*/) {
	var i, l, fromIndex, val;
	if (searchElement === searchElement) { //jslint: ignore
		return indexOf.apply(this, arguments);
	}

	l = toPosInt(value(this).length);
	fromIndex = arguments[1];
	if (isNaN(fromIndex)) fromIndex = 0;
	else if (fromIndex >= 0) fromIndex = floor(fromIndex);
	else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

	for (i = fromIndex; i < l; ++i) {
		if (hasOwnProperty.call(this, i)) {
			val = this[i];
			if (val !== val) return i; //jslint: ignore
		}
	}
	return -1;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(92)()
	? Math.sign
	: __webpack_require__(93);


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== 'function') return false;
	return ((sign(10) === 1) && (sign(-20) === -1));
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) return value;
	return (value > 0) ? 1 : -1;
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var sign = __webpack_require__(91)

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if ((value === 0) || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(94)

  , max = Math.max;

module.exports = function (value) { return max(0, toInteger(value)); };


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order



var callable = __webpack_require__(11)
  , value    = __webpack_require__(7)

  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys
  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== 'function') method = list[method];
		return call.call(method, list, function (key, index) {
			if (!propertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys  = __webpack_require__(104)
  , value = __webpack_require__(7)

  , max = Math.max;

module.exports = function (dest, src/*, srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(26)
  , value  = __webpack_require__(7);

module.exports = function (obj) {
	var copy = Object(value(obj));
	if (copy !== obj) return copy;
	return assign({}, obj);
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804



var create = Object.create, shim;

if (!__webpack_require__(44)()) {
	shim = __webpack_require__(45);
}

module.exports = (function () {
	var nullObject, props, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	props = {};
	desc = { configurable: false, enumerable: false, writable: true,
		value: undefined };
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === '__proto__') {
			props[name] = { configurable: true, enumerable: false, writable: true,
				value: undefined };
			return;
		}
		props[name] = desc;
	});
	Object.defineProperties(nullObject, props);

	Object.defineProperty(shim, 'nullPolyfill', { configurable: false,
		enumerable: false, writable: false, value: nullObject });

	return function (prototype, props) {
		return create((prototype === null) ? nullObject : prototype, props);
	};
}());


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(96)('forEach');


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Deprecated



module.exports = function (obj) { return typeof obj === 'function'; };


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var map = { function: true, object: true };

module.exports = function (x) {
	return ((x != null) && map[typeof x]) || false;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(105)()
	? Object.keys
	: __webpack_require__(106);


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callable = __webpack_require__(11)
  , forEach  = __webpack_require__(101)

  , call = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var o = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, obj, index) {
		o[key] = call.call(cb, thisArg, value, key, obj, index);
	});
	return o;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = Array.prototype.forEach, create = Object.create;

module.exports = function (arg/*, args*/) {
	var set = create(null);
	forEach.call(arguments, function (name) { set[name] = true; });
	return set;
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(19)
  , contains       = __webpack_require__(46)
  , d              = __webpack_require__(10)
  , Iterator       = __webpack_require__(28)

  , defineProperty = Object.defineProperty
  , ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
	Iterator.call(this, arr);
	if (!kind) kind = 'value';
	else if (contains.call(kind, 'key+value')) kind = 'key+value';
	else if (contains.call(kind, 'key')) kind = 'key';
	else kind = 'value';
	defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(ArrayIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__list__[i];
		if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
		return i;
	}),
	toString: d(function () { return '[object Array Iterator]'; })
});


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(25)
  , callable    = __webpack_require__(11)
  , isString    = __webpack_require__(27)
  , get         = __webpack_require__(114)

  , isArray = Array.isArray, call = Function.prototype.call
  , some = Array.prototype.some;

module.exports = function (iterable, cb/*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = 'array';
	else if (isString(iterable)) mode = 'string';
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () { broken = true; };
	if (mode === 'array') {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			if (broken) return true;
		});
		return;
	}
	if (mode === 'string') {
		l = iterable.length;
		for (i = 0; i < l; ++i) {
			char = iterable[i];
			if ((i + 1) < l) {
				code = char.charCodeAt(0);
				if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(25)
  , isString       = __webpack_require__(27)
  , ArrayIterator  = __webpack_require__(112)
  , StringIterator = __webpack_require__(116)
  , iterable       = __webpack_require__(47)
  , iteratorSymbol = __webpack_require__(16).iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(25)
  , isString       = __webpack_require__(27)
  , iteratorSymbol = __webpack_require__(16).iterator

  , isArray = Array.isArray;

module.exports = function (value) {
	if (value == null) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return (typeof value[iteratorSymbol] === 'function');
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols



var setPrototypeOf = __webpack_require__(19)
  , d              = __webpack_require__(10)
  , Iterator       = __webpack_require__(28)

  , defineProperty = Object.defineProperty
  , StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) return new StringIterator(str);
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, '__length__', d('', str.length));

};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

StringIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(StringIterator),
	_next: d(function () {
		if (!this.__list__) return;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
		return char;
	}),
	toString: d(function () { return '[object String Iterator]'; })
});


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var map, iterator, result;
	if (typeof Map !== 'function') return false;
	try {
		// WebKit doesn't support arguments and crashes
		map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
	} catch (e) {
		return false;
	}
	if (String(map) !== '[object Map]') return false;
	if (map.size !== 3) return false;
	if (typeof map.clear !== 'function') return false;
	if (typeof map.delete !== 'function') return false;
	if (typeof map.entries !== 'function') return false;
	if (typeof map.forEach !== 'function') return false;
	if (typeof map.get !== 'function') return false;
	if (typeof map.has !== 'function') return false;
	if (typeof map.keys !== 'function') return false;
	if (typeof map.set !== 'function') return false;
	if (typeof map.values !== 'function') return false;

	iterator = map.entries();
	result = iterator.next();
	if (result.done !== false) return false;
	if (!result.value) return false;
	if (result.value[0] !== 'raz') return false;
	if (result.value[1] !== 'one') return false;

	return true;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Exports true if environment provides native `Map` implementation,
// whatever that is.



module.exports = (function () {
	if (typeof Map === 'undefined') return false;
	return (Object.prototype.toString.call(new Map()) === '[object Map]');
}());


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109)('key',
	'value', 'key+value');


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf    = __webpack_require__(19)
  , d                 = __webpack_require__(10)
  , Iterator          = __webpack_require__(28)
  , toStringTagSymbol = __webpack_require__(16).toStringTag
  , kinds             = __webpack_require__(119)

  , defineProperties = Object.defineProperties
  , unBind = Iterator.prototype._unBind
  , MapIterator;

MapIterator = module.exports = function (map, kind) {
	if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
	Iterator.call(this, map.__mapKeysData__, map);
	if (!kind || !kinds[kind]) kind = 'key+value';
	defineProperties(this, {
		__kind__: d('', kind),
		__values__: d('w', map.__mapValuesData__)
	});
};
if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);

MapIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(MapIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__values__[i];
		if (this.__kind__ === 'key') return this.__list__[i];
		return [this.__list__[i], this.__values__[i]];
	}),
	_unBind: d(function () {
		this.__values__ = null;
		unBind.call(this);
	}),
	toString: d(function () { return '[object Map Iterator]'; })
});
Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
	d('c', 'Map Iterator'));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear          = __webpack_require__(43)
  , eIndexOf       = __webpack_require__(90)
  , setPrototypeOf = __webpack_require__(19)
  , callable       = __webpack_require__(11)
  , validValue     = __webpack_require__(7)
  , d              = __webpack_require__(10)
  , ee             = __webpack_require__(126)
  , Symbol         = __webpack_require__(16)
  , iterator       = __webpack_require__(47)
  , forOf          = __webpack_require__(113)
  , Iterator       = __webpack_require__(120)
  , isNative       = __webpack_require__(118)

  , call = Function.prototype.call
  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf
  , MapPoly;

module.exports = MapPoly = function (/*iterable*/) {
	var iterable = arguments[0], keys, values, self;
	if (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (Map !== MapPoly)) {
		self = setPrototypeOf(new Map(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) iterator(iterable);
	defineProperties(self, {
		__mapKeysData__: d('c', keys = []),
		__mapValuesData__: d('c', values = [])
	});
	if (!iterable) return self;
	forOf(iterable, function (value) {
		var key = validValue(value)[0];
		value = value[1];
		if (eIndexOf.call(keys, key) !== -1) return;
		keys.push(key);
		values.push(value);
	}, self);
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
	MapPoly.prototype = Object.create(Map.prototype, {
		constructor: d(MapPoly)
	});
}

ee(defineProperties(MapPoly.prototype, {
	clear: d(function () {
		if (!this.__mapKeysData__.length) return;
		clear.call(this.__mapKeysData__);
		clear.call(this.__mapValuesData__);
		this.emit('_clear');
	}),
	delete: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return false;
		this.__mapKeysData__.splice(index, 1);
		this.__mapValuesData__.splice(index, 1);
		this.emit('_delete', index, key);
		return true;
	}),
	entries: d(function () { return new Iterator(this, 'key+value'); }),
	forEach: d(function (cb/*, thisArg*/) {
		var thisArg = arguments[1], iterator, result;
		callable(cb);
		iterator = this.entries();
		result = iterator._next();
		while (result !== undefined) {
			call.call(cb, thisArg, this.__mapValuesData__[result],
				this.__mapKeysData__[result], this);
			result = iterator._next();
		}
	}),
	get: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return;
		return this.__mapValuesData__[index];
	}),
	has: d(function (key) {
		return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
	}),
	keys: d(function () { return new Iterator(this, 'key'); }),
	set: d(function (key, value) {
		var index = eIndexOf.call(this.__mapKeysData__, key), emit;
		if (index === -1) {
			index = this.__mapKeysData__.push(key) - 1;
			emit = true;
		}
		this.__mapValuesData__[index] = value;
		if (emit) this.emit('_add', index, key);
		return this;
	}),
	size: d.gs(function () { return this.__mapKeysData__.length; }),
	values: d(function () { return new Iterator(this, 'value'); }),
	toString: d(function () { return '[object Map]'; })
}));
Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
	return this.entries();
}));
Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var validTypes = { object: true, symbol: true };

module.exports = function () {
	var symbol;
	if (typeof Symbol !== 'function') return false;
	symbol = Symbol('test symbol');
	try { String(symbol); } catch (e) { return false; }

	// Return 'true' also for polyfills
	if (!validTypes[typeof Symbol.iterator]) return false;
	if (!validTypes[typeof Symbol.toPrimitive]) return false;
	if (!validTypes[typeof Symbol.toStringTag]) return false;

	return true;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (x) {
	if (!x) return false;
	if (typeof x === 'symbol') return true;
	if (!x.constructor) return false;
	if (x.constructor.name !== 'Symbol') return false;
	return (x[x.constructor.toStringTag] === 'Symbol');
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ES2015 Symbol polyfill for environments that do not support it (or partially support it)



var d              = __webpack_require__(10)
  , validateSymbol = __webpack_require__(125)

  , create = Object.create, defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
  , isNativeSafe;

if (typeof Symbol === 'function') {
	NativeSymbol = Symbol;
	try {
		String(NativeSymbol());
		isNativeSafe = true;
	} catch (ignore) {}
}

var generateName = (function () {
	var created = create(null);
	return function (desc) {
		var postfix = 0, name, ie11BugWorkaround;
		while (created[desc + (postfix || '')]) ++postfix;
		desc += (postfix || '');
		created[desc] = true;
		name = '@@' + desc;
		defineProperty(objPrototype, name, d.gs(null, function (value) {
			// For IE11 issue see:
			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
			//    ie11-broken-getters-on-dom-objects
			// https://github.com/medikoo/es6-symbol/issues/12
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		}));
		return name;
	};
}());

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
	return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
	if (isNativeSafe) return NativeSymbol(description);
	symbol = create(HiddenSymbol.prototype);
	description = (description === undefined ? '' : String(description));
	return defineProperties(symbol, {
		__description__: d('', description),
		__name__: d('', generateName(description))
	});
};
defineProperties(SymbolPolyfill, {
	for: d(function (key) {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
	keyFor: d(function (s) {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

	// If there's native implementation of given symbol, let's fallback to it
	// to ensure proper interoperability with other native functions e.g. Array.from
	hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
	isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
		SymbolPolyfill('isConcatSpreadable')),
	iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
	match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
	replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
	search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
	species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
	split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
	toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
	toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
	unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
});

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d('', function () { return this.__name__; })
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
	var symbol = validateSymbol(this);
	if (typeof symbol === 'symbol') return symbol;
	return symbol.toString();
}));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(123);

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d        = __webpack_require__(10)
  , callable = __webpack_require__(11)

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {
  var currentTurn = 0,
      isDone = false;
  var isSync = false,
      hasNext = false,
      doneArgs = void 0;

  var done = function done() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    isDone = true;

    if (isSync) {
      // Iterate instead of recursing if possible.
      doneArgs = args;
      return;
    }

    callback.apply(undefined, args);
  };

  var next = function next() {
    if (isDone) return;

    hasNext = true;

    if (isSync) return; // Iterate instead of recursing if possible.

    isSync = true;

    while (!isDone && currentTurn < turns && hasNext) {
      hasNext = false;
      work(currentTurn++, next, done);
    }

    isSync = false;

    if (isDone) {
      // This means the loop finished synchronously.
      callback.apply(undefined, _toConsumableArray(doneArgs));
      return;
    }

    if (currentTurn >= turns && hasNext) {
      isDone = true;
      callback();
    }
  };

  next();
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = __webpack_require__(29);

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _LocationUtils = __webpack_require__(12);

var _DOMUtils = __webpack_require__(17);

var _DOMStateStorage = __webpack_require__(49);

var _PathUtils = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.substring(index + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var i = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
};

var ensureSlash = function ensureSlash() {
  var path = getHashPath();

  if ((0, _PathUtils.isAbsolutePath)(path)) return true;

  replaceHashPath('/' + path);

  return false;
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation(queryKey) {
  var path = getHashPath();
  var key = (0, _PathUtils.getQueryStringValueFromPath)(path, queryKey);

  var state = void 0;
  if (key) {
    path = (0, _PathUtils.stripQueryStringValueFromPath)(path, queryKey);
    state = (0, _DOMStateStorage.readState)(key);
  }

  var init = (0, _PathUtils.parsePath)(path);
  init.state = state;

  return (0, _LocationUtils.createLocation)(init, undefined, key);
};

var prevLocation = void 0;

var startListener = exports.startListener = function startListener(listener, queryKey) {
  var handleHashChange = function handleHashChange() {
    if (!ensureSlash()) return; // Hash path must always begin with a /

    var currentLocation = getCurrentLocation(queryKey);

    if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key) return; // Ignore extraneous hashchange events

    prevLocation = currentLocation;

    listener(currentLocation);
  };

  ensureSlash();
  (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
  };
};

var updateLocation = function updateLocation(location, queryKey, updateHash) {
  var state = location.state;
  var key = location.key;

  var path = (0, _PathUtils.createPath)(location);

  if (state !== undefined) {
    path = (0, _PathUtils.addQueryStringValueToPath)(path, queryKey, key);
    (0, _DOMStateStorage.saveState)(key, state);
  }

  prevLocation = location;

  updateHash(path);
};

var pushLocation = exports.pushLocation = function pushLocation(location, queryKey) {
  return updateLocation(location, queryKey, function (path) {
    if (getHashPath() !== path) {
      pushHashPath(path);
    } else {
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'You cannot PUSH the same path using hash history') : void 0;
    }
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location, queryKey) {
  return updateLocation(location, queryKey, function (path) {
    if (getHashPath() !== path) replaceHashPath(path);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceLocation = exports.pushLocation = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = __webpack_require__(29);

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(8);

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  return (0, _LocationUtils.createLocation)(window.location);
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  window.location.href = (0, _PathUtils.createPath)(location);
  return false; // Don't update location
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  window.location.replace((0, _PathUtils.createPath)(location));
  return false; // Don't update location
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = __webpack_require__(30);

var _BrowserProtocol = __webpack_require__(29);

var BrowserProtocol = _interopRequireWildcard(_BrowserProtocol);

var _RefreshProtocol = __webpack_require__(129);

var RefreshProtocol = _interopRequireWildcard(_RefreshProtocol);

var _DOMUtils = __webpack_require__(17);

var _createHistory = __webpack_require__(31);

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates and returns a history object that uses HTML5's history API
 * (pushState, replaceState, and the popstate event) to manage history.
 * This is the recommended method of managing history in browsers because
 * it provides the cleanest URLs.
 *
 * Note: In browsers that do not support the HTML5 history API full
 * page reloads will be used to preserve clean URLs. You can force this
 * behavior using { forceRefresh: true } in options.
 */
var createBrowserHistory = function createBrowserHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Browser history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var useRefresh = options.forceRefresh || !(0, _DOMUtils.supportsHistory)();
  var Protocol = useRefresh ? RefreshProtocol : BrowserProtocol;

  var getUserConfirmation = Protocol.getUserConfirmation;
  var getCurrentLocation = Protocol.getCurrentLocation;
  var pushLocation = Protocol.pushLocation;
  var replaceLocation = Protocol.replaceLocation;
  var go = Protocol.go;


  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = BrowserProtocol.startListener(history.transitionTo);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen
  });
};

exports.default = createBrowserHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = __webpack_require__(30);

var _DOMUtils = __webpack_require__(17);

var _HashProtocol = __webpack_require__(128);

var HashProtocol = _interopRequireWildcard(_HashProtocol);

var _createHistory = __webpack_require__(31);

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DefaultQueryKey = '_k';

var createHashHistory = function createHashHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Hash history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var queryKey = options.queryKey;


  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(queryKey !== false, 'Using { queryKey: false } no longer works. Instead, just don\'t ' + 'use location state if you don\'t want a key in your URL query string') : void 0;

  if (typeof queryKey !== 'string') queryKey = DefaultQueryKey;

  var getUserConfirmation = HashProtocol.getUserConfirmation;


  var getCurrentLocation = function getCurrentLocation() {
    return HashProtocol.getCurrentLocation(queryKey);
  };

  var pushLocation = function pushLocation(location) {
    return HashProtocol.pushLocation(location, queryKey);
  };

  var replaceLocation = function replaceLocation(location) {
    return HashProtocol.replaceLocation(location, queryKey);
  };

  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: HashProtocol.go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = HashProtocol.startListener(history.transitionTo, queryKey);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  var goIsSupportedWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var go = function go(n) {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;

    history.go(n);
  };

  var createHref = function createHref(path) {
    return '#' + history.createHref(path);
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen,
    go: go,
    createHref: createHref
  });
};

exports.default = createHashHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(8);

var _createHistory = __webpack_require__(31);

var _createHistory2 = _interopRequireDefault(_createHistory);

var _Actions = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createStateStorage = function createStateStorage(entries) {
  return entries.filter(function (entry) {
    return entry.state;
  }).reduce(function (memo, entry) {
    memo[entry.key] = entry.state;
    return memo;
  }, {});
};

var createMemoryHistory = function createMemoryHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  if (Array.isArray(options)) {
    options = { entries: options };
  } else if (typeof options === 'string') {
    options = { entries: [options] };
  }

  var getCurrentLocation = function getCurrentLocation() {
    var entry = entries[current];
    var path = (0, _PathUtils.createPath)(entry);

    var key = void 0,
        state = void 0;
    if (entry.key) {
      key = entry.key;
      state = readState(key);
    }

    var init = (0, _PathUtils.parsePath)(path);

    return (0, _LocationUtils.createLocation)(_extends({}, init, { state: state }), undefined, key);
  };

  var canGo = function canGo(n) {
    var index = current + n;
    return index >= 0 && index < entries.length;
  };

  var go = function go(n) {
    if (!n) return;

    if (!canGo(n)) {
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Cannot go(%s) there is not enough history', n) : void 0;

      return;
    }

    current += n;
    var currentLocation = getCurrentLocation();

    // Change action to POP
    history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
  };

  var pushLocation = function pushLocation(location) {
    current += 1;

    if (current < entries.length) entries.splice(current);

    entries.push(location);

    saveState(location.key, location.state);
  };

  var replaceLocation = function replaceLocation(location) {
    entries[current] = location;
    saveState(location.key, location.state);
  };

  var history = (0, _createHistory2.default)(_extends({}, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var _options = options;
  var entries = _options.entries;
  var current = _options.current;


  if (typeof entries === 'string') {
    entries = [entries];
  } else if (!Array.isArray(entries)) {
    entries = ['/'];
  }

  entries = entries.map(function (entry) {
    return (0, _LocationUtils.createLocation)(entry);
  });

  if (current == null) {
    current = entries.length - 1;
  } else {
    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : (0, _invariant2.default)(false) : void 0;
  }

  var storage = createStateStorage(entries);

  var saveState = function saveState(key, state) {
    return storage[key] = state;
  };

  var readState = function readState(key) {
    return storage[key];
  };

  return history;
};

exports.default = createMemoryHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.Actions = exports.useQueries = exports.useBeforeUnload = exports.useBasename = exports.createMemoryHistory = exports.createHashHistory = exports.createHistory = undefined;

var _LocationUtils = __webpack_require__(12);

Object.defineProperty(exports, 'locationsAreEqual', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.locationsAreEqual;
  }
});

var _createBrowserHistory = __webpack_require__(130);

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _createHashHistory2 = __webpack_require__(131);

var _createHashHistory3 = _interopRequireDefault(_createHashHistory2);

var _createMemoryHistory2 = __webpack_require__(132);

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

var _useBasename2 = __webpack_require__(134);

var _useBasename3 = _interopRequireDefault(_useBasename2);

var _useBeforeUnload2 = __webpack_require__(135);

var _useBeforeUnload3 = _interopRequireDefault(_useBeforeUnload2);

var _useQueries2 = __webpack_require__(136);

var _useQueries3 = _interopRequireDefault(_useQueries2);

var _Actions2 = __webpack_require__(20);

var _Actions3 = _interopRequireDefault(_Actions2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.createHistory = _createBrowserHistory2.default;
exports.createHashHistory = _createHashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;
exports.useBasename = _useBasename3.default;
exports.useBeforeUnload = _useBeforeUnload3.default;
exports.useQueries = _useQueries3.default;
exports.Actions = _Actions3.default;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _runTransitionHook = __webpack_require__(32);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _PathUtils = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var useBasename = function useBasename(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var basename = options.basename;


    var addBasename = function addBasename(location) {
      if (!location) return location;

      if (basename && location.basename == null) {
        if (location.pathname.indexOf(basename) === 0) {
          location.pathname = location.pathname.substring(basename.length);
          location.basename = basename;

          if (location.pathname === '') location.pathname = '/';
        } else {
          location.basename = '';
        }
      }

      return location;
    };

    var prependBasename = function prependBasename(location) {
      if (!basename) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var pname = object.pathname;
      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
      var pathname = normalizedBasename + normalizedPathname;

      return _extends({}, location, {
        pathname: pathname
      });
    };

    // Override all read methods with basename-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return addBasename(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, addBasename(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(addBasename(location));
      });
    };

    // Override all write methods with basename-aware versions.
    var push = function push(location) {
      return history.push(prependBasename(location));
    };

    var replace = function replace(location) {
      return history.replace(prependBasename(location));
    };

    var createPath = function createPath(location) {
      return history.createPath(prependBasename(location));
    };

    var createHref = function createHref(location) {
      return history.createHref(prependBasename(location));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useBasename;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _DOMUtils = __webpack_require__(17);

var _ExecutionEnvironment = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var startListener = function startListener(getPromptMessage) {
  var handleBeforeUnload = function handleBeforeUnload(event) {
    var message = getPromptMessage();

    if (typeof message === 'string') {
      (event || window.event).returnValue = message;
      return message;
    }

    return undefined;
  };

  (0, _DOMUtils.addEventListener)(window, 'beforeunload', handleBeforeUnload);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, 'beforeunload', handleBeforeUnload);
  };
};

/**
 * Returns a new createHistory function that can be used to create
 * history objects that know how to use the beforeunload event in web
 * browsers to cancel navigation.
 */
var useBeforeUnload = function useBeforeUnload(createHistory) {
  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'useBeforeUnload only works in DOM environments') : (0, _invariant2.default)(false) : void 0;

  return function (options) {
    var history = createHistory(options);

    var listeners = [];
    var stopListener = void 0;

    var getPromptMessage = function getPromptMessage() {
      var message = void 0;
      for (var i = 0, len = listeners.length; message == null && i < len; ++i) {
        message = listeners[i].call();
      }return message;
    };

    var listenBeforeUnload = function listenBeforeUnload(listener) {
      if (listeners.push(listener) === 1) stopListener = startListener(getPromptMessage);

      return function () {
        listeners = listeners.filter(function (item) {
          return item !== listener;
        });

        if (listeners.length === 0 && stopListener) {
          stopListener();
          stopListener = null;
        }
      };
    };

    return _extends({}, history, {
      listenBeforeUnload: listenBeforeUnload
    });
  };
};

exports.default = useBeforeUnload;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _queryString = __webpack_require__(150);

var _runTransitionHook = __webpack_require__(32);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultStringifyQuery = function defaultStringifyQuery(query) {
  return (0, _queryString.stringify)(query).replace(/%20/g, '+');
};

var defaultParseQueryString = _queryString.parse;

/**
 * Returns a new createHistory function that may be used to create
 * history objects that know how to handle URL queries.
 */
var useQueries = function useQueries(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var stringifyQuery = options.stringifyQuery;
    var parseQueryString = options.parseQueryString;


    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;

    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;

    var decodeQuery = function decodeQuery(location) {
      if (!location) return location;

      if (location.query == null) location.query = parseQueryString(location.search.substring(1));

      return location;
    };

    var encodeQuery = function encodeQuery(location, query) {
      if (query == null) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var queryString = stringifyQuery(query);
      var search = queryString ? '?' + queryString : '';

      return _extends({}, object, {
        search: search
      });
    };

    // Override all read methods with query-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return decodeQuery(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, decodeQuery(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(decodeQuery(location));
      });
    };

    // Override all write methods with query-aware versions.
    var push = function push(location) {
      return history.push(encodeQuery(location, location.query));
    };

    var replace = function replace(location) {
      return history.replace(encodeQuery(location, location.query));
    };

    var createPath = function createPath(location) {
      return history.createPath(encodeQuery(location, location.query));
    };

    var createHref = function createHref(location) {
      return history.createHref(encodeQuery(location, location.query));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var newLocation = history.createLocation.apply(history, [encodeQuery(location, location.query)].concat(args));

      if (location.query) newLocation.query = (0, _LocationUtils.createQuery)(location.query);

      return decodeQuery(newLocation);
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useQueries;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArguments = __webpack_require__(53),
    isArray = __webpack_require__(54);

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.flatten` with added support for restricting
 * flattening and specifying the start index.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, isDeep, isStrict, result) {
  result || (result = []);

  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index];
    if (isObjectLike(value) && isArrayLike(value) &&
        (isStrict || isArray(value) || isArguments(value))) {
      if (isDeep) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, isDeep, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = baseFlatten;


/***/ }),
/* 138 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * Creates a base function for methods like `_.forIn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = baseFor;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.indexOf` without support for binary searches.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 * If `fromRight` is provided elements of `array` are iterated from right to left.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 0 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseIndexOf = __webpack_require__(139),
    cacheIndexOf = __webpack_require__(142),
    createCache = __webpack_require__(143);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniq` without support for callback shorthands
 * and `this` binding.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The function invoked per iteration.
 * @returns {Array} Returns the new duplicate-value-free array.
 */
function baseUniq(array, iteratee) {
  var index = -1,
      indexOf = baseIndexOf,
      length = array.length,
      isCommon = true,
      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
      seen = isLarge ? createCache() : null,
      result = [];

  if (seen) {
    indexOf = cacheIndexOf;
    isCommon = false;
  } else {
    isLarge = false;
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

    if (isCommon && value === value) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (indexOf(seen, computed, 0) < 0) {
      if (iteratee || isLarge) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;


/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is in `cache` mimicking the return signature of
 * `_.indexOf` by returning `0` if the value is found, else `-1`.
 *
 * @private
 * @param {Object} cache The cache to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns `0` if `value` is found, else `-1`.
 */
function cacheIndexOf(cache, value) {
  var data = cache.data,
      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

  return result ? 0 : -1;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = cacheIndexOf;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = __webpack_require__(50);

/** Native method references. */
var Set = getNative(global, 'Set');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeCreate = getNative(Object, 'create');

/**
 *
 * Creates a cache object to store unique values.
 *
 * @private
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var length = values ? values.length : 0;

  this.data = { 'hash': nativeCreate(null), 'set': new Set };
  while (length--) {
    this.push(values[length]);
  }
}

/**
 * Adds `value` to the cache.
 *
 * @private
 * @name push
 * @memberOf SetCache
 * @param {*} value The value to cache.
 */
function cachePush(value) {
  var data = this.data;
  if (typeof value == 'string' || isObject(value)) {
    data.set.add(value);
  } else {
    data.hash[value] = true;
  }
}

/**
 * Creates a `Set` cache object to optimize linear searches of large arrays.
 *
 * @private
 * @param {Array} [values] The values to cache.
 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
 */
function createCache(values) {
  return (nativeCreate && Set) ? new SetCache(values) : null;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

// Add functions to the `Set` cache.
SetCache.prototype.push = cachePush;

module.exports = createCache;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)))

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match latin-1 supplementary letters (excluding mathematical operators). */
var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0';

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to map latin-1 supplementary letters to basic latin letters. */
var deburredLetters = {
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss'
};

/**
 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
function deburrLetter(letter) {
  return deburredLetters[letter];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var deburr = __webpack_require__(144),
    words = __webpack_require__(149);

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string)), callback, '');
  };
}

/**
 * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__foo_bar__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

module.exports = kebabCase;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = __webpack_require__(50),
    isArguments = __webpack_require__(53),
    isArray = __webpack_require__(54);

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFlatten = __webpack_require__(137),
    baseUniq = __webpack_require__(140),
    restParam = __webpack_require__(147);

/**
 * Creates an array of unique values, in order, of the provided arrays using
 * `SameValueZero` for equality comparisons.
 *
 * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 * comparisons are like strict equality comparisons, e.g. `===`, except that
 * `NaN` matches `NaN`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([1, 2], [4, 2], [2, 1]);
 * // => [1, 2, 4]
 */
var union = restParam(function(arrays) {
  return baseUniq(baseFlatten(arrays, false, true));
});

module.exports = union;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match non-compound words composed of alphanumeric characters. */
var reBasicWord = /[a-zA-Z0-9]+/g;

/** Used to match complex or compound words. */
var reComplexWord = RegExp([
  rsUpper + '?' + rsLower + '+(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+',
  rsUpper + '+',
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasComplexWord = /[a-z][A-Z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strictUriEncode = __webpack_require__(168);
var objectAssign = __webpack_require__(55);

function encoderForArrayFormat(opts) {
	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, index) {
				return value === null ? [
					encode(key, opts),
					'[',
					index,
					']'
				].join('') : [
					encode(key, opts),
					'[',
					encode(index, opts),
					']=',
					encode(value, opts)
				].join('');
			};

		case 'bracket':
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'[]=',
					encode(value, opts)
				].join('');
			};

		default:
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'=',
					encode(value, opts)
				].join('');
			};
	}
}

function parserForArrayFormat(opts) {
	var result;

	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, accumulator) {
				result = /\[(\d*)]$/.exec(key);

				key = key.replace(/\[\d*]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return function (key, value, accumulator) {
				result = /(\[])$/.exec(key);

				key = key.replace(/\[]$/, '');

				if (!result || accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		default:
			return function (key, value, accumulator) {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function encode(value, opts) {
	if (opts.encode) {
		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	} else if (typeof input === 'object') {
		return keysSorter(Object.keys(input)).sort(function (a, b) {
			return Number(a) - Number(b);
		}).map(function (key) {
			return input[key];
		});
	}

	return input;
}

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str, opts) {
	opts = objectAssign({arrayFormat: 'none'}, opts);

	var formatter = parserForArrayFormat(opts);

	// Create an object with no prototype
	// https://github.com/sindresorhus/query-string/issues/47
	var ret = Object.create(null);

	if (typeof str !== 'string') {
		return ret;
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return ret;
	}

	str.split('&').forEach(function (param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		formatter(decodeURIComponent(key), val, ret);
	});

	return Object.keys(ret).sort().reduce(function (result, key) {
		var val = ret[key];
		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
			// Sort object keys, not values
			result[key] = keysSorter(val);
		} else {
			result[key] = val;
		}

		return result;
	}, Object.create(null));
};

exports.stringify = function (obj, opts) {
	var defaults = {
		encode: true,
		strict: true,
		arrayFormat: 'none'
	};

	opts = objectAssign(defaults, opts);

	var formatter = encoderForArrayFormat(opts);

	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return encode(key, opts);
		}

		if (Array.isArray(val)) {
			var result = [];

			val.slice().forEach(function (val2) {
				if (val2 === undefined) {
					return;
				}

				result.push(formatter(key, val2, result.length));
			});

			return result.join('&');
		}

		return encode(key, opts) + '=' + encode(val, opts);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = classNameFromVNode;

var _selectorParser2 = __webpack_require__(56);

var _selectorParser3 = _interopRequireDefault(_selectorParser2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function classNameFromVNode(vNode) {
  var _selectorParser = (0, _selectorParser3.default)(vNode.sel);

  var cn = _selectorParser.className;


  if (!vNode.data) {
    return cn;
  }

  var _vNode$data = vNode.data;
  var dataClass = _vNode$data.class;
  var props = _vNode$data.props;


  if (dataClass) {
    var c = Object.keys(vNode.data.class).filter(function (cl) {
      return vNode.data.class[cl];
    });
    cn += ' ' + c.join(' ');
  }

  if (props && props.className) {
    cn += ' ' + props.className;
  }

  return cn.trim();
}

/***/ }),
/* 152 */
/***/ (function(module, exports) {


// All SVG children elements, not in this list, should self-close

module.exports = {
  // http://www.w3.org/TR/SVG/intro.html#TermContainerElement
  'a': true,
  'defs': true,
  'glyph': true,
  'g': true,
  'marker': true,
  'mask': true,
  'missing-glyph': true,
  'pattern': true,
  'svg': true,
  'switch': true,
  'symbol': true,

  // http://www.w3.org/TR/SVG/intro.html#TermDescriptiveElement
  'desc': true,
  'metadata': true,
  'title': true
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {


var init = __webpack_require__(154);

module.exports = init([__webpack_require__(155), __webpack_require__(156)]);

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {


var parseSelector = __webpack_require__(57);
var VOID_ELEMENTS = __webpack_require__(157);
var CONTAINER_ELEMENTS = __webpack_require__(152);

module.exports = function init(modules) {
  function parse(data) {
    return modules.reduce(function (arr, fn) {
      arr.push(fn(data));
      return arr;
    }, []).filter(function (result) {
      return result !== '';
    });
  }

  return function renderToString(vnode) {
    if (!vnode.sel && vnode.text) {
      return vnode.text;
    }

    vnode.data = vnode.data || {};

    // Support thunks
    if (typeof vnode.sel === 'string' && vnode.sel.slice(0, 5) === 'thunk') {
      vnode = vnode.data.fn.apply(null, vnode.data.args);
    }

    var tagName = parseSelector(vnode.sel).tagName;
    var attributes = parse(vnode);
    var svg = vnode.data.ns === 'http://www.w3.org/2000/svg';
    var tag = [];

    // Open tag
    tag.push('<' + tagName);
    if (attributes.length) {
      tag.push(' ' + attributes.join(' '));
    }
    if (svg && CONTAINER_ELEMENTS[tagName] !== true) {
      tag.push(' /');
    }
    tag.push('>');

    // Close tag, if needed
    if (VOID_ELEMENTS[tagName] !== true && !svg || svg && CONTAINER_ELEMENTS[tagName] === true) {
      if (vnode.data.props && vnode.data.props.innerHTML) {
        tag.push(vnode.data.props.innerHTML);
      } else if (vnode.text) {
        tag.push(vnode.text);
      } else if (vnode.children) {
        vnode.children.forEach(function (child) {
          tag.push(renderToString(child));
        });
      }
      tag.push('</' + tagName + '>');
    }

    return tag.join('');
  };
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {


var forOwn = __webpack_require__(52);
var escape = __webpack_require__(51);
var union = __webpack_require__(148);

var parseSelector = __webpack_require__(57);

// data.attrs, data.props, data.class

module.exports = function attributes(vnode) {
  var selector = parseSelector(vnode.sel);
  var parsedClasses = selector.className.split(' ');

  var attributes = [];
  var classes = [];
  var values = {};

  if (selector.id) {
    values.id = selector.id;
  }

  setAttributes(vnode.data.props, values);
  setAttributes(vnode.data.attrs, values); // `attrs` override `props`, not sure if this is good so

  if (vnode.data.class) {
    // Omit `className` attribute if `class` is set on vnode
    values.class = undefined;
  }
  forOwn(vnode.data.class, function (value, key) {
    if (value === true) {
      classes.push(key);
    }
  });
  classes = union(classes, values.class, parsedClasses).filter(function (x) {
    return x !== '';
  });

  if (classes.length) {
    values.class = classes.join(' ');
  }

  forOwn(values, function (value, key) {
    attributes.push(value === true ? key : key + '="' + escape(value) + '"');
  });

  return attributes.length ? attributes.join(' ') : '';
};

function setAttributes(values, target) {
  forOwn(values, function (value, key) {
    if (key === 'htmlFor') {
      target['for'] = value;
      return;
    }
    if (key === 'className') {
      target['class'] = value.split(' ');
      return;
    }
    if (key === 'innerHTML') {
      return;
    }
    target[key] = value;
  });
}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var forOwn = __webpack_require__(52);
var escape = __webpack_require__(51);
var kebabCase = __webpack_require__(145);

// data.style

module.exports = function style(vnode) {
  var styles = [];
  var style = vnode.data.style || {};

  // merge in `delayed` properties
  if (style.delayed) {
    _extends(style, style.delayed);
  }

  forOwn(style, function (value, key) {
    // omit hook objects
    if (typeof value === 'string') {
      styles.push(kebabCase(key) + ': ' + escape(value));
    }
  });

  return styles.length ? 'style="' + styles.join('; ') + '"' : '';
};

/***/ }),
/* 157 */
/***/ (function(module, exports) {


// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements

module.exports = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var VNode = __webpack_require__(35);
var is = __webpack_require__(21);

function addNS(data, children) {
  data.ns = 'http://www.w3.org/2000/svg';
  if (children !== undefined) {
    for (var i = 0; i < children.length; ++i) {
      addNS(children[i].data, children[i].children);
    }
  }
}

module.exports = function h(sel, b, c) {
  var data = {}, children, text, i;
  if (c !== undefined) {
    data = b;
    if (is.array(c)) { children = c; }
    else if (is.primitive(c)) { text = c; }
  } else if (b !== undefined) {
    if (is.array(b)) { children = b; }
    else if (is.primitive(b)) { text = b; }
    else { data = b; }
  }
  if (is.array(children)) {
    for (i = 0; i < children.length; ++i) {
      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
    }
  }
  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
    addNS(data, children);
  }
  return VNode(sel, data, children, text, undefined);
};


/***/ }),
/* 159 */
/***/ (function(module, exports) {

function createElement(tagName){
  return document.createElement(tagName);
}

function createElementNS(namespaceURI, qualifiedName){
  return document.createElementNS(namespaceURI, qualifiedName);
}

function createTextNode(text){
  return document.createTextNode(text);
}


function insertBefore(parentNode, newNode, referenceNode){
  parentNode.insertBefore(newNode, referenceNode);
}


function removeChild(node, child){
  node.removeChild(child);
}

function appendChild(node, child){
  node.appendChild(child);
}

function parentNode(node){
  return node.parentElement;
}

function nextSibling(node){
  return node.nextSibling;
}

function tagName(node){
  return node.tagName;
}

function setTextContent(node, text){
  node.textContent = text;
}

module.exports = {
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  appendChild: appendChild,
  removeChild: removeChild,
  insertBefore: insertBefore,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent
};


/***/ }),
/* 160 */
/***/ (function(module, exports) {

var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", 
                "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", 
                "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", 
                "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", 
                "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", 
                "truespeed", "typemustmatch", "visible"];
    
var booleanAttrsDict = {};
for(var i=0, len = booleanAttrs.length; i < len; i++) {
  booleanAttrsDict[booleanAttrs[i]] = true;
}
    
function updateAttrs(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
  
  // update modified attributes, add new attributes
  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      // TODO: add support to namespaced attributes (setAttributeNS)
      if(!cur && booleanAttrsDict[key])
        elm.removeAttribute(key);
      else
        elm.setAttribute(key, cur);
    }
  }
  //remove removed attributes
  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
  // the other option is to remove all attributes with value == undefined
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}

module.exports = {create: updateAttrs, update: updateAttrs};


/***/ }),
/* 161 */
/***/ (function(module, exports) {

function updateClass(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldClass = oldVnode.data.class || {},
      klass = vnode.data.class || {};
  for (name in oldClass) {
    if (!klass[name]) {
      elm.classList.remove(name);
    }
  }
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      elm.classList[cur ? 'add' : 'remove'](name);
    }
  }
}

module.exports = {create: updateClass, update: updateClass};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var is = __webpack_require__(21);

function arrInvoker(arr) {
  return function() {
    if (!arr.length) return;
    // Special case when length is two, for performance
    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));
  };
}

function fnInvoker(o) {
  return function(ev) { 
    if (o.fn === null) return;
    o.fn(ev); 
  };
}

function updateEventListeners(oldVnode, vnode) {
  var name, cur, old, elm = vnode.elm,
      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
  if (!on) return;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    if (old === undefined) {
      if (is.array(cur)) {
        elm.addEventListener(name, arrInvoker(cur));
      } else {
        cur = {fn: cur};
        on[name] = cur;
        elm.addEventListener(name, fnInvoker(cur));
      }
    } else if (is.array(old)) {
      // Deliberately modify old array since it's captured in closure created with `arrInvoker`
      old.length = cur.length;
      for (var i = 0; i < old.length; ++i) old[i] = cur[i];
      on[name]  = old;
    } else {
      old.fn = cur;
      on[name] = old;
    }
  }
  if (oldOn) {
    for (name in oldOn) {
      if (on[name] === undefined) {
        var old = oldOn[name];
        if (is.array(old)) {
          old.length = 0;
        }
        else {
          old.fn = null;
        }
      }
    }
  }
}

module.exports = {create: updateEventListeners, update: updateEventListeners};


/***/ }),
/* 163 */
/***/ (function(module, exports) {

var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function getTextNodeRect(textNode) {
  var rect;
  if (document.createRange) {
    var range = document.createRange();
    range.selectNodeContents(textNode);
    if (range.getBoundingClientRect) {
        rect = range.getBoundingClientRect();
    }
  }
  return rect;
}

function calcTransformOrigin(isTextNode, textRect, boundingRect) {
  if (isTextNode) {
    if (textRect) {
      //calculate pixels to center of text from left edge of bounding box
      var relativeCenterX = textRect.left + textRect.width/2 - boundingRect.left;
      var relativeCenterY = textRect.top + textRect.height/2 - boundingRect.top;
      return relativeCenterX + 'px ' + relativeCenterY + 'px';
    }
  }
  return '0 0'; //top left
}

function getTextDx(oldTextRect, newTextRect) {
  if (oldTextRect && newTextRect) {
    return ((oldTextRect.left + oldTextRect.width/2) - (newTextRect.left + newTextRect.width/2));
  }
  return 0;
}
function getTextDy(oldTextRect, newTextRect) {
  if (oldTextRect && newTextRect) {
    return ((oldTextRect.top + oldTextRect.height/2) - (newTextRect.top + newTextRect.height/2));
  }
  return 0;
}

function isTextElement(elm) {
  return elm.childNodes.length === 1 && elm.childNodes[0].nodeType === 3;
}

var removed, created;

function pre(oldVnode, vnode) {
  removed = {};
  created = [];
}

function create(oldVnode, vnode) {
  var hero = vnode.data.hero;
  if (hero && hero.id) {
    created.push(hero.id);
    created.push(vnode);
  }
}

function destroy(vnode) {
  var hero = vnode.data.hero;
  if (hero && hero.id) {
    var elm = vnode.elm;
    vnode.isTextNode = isTextElement(elm); //is this a text node?
    vnode.boundingRect = elm.getBoundingClientRect(); //save the bounding rectangle to a new property on the vnode
    vnode.textRect = vnode.isTextNode ? getTextNodeRect(elm.childNodes[0]) : null; //save bounding rect of inner text node
    var computedStyle = window.getComputedStyle(elm, null); //get current styles (includes inherited properties)
    vnode.savedStyle = JSON.parse(JSON.stringify(computedStyle)); //save a copy of computed style values
    removed[hero.id] = vnode;
  }
}

function post() {
  var i, id, newElm, oldVnode, oldElm, hRatio, wRatio,
      oldRect, newRect, dx, dy, origTransform, origTransition,
      newStyle, oldStyle, newComputedStyle, isTextNode,
      newTextRect, oldTextRect;
  for (i = 0; i < created.length; i += 2) {
    id = created[i];
    newElm = created[i+1].elm;
    oldVnode = removed[id];
    if (oldVnode) {
      isTextNode = oldVnode.isTextNode && isTextElement(newElm); //Are old & new both text?
      newStyle = newElm.style;
      newComputedStyle = window.getComputedStyle(newElm, null); //get full computed style for new element
      oldElm = oldVnode.elm;
      oldStyle = oldElm.style;
      //Overall element bounding boxes
      newRect = newElm.getBoundingClientRect();
      oldRect = oldVnode.boundingRect; //previously saved bounding rect
      //Text node bounding boxes & distances
      if (isTextNode) {
        newTextRect = getTextNodeRect(newElm.childNodes[0]);
        oldTextRect = oldVnode.textRect;
        dx = getTextDx(oldTextRect, newTextRect);
        dy = getTextDy(oldTextRect, newTextRect);
      } else {
        //Calculate distances between old & new positions
        dx = oldRect.left - newRect.left;
        dy = oldRect.top - newRect.top;
      }
      hRatio = newRect.height / (Math.max(oldRect.height, 1));
      wRatio = isTextNode ? hRatio : newRect.width / (Math.max(oldRect.width, 1)); //text scales based on hRatio
      // Animate new element
      origTransform = newStyle.transform;
      origTransition = newStyle.transition;
      if (newComputedStyle.display === 'inline') //inline elements cannot be transformed
        newStyle.display = 'inline-block';        //this does not appear to have any negative side effects
      newStyle.transition = origTransition + 'transform 0s';
      newStyle.transformOrigin = calcTransformOrigin(isTextNode, newTextRect, newRect);
      newStyle.opacity = '0';
      newStyle.transform = origTransform + 'translate('+dx+'px, '+dy+'px) ' +
                               'scale('+1/wRatio+', '+1/hRatio+')';
      setNextFrame(newStyle, 'transition', origTransition);
      setNextFrame(newStyle, 'transform', origTransform);
      setNextFrame(newStyle, 'opacity', '1');
      // Animate old element
      for (var key in oldVnode.savedStyle) { //re-apply saved inherited properties
        if (parseInt(key) != key) {
          var ms = key.substring(0,2) === 'ms';
          var moz = key.substring(0,3) === 'moz';
          var webkit = key.substring(0,6) === 'webkit';
      	  if (!ms && !moz && !webkit) //ignore prefixed style properties
        	  oldStyle[key] = oldVnode.savedStyle[key];
        }
      }
      oldStyle.position = 'absolute';
      oldStyle.top = oldRect.top + 'px'; //start at existing position
      oldStyle.left = oldRect.left + 'px';
      oldStyle.width = oldRect.width + 'px'; //Needed for elements who were sized relative to their parents
      oldStyle.height = oldRect.height + 'px'; //Needed for elements who were sized relative to their parents
      oldStyle.margin = 0; //Margin on hero element leads to incorrect positioning
      oldStyle.transformOrigin = calcTransformOrigin(isTextNode, oldTextRect, oldRect);
      oldStyle.transform = '';
      oldStyle.opacity = '1';
      document.body.appendChild(oldElm);
      setNextFrame(oldStyle, 'transform', 'translate('+ -dx +'px, '+ -dy +'px) scale('+wRatio+', '+hRatio+')'); //scale must be on far right for translate to be correct
      setNextFrame(oldStyle, 'opacity', '0');
      oldElm.addEventListener('transitionend', function(ev) {
        if (ev.propertyName === 'transform')
          document.body.removeChild(ev.target);
      });
    }
  }
  removed = created = undefined;
}

module.exports = {pre: pre, create: create, destroy: destroy, post: post};


/***/ }),
/* 164 */
/***/ (function(module, exports) {

function updateProps(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
  for (key in oldProps) {
    if (!props[key]) {
      delete elm[key];
    }
  }
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}

module.exports = {create: updateProps, update: updateProps};


/***/ }),
/* 165 */
/***/ (function(module, exports) {

var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function updateStyle(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldStyle = oldVnode.data.style || {},
      style = vnode.data.style || {},
      oldHasDel = 'delayed' in oldStyle;
  for (name in oldStyle) {
    if (!style[name]) {
      elm.style[name] = '';
    }
  }
  for (name in style) {
    cur = style[name];
    if (name === 'delayed') {
      for (name in style.delayed) {
        cur = style.delayed[name];
        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
          setNextFrame(elm.style, name, cur);
        }
      }
    } else if (name !== 'remove' && cur !== oldStyle[name]) {
      elm.style[name] = cur;
    }
  }
}

function applyDestroyStyle(vnode) {
  var style, name, elm = vnode.elm, s = vnode.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}

function applyRemoveStyle(vnode, rm) {
  var s = vnode.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
      compStyle, style = s.remove, amount = 0, applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle['transition-property'].split(', ');
  for (; i < props.length; ++i) {
    if(applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener('transitionend', function(ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}

module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint newcap: false
/* global require, module, document, Node */


var VNode = __webpack_require__(35);
var is = __webpack_require__(21);
var domApi = __webpack_require__(159);

function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }

var emptyNode = VNode('', {}, [], undefined, undefined);

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, map = {}, key;
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) map[key] = i;
  }
  return map;
}

var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

function init(modules, api) {
  var i, j, cbs = {};

  if (isUndef(api)) api = domApi;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
    }
  }

  function emptyNodeAt(elm) {
    return VNode(api.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    return function() {
      if (--listeners === 0) {
        var parent = api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }

  function createElm(vnode, insertedVnodeQueue) {
    var i, data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode);
        data = vnode.data;
      }
    }
    var elm, children = vnode.children, sel = vnode.sel;
    if (isDef(sel)) {
      // Parse selector
      var hashIdx = sel.indexOf('#');
      var dotIdx = sel.indexOf('.', hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                                                          : api.createElement(tag);
      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          api.appendChild(elm, createElm(children[i], insertedVnodeQueue));
        }
      } else if (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (i.create) i.create(emptyNode, vnode);
        if (i.insert) insertedVnodeQueue.push(vnode);
      }
    } else {
      elm = vnode.elm = api.createTextNode(vnode.text);
    }
    return vnode.elm;
  }

  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j, data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i, listeners, rm, ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
            i(ch, rm);
          } else {
            rm();
          }
        } else { // Text node
          api.removeChild(parentElm, ch.elm);
        }
      }
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    var oldStartIdx = 0, newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, before;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) { // New element
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
          oldCh[idxInOld] = undefined;
          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
    var i, hook;
    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
    if (oldVnode === vnode) return;
    if (!sameVnode(oldVnode, vnode)) {
      var parentElm = api.parentNode(oldVnode.elm);
      elm = createElm(vnode, insertedVnodeQueue);
      api.insertBefore(parentElm, elm, oldVnode.elm);
      removeVnodes(parentElm, [oldVnode], 0, 0);
      return;
    }
    if (isDef(vnode.data)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
      i = vnode.data.hook;
      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, '');
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      api.setTextContent(elm, vnode.text);
    }
    if (isDef(hook) && isDef(i = hook.postpatch)) {
      i(oldVnode, vnode);
    }
  }

  return function(oldVnode, vnode) {
    var i, elm, parent;
    var insertedVnodeQueue = [];
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();

    if (isUndef(oldVnode.sel)) {
      oldVnode = emptyNodeAt(oldVnode);
    }

    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent = api.parentNode(elm);

      createElm(vnode, insertedVnodeQueue);

      if (parent !== null) {
        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }

    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
}

module.exports = {init: init};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var h = __webpack_require__(158);

function copyToThunk(vnode, thunk) {
  thunk.elm = vnode.elm;
  vnode.data.fn = thunk.data.fn;
  vnode.data.args = thunk.data.args;
  thunk.data = vnode.data;
  thunk.children = vnode.children;
  thunk.text = vnode.text;
  thunk.elm = vnode.elm;
}

function init(thunk) {
  var i, cur = thunk.data;
  var vnode = cur.fn.apply(undefined, cur.args);
  copyToThunk(vnode, thunk);
}

function prepatch(oldVnode, thunk) {
  var i, old = oldVnode.data, cur = thunk.data, vnode;
  var oldArgs = old.args, args = cur.args;
  if (old.fn !== cur.fn || oldArgs.length !== args.length) {
    copyToThunk(cur.fn.apply(undefined, args), thunk);
  }
  for (i = 0; i < args.length; ++i) {
    if (oldArgs[i] !== args[i]) {
      copyToThunk(cur.fn.apply(undefined, args), thunk);
      return;
    }
  }
  copyToThunk(oldVnode, thunk);
}

module.exports = function(sel, key, fn, args) {
  if (args === undefined) {
    args = fn;
    fn = key;
    key = undefined;
  }
  return h(sel, {
    key: key,
    hook: {init: init, prepatch: prepatch},
    fn: fn,
    args: args
  });
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(170);
/* harmony export (immutable) */ __webpack_exports__["default"] = switchPath;

function switchPathInputGuard(path, routes) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["a" /* isPattern */])(path)) {
        throw new Error("First parameter to switchPath must be a route path.");
    }
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(routes)) {
        throw new Error("Second parameter to switchPath must be an object " +
            "containing route patterns.");
    }
}
function validatePath(sourcePath, matchedPath) {
    var sourceParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(sourcePath);
    var matchedParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(matchedPath);
    for (var i = 0; i < matchedParts.length; ++i) {
        if (matchedParts[i] !== sourceParts[i]) {
            return null;
        }
    }
    return "/" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* extractPartial */])(sourcePath, matchedPath);
}
function betterMatch(candidate, reference) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */])(candidate)) {
        return false;
    }
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */])(reference)) {
        return true;
    }
    if (!validatePath(candidate, reference)) {
        return false;
    }
    return candidate.length >= reference.length;
}
function matchesWithParams(sourcePath, pattern) {
    var sourceParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(sourcePath);
    var patternParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(pattern);
    var params = patternParts
        .map(function (part, i) { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isParam */])(part) ? sourceParts[i] : null; })
        .filter(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */]);
    var matched = patternParts
        .every(function (part, i) { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isParam */])(part) || part === sourceParts[i]; });
    return matched ? params : [];
}
function getParamFnValue(paramFn, params) {
    var _paramFn = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(paramFn) ? paramFn["/"] : paramFn;
    return typeof _paramFn === "function" ? _paramFn.apply(void 0, params) : _paramFn;
}
function validate(_a) {
    var sourcePath = _a.sourcePath, matchedPath = _a.matchedPath, matchedValue = _a.matchedValue, routes = _a.routes;
    var path = matchedPath ? validatePath(sourcePath, matchedPath) : null;
    var value = matchedValue;
    if (!path) {
        path = routes["*"] ? sourcePath : null;
        value = path ? routes["*"] : null;
    }
    return { path: path, value: value };
}
function switchPath(sourcePath, routes) {
    switchPathInputGuard(sourcePath, routes);
    var matchedPath = null;
    var matchedValue = null;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["g" /* traverseRoutes */])(routes, function matchPattern(pattern) {
        if (sourcePath.search(pattern) === 0 && betterMatch(pattern, matchedPath)) {
            matchedPath = pattern;
            matchedValue = routes[pattern];
        }
        var params = matchesWithParams(sourcePath, pattern).filter(Boolean);
        if (params.length > 0 && betterMatch(sourcePath, matchedPath)) {
            matchedPath = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* extractPartial */])(sourcePath, pattern);
            matchedValue = getParamFnValue(routes[pattern], params);
        }
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(routes[pattern]) && params.length === 0) {
            if (sourcePath !== "/") {
                var child = switchPath(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["h" /* unprefixed */])(sourcePath, pattern) || "/", routes[pattern]);
                var nestedPath = pattern + child.path;
                if (child.path !== null &&
                    betterMatch(nestedPath, matchedPath)) {
                    matchedPath = nestedPath;
                    matchedValue = child.value;
                }
            }
        }
    });
    return validate({ sourcePath: sourcePath, matchedPath: matchedPath, matchedValue: matchedValue, routes: routes });
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isPattern;
/* harmony export (immutable) */ __webpack_exports__["b"] = isRouteDefinition;
/* harmony export (immutable) */ __webpack_exports__["g"] = traverseRoutes;
/* harmony export (immutable) */ __webpack_exports__["e"] = isNotNull;
/* harmony export (immutable) */ __webpack_exports__["c"] = splitPath;
/* harmony export (immutable) */ __webpack_exports__["f"] = isParam;
/* harmony export (immutable) */ __webpack_exports__["d"] = extractPartial;
/* harmony export (immutable) */ __webpack_exports__["h"] = unprefixed;
function isPattern(candidate) {
    return candidate.charAt(0) === "/" || candidate === "*";
}
function isRouteDefinition(candidate) {
    return !candidate || typeof candidate !== "object" ?
        false : isPattern(Object.keys(candidate)[0]);
}
function traverseRoutes(routes, callback) {
    var keys = Object.keys(routes);
    for (var i = 0; i < keys.length; ++i) {
        var pattern = keys[i];
        if (pattern === "*")
            continue;
        callback(pattern);
    }
}
function isNotNull(candidate) {
    return candidate !== null;
}
function splitPath(path) {
    return path.split("/").filter(function (s) { return !!s; });
}
function isParam(candidate) {
    return candidate.match(/:\w+/) !== null;
}
function extractPartial(sourcePath, pattern) {
    var patternParts = splitPath(pattern);
    var sourceParts = splitPath(sourcePath);
    var matchedParts = [];
    for (var i = 0; i < patternParts.length; ++i) {
        matchedParts.push(sourceParts[i]);
    }
    return matchedParts.filter(isNotNull).join("/");
}
function unprefixed(fullString, prefix) {
    return fullString.split(prefix)[1];
}
//# sourceMappingURL=util.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(172);


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(173);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37), __webpack_require__(60)(module)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(58);
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var Index;
(function (Index) {
    function run(sources) {
        var vTree$ = xstream_1.default.of(dom_1.div(".centered", [
            UI.Container.render([
                UI.Grid.render({ centered: true }, [
                    UI.Row.render([
                        UI.Header.render({ size: UI.Size.Huge }, "Welcome.", {
                            subtext: "At the moment the docs are a WIP. Planned pages are scaffolded in the sidemenu."
                        }),
                    ])
                ])
            ])
        ]));
        return {
            DOM: vTree$,
            router: xstream_1.default.never()
        };
    }
    Index.run = run;
})(Index = exports.Index || (exports.Index = {}));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable-next-line:no-unused-variable
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var sidebar_1 = __webpack_require__(176);
var Layout;
(function (Layout) {
    function run(sources, page) {
        /*** Create components ***/
        var sidebar = sidebar_1.Sidebar.run(sources);
        /*** Compose view ***/
        var vTree$ = xstream_1.default.combine(sidebar.DOM, page.DOM)
            .map(function (_a) {
            var sidebar = _a[0], page = _a[1];
            return dom_1.div(".full.height", [
                dom_1.div(".content.pusher", [
                    sidebar,
                    page
                ]),
            ]);
        });
        return {
            DOM: vTree$,
            router: page.router
        };
    }
    Layout.run = run;
})(Layout = exports.Layout || (exports.Layout = {}));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(58);
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var Sidebar;
(function (Sidebar) {
    function run(sources) {
        var currentPage$ = sources.router.history$.map(function (x) { return x.pathname; });
        var vTree$ = currentPage$.map(function (page) {
            return dom_1.div(".left.menu", [
                dom_1.div(".fixed", [
                    UI.Menu.render({
                        vertical: true, inverted: true,
                        attachment: UI.Attachment.None, size: UI.Size.Fluid
                    }, [{
                            header: true,
                            body: ["Introduction", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: "/", active: page === "/" || page === "/home",
                                        body: "About"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Elements", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: "/elements/button", active: page === "/elements/button",
                                        body: "Button"
                                    }, {
                                        link: true, href: "/elements/container", active: page === "/elements/container",
                                        body: "Container"
                                    }, {
                                        link: true, href: "/elements/divider", active: page === "/elements/divider",
                                        body: "Divider"
                                    }, {
                                        link: true, href: "/elements/header", active: page === "/elements/header",
                                        body: "Header"
                                    }, {
                                        link: true, href: "/elements/icon", active: page === "/elements/icon",
                                        body: "Icon"
                                    }, {
                                        link: true, href: "/elements/image", active: page === "/elements/image",
                                        body: "Image"
                                    }, {
                                        link: true, href: "/elements/label", active: page === "/elements/label",
                                        body: "Label"
                                    }, {
                                        link: true, href: "/elements/list", active: page === "/elements/list",
                                        body: "List"
                                    }, {
                                        link: true, href: "/elements/loader", active: page === "/elements/loader",
                                        body: "Loader"
                                    }, {
                                        link: true, href: "/elements/segment", active: page === "/elements/segment",
                                        body: "Segment"
                                    }, {
                                        link: true, href: "/elements/step", active: page === "/elements/step",
                                        body: "Step"
                                    }, {
                                        link: true, href: "/elements/textbox", active: page === "/elements/textbox",
                                        body: "Textbox"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Collections", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: "/collections/breadcrumb", active: page === "/collections/breadcrumb",
                                        body: "Breadcrumb"
                                    }, {
                                        link: true, href: "/collections/form", active: page === "/collections/form",
                                        body: "Form"
                                    }, {
                                        link: true, href: "/collections/grid", active: page === "/collections/grid",
                                        body: "Grid"
                                    }, {
                                        link: true, href: "/collections/menu", active: page === "/collections/menu",
                                        body: "Menu"
                                    }, {
                                        link: true, href: "/collections/message", active: page === "/collections/message",
                                        body: "Message"
                                    }, {
                                        link: true, href: "/collections/table", active: page === "/collections/table",
                                        body: "Table"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Modules", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: "/modules/checkbox", active: page === "/modules/checkbox",
                                        body: "Checkbox"
                                    }, {
                                        link: true, href: "/modules/dimmer", active: page === "/modules/dimmer",
                                        body: "Dimmer"
                                    }, {
                                        link: true, href: "/modules/dropdown", active: page === "/modules/dropdown",
                                        body: "Dropdown"
                                    }, {
                                        link: true, href: "/modules/modal", active: page === "/modules/modal",
                                        body: "Modal"
                                    }, {
                                        link: true, href: "/modules/popup", active: page === "/modules/popup",
                                        body: "Popup"
                                    }, {
                                        link: true, href: "/modules/progress", active: page === "/modules/progress",
                                        body: "Progress"
                                    }, {
                                        link: true, href: "/modules/transition", active: page === "/modules/transition",
                                        body: "Transition"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Views", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: "/views/statistic", active: page === "/views/statistic",
                                        body: "Statistic"
                                    }])]
                        }])
                ])
            ]);
        });
        return {
            DOM: vTree$,
            router: xstream_1.default.never()
        };
    }
    Sidebar.run = run;
})(Sidebar = exports.Sidebar || (exports.Sidebar = {}));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var xstream_1 = __webpack_require__(0);
var callPage = function (sources) {
    return function (_a) {
        var path = _a.path, value = _a.value;
        var pSources = Object.assign({}, sources, { router: sources.router.path(path) });
        var isolatedPage = isolate_1.default(value)(pSources);
        return isolatedPage;
    };
};
function propOrNever(key, x) {
    if (x.hasOwnProperty(key)) {
        return x[key];
    }
    return xstream_1.default.never();
}
function flattenByKey(key, stream) {
    return stream.map(function (x) { return propOrNever(key, x); }).flatten();
}
function ComponentRouter(sources) {
    var component$ = sources.router.define(sources.routes)
        .map(function (route) { return callPage(sources)(route); })
        .remember()
        .debug(function () { }); //State$ does not work without this line. Unable to reproduce in webpackbin.
    var pluck = function (key) { return flattenByKey(key, component$); };
    var sinks = {
        pluck: pluck,
        DOM: pluck("DOM"),
        router: pluck("router"),
    };
    return sinks;
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = function (sources) { return isolate_1.default(ComponentRouter)(sources); };


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(174);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    "/": index_1.Index.run
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var Breadcrumb;
(function (Breadcrumb) {
    /**
     * An interactive Breadcrumb component for displaying a history of links.
     * Accepts the following properties in props$:
     *  arrow?: boolean - Styles the breadcrumb to use arrow icons.
     *  checvron?: boolean - Styles the breadcrumb to use chevron icons.
     * Expects the following type of content: Array of {}
     *   active?: boolean - Highlights the section as the current state.
     *   text?: string - The text for the section.
     *   href?: string - The location for the section to point towards.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var breadcrumb$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: breadcrumb$,
                Events: function (type) { return sources.DOM.select(".breadcrumb").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Breadcrumb.run = run;
    /**
     * A static Breadcrumb component for displaying a history of links.
     * Accepts the following properties
     *  arrow?: boolean - Styles the breadcrumb to use arrow icons.
     *  checvron?: boolean - Styles the breadcrumb to use chevron icons.
     * Expects the following type of content: Array of {}
     *   active?: boolean - Highlights the section as the current state.
     *   text?: string - The text for the section.
     *   href?: string - The location for the section to point towards.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var children = content.map(function (c) { return [
            section(c), divider(props)
        ]; }).reduce(function (a, n) { return a.concat(n); });
        children.splice(-1, 1);
        return dom_1.div({ props: { className: "ui breadcrumb" } }, children);
    }
    Breadcrumb.render = render;
    function section(section) {
        return section.active
            ? dom_1.div({ props: { className: "active section" } }, section.text)
            : dom_1.a({ props: { className: "section", href: section.href } }, section.text);
    }
    function divider(props) {
        return dom_1.span({ props: { className: "divider" } }, dividerIcon(props));
    }
    function dividerIcon(props) {
        if (props.arrow) {
            return dom_1.i({ props: { className: "right arrow icon divider" } });
        }
        if (props.chevron) {
            return dom_1.i({ props: { className: "right chevron icon divider" } });
        }
        return (" / ");
    }
    function isContent(propsOrContent) {
        return propsOrContent !== undefined && propsOrContent.push !== undefined;
    }
})(Breadcrumb = exports.Breadcrumb || (exports.Breadcrumb = {}));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Field;
(function (Field) {
    /**
     * Wraps content in a Field suitable for the Form component.
     * Accepts the following properties in props$:
     *   width?: number - The width of the field in grid columns.
     *   inline?: boolean - Styles the label to be next to the field instead of above it.
     *   centered?: boolean - Styles the content of the field to be centered.
     *   required?: boolean - Styles the field to show it is mandatory.
     * Expects the following type of content in content$: {} of
     *   label?: DOMContent - The label for the field.
     *   body: DOMContent - The field input.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extra = _a[2];
                return render(props, content, extra);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".field").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Field.run = run;
    /**
     * Wraps content in a Field suitable for the Form component.
     * Accepts the following properties:
     *   width?: number - The width of the field in grid columns.
     *   inline?: boolean - Styles the label to be next to the field instead of above it.
     *   centered?: boolean - Styles the content of the field to be centered.
     *   required?: boolean - Styles the field to show it is mandatory.
     * Expects the following type of content: {} of
     *   label?: DOMContent - The label for the field.
     *   body: DOMContent - The field input.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var extra = interfaces_1.isDOMContent(pOrC) ? (c === "") ? e : c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [].concat(extra ? dom_1.label(extra) : "", content));
    }
    Field.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.width) {
            className += utils_1.numToText(props.width) + " wide";
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.centered) {
            className += " centered";
        }
        if (props.required) {
            className += " required";
        }
        className += " field";
        return className;
    }
})(Field = exports.Field || (exports.Field = {}));


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Fields;
(function (Fields) {
    /**
     * Wraps multiple related Field components together.
     * Accepts the following properties in props$:
     *   label?: DOMContent - A label for the fields.
     *   equalWidth?: boolean - Divides fields in equal width.
     *   grouped?: boolean - Groups fields together for related choices.
     *   inline?: boolean - Styles the labels to be next to the fields instead of above them.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".fields").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Fields.run = run;
    /**
     * Wraps multiple related Field components together.
     * Accepts the following properties:
     *   label?: DOMContent - A label for the fields.
     *   equalWidth?: boolean - Divides fields in equal width.
     *   grouped?: boolean - Groups fields together for related choices.
     *   inline?: boolean - Styles the labels to be next to the fields instead of above them.
     *   required?: boolean - Styles the the fields to make them appear mandetory.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var lbl = props.label ? dom_1.label(props.label) : "";
        var children = content.length ? [lbl].concat(content) : [lbl, content];
        return dom_1.div({ props: { className: getClassname(props, content) } }, children);
    }
    Fields.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.equalWidth && content.length) {
            className += utils_1.numToText(content.length);
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.grouped) {
            className += " grouped";
        }
        if (props.required) {
            className += " required";
        }
        className += " fields";
        return className;
    }
})(Fields = exports.Fields || (exports.Fields = {}));


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Form;
(function (Form) {
    /**
     * A form component for capturing groups of user input.
     * Accepts the following properties in props$:
     *   loading?: boolean - Styles the form with a loader.
     *   equalWidth?: boolean - Styles the form content to have equal widths per row.
     *   inverted?: boolean - Styles the form for dark backgrounds.
     *   size?: Size - The size of the form's content.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".form").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Form.run = run;
    /**
     * A form component for capturing groups of user input.
     * Accepts the following properties:
     *   loading?: boolean - Styles the form with a loader.
     *   equalWidth?: boolean - Styles the form content to have equal widths per row.
     *   inverted?: boolean - Styles the form for dark backgrounds.
     *   size?: Size - The size of the form's content.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Form.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.loading) {
            className += " loading";
        }
        if (props.equalWidth) {
            className += " equal width";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " form";
        return className;
    }
})(Form = exports.Form || (exports.Form = {}));


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(182));
__export(__webpack_require__(180));
__export(__webpack_require__(181));


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Column;
(function (Column) {
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties in props$:
     *   float?: Float - Wether the column should be left or right floated.
     *   width?: int - The default width of the column.
     *   mobile?: int - The width of the column on mobile devices.
     *   tablet?: int - The width of the column on tablet devices.
     *   computer?: int - The width of the column on computer devices.
     *   largescreen?: int - The width of the column on large screen devices.
     *   size?: Size - The size of the column.
     *   alignment?: VerticalAlignment - The vertical alignment of the column.
     *   textAlignment?: TextAlignment - The text alignment of the column.
     * Expects the following type of content in Content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".column").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Column.run = run;
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties:
     *   float?: Float - Wether the column should be left or right floated.
     *   width?: int - The default width of the column.
     *   mobile?: int - The width of the column on mobile devices.
     *   tablet?: int - The width of the column on tablet devices.
     *   computer?: int - The width of the column on computer devices.
     *   largescreen?: int - The width of the column on large screen devices.
     *   size?: Size - The size of the column.
     *   alignment?: VerticalAlignment - The vertical alignment of the column.
     *   textAlignment?: TextAlignment - The text alignment of the column.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Column.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.float && props.float === enums_1.Float.Right) {
            className += " right floated";
        }
        if (props.float && props.float === enums_1.Float.Left) {
            className += " left floated";
        }
        if (props.mobile) {
            className += utils_1.numToText(props.mobile) + " wide mobile";
        }
        if (props.tablet) {
            className += utils_1.numToText(props.tablet) + " wide tablet";
        }
        if (props.computer) {
            className += utils_1.numToText(props.computer) + " wide computer";
        }
        if (props.largescreen) {
            className += utils_1.numToText(props.largescreen) + " wide largescreen";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        if (props.width) {
            className += utils_1.numToText(props.width) + " wide";
        }
        className += " column";
        return className;
    }
})(Column = exports.Column || (exports.Column = {}));


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Grid;
(function (Grid) {
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties in props$:
     *   equallyDivided?: boolean - Styles grid content to take up equal amounts of space.
     *   divided?: boolean - Use dividers to seperate content in the Grid.
     *   container? : boolean - Wraps the grid in a container.
     *   celled?: boolean - Divides the grid into cells.
     *   intCelled?: boolean - Divides the grid into cells with only internal dividers.
     *   padded?: boolean - Adds vertical and horizontal gutters to the grid.
     *   relaxed?: boolean - Increases the amount of negative space.
     *   centered?: boolean - Centers the content of the Grid.
     *   alignment?: VerticalAlignment: Determines the alignment of content in the Grid.
     *   textAlignment?: TextAlignment: Determines the text alignment of content in the Grid.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".grid").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Grid.run = run;
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties:
     *   equallyDivided?: boolean - Styles grid content to take up equal amounts of space.
     *   divided?: boolean - Use dividers to seperate content in the Grid.
     *   container? : boolean - Wraps the grid in a container.
     *   celled?: boolean - Divides the grid into cells.
     *   intCelled?: boolean - Divides the grid into cells with only internal dividers.
     *   padded?: boolean - Adds vertical and horizontal gutters to the grid.
     *   relaxed?: boolean - Increases the amount of negative space.
     *   centered?: boolean - Centers the content of the Grid.
     *   alignment?: VerticalAlignment: Determines the alignment of content in the Grid.
     *   textAlignment?: TextAlignment: Determines the text alignment of content in the Grid.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props, content) } }, content);
    }
    Grid.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.equallyDivided) {
            className += utils_1.numToText(content.length ? content.length : 1) + " column";
        }
        if (props.divided) {
            className += " divided";
        }
        if (props.container) {
            className += " container";
        }
        if (props.celled) {
            className += " celled";
        }
        if (props.intCelled) {
            className += " internally celled";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.relaxed) {
            className += " relaxed";
        }
        if (props.centered) {
            className += " centered";
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        className += " grid";
        return className;
    }
    Grid.getClassname = getClassname;
})(Grid = exports.Grid || (exports.Grid = {}));


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(185));
__export(__webpack_require__(187));
__export(__webpack_require__(184));


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Row;
(function (Row) {
    /**
     * Creates a Row component that wraps Column content.
     * Accepts the following properties in props$:
     *   stretched?: boolean - Ensures the columns are stretched to equal height.
     *   mobile?: boolean - Makes the row visible only on mobile devices.
     *   tablet?: boolean - Makes the row visible only on tablet devices.
     *   computer?: boolean - Makes the row visible only on computer devices.
     *   largescreen?: boolean - Makes the row visible only on largescreen devices.
     *   equallyDivided?: boolean - Makes each column of the row equal in width.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".row").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Row.run = run;
    /**
     * Creates a Row component that wraps Column content.
     * Accepts the following properties:
     *   stretched?: boolean - Ensures the columns are stretched to equal height.
     *   mobile?: boolean - Makes the row visible only on mobile devices.
     *   tablet?: boolean - Makes the row visible only on tablet devices.
     *   computer?: boolean - Makes the row visible only on computer devices.
     *   largescreen?: boolean - Makes the row visible only on largescreen devices.
     *   equallyDivided?: boolean - Makes each column of the row equal in width.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props, content) } }, content);
    }
    Row.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.stretched) {
            className += " stretched";
        }
        if (props.mobile) {
            className += " mobile only";
        }
        if (props.tablet) {
            className += " tablet only";
        }
        if (props.computer) {
            className += " computer only";
        }
        if (props.largescreen) {
            className += " largescreen only";
        }
        if (props.equallyDivided) {
            className += utils_1.numToText(content.length ? content.length : 1) + " column";
        }
        className += " row";
        return className;
    }
})(Row = exports.Row || (exports.Row = {}));


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(179));
__export(__webpack_require__(183));
__export(__webpack_require__(186));
__export(__webpack_require__(59));
__export(__webpack_require__(189));
__export(__webpack_require__(190));


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var icon_1 = __webpack_require__(22);
var transition_1 = __webpack_require__(13);
var Message;
(function (Message) {
    /**
     * A message component to present messages to users.
     * Accepts the following properties in props$:
     *   on$?: Stream<boolean> - When to show/hide the message.
     *   closeable?: boolean - Provides a close icon for the message for dismissal.
     *   icon?: boolean - Formats the message to support an icon.
     *   floating?: boolean - Formats the message to float above related content.
     *   compact?: boolean - Formats a message to only occupy width needed by its content.
     *   attached?: boolean - Formats the message to appear attached to other content.
     *   size?: Size - The size of the message.
     *   color?: Color - The color of the message.
     * Expects the following type of content in content$: {}
     *   icon?: String|VNode - A message can have an icon signifying the type of message.
     *   header?: String|VNode - A message can have a header text.
     *   body?: String|VNode - A message can have additionaly body content.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var icon = icon_1.Icon.run({ DOM: sources.DOM, props$: xstream_1.default.of({ type: "close" }) });
            var close$ = icon.Events("click").mapTo(false);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, icon.DOM)
                .map(function (_a) {
                var props = _a[0], content = _a[1], closeIcon = _a[2];
                return dom_1.div({ props: { className: getClassname(props) } }, [
                    content.icon,
                    props.closeable ? closeIcon : "",
                    dom_1.div({ props: { className: "content" } }, [].concat(content.header ? dom_1.div({ props: { className: "header" } }, content.header) : "", content.body))
                ]);
            });
            var on$ = sources.props$.map(function (props) { return props.on$ ? props.on$ : xstream_1.default.of(true); }).flatten();
            var active$ = xstream_1.default.merge(on$, close$);
            var transition$ = active$.fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? { animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out }
                : { animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out }; }, { animation: enums_1.Animation.None, direction: enums_1.Direction.None });
            var animatedVTree$ = transition_1.Transition.run({ DOM: sources.DOM, target$: vTree$, args$: transition$ }).DOM;
            return {
                DOM: animatedVTree$,
                Events: function (type) { return sources.DOM.select(".message").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Message.run = run;
    /**
     * A message component to present messages to users.
     * Accepts the following properties:
     *   on$?: Stream<boolean> - When to show/hide the message.
     *   closeable?: boolean - Provides a close icon for the message for dismissal.
     *   icon?: boolean - Formats the message to support an icon.
     *   floating?: boolean - Formats the message to float above related content.
     *   compact?: boolean - Formats a message to only occupy width needed by its content.
     *   attached?: boolean - Formats the message to appear attached to other content.
     *   size?: Size - The size of the message.
     *   color?: Color - The color of the message.
     * Expects the following type of content: {}
     *   icon?: String|VNode - A message can have an icon signifying the type of message.
     *   header?: String|VNode - A message can have a header text.
     *   body?: String|VNode - A message can have additionaly body content.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = {}; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var closeIcon = icon_1.Icon.render({}, enums_1.IconType.Close);
        return dom_1.div({ props: { className: getClassname(props) } }, [
            content.icon ? icon_1.Icon.render(content.icon) : "",
            props.closeable ? closeIcon : "",
            dom_1.div({ props: { className: "content" } }, [].concat(content.header ? dom_1.div({ props: { className: "header" } }, content.header) : "", content.body))
        ]);
    }
    Message.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.icon) {
            className += " icon";
        }
        if (props.floating) {
            className += " floating";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.attached) {
            className += " attached";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " message";
        return className;
    }
    function isContent(content) {
        return content !== undefined && (interfaces_1.isDOMContent(content.icon) || interfaces_1.isDOMContent(content.header) || interfaces_1.isDOMContent(content.body));
    }
})(Message = exports.Message || (exports.Message = {}));


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Table;
(function (Table) {
    /**
     * A table component to show content in a table.
     * Accepts the following properties in props$:
     *   singleline?: boolean - Formats the content of the table to fit on a single line.
     *   fixed?: boolean - Stops resizing of table cells based on content.
     *   selectable?: boolean - Styles the rows of the table to be selectable.
     *   striped?: boolean - Styles the rows of the table to alternate colors.
     *   celled?: boolean - Divides each row into seperate cells.
     *   basic?: boolean - Reduces the complexity of the table.
     *   verybasic?: boolean - Reduces the complexity of the table by a lot.
     *   collapsing?: boolean - Makes the table only take up as much space as needed.
     *   padded?: boolean - Adds extra padding to the table content.
     *   verypadded?: boolean - Adds a lot of extra padding to the table content.
     *   compact?: boolean - Styles the table content to be more compact, to allow for more rows.
     *   verycompact?: boolean - Styles the table content to be greatly compacted.
     *   size?: Size - The size of the table content.
     *   color?: Color - The colour of the table.
     * Expects the following type of content in content$: {} of
     * 	headers: [DOMContent]
     * 	body: [[DomContent]]
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of({ body: [] });
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".table").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Table.run = run;
    /**
     * A table component to show content in a table.
     * Accepts the following properties in props$:
     *   singleline?: boolean - Formats the content of the table to fit on a single line.
     *   fixed?: boolean - Stops resizing of table cells based on content.
     *   selectable?: boolean - Styles the rows of the table to be selectable.
     *   striped?: boolean - Styles the rows of the table to alternate colors.
     *   celled?: boolean - Divides each row into seperate cells.
     *   basic?: boolean - Reduces the complexity of the table.
     *   verybasic?: boolean - Reduces the complexity of the table by a lot.
     *   collapsing?: boolean - Makes the table only take up as much space as needed.
     *   padded?: boolean - Adds extra padding to the table content.
     *   verypadded?: boolean - Adds a lot of extra padding to the table content.
     *   compact?: boolean - Styles the table content to be more compact, to allow for more rows.
     *   verycompact?: boolean - Styles the table content to be greatly compacted.
     *   size?: Size - The size of the table content.
     *   color?: Color - The colour of the table.
     * Expects the following type of content in content$: {} of
     * 	headers: [DOMContent]
     * 	body: [[DomContent]]
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = { body: [] }; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var header = content.header ? dom_1.thead([dom_1.tr(content.header.map(function (h) { return dom_1.th(h); }))]) : "";
        var footer;
        if (interfaces_1.isDOMContent(content.footer)) {
            footer = dom_1.tfoot(content.footer);
        }
        else {
            footer = content.footer ? dom_1.tfoot([dom_1.tr(content.footer.map(function (f) { return dom_1.th(f); }))]) : "";
        }
        return dom_1.table({ props: { className: getClassname(props) } }, [
            header,
            dom_1.tbody(content.body.map(function (r) { return dom_1.tr(r.map(function (c) { return dom_1.td(c); })); })),
            footer
        ]);
    }
    Table.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.singleline) {
            className += " single line";
        }
        if (props.fixed) {
            className += " fixed";
        }
        if (props.selectable) {
            className += " selectable";
        }
        if (props.striped) {
            className += " striped";
        }
        if (props.celled) {
            className += " celled";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.verybasic) {
            className += " very basic";
        }
        if (props.collapsing) {
            className += " collapsing";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.verypadded) {
            className += " very padded";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.verycompact) {
            className += " very compact";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " table";
        return className;
    }
    function isContent(content) {
        return content !== undefined && (content.body !== undefined &&
            (content.header !== undefined ||
                content.footer !== undefined));
    }
})(Table = exports.Table || (exports.Table = {}));


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Button;
(function (Button) {
    /**
     * An interactive button component for user interaction through clicking.
     * Accepts the following type of properties in props$:
     *   animated? : boolean - Allows for an animation in the button to show hidden content.
     *   verticalAnimated?: boolean - See animated. This animation is vertical.
     *   labeled?: boolean - Adds styling for labeled buttons.
     *   icon?: boolean - Adds styling for buttons with an icon.
     *   basic?: boolean - Styles the button to appear simpler.
     *   inverted?: boolean - Styles the button to appear on dark backgrounds.
     *   active?: boolean - Sets the button to the active state.
     *   disabled?: boolean - Styles the button to appear disabled.
     *   loading?: boolean - Styles the button show that it is loading / working.
     *   compact?: boolean - Styles the button for a tight fit.
     *   circular?: boolean - Styles the button to appear circular.
     *   fluid?: boolean - Styles the button to be as wide as possible.
     *   href?: string - Outputs the button as a link to to the href.
     *   attachment?: Attachment - Where the button should be attached to.
     *   size?: Size - The size of the button.
     *   float?: Float - The left or right float of the button.
     *   color?: Color - The color of the button.
     * Expects the following type of content in content$: {} of
     *   body?: DOMContent - The body content to display on the button.
     *   hidden?: DOMContent - The hidden content to display for animated buttons.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vtree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vtree$,
                Events: function (type) { return sources.DOM.select(".ui.button").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Button.run = run;
    /**
     * A static button component for user interaction through clicking.
     * Accepts the following type of properties:
     *   animated? : boolean - Allows for an animation in the button to show hidden content.
     *   verticalAnimated?: boolean - See animated. This animation is vertical.
     *   labeled?: boolean - Adds styling for labeled buttons.
     *   icon?: boolean - Adds styling for buttons with an icon.
     *   basic?: boolean - Styles the button to appear simpler.
     *   inverted?: boolean - Styles the button to appear on dark backgrounds.
     *   active?: boolean - Sets the button to the active state.
     *   disabled?: boolean - Styles the button to appear disabled.
     *   loading?: boolean - Styles the button show that it is loading / working.
     *   compact?: boolean - Styles the button for a tight fit.
     *   circular?: boolean - Styles the button to appear circular.
     *   fluid?: boolean - Styles the button to be as wide as possible.
     *   href?: string - Outputs the button as a link to to the href.
     *   attachment?: Attachment - Where the button should be attached to.
     *   size?: Size - The size of the button.
     *   float?: Float - The left or right float of the button.
     *   color?: Color - The color of the button.
     * Expects the following type of content: {} of
     *   body?: DOMContent - The body content to display on the button.
     *   hidden?: DOMContent - The hidden content to display for animated buttons.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var extra = interfaces_1.isDOMContent(pOrC) ? (c !== "") ? c : e : e;
        var children = extra
            ? [dom_1.div({ props: { className: "visible content" } }, content),
                dom_1.div({ props: { className: "hidden content" } }, extra)]
            : content;
        return props.href
            ? dom_1.a({ props: { href: props.href, className: getClassname(props) } }, children)
            : dom_1.div({ props: { className: getClassname(props) } }, children);
    }
    Button.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.animated) {
            className += " animated";
        }
        if (props.verticalAnimated) {
            className += " vertical.animated";
        }
        if (props.labeled) {
            className += " labeled";
        }
        if (props.rightlabeled) {
            className += " right labeled";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.active) {
            className += " active";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.fluid) {
            className += " fluid";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " button";
        return className;
    }
})(Button = exports.Button || (exports.Button = {}));


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Container;
(function (Container) {
    /**
    * A responsive container component to host other content.
    * Does not accept any properties in props$.
    * Expects the following type of content in content$: DOMContent
    */
    function run(sources) {
        function main(sources) {
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = sources.content$.map(function (content) { return render(content); });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".container").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Container.run = run;
    /**
    * A responsive container component to host other content.
    * Does not accept any properties.
    * Expects the following type of content: DOMContent
    */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        // let props = isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: "ui container" } }, content);
    }
    Container.render = render;
})(Container = exports.Container || (exports.Container = {}));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Divider;
(function (Divider) {
    /**
     * Creates a divider element to seperate content on page.
     * Accepts the following properties in props$:
     * 	content?: VNode - The content to add to the divider.
     * 	horizontal?: boolean - Needed to render text horizontally in the divider.
     * 	vertical?: boolean - Determines vertical/horizontal orientation of the divider.
     * 	inverted?: boolean - For dark backgrounds.
     * 	fitted?: boolean - Minimizes the space between divided content.
     * 	hidden?: boolean - Creates an invisible divider that divides the content.
     * 	section?: boolean - Provides greater margins for between divided content.
     * 	clearing?: boolean - Clears floated content.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".divider").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Divider.run = run;
    /**
     * Creates a divider element to seperate content on page.
     * Accepts the following properties:
     * 	content?: VNode - The content to add to the divider.
     * 	horizontal?: boolean - Needed to render text horizontally in the divider.
     * 	vertical?: boolean - Determines vertical/horizontal orientation of the divider.
     * 	inverted?: boolean - For dark backgrounds.
     * 	fitted?: boolean - Minimizes the space between divided content.
     * 	hidden?: boolean - Creates an invisible divider that divides the content.
     * 	section?: boolean - Provides greater margins for between divided content.
     * 	clearing?: boolean - Clears floated content.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassName(props, content) } }, content);
    }
    Divider.render = render;
    function getClassName(props, content) {
        var className = "ui";
        if (props.vertical) {
            className += " vertical";
        }
        else if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.hidden) {
            className += " hidden";
        }
        if (props.section) {
            className += " section";
        }
        if (props.clearing) {
            className += " clearing";
        }
        if (props.header) {
            className += " header";
        }
        className += " divider";
        return className;
    }
})(Divider = exports.Divider || (exports.Divider = {}));


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Header;
(function (Header) {
    /**
     * Creates a header for important text.
     * Accepts the following properties in props$:
     *   icon?: boolean - Adds styling for icon headers.
     *   divider?: boolean - Adds styling for headers to seperate content.
     *   block?: boolean - Wraps header in a block.
     *   disabled?: boolean - Styling for disabled content.
     *   inverted?: boolean - Styling for dark backgrounds.
     *   attachment?: Attachment - Styling for headers attached to other content.
     *   float?: Float - Floats the header to the left or right.
     *   textAlignment?: TextAlignment - Text alignment of the header text.
     *   size?: Size - Determines the size of the header.
     *   color?: Color - The color of the header.
     * Expects the following type of content in content$: {} of
     *   text: DOMContent - The header text.
     *   subtext?: DOMContent- An optional sub-header to accompany the header.
     *   icon?: DOMContent - Optional image/icon content for the header.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of({});
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".header").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Header.run = run;
    /**
     * Creates a header for important text.
     * Accepts the following properties:
     *   icon?: boolean - Adds styling for icon headers.
     *   divider?: boolean - Adds styling for headers to seperate content.
     *   block?: boolean - Wraps header in a block.
     *   disabled?: boolean - Styling for disabled content.
     *   inverted?: boolean - Styling for dark backgrounds.
     *   attachment?: Attachment - Styling for headers attached to other content.
     *   float?: Float - Floats the header to the left or right.
     *   textAlignment?: TextAlignment - Text alignment of the header text.
     *   size?: Size - Determines the size of the header.
     *   color?: Color - The color of the header.
     * Expects the following type of content: {} of
     *   text: DOMContent - The header text.
     *   subtext?: DOMContent- An optional sub-header to accompany the header.
     *   icon?: DOMContent - Optional image/icon content for the header.
     */
    function render(pOrCorE, cOrE, e) {
        if (pOrCorE === void 0) { pOrCorE = {}; }
        if (cOrE === void 0) { cOrE = {}; }
        if (e === void 0) { e = {}; }
        var props = interfaces_1.isDOMContent(pOrCorE) ? {} : isExtras(pOrCorE) ? {} : pOrCorE;
        var content = interfaces_1.isDOMContent(pOrCorE) ? pOrCorE : interfaces_1.isDOMContent(cOrE) ? cOrE : "";
        var extras = isExtras(pOrCorE) ? pOrCorE : isExtras(cOrE) ? cOrE : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            extras.icon ? extras.icon : "",
            dom_1.div({ props: { className: "content" } }, [].concat(content, extras.subtext ? dom_1.div({ props: { className: "sub header" } }, extras.subtext) : ""))
        ]);
    }
    Header.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.icon) {
            className += " icon";
        }
        if (props.divider) {
            className += " divider";
        }
        if (props.block) {
            className += " block";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " header";
        return className;
    }
    function isExtras(extra) {
        return extra !== undefined && (extra.subtext !== undefined
            || (extra.icon !== undefined && typeof (extra.icon) !== "boolean"));
    }
})(Header = exports.Header || (exports.Header = {}));


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var Image;
(function (Image) {
    /**
     * An image component for displaying images.
     * Accepts the following properties in props$:
     *   href?: string - Styles the image as a link towards the location.
     *   hidden?: boolean - Hides the image.
     *   disabled?: boolean - Styles the image to appear disabled.
     *   avatar?: boolean - Styles the image for usage as an avatar.
     *   bordered?: boolean - Styles the image with a border.
     *   spaced?: boolean - Styles the image with extra spacing to seperate it from nearby content.
     *   circular?: boolean - Styles the image to be circular.
     *   rounded?: boolean - Styles the image to have rounded edges.
     *   float?: Float - The float orientation of the image.
     *   size?: Size - The size of the image.
     *   verticalAlignment?: VerticalAlignment - The vertical alignment of text nearby the image.
     * Expects the following type of content in content$: string - The src url.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".image").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Image.run = run;
    /**
     * An image component for displaying images.
     * Accepts the following properties:
     *   link?: boolean - Styles the image as a link.
     *   hidden?: boolean - Hides the image.
     *   disabled?: boolean - Styles the image to appear disabled.
     *   avatar?: boolean - Styles the image for usage as an avatar.
     *   bordered?: boolean - Styles the image with a border.
     *   spaced?: boolean - Styles the image with extra spacing to seperate it from nearby content.
     *   circular?: boolean - Styles the image to be circular.
     *   rounded?: boolean - Styles the image to have rounded edges.
     *   float?: Float - The float orientation of the image.
     *   size?: Size - The size of the image.
     *   verticalAlignment?: VerticalAlignment - The vertical alignment of text nearby the image.
     * Expects the following type of content: string - The src url.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = typeof (pOrC) === "string" ? {} : pOrC;
        var content = typeof (pOrC) === "string" ? pOrC : c;
        var image = dom_1.img({ props: { className: getClassname(props), src: content } });
        return props.href ? dom_1.a({ props: { href: props.href } }, image) : image;
    }
    Image.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.href) {
            className += " link";
        }
        if (props.hidden) {
            className += " hidden";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.avatar) {
            className += " avatar";
        }
        if (props.bordered) {
            className += " bordered";
        }
        if (props.spaced) {
            className += " spaced";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.rounded) {
            className += " rounded";
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.verticalAlignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.verticalAlignment);
        }
        return className + " image";
    }
})(Image = exports.Image || (exports.Image = {}));


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(191));
__export(__webpack_require__(192));
__export(__webpack_require__(193));
__export(__webpack_require__(194));
__export(__webpack_require__(22));
__export(__webpack_require__(195));
__export(__webpack_require__(197));
__export(__webpack_require__(198));
__export(__webpack_require__(199));
__export(__webpack_require__(200));
__export(__webpack_require__(201));
__export(__webpack_require__(202));


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Label;
(function (Label) {
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties in props$:
     *   circular?: boolean - Styles the label to be circular.
     *   empty?: boolean - Styles the label for empty content.
     *   pointing?: boolean - Styles the label to be pointing towards nearby content.
     *   basic?: boolean - Styles the label to be minimalistic.
     *   leftCorner?: boolean - Attaches the label to the top-left corner of nearby content.
     *   rightCorner?: boolean - Attaches the label to the top-right corner of nearby content.
     *   tag?: boolean - Styles the label to look like a tag.
     *   ribbon?: boolean - Styles the label to look like a ribbon over the left side of content.
     *   invRibbon?: boolean - Styles the label to look like a ribbon over the right side of content.
     *   horizontal?: boolean - Styles the label for horizontal content.
     *   floating?: boolean - Styles the label to be floating over nearby content.
     *   attachment?: Attachment - Where the label should be attached to.
     *   size?: Size - The size of the label.
     *   color?: Color - The color of the label.
     * Expects the following type of content and extras: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".label").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Label.run = run;
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties:
     *   circular?: boolean - Styles the label to be circular.
     *   empty?: boolean - Styles the label for empty content.
     *   pointing?: boolean - Styles the label to be pointing towards nearby content.
     *   basic?: boolean - Styles the label to be minimalistic.
     *   leftCorner?: boolean - Attaches the label to the top-left corner of nearby content.
     *   rightCorner?: boolean - Attaches the label to the top-right corner of nearby content.
     *   tag?: boolean - Styles the label to look like a tag.
     *   ribbon?: boolean - Styles the label to look like a ribbon over the left side of content.
     *   invRibbon?: boolean - Styles the label to look like a ribbon over the right side of content.
     *   horizontal?: boolean - Styles the label for horizontal content.
     *   floating?: boolean - Styles the label to be floating over nearby content.
     *   attachment?: Attachment - Where the label should be attached to.
     *   size?: Size - The size of the label.
     *   color?: Color - The color of the label.
     * Expects the following type of content and extras: DOMContent
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var detail = interfaces_1.isDOMContent(pOrC) ? c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            content,
            detail ? dom_1.div({ props: { className: "detail" } }, detail) : ""
        ]);
    }
    Label.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.circular) {
            className += " circular";
        }
        if (props.empty) {
            className += " empty";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.leftCorner) {
            className += " left corner";
        }
        if (props.rightCorner) {
            className += " right corner";
        }
        if (props.tag) {
            className += " tag";
        }
        if (props.ribbon) {
            className += " ribbon";
        }
        if (props.invRibbon) {
            className += " right ribbon";
        }
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.floating) {
            className += " floating ";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " label";
        return className;
    }
})(Label = exports.Label || (exports.Label = {}));


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var List;
(function (List) {
    /**
     * Creates a List component for showing lists of content.
     * Accepts the following properties in props$:
     *   bulleted?: boolean - Displays list as a bulleted list.
     *   ordered?: boolean - Displays list as an ordered list.
     *   link?: boolean - Styling for lists with links.
     *   horizontal?: boolean - Displays list horizontally.
     *   inverted?: boolean - Styling for lists on dark backgrounds.
     *   selection?: boolean - Styling for lists meant to display a selection.
     *   animated?: boolean - Adds an animation to display currently selected item.
     *   relaxed?: boolean - Adds more negative space arround the list.
     *   divided?: boolean - Adds horizontal dividers between content of list.
     *   celled?: boolean - Wraps content of list in cells.
     *   size?: Size - The size of the list and its content.
     *   alignment?: VerticalAlignment - The vertical alignment of list's content.
     *   float?: Float - Wether the list should be left or right floating.
     * Expects the following type of content: Array of {}
     *   left?: DOMContent - Left floated content for the item.
     *   body?: DOMContent - Body content for the item.
     *   right?: DOMContent - Right floated content for the item.
     *   header?: DOMContent - Name of the list item
     *   description?: DOMContent - Description of the list item.
     *   href?: string - Link for link lists
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".list").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    List.run = run;
    /**
     * Creates a List component for showing lists of content.
     * Accepts the following properties in props$:
     *   bulleted?: boolean - Displays list as a bulleted list.
     *   ordered?: boolean - Displays list as an ordered list.
     *   link?: boolean - Styling for lists with links.
     *   horizontal?: boolean - Displays list horizontally.
     *   inverted?: boolean - Styling for lists on dark backgrounds.
     *   selection?: boolean - Styling for lists meant to display a selection.
     *   animated?: boolean - Adds an animation to display currently selected item.
     *   relaxed?: boolean - Adds more negative space arround the list.
     *   divided?: boolean - Adds horizontal dividers between content of list.
     *   celled?: boolean - Wraps content of list in cells.
     *   size?: Size - The size of the list and its content.
     *   alignment?: VerticalAlignment - The vertical alignment of list's content.
     *   float?: Float - Wether the list should be left or right floating.
     * Expects the following type of content: Array of {}
     *   left?: DOMContent - Left floated content for the item.
     *   body?: DOMContent - Body content for the item.
     *   right?: DOMContent - Right floated content for the item.
     *   header?: DOMContent - Name of the list item
     *   description?: DOMContent - Description of the list item.
     *   href?: string - Link for link lists
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content.map(function (_a) {
            var header = _a.header, icon = _a.icon, content = _a.content, description = _a.description, href = _a.href, left = _a.left, right = _a.right;
            var l = left ? dom_1.div({ props: { className: "left floated content" } }, left) : undefined;
            var r = right ? dom_1.div({ props: { className: "right floated content" } }, right) : undefined;
            var h = header ? dom_1.div({ props: { className: "header" } }, header) : undefined;
            var d = description ? dom_1.div({ props: { className: "description" } }, description) : undefined;
            var i = icon ? icon : "";
            var c = dom_1.div({ props: { className: "content" } }, [].concat(h, d, content));
            var children = [].concat(l, i, c, r);
            return href
                ? dom_1.a({ props: { className: "item" } }, { props: { href: href } }, children)
                : dom_1.div({ props: { className: "item" } }, children);
        }));
    }
    List.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.bulleted) {
            className += " bulleted";
        }
        if (props.ordered) {
            className += " ordered";
        }
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.selection) {
            className += " selection";
        }
        if (props.animated) {
            className += " animated";
        }
        if (props.relaxed) {
            className += " relaxed";
        }
        if (props.divided) {
            className += " divided";
        }
        if (props.celled) {
            className += " celled";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        className += " list";
        return className;
    }
})(List = exports.List || (exports.List = {}));


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var dimmer_1 = __webpack_require__(36);
var Loader;
(function (Loader) {
    /**
     * A loader component to show that certain content or a page is loading.
     * Accepts the following properties in props$:
     *   type: LoaderType - The type of loader to use. See exported enum.
     *   element?: Stream<VNode> - The element to mark as loaded. (Only used for type.Content)
     *   on$: Stream<boolean> - When to show/hide the loader. (Not used for inline, add disabled property instead.)
     *   centered?: boolean - Centers the loader spinner in its parent component.
     *   active?: boolean - Always shows the loader.
     *   disabled?: boolean - Always hides the loader.
     *   indeterminate?: boolean - Makes the loader spin indicate its unsure of how long a task will take.
     *   text?: boolean - Positions the loader to leave space for text.
     *   size?: Size - The size of the loader.
     * Expects the following type of content in content$ of: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ type: LoaderType.Inline });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var props$ = sources.props$.remember();
            var vTree$ = xstream_1.default.combine(props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            var on$ = props$.map(function (props) { return props.on$; }).flatten();
            var target$ = props$.map(function (props) { return props.type === LoaderType.Page ? xstream_1.default.of("page") : props.element; }).flatten();
            var dimmer = dimmer_1.Dimmer.run({ DOM: sources.DOM, args$: on$, target$: target$, content$: vTree$ }, props$.map(function (props) { return props.inverted; }));
            var result$ = props$.map(function (props) { return props.type === LoaderType.Inline ? vTree$ : dimmer.DOM; }).flatten();
            return {
                DOM: result$,
                Events: function (type) { return sources.DOM.select(".loader").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Loader.run = run;
    /**
     * A loader component to show that certain content or a page is loading.
     * Accepts the following properties:
     *   type: LoaderType - The type of loader to use. See exported enum.
     *   element?: Stream<VNode> - The element to mark as loaded. (Only used for type.Content)
     *   on$: Stream<boolean> - When to show/hide the loader. (Not used for inline, add disabled property instead.)
     *   centered?: boolean - Centers the loader spinner in its parent component.
     *   active?: boolean - Always shows the loader.
     *   disabled?: boolean - Always hides the loader.
     *   indeterminate?: boolean - Makes the loader spin indicate its unsure of how long a task will take.
     *   text?: boolean - Positions the loader to leave space for text.
     *   size?: Size - The size of the loader.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = { type: LoaderType.Page }; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? { type: LoaderType.Page } : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return [dom_1.div({ props: { className: getClassname(props) } }, content)];
    }
    Loader.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.active) {
            className += " active";
        }
        if (props.centered) {
            className += " centered";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.indeterminate) {
            className += " indeterminate";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.text) {
            className += " text";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += LoaderType.ToClassname(props.type);
        return className;
    }
    var LoaderType;
    (function (LoaderType) {
        LoaderType[LoaderType["Inline"] = 0] = "Inline";
        LoaderType[LoaderType["Page"] = 1] = "Page";
        LoaderType[LoaderType["Content"] = 2] = "Content";
    })(LoaderType = Loader.LoaderType || (Loader.LoaderType = {}));
    (function (LoaderType) {
        function ToClassname(type) {
            switch (type) {
                case LoaderType.Inline: return " inline loader";
                case LoaderType.Page: return " loader";
                case LoaderType.Content: return " loader";
            }
        }
        LoaderType.ToClassname = ToClassname;
    })(LoaderType = Loader.LoaderType || (Loader.LoaderType = {}));
})(Loader = exports.Loader || (exports.Loader = {}));


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Segment;
(function (Segment) {
    /**
     * A segment component to divide up page content into segments.
     * Accepts the following properties in props$:
     *   raised?: boolean? - Styles the segment to appear floating above nearby content.
     *   stacked?: boolean? - Styles the segment to appear like a stack of papers.
     *   tallStacked?: boolean? - Styles the segment to appear like a tall stack of papers.
     *   piled?: boolean? - Styles the segment to appear like a pile of papers.
     *   vertical?: boolean? - Styles the segment content to be aligned as part of a vertical group.
     *   loading?: boolean? - Styles the segment with a loading icon.
     *   inverted?: boolean? - Styles the segment for dark content.
     *   padded?: boolean? - Increases the padding on the segment.
     *   veryPadded?: boolean - Increases the padding on the segment by a lot.
     *   compact?: boolean - Makes the segment take up only the space needed by its content.
     *   circular?: boolean - Styles the segment to be circular.
     *   clearing?: boolean - Clears floated content.
     *   basic?: boolean - Removes any special styling.
     *   color?: Color - The color of the segment.
     *   attachment?: Attachment - The attachment of the segment.
     *   float?: Float - Where the segment should float.
     *   textAlignment?: TextAlignment - The text alignment of the segment.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".segment").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Segment.run = run;
    /**
     * A segment component to divide up page content into segments.
     * Accepts the following properties:
     *   raised?: boolean? - Styles the segment to appear floating above nearby content.
     *   stacked?: boolean? - Styles the segment to appear like a stack of papers.
     *   tallStacked?: boolean? - Styles the segment to appear like a tall stack of papers.
     *   piled?: boolean? - Styles the segment to appear like a pile of papers.
     *   vertical?: boolean? - Styles the segment content to be aligned as part of a vertical group.
     *   loading?: boolean? - Styles the segment with a loading icon.
     *   inverted?: boolean? - Styles the segment for dark content.
     *   padded?: boolean? - Increases the padding on the segment.
     *   veryPadded?: boolean - Increases the padding on the segment by a lot.
     *   compact?: boolean - Makes the segment take up only the space needed by its content.
     *   circular?: boolean - Styles the segment to be circular.
     *   clearing?: boolean - Clears floated content.
     *   basic?: boolean - Removes any special styling.
     *   color?: Color - The color of the segment.
     *   attachment?: Attachment - The attachment of the segment.
     *   float?: Float - Where the segment should float.
     *   textAlignment?: TextAlignment - The text alignment of the segment.
     * Expects the following type of content : DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Segment.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.raised) {
            className += " raised";
        }
        if (props.stacked) {
            className += " stacked";
        }
        if (props.tallStacked) {
            className += " tall stacked";
        }
        if (props.piled) {
            className += " piled";
        }
        if (props.vertical) {
            className += " vertical";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.veryPadded) {
            className += " very padded";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.clearing) {
            className += " clearing";
        }
        if (props.basic) {
            className += " basic";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        className += " segment";
        return className;
    }
})(Segment = exports.Segment || (exports.Segment = {}));


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Steps;
(function (Steps) {
    /**
     * A steps component to show the completion status of a series of activities.
     * Accepts the following properties in props$:
     *  link?: boolean - Styles to steps to display as a link.
     * 	vertical?: boolean - Styles the steps to align vertically.
     * 	stackable?: boolean - Lets the steps realign vertically on smaller screens.
     * 	evenlyDivided?: boolean - Arranges the steps to take up equal amount of width of their parent.
     * 	fluid?: boolean - Styles the steps to take up the full width of their parent.
     * 	size?: Size - The size of the steps.
     * 	attachment?: Attachment - Styles the steps to appear attached to nearby content.
     * Expects the following type of content in content$: Array of {}
     * 	icon?: DOMContent The icon to use for the step.
     * 	header?: DOMContent - The title for the step.
     * 	description?: DOMContent - The description for the step.
     * 	isCompleted?: boolean - Marks the step as completed.
     * 	isActive?: boolean - Marks the step as the current step.
     * 	isDisabled?: boolean - Marks the step as disabled.
     *  link?: boolean - Style the step to be clickable.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            var evt = function (type) { return sources.DOM.select(".step").events(type); };
            return {
                DOM: vTree$,
                Events: evt,
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Steps.run = run;
    /**
     * A steps component to show the completion status of a series of activities.
     * Accepts the following properties:
     *  link?: boolean - Styles to steps to display as a link.
     * 	vertical?: boolean - Styles the steps to align vertically.
     * 	stackable?: boolean - Lets the steps realign vertically on smaller screens.
     * 	evenlyDivided?: boolean - Arranges the steps to take up equal amount of width of their parent.
     * 	fluid?: boolean - Styles the steps to take up the full width of their parent.
     * 	size?: Size - The size of the steps.
     * 	attachment?: Attachment - Styles the steps to appear attached to nearby content.
     * Expects the following type of content: Array of {}
     * 	icon?: DOMContent The icon to use for the step.
     * 	header?: DOMContent - The title for the step.
     * 	description?: DOMContent - The description for the step.
     * 	isCompleted?: boolean - Marks the step as completed.
     * 	isActive?: boolean - Marks the step as the current step.
     * 	isDisabled?: boolean - Marks the step as disabled.
     *  link?: boolean - Style the step to be clickable.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = pOrC instanceof Array ? {} : pOrC;
        var content = pOrC instanceof Array ? pOrC : c;
        var children = content.map(function (_a, i) {
            var icon = _a.icon, header = _a.header, description = _a.description, isCompleted = _a.isCompleted, isActive = _a.isActive, isDisabled = _a.isDisabled, link = _a.link;
            return props.link
                ? dom_1.a({ props: { id: i, className: getStepClassname(isCompleted, isActive, isDisabled, link) } }, [
                    icon,
                    dom_1.div({ props: { className: "content" } }, [
                        dom_1.div({ props: { className: "title" } }, header),
                        dom_1.div({ props: { className: "description" } }, description)
                    ])
                ])
                : dom_1.div({ props: { id: i, className: getStepClassname(isCompleted, isActive, isDisabled, link) } }, [
                    icon,
                    dom_1.div({ props: { className: "content" } }, [
                        dom_1.div({ props: { className: "title" } }, header),
                        dom_1.div({ props: { className: "description" } }, description)
                    ])
                ]);
        });
        return dom_1.div({ props: { className: getClassname(props, content.length) } }, children);
    }
    Steps.render = render;
    function getStepClassname(isCompleted, isActive, isDisabled, link) {
        var className = "";
        if (isActive) {
            className += "active";
        }
        if (isCompleted) {
            className += " completed";
        }
        if (isDisabled) {
            className += " disabled";
        }
        if (link) {
            className += " link";
        }
        className += " step";
        return className;
    }
    function getClassname(props, length) {
        var className = "ui";
        if (props.vertical) {
            className += " vertical";
        }
        if (props.stackable) {
            className += " stackable";
        }
        if (props.fluid) {
            className += " fluid";
        }
        if (props.evenlyDivided) {
            className += utils_1.numToText(length);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        className += " steps";
        return className;
    }
})(Steps = exports.Steps || (exports.Steps = {}));


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Textbox;
(function (Textbox) {
    /**
     * A textbox component for capturing user input.
     * Accepts the following properties in props$:
     *   initial?: string - The initial value of the textbox.
     *   placeholder?: string - The placeholder text of the textbox.
     *   icon?: boolean - Styles the textbox for displaying an icon in the textbox.
     *   labeled?: boolean - Styles the textbox for displaying a label in the textbox.
     *   action?: boolean - Styles the textbox for displaying an action component in the textbox.
     *   leftContent?: boolean - Adds content to the left side of the textbox.
     *   rightContent?: boolean - Adds content to the right side of the textbox.
     *   transparent?: boolean - Styles the textbox to appear transparent.
     *   inverted?: boolean - Styles the textbox for darker backgrounds.
     *   focus?: boolean - Styles the textbox to show it has focus.
     *   loading?: boolean - Styles the textbox with a loading icon.
     *   disabled?: boolean - Styles the textbox to appear disabled.
     *   color?: Color - The color of the textbox.
     *   size?: Size - The size of the textbox.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var evt = function (type) { return sources.DOM.select(".input").events(type); };
            var props$ = sources.props$.remember();
            // const initialValue$ = props$.map(props => props.initial);
            var newValue$ = evt("input").map(function (ev) { return ev.target.value; }).remember();
            // const value$ = xs.merge(initialValue$, newValue$);
            var vtree$ = xstream_1.default.combine(props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vtree$,
                Events: evt,
                value$: newValue$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Textbox.run = run;
    /**
     * A textbox component for capturing user input.
     * Accepts the following properties:
     *   initial?: string - The initial value of the textbox.
     *   placeholder?: string - The placeholder text of the textbox.
     *   icon?: boolean - Styles the textbox for displaying an icon in the textbox.
     *   labeled?: boolean - Styles the textbox for displaying a label in the textbox.
     *   action?: boolean - Styles the textbox for displaying an action component in the textbox.
     *   leftContent?: boolean - Adds content to the left side of the textbox.
     *   rightContent?: boolean - Adds content to the right side of the textbox.
     *   transparent?: boolean - Styles the textbox to appear transparent.
     *   inverted?: boolean - Styles the textbox for darker backgrounds.
     *   focus?: boolean - Styles the textbox to show it has focus.
     *   loading?: boolean - Styles the textbox with a loading icon.
     *   disabled?: boolean - Styles the textbox to appear disabled.
     *   color?: Color - The color of the textbox.
     *   size?: Size - The size of the textbox.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var textbox = props.large
            ? dom_1.textarea({ props: { value: props.initial, placeholder: props.placeholder } })
            : dom_1.input({ props: { type: props.type ? props.type : "text", value: props.initial, placeholder: props.placeholder } });
        return props.rightContent
            ? dom_1.div({ props: { className: getClassname(props) } }, [
                textbox,
                content
            ])
            : dom_1.div({ props: { className: getClassname(props) } }, [
                content,
                textbox
            ]);
    }
    Textbox.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.leftContent) {
            className += " left";
        }
        if (props.rightContent) {
            className += " right";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.labeled) {
            className += " labeled";
        }
        if (props.action) {
            className += " action";
        }
        if (props.transparent) {
            className += " transparent";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.focus) {
            className += " focus";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " input";
        return className;
    }
})(Textbox = exports.Textbox || (exports.Textbox = {}));


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IconType;
(function (IconType) {
    function ToClassname(type) {
        if (type < 0)
            return "";
        var name = IconType[type];
        return " " + name.match(/[A-Z][a-z]+/g).join(" ").toLowerCase();
    }
    IconType.ToClassname = ToClassname;
    function GetNames() {
        var names = [];
        for (var n in IconType) {
            if (typeof IconType[n] === 'number')
                names.push(n);
        }
        return names;
    }
    IconType.GetNames = GetNames;
})(IconType = exports.IconType || (exports.IconType = {}));
(function (IconType) {
    IconType[IconType["Search"] = 0] = "Search";
    IconType[IconType["MailOutline"] = 1] = "MailOutline";
    IconType[IconType["External"] = 2] = "External";
    IconType[IconType["Signal"] = 3] = "Signal";
    IconType[IconType["Setting"] = 4] = "Setting";
    IconType[IconType["Home"] = 5] = "Home";
    IconType[IconType["Inbox"] = 6] = "Inbox";
    IconType[IconType["Browser"] = 7] = "Browser";
    IconType[IconType["Tag"] = 8] = "Tag";
    IconType[IconType["Tags"] = 9] = "Tags";
    IconType[IconType["Calendar"] = 10] = "Calendar";
    IconType[IconType["Comment"] = 11] = "Comment";
    IconType[IconType["Comments"] = 12] = "Comments";
    IconType[IconType["Shop"] = 13] = "Shop";
    IconType[IconType["Privacy"] = 14] = "Privacy";
    IconType[IconType["Settings"] = 15] = "Settings";
    IconType[IconType["Trophy"] = 16] = "Trophy";
    IconType[IconType["Payment"] = 17] = "Payment";
    IconType[IconType["Feed"] = 18] = "Feed";
    IconType[IconType["AlarmOutline"] = 19] = "AlarmOutline";
    IconType[IconType["Tasks"] = 20] = "Tasks";
    IconType[IconType["Cloud"] = 21] = "Cloud";
    IconType[IconType["Lab"] = 22] = "Lab";
    IconType[IconType["Mail"] = 23] = "Mail";
    IconType[IconType["Idea"] = 24] = "Idea";
    IconType[IconType["Dashboard"] = 25] = "Dashboard";
    IconType[IconType["Sitemap"] = 26] = "Sitemap";
    IconType[IconType["Alarm"] = 27] = "Alarm";
    IconType[IconType["Terminal"] = 28] = "Terminal";
    IconType[IconType["Code"] = 29] = "Code";
    IconType[IconType["Protect"] = 30] = "Protect";
    IconType[IconType["CalendarOutline"] = 31] = "CalendarOutline";
    IconType[IconType["Ticket"] = 32] = "Ticket";
    IconType[IconType["ExternalSquare"] = 33] = "ExternalSquare";
    IconType[IconType["Map"] = 34] = "Map";
    IconType[IconType["Bug"] = 35] = "Bug";
    IconType[IconType["MailSquare"] = 36] = "MailSquare";
    IconType[IconType["History"] = 37] = "History";
    IconType[IconType["Options"] = 38] = "Options";
    IconType[IconType["CommentOutline"] = 39] = "CommentOutline";
    IconType[IconType["CommentsOutline"] = 40] = "CommentsOutline";
    IconType[IconType["TextTelephone"] = 41] = "TextTelephone";
    IconType[IconType["Find"] = 42] = "Find";
    IconType[IconType["Wifi"] = 43] = "Wifi";
    IconType[IconType["AlarmSlash"] = 44] = "AlarmSlash";
    IconType[IconType["AlarmSlashOutline"] = 45] = "AlarmSlashOutline";
    IconType[IconType["Copyright"] = 46] = "Copyright";
    IconType[IconType["At"] = 47] = "At";
    IconType[IconType["Eyedropper"] = 48] = "Eyedropper";
    IconType[IconType["PaintBrush"] = 49] = "PaintBrush";
    IconType[IconType["Heartbeat"] = 50] = "Heartbeat";
    IconType[IconType["Download"] = 51] = "Download";
    IconType[IconType["Repeat"] = 52] = "Repeat";
    IconType[IconType["Refresh"] = 53] = "Refresh";
    IconType[IconType["Lock"] = 54] = "Lock";
    IconType[IconType["Bookmark"] = 55] = "Bookmark";
    IconType[IconType["Print"] = 56] = "Print";
    IconType[IconType["Write"] = 57] = "Write";
    IconType[IconType["Theme"] = 58] = "Theme";
    IconType[IconType["Adjust"] = 59] = "Adjust";
    IconType[IconType["Edit"] = 60] = "Edit";
    IconType[IconType["ExternalShare"] = 61] = "ExternalShare";
    IconType[IconType["Ban"] = 62] = "Ban";
    IconType[IconType["MailForward"] = 63] = "MailForward";
    IconType[IconType["Share"] = 64] = "Share";
    IconType[IconType["Expand"] = 65] = "Expand";
    IconType[IconType["Compress"] = 66] = "Compress";
    IconType[IconType["Unhide"] = 67] = "Unhide";
    IconType[IconType["Hide"] = 68] = "Hide";
    IconType[IconType["Random"] = 69] = "Random";
    IconType[IconType["Retweet"] = 70] = "Retweet";
    IconType[IconType["SignOut"] = 71] = "SignOut";
    IconType[IconType["Pin"] = 72] = "Pin";
    IconType[IconType["SignIn"] = 73] = "SignIn";
    IconType[IconType["Upload"] = 74] = "Upload";
    IconType[IconType["Call"] = 75] = "Call";
    IconType[IconType["CallSquare"] = 76] = "CallSquare";
    IconType[IconType["RemoveBookmark"] = 77] = "RemoveBookmark";
    IconType[IconType["Unlock"] = 78] = "Unlock";
    IconType[IconType["Configure"] = 79] = "Configure";
    IconType[IconType["Filter"] = 80] = "Filter";
    IconType[IconType["Wizard"] = 81] = "Wizard";
    IconType[IconType["Undo"] = 82] = "Undo";
    IconType[IconType["Exchange"] = 83] = "Exchange";
    IconType[IconType["CloudDownload"] = 84] = "CloudDownload";
    IconType[IconType["CloudUpload"] = 85] = "CloudUpload";
    IconType[IconType["Reply"] = 86] = "Reply";
    IconType[IconType["ReplyAll"] = 87] = "ReplyAll";
    IconType[IconType["Erase"] = 88] = "Erase";
    IconType[IconType["UnlockAlternate"] = 89] = "UnlockAlternate";
    IconType[IconType["Archive"] = 90] = "Archive";
    IconType[IconType["Translate"] = 91] = "Translate";
    IconType[IconType["Recycle"] = 92] = "Recycle";
    IconType[IconType["Send"] = 93] = "Send";
    IconType[IconType["SendOutline"] = 94] = "SendOutline";
    IconType[IconType["ShareAlternate"] = 95] = "ShareAlternate";
    IconType[IconType["ShareAlternateSquare"] = 96] = "ShareAlternateSquare";
    IconType[IconType["Wait"] = 97] = "Wait";
    IconType[IconType["WriteSquare"] = 98] = "WriteSquare";
    IconType[IconType["ShareSquare"] = 99] = "ShareSquare";
    IconType[IconType["AddToCart"] = 100] = "AddToCart";
    IconType[IconType["InCart"] = 101] = "InCart";
    IconType[IconType["AddUser"] = 102] = "AddUser";
    IconType[IconType["RemoveUser"] = 103] = "RemoveUser";
    IconType[IconType["HelpCircle"] = 104] = "HelpCircle";
    IconType[IconType["InfoCircle"] = 105] = "InfoCircle";
    IconType[IconType["Warning"] = 106] = "Warning";
    IconType[IconType["WarningCircle"] = 107] = "WarningCircle";
    IconType[IconType["WarningSign"] = 108] = "WarningSign";
    IconType[IconType["Help"] = 109] = "Help";
    IconType[IconType["Info"] = 110] = "Info";
    IconType[IconType["Announcement"] = 111] = "Announcement";
    IconType[IconType["Birthday"] = 112] = "Birthday";
    IconType[IconType["Users"] = 113] = "Users";
    IconType[IconType["Doctor"] = 114] = "Doctor";
    IconType[IconType["Child"] = 115] = "Child";
    IconType[IconType["User"] = 116] = "User";
    IconType[IconType["Handicap"] = 117] = "Handicap";
    IconType[IconType["Student"] = 118] = "Student";
    IconType[IconType["Spy"] = 119] = "Spy";
    IconType[IconType["GridLayout"] = 120] = "GridLayout";
    IconType[IconType["ListLayout"] = 121] = "ListLayout";
    IconType[IconType["BlockLayout"] = 122] = "BlockLayout";
    IconType[IconType["Zoom"] = 123] = "Zoom";
    IconType[IconType["ZoomOut"] = 124] = "ZoomOut";
    IconType[IconType["ResizeVertical"] = 125] = "ResizeVertical";
    IconType[IconType["ResizeHorizontal"] = 126] = "ResizeHorizontal";
    IconType[IconType["Maximize"] = 127] = "Maximize";
    IconType[IconType["Crop"] = 128] = "Crop";
    IconType[IconType["Female"] = 129] = "Female";
    IconType[IconType["Male"] = 130] = "Male";
    IconType[IconType["Woman"] = 131] = "Woman";
    IconType[IconType["Man"] = 132] = "Man";
    IconType[IconType["NonBinaryTransgender"] = 133] = "NonBinaryTransgender";
    IconType[IconType["Intergender"] = 134] = "Intergender";
    IconType[IconType["Transgender"] = 135] = "Transgender";
    IconType[IconType["Lesbian"] = 136] = "Lesbian";
    IconType[IconType["Gay"] = 137] = "Gay";
    IconType[IconType["Heterosexual"] = 138] = "Heterosexual";
    IconType[IconType["OtherGender"] = 139] = "OtherGender";
    IconType[IconType["OtherGenderVertical"] = 140] = "OtherGenderVertical";
    IconType[IconType["OtherGenderHorizontal"] = 141] = "OtherGenderHorizontal";
    IconType[IconType["Neuter"] = 142] = "Neuter";
    IconType[IconType["Cocktail"] = 143] = "Cocktail";
    IconType[IconType["Road"] = 144] = "Road";
    IconType[IconType["Flag"] = 145] = "Flag";
    IconType[IconType["Book"] = 146] = "Book";
    IconType[IconType["Gift"] = 147] = "Gift";
    IconType[IconType["Leaf"] = 148] = "Leaf";
    IconType[IconType["Fire"] = 149] = "Fire";
    IconType[IconType["Plane"] = 150] = "Plane";
    IconType[IconType["Magnet"] = 151] = "Magnet";
    IconType[IconType["Legal"] = 152] = "Legal";
    IconType[IconType["Lemon"] = 153] = "Lemon";
    IconType[IconType["World"] = 154] = "World";
    IconType[IconType["Travel"] = 155] = "Travel";
    IconType[IconType["Shipping"] = 156] = "Shipping";
    IconType[IconType["Money"] = 157] = "Money";
    IconType[IconType["Lightning"] = 158] = "Lightning";
    IconType[IconType["Rain"] = 159] = "Rain";
    IconType[IconType["Treatment"] = 160] = "Treatment";
    IconType[IconType["Suitcase"] = 161] = "Suitcase";
    IconType[IconType["Bar"] = 162] = "Bar";
    IconType[IconType["FlagOutline"] = 163] = "FlagOutline";
    IconType[IconType["FlagCheckered"] = 164] = "FlagCheckered";
    IconType[IconType["Puzzle"] = 165] = "Puzzle";
    IconType[IconType["FireExtinguisher"] = 166] = "FireExtinguisher";
    IconType[IconType["Rocket"] = 167] = "Rocket";
    IconType[IconType["Anchor"] = 168] = "Anchor";
    IconType[IconType["Bullseye"] = 169] = "Bullseye";
    IconType[IconType["Sun"] = 170] = "Sun";
    IconType[IconType["Moon"] = 171] = "Moon";
    IconType[IconType["Fax"] = 172] = "Fax";
    IconType[IconType["LifeRing"] = 173] = "LifeRing";
    IconType[IconType["Bomb"] = 174] = "Bomb";
    IconType[IconType["Soccer"] = 175] = "Soccer";
    IconType[IconType["Calculator"] = 176] = "Calculator";
    IconType[IconType["Diamond"] = 177] = "Diamond";
    IconType[IconType["Crosshairs"] = 178] = "Crosshairs";
    IconType[IconType["Asterisk"] = 179] = "Asterisk";
    IconType[IconType["Certificate"] = 180] = "Certificate";
    IconType[IconType["Circle"] = 181] = "Circle";
    IconType[IconType["QuoteLeft"] = 182] = "QuoteLeft";
    IconType[IconType["QuoteRight"] = 183] = "QuoteRight";
    IconType[IconType["EllipsisHorizontal"] = 184] = "EllipsisHorizontal";
    IconType[IconType["EllipsisVertical"] = 185] = "EllipsisVertical";
    IconType[IconType["Cube"] = 186] = "Cube";
    IconType[IconType["Cubes"] = 187] = "Cubes";
    IconType[IconType["CircleNotched"] = 188] = "CircleNotched";
    IconType[IconType["CircleThin"] = 189] = "CircleThin";
    IconType[IconType["SquareOutline"] = 190] = "SquareOutline";
    IconType[IconType["Square"] = 191] = "Square";
    IconType[IconType["Checkmark"] = 192] = "Checkmark";
    IconType[IconType["Remove"] = 193] = "Remove";
    IconType[IconType["CheckmarkBox"] = 194] = "CheckmarkBox";
    IconType[IconType["Move"] = 195] = "Move";
    IconType[IconType["AddCircle"] = 196] = "AddCircle";
    IconType[IconType["MinusCircle"] = 197] = "MinusCircle";
    IconType[IconType["RemoveCircle"] = 198] = "RemoveCircle";
    IconType[IconType["CheckCircle"] = 199] = "CheckCircle";
    IconType[IconType["RemoveCircleOutline"] = 200] = "RemoveCircleOutline";
    IconType[IconType["CheckCircleOutline"] = 201] = "CheckCircleOutline";
    IconType[IconType["Plus"] = 202] = "Plus";
    IconType[IconType["Minus"] = 203] = "Minus";
    IconType[IconType["AddSquare"] = 204] = "AddSquare";
    IconType[IconType["Radio"] = 205] = "Radio";
    IconType[IconType["SelectedRadio"] = 206] = "SelectedRadio";
    IconType[IconType["MinusSquare"] = 207] = "MinusSquare";
    IconType[IconType["MinusSquareOutline"] = 208] = "MinusSquareOutline";
    IconType[IconType["CheckSquare"] = 209] = "CheckSquare";
    IconType[IconType["PlusSquareOutline"] = 210] = "PlusSquareOutline";
    IconType[IconType["ToggleOff"] = 211] = "ToggleOff";
    IconType[IconType["ToggleOn"] = 212] = "ToggleOn";
    IconType[IconType["Film"] = 213] = "Film";
    IconType[IconType["Sound"] = 214] = "Sound";
    IconType[IconType["Photo"] = 215] = "Photo";
    IconType[IconType["BarChart"] = 216] = "BarChart";
    IconType[IconType["CameraRetro"] = 217] = "CameraRetro";
    IconType[IconType["Newspaper"] = 218] = "Newspaper";
    IconType[IconType["AreaChart"] = 219] = "AreaChart";
    IconType[IconType["PieChart"] = 220] = "PieChart";
    IconType[IconType["LineChart"] = 221] = "LineChart";
    IconType[IconType["ArrowCircleOutlineDown"] = 222] = "ArrowCircleOutlineDown";
    IconType[IconType["ArrowCircleOutlineUp"] = 223] = "ArrowCircleOutlineUp";
    IconType[IconType["ChevronLeft"] = 224] = "ChevronLeft";
    IconType[IconType["ChevronRight"] = 225] = "ChevronRight";
    IconType[IconType["ArrowLeft"] = 226] = "ArrowLeft";
    IconType[IconType["ArrowRight"] = 227] = "ArrowRight";
    IconType[IconType["ArrowUp"] = 228] = "ArrowUp";
    IconType[IconType["ArrowDown"] = 229] = "ArrowDown";
    IconType[IconType["ChevronUp"] = 230] = "ChevronUp";
    IconType[IconType["ChevronDown"] = 231] = "ChevronDown";
    IconType[IconType["PointingRight"] = 232] = "PointingRight";
    IconType[IconType["PointingLeft"] = 233] = "PointingLeft";
    IconType[IconType["PointingUp"] = 234] = "PointingUp";
    IconType[IconType["PointingDown"] = 235] = "PointingDown";
    IconType[IconType["ArrowCircleLeft"] = 236] = "ArrowCircleLeft";
    IconType[IconType["ArrowCircleRight"] = 237] = "ArrowCircleRight";
    IconType[IconType["ArrowCircleUp"] = 238] = "ArrowCircleUp";
    IconType[IconType["ArrowCircleDown"] = 239] = "ArrowCircleDown";
    IconType[IconType["CaretDown"] = 240] = "CaretDown";
    IconType[IconType["CaretUp"] = 241] = "CaretUp";
    IconType[IconType["CaretLeft"] = 242] = "CaretLeft";
    IconType[IconType["CaretRight"] = 243] = "CaretRight";
    IconType[IconType["AngleDoubleLeft"] = 244] = "AngleDoubleLeft";
    IconType[IconType["AngleDoubleRight"] = 245] = "AngleDoubleRight";
    IconType[IconType["AngleDoubleUp"] = 246] = "AngleDoubleUp";
    IconType[IconType["AngleDoubleDown"] = 247] = "AngleDoubleDown";
    IconType[IconType["AngleLeft"] = 248] = "AngleLeft";
    IconType[IconType["AngleRight"] = 249] = "AngleRight";
    IconType[IconType["AngleUp"] = 250] = "AngleUp";
    IconType[IconType["AngleDown"] = 251] = "AngleDown";
    IconType[IconType["ChevronCircleLeft"] = 252] = "ChevronCircleLeft";
    IconType[IconType["ChevronCircleRight"] = 253] = "ChevronCircleRight";
    IconType[IconType["ChevronCircleUp"] = 254] = "ChevronCircleUp";
    IconType[IconType["ChevronCircleDown"] = 255] = "ChevronCircleDown";
    IconType[IconType["ToggleDown"] = 256] = "ToggleDown";
    IconType[IconType["ToggleUp"] = 257] = "ToggleUp";
    IconType[IconType["ToggleRight"] = 258] = "ToggleRight";
    IconType[IconType["LongArrowDown"] = 259] = "LongArrowDown";
    IconType[IconType["LongArrowUp"] = 260] = "LongArrowUp";
    IconType[IconType["LongArrowLeft"] = 261] = "LongArrowLeft";
    IconType[IconType["LongArrowRight"] = 262] = "LongArrowRight";
    IconType[IconType["ArrowCircleOutlineRight"] = 263] = "ArrowCircleOutlineRight";
    IconType[IconType["ArrowCircleOutlineLeft"] = 264] = "ArrowCircleOutlineLeft";
    IconType[IconType["ToggleLeft"] = 265] = "ToggleLeft";
    IconType[IconType["Power"] = 266] = "Power";
    IconType[IconType["Trash"] = 267] = "Trash";
    IconType[IconType["TrashOutline"] = 268] = "TrashOutline";
    IconType[IconType["DiskOutline"] = 269] = "DiskOutline";
    IconType[IconType["Desktop"] = 270] = "Desktop";
    IconType[IconType["Laptop"] = 271] = "Laptop";
    IconType[IconType["Tablet"] = 272] = "Tablet";
    IconType[IconType["Mobile"] = 273] = "Mobile";
    IconType[IconType["Game"] = 274] = "Game";
    IconType[IconType["Keyboard"] = 275] = "Keyboard";
    IconType[IconType["Plug"] = 276] = "Plug";
    IconType[IconType["Folder"] = 277] = "Folder";
    IconType[IconType["FolderOpen"] = 278] = "FolderOpen";
    IconType[IconType["LevelUp"] = 279] = "LevelUp";
    IconType[IconType["LevelDown"] = 280] = "LevelDown";
    IconType[IconType["File"] = 281] = "File";
    IconType[IconType["FileOutline"] = 282] = "FileOutline";
    IconType[IconType["FileText"] = 283] = "FileText";
    IconType[IconType["FileTextOutline"] = 284] = "FileTextOutline";
    IconType[IconType["FolderOutline"] = 285] = "FolderOutline";
    IconType[IconType["FolderOpenOutline"] = 286] = "FolderOpenOutline";
    IconType[IconType["FilePdfOutline"] = 287] = "FilePdfOutline";
    IconType[IconType["FileWordOutline"] = 288] = "FileWordOutline";
    IconType[IconType["FileExcelOutline"] = 289] = "FileExcelOutline";
    IconType[IconType["FilePowerpointOutline"] = 290] = "FilePowerpointOutline";
    IconType[IconType["FileImageOutline"] = 291] = "FileImageOutline";
    IconType[IconType["FileArchiveOutline"] = 292] = "FileArchiveOutline";
    IconType[IconType["FileAudioOutline"] = 293] = "FileAudioOutline";
    IconType[IconType["FileVideoOutline"] = 294] = "FileVideoOutline";
    IconType[IconType["FileCodeOutline"] = 295] = "FileCodeOutline";
    IconType[IconType["Barcode"] = 296] = "Barcode";
    IconType[IconType["Qrcode"] = 297] = "Qrcode";
    IconType[IconType["Fork"] = 298] = "Fork";
    IconType[IconType["Html5"] = 299] = "Html5";
    IconType[IconType["Css3"] = 300] = "Css3";
    IconType[IconType["Rss"] = 301] = "Rss";
    IconType[IconType["RssSquare"] = 302] = "RssSquare";
    IconType[IconType["Openid"] = 303] = "Openid";
    IconType[IconType["Database"] = 304] = "Database";
    IconType[IconType["Server"] = 305] = "Server";
    IconType[IconType["Heart"] = 306] = "Heart";
    IconType[IconType["Star"] = 307] = "Star";
    IconType[IconType["EmptyStar"] = 308] = "EmptyStar";
    IconType[IconType["ThumbsOutlineUp"] = 309] = "ThumbsOutlineUp";
    IconType[IconType["ThumbsOutlineDown"] = 310] = "ThumbsOutlineDown";
    IconType[IconType["StarHalf"] = 311] = "StarHalf";
    IconType[IconType["EmptyHeart"] = 312] = "EmptyHeart";
    IconType[IconType["Smile"] = 313] = "Smile";
    IconType[IconType["Frown"] = 314] = "Frown";
    IconType[IconType["Meh"] = 315] = "Meh";
    IconType[IconType["StarHalfEmpty"] = 316] = "StarHalfEmpty";
    IconType[IconType["ThumbsUp"] = 317] = "ThumbsUp";
    IconType[IconType["ThumbsDown"] = 318] = "ThumbsDown";
    IconType[IconType["Music"] = 319] = "Music";
    IconType[IconType["VideoPlayOutline"] = 320] = "VideoPlayOutline";
    IconType[IconType["VolumeOff"] = 321] = "VolumeOff";
    IconType[IconType["VolumeDown"] = 322] = "VolumeDown";
    IconType[IconType["VolumeUp"] = 323] = "VolumeUp";
    IconType[IconType["Record"] = 324] = "Record";
    IconType[IconType["StepBackward"] = 325] = "StepBackward";
    IconType[IconType["FastBackward"] = 326] = "FastBackward";
    IconType[IconType["Backward"] = 327] = "Backward";
    IconType[IconType["Play"] = 328] = "Play";
    IconType[IconType["Pause"] = 329] = "Pause";
    IconType[IconType["Stop"] = 330] = "Stop";
    IconType[IconType["Forward"] = 331] = "Forward";
    IconType[IconType["FastForward"] = 332] = "FastForward";
    IconType[IconType["StepForward"] = 333] = "StepForward";
    IconType[IconType["Eject"] = 334] = "Eject";
    IconType[IconType["Unmute"] = 335] = "Unmute";
    IconType[IconType["Mute"] = 336] = "Mute";
    IconType[IconType["VideoPlay"] = 337] = "VideoPlay";
    IconType[IconType["ClosedCaptioning"] = 338] = "ClosedCaptioning";
    IconType[IconType["Marker"] = 339] = "Marker";
    IconType[IconType["Coffee"] = 340] = "Coffee";
    IconType[IconType["Food"] = 341] = "Food";
    IconType[IconType["BuildingOutline"] = 342] = "BuildingOutline";
    IconType[IconType["Hospital"] = 343] = "Hospital";
    IconType[IconType["Emergency"] = 344] = "Emergency";
    IconType[IconType["FirstAid"] = 345] = "FirstAid";
    IconType[IconType["Military"] = 346] = "Military";
    IconType[IconType["H"] = 347] = "H";
    IconType[IconType["LocationArrow"] = 348] = "LocationArrow";
    IconType[IconType["SpaceShuttle"] = 349] = "SpaceShuttle";
    IconType[IconType["University"] = 350] = "University";
    IconType[IconType["Building"] = 351] = "Building";
    IconType[IconType["Paw"] = 352] = "Paw";
    IconType[IconType["Spoon"] = 353] = "Spoon";
    IconType[IconType["Car"] = 354] = "Car";
    IconType[IconType["Taxi"] = 355] = "Taxi";
    IconType[IconType["Tree"] = 356] = "Tree";
    IconType[IconType["Bicycle"] = 357] = "Bicycle";
    IconType[IconType["Bus"] = 358] = "Bus";
    IconType[IconType["Ship"] = 359] = "Ship";
    IconType[IconType["Motorcycle"] = 360] = "Motorcycle";
    IconType[IconType["StreetView"] = 361] = "StreetView";
    IconType[IconType["Hotel"] = 362] = "Hotel";
    IconType[IconType["Train"] = 363] = "Train";
    IconType[IconType["Subway"] = 364] = "Subway";
    IconType[IconType["Table"] = 365] = "Table";
    IconType[IconType["Columns"] = 366] = "Columns";
    IconType[IconType["Sort"] = 367] = "Sort";
    IconType[IconType["SortAscending"] = 368] = "SortAscending";
    IconType[IconType["SortDescending"] = 369] = "SortDescending";
    IconType[IconType["SortAlphabetAscending"] = 370] = "SortAlphabetAscending";
    IconType[IconType["SortAlphabetDescending"] = 371] = "SortAlphabetDescending";
    IconType[IconType["SortContentAscending"] = 372] = "SortContentAscending";
    IconType[IconType["SortContentDescending"] = 373] = "SortContentDescending";
    IconType[IconType["SortNumericAscending"] = 374] = "SortNumericAscending";
    IconType[IconType["SortNumericDescending"] = 375] = "SortNumericDescending";
    IconType[IconType["Font"] = 376] = "Font";
    IconType[IconType["Bold"] = 377] = "Bold";
    IconType[IconType["Italic"] = 378] = "Italic";
    IconType[IconType["TextHeight"] = 379] = "TextHeight";
    IconType[IconType["TextWidth"] = 380] = "TextWidth";
    IconType[IconType["AlignLeft"] = 381] = "AlignLeft";
    IconType[IconType["AlignCenter"] = 382] = "AlignCenter";
    IconType[IconType["AlignRight"] = 383] = "AlignRight";
    IconType[IconType["AlignJustify"] = 384] = "AlignJustify";
    IconType[IconType["List"] = 385] = "List";
    IconType[IconType["Outdent"] = 386] = "Outdent";
    IconType[IconType["Indent"] = 387] = "Indent";
    IconType[IconType["Linkify"] = 388] = "Linkify";
    IconType[IconType["Cut"] = 389] = "Cut";
    IconType[IconType["Copy"] = 390] = "Copy";
    IconType[IconType["Attach"] = 391] = "Attach";
    IconType[IconType["Save"] = 392] = "Save";
    IconType[IconType["Content"] = 393] = "Content";
    IconType[IconType["UnorderedList"] = 394] = "UnorderedList";
    IconType[IconType["OrderedList"] = 395] = "OrderedList";
    IconType[IconType["Strikethrough"] = 396] = "Strikethrough";
    IconType[IconType["Underline"] = 397] = "Underline";
    IconType[IconType["Paste"] = 398] = "Paste";
    IconType[IconType["Unlink"] = 399] = "Unlink";
    IconType[IconType["Superscript"] = 400] = "Superscript";
    IconType[IconType["Subscript"] = 401] = "Subscript";
    IconType[IconType["Header"] = 402] = "Header";
    IconType[IconType["Paragraph"] = 403] = "Paragraph";
    IconType[IconType["Euro"] = 404] = "Euro";
    IconType[IconType["Pound"] = 405] = "Pound";
    IconType[IconType["Dollar"] = 406] = "Dollar";
    IconType[IconType["Rupee"] = 407] = "Rupee";
    IconType[IconType["Yen"] = 408] = "Yen";
    IconType[IconType["Ruble"] = 409] = "Ruble";
    IconType[IconType["Won"] = 410] = "Won";
    IconType[IconType["Lira"] = 411] = "Lira";
    IconType[IconType["Shekel"] = 412] = "Shekel";
    IconType[IconType["Paypal"] = 413] = "Paypal";
    IconType[IconType["PaypalCard"] = 414] = "PaypalCard";
    IconType[IconType["GoogleWallet"] = 415] = "GoogleWallet";
    IconType[IconType["Visa"] = 416] = "Visa";
    IconType[IconType["Mastercard"] = 417] = "Mastercard";
    IconType[IconType["Discover"] = 418] = "Discover";
    IconType[IconType["AmericanExpress"] = 419] = "AmericanExpress";
    IconType[IconType["Stripe"] = 420] = "Stripe";
    IconType[IconType["TwitterSquare"] = 421] = "TwitterSquare";
    IconType[IconType["FacebookSquare"] = 422] = "FacebookSquare";
    IconType[IconType["LinkedinSquare"] = 423] = "LinkedinSquare";
    IconType[IconType["GithubSquare"] = 424] = "GithubSquare";
    IconType[IconType["Twitter"] = 425] = "Twitter";
    IconType[IconType["Facebook"] = 426] = "Facebook";
    IconType[IconType["Github"] = 427] = "Github";
    IconType[IconType["Pinterest"] = 428] = "Pinterest";
    IconType[IconType["PinterestSquare"] = 429] = "PinterestSquare";
    IconType[IconType["GooglePlusSquare"] = 430] = "GooglePlusSquare";
    IconType[IconType["GooglePlus"] = 431] = "GooglePlus";
    IconType[IconType["Linkedin"] = 432] = "Linkedin";
    IconType[IconType["GithubAlternate"] = 433] = "GithubAlternate";
    IconType[IconType["Maxcdn"] = 434] = "Maxcdn";
    IconType[IconType["Bitcoin"] = 435] = "Bitcoin";
    IconType[IconType["YoutubeSquare"] = 436] = "YoutubeSquare";
    IconType[IconType["Youtube"] = 437] = "Youtube";
    IconType[IconType["Xing"] = 438] = "Xing";
    IconType[IconType["XingSquare"] = 439] = "XingSquare";
    IconType[IconType["YoutubePlay"] = 440] = "YoutubePlay";
    IconType[IconType["Dropbox"] = 441] = "Dropbox";
    IconType[IconType["StackOverflow"] = 442] = "StackOverflow";
    IconType[IconType["Instagram"] = 443] = "Instagram";
    IconType[IconType["Flickr"] = 444] = "Flickr";
    IconType[IconType["Adn"] = 445] = "Adn";
    IconType[IconType["Bitbucket"] = 446] = "Bitbucket";
    IconType[IconType["BitbucketSquare"] = 447] = "BitbucketSquare";
    IconType[IconType["Tumblr"] = 448] = "Tumblr";
    IconType[IconType["TumblrSquare"] = 449] = "TumblrSquare";
    IconType[IconType["Apple"] = 450] = "Apple";
    IconType[IconType["Windows"] = 451] = "Windows";
    IconType[IconType["Android"] = 452] = "Android";
    IconType[IconType["Linux"] = 453] = "Linux";
    IconType[IconType["Dribbble"] = 454] = "Dribbble";
    IconType[IconType["Skype"] = 455] = "Skype";
    IconType[IconType["Foursquare"] = 456] = "Foursquare";
    IconType[IconType["Trello"] = 457] = "Trello";
    IconType[IconType["Gittip"] = 458] = "Gittip";
    IconType[IconType["Vk"] = 459] = "Vk";
    IconType[IconType["Weibo"] = 460] = "Weibo";
    IconType[IconType["Renren"] = 461] = "Renren";
    IconType[IconType["Pagelines"] = 462] = "Pagelines";
    IconType[IconType["StackExchange"] = 463] = "StackExchange";
    IconType[IconType["Vimeo"] = 464] = "Vimeo";
    IconType[IconType["Slack"] = 465] = "Slack";
    IconType[IconType["Wordpress"] = 466] = "Wordpress";
    IconType[IconType["Yahoo"] = 467] = "Yahoo";
    IconType[IconType["Google"] = 468] = "Google";
    IconType[IconType["Reddit"] = 469] = "Reddit";
    IconType[IconType["RedditSquare"] = 470] = "RedditSquare";
    IconType[IconType["StumbleuponCircle"] = 471] = "StumbleuponCircle";
    IconType[IconType["Stumbleupon"] = 472] = "Stumbleupon";
    IconType[IconType["Delicious"] = 473] = "Delicious";
    IconType[IconType["Digg"] = 474] = "Digg";
    IconType[IconType["PiedPiper"] = 475] = "PiedPiper";
    IconType[IconType["PiedPiperAlternate"] = 476] = "PiedPiperAlternate";
    IconType[IconType["Drupal"] = 477] = "Drupal";
    IconType[IconType["Joomla"] = 478] = "Joomla";
    IconType[IconType["Behance"] = 479] = "Behance";
    IconType[IconType["BehanceSquare"] = 480] = "BehanceSquare";
    IconType[IconType["Steam"] = 481] = "Steam";
    IconType[IconType["SteamSquare"] = 482] = "SteamSquare";
    IconType[IconType["Spotify"] = 483] = "Spotify";
    IconType[IconType["Deviantart"] = 484] = "Deviantart";
    IconType[IconType["Soundcloud"] = 485] = "Soundcloud";
    IconType[IconType["Vine"] = 486] = "Vine";
    IconType[IconType["Codepen"] = 487] = "Codepen";
    IconType[IconType["Jsfiddle"] = 488] = "Jsfiddle";
    IconType[IconType["Rebel"] = 489] = "Rebel";
    IconType[IconType["Empire"] = 490] = "Empire";
    IconType[IconType["GitSquare"] = 491] = "GitSquare";
    IconType[IconType["Git"] = 492] = "Git";
    IconType[IconType["HackerNews"] = 493] = "HackerNews";
    IconType[IconType["TencentWeibo"] = 494] = "TencentWeibo";
    IconType[IconType["Qq"] = 495] = "Qq";
    IconType[IconType["Wechat"] = 496] = "Wechat";
    IconType[IconType["Slideshare"] = 497] = "Slideshare";
    IconType[IconType["Twitch"] = 498] = "Twitch";
    IconType[IconType["Yelp"] = 499] = "Yelp";
    IconType[IconType["Lastfm"] = 500] = "Lastfm";
    IconType[IconType["LastfmSquare"] = 501] = "LastfmSquare";
    IconType[IconType["Ioxhost"] = 502] = "Ioxhost";
    IconType[IconType["Angellist"] = 503] = "Angellist";
    IconType[IconType["Meanpath"] = 504] = "Meanpath";
    IconType[IconType["Buysellads"] = 505] = "Buysellads";
    IconType[IconType["Connectdevelop"] = 506] = "Connectdevelop";
    IconType[IconType["Dashcube"] = 507] = "Dashcube";
    IconType[IconType["Forumbee"] = 508] = "Forumbee";
    IconType[IconType["Leanpub"] = 509] = "Leanpub";
    IconType[IconType["Sellsy"] = 510] = "Sellsy";
    IconType[IconType["Shirtsinbulk"] = 511] = "Shirtsinbulk";
    IconType[IconType["Simplybuilt"] = 512] = "Simplybuilt";
    IconType[IconType["Skyatlas"] = 513] = "Skyatlas";
    IconType[IconType["Whatsapp"] = 514] = "Whatsapp";
    IconType[IconType["Viacoin"] = 515] = "Viacoin";
    IconType[IconType["Medium"] = 516] = "Medium";
    IconType[IconType["Like"] = 517] = "Like";
    IconType[IconType["Favorite"] = 518] = "Favorite";
    IconType[IconType["Video"] = 519] = "Video";
    IconType[IconType["Check"] = 520] = "Check";
    IconType[IconType["Close"] = 521] = "Close";
    IconType[IconType["Cancel"] = 522] = "Cancel";
    IconType[IconType["Delete"] = 523] = "Delete";
    IconType[IconType["X"] = 524] = "X";
    IconType[IconType["UserTimes"] = 525] = "UserTimes";
    IconType[IconType["UserClose"] = 526] = "UserClose";
    IconType[IconType["UserCancel"] = 527] = "UserCancel";
    IconType[IconType["UserDelete"] = 528] = "UserDelete";
    IconType[IconType["UserX"] = 529] = "UserX";
    IconType[IconType["ZoomIn"] = 530] = "ZoomIn";
    IconType[IconType["Magnify"] = 531] = "Magnify";
    IconType[IconType["Shutdown"] = 532] = "Shutdown";
    IconType[IconType["Clock"] = 533] = "Clock";
    IconType[IconType["Time"] = 534] = "Time";
    IconType[IconType["PlayCircleOutline"] = 535] = "PlayCircleOutline";
    IconType[IconType["Headphone"] = 536] = "Headphone";
    IconType[IconType["Camera"] = 537] = "Camera";
    IconType[IconType["VideoCamera"] = 538] = "VideoCamera";
    IconType[IconType["Picture"] = 539] = "Picture";
    IconType[IconType["Pencil"] = 540] = "Pencil";
    IconType[IconType["Compose"] = 541] = "Compose";
    IconType[IconType["Point"] = 542] = "Point";
    IconType[IconType["Tint"] = 543] = "Tint";
    IconType[IconType["Signup"] = 544] = "Signup";
    IconType[IconType["PlusCircle"] = 545] = "PlusCircle";
    IconType[IconType["Dont"] = 546] = "Dont";
    IconType[IconType["Minimize"] = 547] = "Minimize";
    IconType[IconType["Add"] = 548] = "Add";
    IconType[IconType["Eye"] = 549] = "Eye";
    IconType[IconType["Attention"] = 550] = "Attention";
    IconType[IconType["Cart"] = 551] = "Cart";
    IconType[IconType["Shuffle"] = 552] = "Shuffle";
    IconType[IconType["Talk"] = 553] = "Talk";
    IconType[IconType["Chat"] = 554] = "Chat";
    IconType[IconType["ShoppingCart"] = 555] = "ShoppingCart";
    IconType[IconType["BarGraph"] = 556] = "BarGraph";
    IconType[IconType["AreaGraph"] = 557] = "AreaGraph";
    IconType[IconType["PieGraph"] = 558] = "PieGraph";
    IconType[IconType["LineGraph"] = 559] = "LineGraph";
    IconType[IconType["Key"] = 560] = "Key";
    IconType[IconType["Cogs"] = 561] = "Cogs";
    IconType[IconType["Discussions"] = 562] = "Discussions";
    IconType[IconType["LikeOutline"] = 563] = "LikeOutline";
    IconType[IconType["DislikeOutline"] = 564] = "DislikeOutline";
    IconType[IconType["HeartOutline"] = 565] = "HeartOutline";
    IconType[IconType["LogOut"] = 566] = "LogOut";
    IconType[IconType["ThumbTack"] = 567] = "ThumbTack";
    IconType[IconType["Winner"] = 568] = "Winner";
    IconType[IconType["BookmarkOutline"] = 569] = "BookmarkOutline";
    IconType[IconType["Phone"] = 570] = "Phone";
    IconType[IconType["PhoneSquare"] = 571] = "PhoneSquare";
    IconType[IconType["CreditCard"] = 572] = "CreditCard";
    IconType[IconType["HddOutline"] = 573] = "HddOutline";
    IconType[IconType["Bullhorn"] = 574] = "Bullhorn";
    IconType[IconType["Bell"] = 575] = "Bell";
    IconType[IconType["BellOutline"] = 576] = "BellOutline";
    IconType[IconType["BellSlash"] = 577] = "BellSlash";
    IconType[IconType["BellSlashOutline"] = 578] = "BellSlashOutline";
    IconType[IconType["HandOutlineRight"] = 579] = "HandOutlineRight";
    IconType[IconType["HandOutlineLeft"] = 580] = "HandOutlineLeft";
    IconType[IconType["HandOutlineUp"] = 581] = "HandOutlineUp";
    IconType[IconType["HandOutlineDown"] = 582] = "HandOutlineDown";
    IconType[IconType["Globe"] = 583] = "Globe";
    IconType[IconType["Wrench"] = 584] = "Wrench";
    IconType[IconType["Briefcase"] = 585] = "Briefcase";
    IconType[IconType["Group"] = 586] = "Group";
    IconType[IconType["Flask"] = 587] = "Flask";
    IconType[IconType["Sidebar"] = 588] = "Sidebar";
    IconType[IconType["Bars"] = 589] = "Bars";
    IconType[IconType["ListUl"] = 590] = "ListUl";
    IconType[IconType["ListOl"] = 591] = "ListOl";
    IconType[IconType["NumberedList"] = 592] = "NumberedList";
    IconType[IconType["Magic"] = 593] = "Magic";
    IconType[IconType["Truck"] = 594] = "Truck";
    IconType[IconType["Currency"] = 595] = "Currency";
    IconType[IconType["TriangleDown"] = 596] = "TriangleDown";
    IconType[IconType["Dropdown"] = 597] = "Dropdown";
    IconType[IconType["TriangleUp"] = 598] = "TriangleUp";
    IconType[IconType["TriangleLeft"] = 599] = "TriangleLeft";
    IconType[IconType["TriangleRight"] = 600] = "TriangleRight";
    IconType[IconType["Envelope"] = 601] = "Envelope";
    IconType[IconType["Conversation"] = 602] = "Conversation";
    IconType[IconType["Umbrella"] = 603] = "Umbrella";
    IconType[IconType["Clipboard"] = 604] = "Clipboard";
    IconType[IconType["Lightbulb"] = 605] = "Lightbulb";
    IconType[IconType["Ambulance"] = 606] = "Ambulance";
    IconType[IconType["Medkit"] = 607] = "Medkit";
    IconType[IconType["FighterJet"] = 608] = "FighterJet";
    IconType[IconType["Beer"] = 609] = "Beer";
    IconType[IconType["PlusSquare"] = 610] = "PlusSquare";
    IconType[IconType["Computer"] = 611] = "Computer";
    IconType[IconType["CircleOutline"] = 612] = "CircleOutline";
    IconType[IconType["Intersex"] = 613] = "Intersex";
    IconType[IconType["Asexual"] = 614] = "Asexual";
    IconType[IconType["Spinner"] = 615] = "Spinner";
    IconType[IconType["Gamepad"] = 616] = "Gamepad";
    IconType[IconType["StarHalfFull"] = 617] = "StarHalfFull";
    IconType[IconType["Question"] = 618] = "Question";
    IconType[IconType["Eraser"] = 619] = "Eraser";
    IconType[IconType["Microphone"] = 620] = "Microphone";
    IconType[IconType["MicrophoneSlash"] = 621] = "MicrophoneSlash";
    IconType[IconType["Shield"] = 622] = "Shield";
    IconType[IconType["Target"] = 623] = "Target";
    IconType[IconType["PlayCircle"] = 624] = "PlayCircle";
    IconType[IconType["PencilSquare"] = 625] = "PencilSquare";
    IconType[IconType["Compass"] = 626] = "Compass";
    IconType[IconType["Amex"] = 627] = "Amex";
    IconType[IconType["Eur"] = 628] = "Eur";
    IconType[IconType["Gbp"] = 629] = "Gbp";
    IconType[IconType["Usd"] = 630] = "Usd";
    IconType[IconType["Inr"] = 631] = "Inr";
    IconType[IconType["Cny"] = 632] = "Cny";
    IconType[IconType["Rmb"] = 633] = "Rmb";
    IconType[IconType["Jpy"] = 634] = "Jpy";
    IconType[IconType["Rouble"] = 635] = "Rouble";
    IconType[IconType["Rub"] = 636] = "Rub";
    IconType[IconType["Krw"] = 637] = "Krw";
    IconType[IconType["Btc"] = 638] = "Btc";
    IconType[IconType["Sheqel"] = 639] = "Sheqel";
    IconType[IconType["Ils"] = 640] = "Ils";
    IconType[IconType["Try"] = 641] = "Try";
    IconType[IconType["Zip"] = 642] = "Zip";
    IconType[IconType["DotCircleOutline"] = 643] = "DotCircleOutline";
    IconType[IconType["Sliders"] = 644] = "Sliders";
    IconType[IconType["Wi"] = 645] = "Wi";
    IconType[IconType["Graduation"] = 646] = "Graduation";
    IconType[IconType["Weixin"] = 647] = "Weixin";
    IconType[IconType["Binoculars"] = 648] = "Binoculars";
    IconType[IconType["Gratipay"] = 649] = "Gratipay";
    IconType[IconType["Genderless"] = 650] = "Genderless";
    IconType[IconType["Teletype"] = 651] = "Teletype";
    IconType[IconType["PowerCord"] = 652] = "PowerCord";
    IconType[IconType["Tty"] = 653] = "Tty";
    IconType[IconType["Cc"] = 654] = "Cc";
    IconType[IconType["PlusCart"] = 655] = "PlusCart";
    IconType[IconType["ArrowDownCart"] = 656] = "ArrowDownCart";
    IconType[IconType["Detective"] = 657] = "Detective";
    IconType[IconType["Venus"] = 658] = "Venus";
    IconType[IconType["Mars"] = 659] = "Mars";
    IconType[IconType["Mercury"] = 660] = "Mercury";
    IconType[IconType["VenusDouble"] = 661] = "VenusDouble";
    IconType[IconType["FemaleHomosexual"] = 662] = "FemaleHomosexual";
    IconType[IconType["MarsDouble"] = 663] = "MarsDouble";
    IconType[IconType["MaleHomosexual"] = 664] = "MaleHomosexual";
    IconType[IconType["VenusMars"] = 665] = "VenusMars";
    IconType[IconType["MarsStroke"] = 666] = "MarsStroke";
    IconType[IconType["MarsAlternate"] = 667] = "MarsAlternate";
    IconType[IconType["MarsVertical"] = 668] = "MarsVertical";
    IconType[IconType["MarsHorizontal"] = 669] = "MarsHorizontal";
    IconType[IconType["MarsStrokeVertical"] = 670] = "MarsStrokeVertical";
    IconType[IconType["MarsStrokeHorizontal"] = 671] = "MarsStrokeHorizontal";
    IconType[IconType["FacebookOfficial"] = 672] = "FacebookOfficial";
    IconType[IconType["PinterestOfficial"] = 673] = "PinterestOfficial";
    IconType[IconType["Bed"] = 674] = "Bed";
})(IconType = exports.IconType || (exports.IconType = {}));


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(188));
__export(__webpack_require__(196));
__export(__webpack_require__(207));
__export(__webpack_require__(211));
__export(__webpack_require__(4));
__export(__webpack_require__(3));


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Checkbox;
(function (Checkbox) {
    /**
    * Creates a checkbox element on the page.
    * Accepts the following properties in props$:
    *   readonly?: boolean - Styles the checkbox to appear read-only.
    *   checked?: boolean - Styles the checkbox to appear checked.
    *   disabled?: boolean - Styles the checkbox to appear disabled.
    *   fitted?: boolean - Styles the checkbox for tight fits with nearby content.
    *   radio?: string - Styles the checkbox to appear like a radio button belonging to the group.
    *   toggle?: boolean - Styles the checkbox to appear like a toggle.
    * Expects the following type of content in content$: DOMContent
    * @param {ComponentSources} sources The default component sources.
    */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var evt = function (type) { return sources.DOM.select("input").events(type); };
            var clicked$ = evt("click");
            var props$ = sources.props$.remember();
            var checked$ = props$.map(function (props) {
                return clicked$.fold(function (acc, evt) { return evt.srcElement.checked; }, props.checked ? true : false);
            }).flatten().remember();
            // const renderProps$ =  xs.combine(props$, checked$).map(
            //   ([props, checked]) => Object.assign({}, props, {checked})
            // );
            var vTree$ = xstream_1.default.combine(props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: evt,
                value$: checked$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Checkbox.run = run;
    /**
    * Creates a checkbox element on the page.
    * Accepts the following properties in props$:
    *   readonly?: boolean - Styles the checkbox to appear read-only.
    *   checked?: boolean - Styles the checkbox to appear checked.
    *   disabled?: boolean - Styles the checkbox to appear disabled.
    *   fitted?: boolean - Styles the checkbox for tight fits with nearby content.
    *   radio?: string - Styles the checkbox to appear like a radio button belonging to the group.
    *   toggle?: boolean - Styles the checkbox to appear like a toggle.
    * Expects the following type of content in content$: DOMContent
    * @param {ComponentSources} sources The default component sources.
    */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassName(props) } }, [
            dom_1.input({ props: {
                    type: props.radio ? "radio" : "checkbox",
                    name: props.name,
                    checked: props.checked,
                    disabled: props.readonly || props.disabled
                } }),
            dom_1.label({ props: { for: props.name } }, props.fitted ? "" : content)
        ]);
    }
    Checkbox.render = render;
    function getClassName(props) {
        var className = "ui";
        if (props.readonly) {
            className += " read-only";
        }
        if (props.checked) {
            className += " checked";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.radio) {
            className += " radio";
        }
        if (props.toggle) {
            className += " toggle";
        }
        return className + " checkbox";
    }
})(Checkbox = exports.Checkbox || (exports.Checkbox = {}));


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var dropRepeats_1 = __webpack_require__(63);
var debounce_1 = __webpack_require__(61);
var concat_1 = __webpack_require__(213);
var isolate_1 = __webpack_require__(2);
var delay_1 = __webpack_require__(62);
var dom_1 = __webpack_require__(1);
var menu_1 = __webpack_require__(59);
var icon_1 = __webpack_require__(22);
var transition_1 = __webpack_require__(13);
var Dropdown;
(function (Dropdown) {
    /**
     * A dropdown component for capturing user input.
     * Accepts the following properties in props$:
     *  active?: boolean,
     *  initial?: any
     *  default?: string
     *  selection?: boolean
     *  inline?: boolean
     *  floating?: boolean
     *  loading?: boolean
     *  disabled?: boolean
     *  scrolling?: boolean
     *  search?: boolean
     *  compact?: boolean
     *  size?: Size
     *  color?: Color
     * Expects the following type of content in content$: Array of {
     *  body: DOMContent,
     *  value: any,
     *  header?: boolean,
     *  fitted?: boolean,
     *  disabled?: boolean,
     *  active?: boolean
     * }
     */
    function run(sources) {
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".dropdown").events(type); };
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var props$ = sources.props$.remember();
            var itemClick$proxy = xstream_1.default.create();
            var value$proxy = xstream_1.default.create();
            var dropdownClick$ = evt("click")
                .filter(function (evt) { return !evt.srcElement.classList.contains("item"); })
                .mapTo(enums_1.Direction.In);
            var mouseleave$ = xstream_1.default.merge(evt("mouseleave").filter(function (evt) { return evt.srcElement.className.indexOf("icon") === -1; }), evt("mouseenter"))
                .map(function (evt) { return evt.type === "mouseenter" ? enums_1.Direction.In : enums_1.Direction.Out; })
                .compose(debounce_1.default(250))
                .filter(function (dir) { return dir === enums_1.Direction.Out; });
            var transition$ = xstream_1.default.merge(dropdownClick$, itemClick$proxy, mouseleave$)
                .startWith(enums_1.Direction.Out)
                .map(function (dir) { return ({
                animation: enums_1.Animation.Fade,
                direction: dir
            }); })
                .compose(dropRepeats_1.default(function (a, b) { return a.direction === b.direction
                && a.animation === b.animation; }))
                .drop(1)
                .startWith({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var filter$ = sources.DOM.select("input").events("keyup")
                .map(function (ev) { return ev.target.value; })
                .startWith("");
            var filteredContent$ = xstream_1.default.combine(sources.content$, filter$).map(function (_a) {
                var content = _a[0], filter = _a[1];
                return content.filter(function (c) { return filterContent(c, filter); });
            }).remember();
            var content$ = xstream_1.default.combine(filteredContent$, value$proxy).map(function (_a) {
                var content = _a[0], value = _a[1];
                return content.map(function (item) { return item.value === value ? Object.assign({}, item, { active: true }) : item; });
            }).remember();
            var menu = menu_1.Menu.run({ DOM: sources.DOM, content$: content$ });
            var transitionedMenu = transition_1.Transition.run({ DOM: sources.DOM, target$: menu.DOM, args$: transition$ });
            var itemClick$ = evt("click").filter(function (x) { return x.target.classList.contains("item"); }).remember();
            itemClick$proxy.imitate(itemClick$.mapTo(enums_1.Direction.Out));
            var clickedId$ = itemClick$
                .map(function (ev) { return parseInt(ev.target.id); })
                .filter(function (n) { return !isNaN(n) && typeof (n) !== "undefined"; });
            var emittedValue$ = clickedId$.map(function (id) { return filteredContent$.map(function (items) { return items[id].value; }).take(1); }).flatten().remember();
            var initialValue$ = props$.map(function (props) { return props.initial; }).remember();
            value$proxy.imitate(xstream_1.default.merge(initialValue$, emittedValue$));
            var icon = icon_1.Icon.render({}, enums_1.IconType.Dropdown);
            var active$ = xstream_1.default.merge(transition$.filter(function (x) { return x.direction === enums_1.Direction.In; }).mapTo(true), transition$.filter(function (x) { return x.direction === enums_1.Direction.Out; }).compose(delay_1.default(250)).mapTo(false));
            var streams = xstream_1.default.combine(props$, active$, transitionedMenu.DOM, content$.map(function (content) { return content.filter(function (item) { return item.active; })[0]; }));
            var vtree$ = streams.map(function (_a) {
                var props = _a[0], active = _a[1], menu = _a[2], item = _a[3];
                return dom_1.div({ props: { className: getClassName(props, active) } }, [
                    getText(item, props),
                    props.search ? dom_1.input({ props: { className: "search" } }) : "",
                    icon, menu
                ]);
            }).remember();
            //Todo find cleaner way to clear input using snabbdom hooks?
            emittedValue$.map(function (_) { return vtree$.take(1); }).flatten().addListener(new ExecuteListener(function (vnode) {
                function clear() {
                    if (typeof (vnode.elm) !== "undefined") {
                        var elm = vnode.elm.getElementsByTagName("input");
                        if (elm[0] && elm[0].value !== "") {
                            {
                                console.log("Sending next");
                            }
                            elm[0].value = "";
                            filter$.shamefullySendNext("");
                        }
                    }
                    else {
                        setTimeout(clear, 100);
                    }
                }
                clear();
            }));
            return {
                DOM: vtree$,
                Events: evt,
                value$: concat_1.default(initialValue$, emittedValue$)
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Dropdown.run = run;
    /**
     * A dropdown component for capturing user input.
     * Accepts the following properties:
     *  active?: boolean,
     *  initial?: any
     *  default?: string
     *  selection?: boolean
     *  inline?: boolean
     *  floating?: boolean
     *  loading?: boolean
     *  disabled?: boolean
     *  scrolling?: boolean
     *  search?: boolean
     *  compact?: boolean
     *  size?: Size
     *  color?: Color
     * Expects the following type of content: Array of {
     *  body: DOMContent,
     *  value: any,
     *  header?: boolean,
     *  fitted?: boolean,
     *  disabled?: boolean,
     *  active?: boolean
     * }
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        var icon = icon_1.Icon.render({}, enums_1.IconType.Dropdown);
        var menu = menu_1.Menu.render({}, content);
        var item = content.filter(function (item) { return item.active; })[0];
        return dom_1.div({ props: { className: getClassName(props) } }, [
            getText(item, props),
            props.search ? dom_1.input({ props: { className: "search" } }) : "",
            icon, menu
        ]);
    }
    Dropdown.render = render;
    function getClassName(props, active) {
        var className = "ui";
        if (props.rightAligned) {
            className += " right";
        }
        if (props.selection) {
            className += " selection";
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.floating) {
            className += " floating";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.scrolling) {
            className += " scrolling";
        }
        if (props.search) {
            className += " search";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (active || props.active) {
            className += " active";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        return className + " dropdown";
    }
    function getText(item, props) {
        if (typeof (props.static) !== "undefined") {
            return dom_1.div({ props: { className: "text" } }, props.static);
        }
        if (item === null) {
            return dom_1.div({ props: { className: "default text" } }, props.default);
        }
        return dom_1.div({ props: { className: "text" } }, item.body);
    }
    function filterContent(item, filter) {
        function f(node) {
            if (node.text) {
                return node.text.indexOf(filter) !== -1 || !filter;
            }
            else {
                for (var c in node.children) {
                    if (f(c)) {
                        return true;
                    }
                }
                return false;
            }
        }
        if (typeof (item.body === "string")) {
            return item.body.indexOf(filter) !== -1 || !filter;
        }
        if (!item.body.push) {
            return f(item.body);
        }
        for (var c in item.body.children) {
            if (f(c)) {
                return true;
            }
        }
        return false;
    }
    var ExecuteListener = (function () {
        function ExecuteListener(f) {
            this.f = f;
        }
        ExecuteListener.prototype.next = function (i) { this.f(i); };
        ExecuteListener.prototype.error = function (i) { };
        ExecuteListener.prototype.complete = function () { };
        return ExecuteListener;
    }());
})(Dropdown = exports.Dropdown || (exports.Dropdown = {}));


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(205));
__export(__webpack_require__(36));
__export(__webpack_require__(206));
__export(__webpack_require__(208));
__export(__webpack_require__(209));
__export(__webpack_require__(210));
__export(__webpack_require__(13));


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var enums_1 = __webpack_require__(3);
var dimmer_1 = __webpack_require__(36);
var icon_1 = __webpack_require__(22);
var transition_1 = __webpack_require__(13);
var Modal;
(function (Modal) {
    /**
     * A modal component for displaying content in a modal.
     * Accepts the following type of properties in props$:
     *   header: String - The header text for the component.
     *   on$: Stream<Boolean> - When to display the modal.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ on$: xstream_1.default.of(false) });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.actions$ = sources.actions$ ? sources.actions$ : xstream_1.default.of("");
            sources.target$ = sources.target$ ? sources.target$ : xstream_1.default.of("page");
            var closeIcon = icon_1.Icon.run({ DOM: sources.DOM, props$: xstream_1.default.of({ link: true }), content$: xstream_1.default.of(enums_1.IconType.Close) });
            var close$ = closeIcon.Events("click").mapTo(false);
            /*** Render modal ***/
            var dimmerclick$proxy = xstream_1.default.create();
            var on$ = xstream_1.default.merge(sources.on$, dimmerclick$proxy, close$).remember();
            var content$ = xstream_1.default.combine(sources.props$, sources.content$, sources.actions$, closeIcon.DOM).map(function (_a) {
                var props = _a[0], content = _a[1], actions = _a[2], icon = _a[3];
                return dom_1.div({ props: { className: "ui scrolling active modal" } }, [
                    icon,
                    dom_1.div({ props: { className: "header" } }, props.header),
                    dom_1.div({ props: { className: "content" } }, content),
                    actions ? dom_1.div({ props: { className: "actions" } }, actions) : ""
                ]);
            }).remember();
            /*** Animation ***/
            var transition$ = on$
                .fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? ({ animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out })
                : {
                    animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out
                }; }, ({ animation: enums_1.Animation.None, direction: enums_1.Direction.None }));
            var animatedContent = transition_1.Transition.run({ DOM: sources.DOM, target$: content$, args$: transition$ });
            /*** Activate dimmer ***/
            var dimmerContent$ = animatedContent.DOM.map(function (x) { return [x]; });
            var dimmer = dimmer_1.Dimmer.run({ DOM: sources.DOM, target$: sources.target$, args$: on$, content$: dimmerContent$ }, sources.props$.map(function (x) { return x.inverted; }));
            var dimmerclick$ = dimmer.Events("mousedown")
                .filter(function (evt) { return evt.srcElement === evt.currentTarget; })
                .mapTo(false);
            dimmerclick$proxy.imitate(dimmerclick$);
            var fadeOutEnd$ = on$.map(function (active) { return !active ? dimmer.Events("animationend") : xstream_1.default.never(); }).flatten().mapTo(false);
            // const active$ = xs.merge(sources.on$, fadeOutEnd$).remember();
            return {
                active$: xstream_1.default.merge(sources.on$, fadeOutEnd$),
                DOM: dimmer.DOM,
                Events: animatedContent.Events
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Modal.run = run;
})(Modal = exports.Modal || (exports.Modal = {}));


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var transition_1 = __webpack_require__(13);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var debounce_1 = __webpack_require__(61);
var dropRepeats_1 = __webpack_require__(63);
var delay_1 = __webpack_require__(62);
var Popup;
(function (Popup) {
    function run(sources) {
        function main(sources) {
            sources.args$ = sources.args$ ? sources.args$ : xstream_1.default.of({ active: false, attachment: PopupAttachment.BottomLeft });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var args$ = sources.args$.remember();
            var vTree$ = xstream_1.default.combine(args$, sources.content$).map(function (_a) {
                var args = _a[0], content = _a[1];
                return render(args, content);
            });
            var mouseleave$proxy = xstream_1.default.create();
            var mouseenter$proxy = xstream_1.default.create();
            var active$ = args$.map(function (arg) { return arg.active ? enums_1.Direction.In : enums_1.Direction.Out; }).drop(1);
            var timer$ = active$.map(function (dir) { return dir === enums_1.Direction.Out ? xstream_1.default.of(enums_1.Direction.Out)
                : xstream_1.default.of(enums_1.Direction.Out).compose(delay_1.default(1000)).endWhen(mouseenter$proxy); }).flatten();
            var transition$ = xstream_1.default.merge(active$, mouseleave$proxy, timer$)
                .map(function (dir) { return ({
                animation: enums_1.Animation.Fade,
                direction: dir
            }); })
                .compose(dropRepeats_1.default(function (a, b) { return a.direction === b.direction
                && a.animation === b.animation; }))
                .startWith({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var animatedPopup = transition_1.Transition.run({ DOM: sources.DOM, target$: vTree$, args$: transition$ });
            var mouseenter$ = animatedPopup.Events("mouseenter");
            var mouseleave$ = xstream_1.default.merge(animatedPopup.Events("mouseleave"), mouseenter$)
                .map(function (evt) { return evt.type === "mouseenter" ? enums_1.Direction.In : enums_1.Direction.Out; })
                .compose(debounce_1.default(200))
                .filter(function (dir) { return dir === enums_1.Direction.Out; });
            mouseleave$proxy.imitate(mouseleave$);
            mouseenter$proxy.imitate(mouseenter$);
            var popup$ = animatedPopup.DOM.remember();
            return {
                DOM: popup$,
                Events: animatedPopup.Events,
                tether: xstream_1.default.combine(popup$, sources.target$, args$)
                    .map(function (_a) {
                    var element = _a[0], target = _a[1], args = _a[2];
                    return ({ element: element, target: target, args: args });
                })
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Popup.run = run;
    function render(args, content) {
        if (args === void 0) { args = { active: true, attachment: PopupAttachment.BottomLeft }; }
        if (content === void 0) { content = ""; }
        return dom_1.div({ props: { className: getClassname(args) } }, [
            args.header ? dom_1.div({ props: { className: "header" } }, args.header) : "",
            content
        ]);
    }
    Popup.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.wide) {
            className += " wide";
        }
        if (props.veryWide) {
            className += " very wide";
        }
        if (props.flowing) {
            className += " flowing";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += PopupAttachment.ToClassname(props.attachment) + " popup";
        return className;
    }
    var PopupAttachment;
    (function (PopupAttachment) {
        PopupAttachment[PopupAttachment["TopLeft"] = 0] = "TopLeft";
        PopupAttachment[PopupAttachment["TopMiddle"] = 1] = "TopMiddle";
        PopupAttachment[PopupAttachment["TopRight"] = 2] = "TopRight";
        PopupAttachment[PopupAttachment["LeftCenter"] = 3] = "LeftCenter";
        PopupAttachment[PopupAttachment["RightCenter"] = 4] = "RightCenter";
        PopupAttachment[PopupAttachment["BottomLeft"] = 5] = "BottomLeft";
        PopupAttachment[PopupAttachment["BottomMiddle"] = 6] = "BottomMiddle";
        PopupAttachment[PopupAttachment["BottomRight"] = 7] = "BottomRight";
        PopupAttachment[PopupAttachment["Center"] = 8] = "Center";
    })(PopupAttachment = Popup.PopupAttachment || (Popup.PopupAttachment = {}));
    (function (PopupAttachment) {
        function ToClassname(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return " top left";
                case PopupAttachment.TopMiddle: return " top center";
                case PopupAttachment.TopRight: return " top right";
                case PopupAttachment.LeftCenter: return " left center";
                case PopupAttachment.RightCenter: return " right center";
                case PopupAttachment.BottomLeft: return " bottom left";
                case PopupAttachment.BottomMiddle: return " bottom center";
                case PopupAttachment.BottomRight: return " bottom right";
                case PopupAttachment.Center: return " center";
                default: return " bottom left";
            }
        }
        PopupAttachment.ToClassname = ToClassname;
        function ToTether(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return "top left";
                case PopupAttachment.TopMiddle: return "top center";
                case PopupAttachment.TopRight: return "top right";
                case PopupAttachment.LeftCenter: return "left middle";
                case PopupAttachment.RightCenter: return "right middle";
                case PopupAttachment.BottomLeft: return "bottom left";
                case PopupAttachment.BottomMiddle: return "bottom center";
                case PopupAttachment.BottomRight: return "bottom right";
                case PopupAttachment.Center: return "center";
                default: return "bottom left";
            }
        }
        PopupAttachment.ToTether = ToTether;
        function ToOppositeTether(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return "bottom right";
                case PopupAttachment.TopMiddle: return "bottom center";
                case PopupAttachment.TopRight: return "bottom left";
                case PopupAttachment.LeftCenter: return "right middle";
                case PopupAttachment.RightCenter: return "left middle";
                case PopupAttachment.BottomLeft: return "top right";
                case PopupAttachment.BottomMiddle: return "top center";
                case PopupAttachment.BottomRight: return "top left";
                case PopupAttachment.Center: return "center";
                default: return "bottom left";
            }
        }
        PopupAttachment.ToOppositeTether = ToOppositeTether;
    })(PopupAttachment = Popup.PopupAttachment || (Popup.PopupAttachment = {}));
})(Popup = exports.Popup || (exports.Popup = {}));


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var ProgressBar;
(function (ProgressBar) {
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties in props$:
     *   progress: number - The % of progress the progress bar should reflect.
     *   active?: boolean - Styles the progress bar to reflect activitiy.
     *   disabled?: boolean - Styles the progress bar to appear disabled.
     *   inverted?: boolean - Styles the progress bar for dark backgrounds.
     *   attachment?: Attachment - Where the progress bar should be attached to.
     *   size?: Size - The size of the progress bar.
     *   color?: Color - The color of the progress bar.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ progress: 0 });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".progress").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    ProgressBar.run = run;
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following propertiea:
     *   progress: number - The % of progress the progress bar should reflect.
     *   active?: boolean - Styles the progress bar to reflect activitiy.
     *   disabled?: boolean - Styles the progress bar to appear disabled.
     *   inverted?: boolean - Styles the progress bar for dark backgrounds.
     *   attachment?: Attachment - Where the progress bar should be attached to.
     *   size?: Size - The size of the progress bar.
     *   color?: Color - The color of the progress bar.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = { progress: 0 }; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? { progress: 0 } : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            dom_1.div({ props: { className: "bar" } }, { style: { width: props.progress + "%" } }, [
                dom_1.div({ props: { className: "progress" } }, [props.progress + "%"])
            ]),
            dom_1.div({ props: { className: "label" } }, content)
        ]);
    }
    ProgressBar.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.active) {
            className += " active";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " progress";
        return className;
    }
})(ProgressBar = exports.ProgressBar || (exports.ProgressBar = {}));


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(212));


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Statistic;
(function (Statistic) {
    /**
     * A statistic component to show statistics.
     * Accepts the following properties in props$:
     *   horizontal?: boolean - Styles the statistic to display horizontally.
     *   inverted?: boolean - Styles the statistic for a dark background.
     *   color?: Color - The color of the statistic.
     *   size?: Size - The size of the statistic.
     *   float?: Float - Where to float the statistic.
     * Expects the following type of content in content$: {} of
     *   value: String|VNode - The value for the statistic.
     *   label: String|VNode - The label for the statistic.
     *   isText?: boolean - Formats the statistic value for text based values.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".statistic").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Statistic.run = run;
    /**
     * A statistic component to show statistics.
     * Accepts the following properties:
     *   horizontal?: boolean - Styles the statistic to display horizontally.
     *   inverted?: boolean - Styles the statistic for a dark background.
     *   color?: Color - The color of the statistic.
     *   size?: Size - The size of the statistic.
     *   float?: Float - Where to float the statistic.
     * Expects the following type of content: {} of
     *   value: String|VNode - The value for the statistic.
     *   label: String|VNode - The label for the statistic.
     *   isText?: boolean - Formats the statistic value for text based values.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var label = interfaces_1.isDOMContent(pOrC) ? c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            dom_1.div({ props: { className: props.text ? "text value" : "value" } }, content),
            dom_1.div({ props: { className: "label" } }, label)
        ]);
    }
    Statistic.render = render;
    function getClassname(props) {
        var className = "ui ";
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        className += " statistic";
        return className;
    }
})(Statistic = exports.Statistic || (exports.Statistic = {}));


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var ConcatProducer = (function () {
    function ConcatProducer(streams) {
        this.streams = streams;
        this.type = 'concat';
        this.out = null;
        this.i = 0;
    }
    ConcatProducer.prototype._start = function (out) {
        this.out = out;
        this.streams[this.i]._add(this);
    };
    ConcatProducer.prototype._stop = function () {
        var streams = this.streams;
        if (this.i < streams.length) {
            streams[this.i]._remove(this);
        }
        this.i = 0;
        this.out = null;
    };
    ConcatProducer.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        u._n(t);
    };
    ConcatProducer.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    ConcatProducer.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        var streams = this.streams;
        streams[this.i]._remove(this);
        if (++this.i < streams.length) {
            streams[this.i]._add(this);
        }
        else {
            u._c();
        }
    };
    return ConcatProducer;
}());
/**
 * Puts one stream after the other. *concat* is a factory that takes multiple
 * streams as arguments, and starts the `n+1`-th stream only when the `n`-th
 * stream has completed. It concatenates those streams together.
 *
 * Marble diagram:
 *
 * ```text
 * --1--2---3---4-|
 * ...............--a-b-c--d-|
 *           concat
 * --1--2---3---4---a-b-c--d-|
 * ```
 *
 * Example:
 *
 * ```js
 * import concat from 'xstream/extra/concat'
 *
 * const streamA = xs.of('a', 'b', 'c')
 * const streamB = xs.of(10, 20, 30)
 * const streamC = xs.of('X', 'Y', 'Z')
 *
 * const outputStream = concat(streamA, streamB, streamC)
 *
 * outputStream.addListener({
 *   next: (x) => console.log(x),
 *   error: (err) => console.error(err),
 *   complete: () => console.log('concat completed'),
 * })
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to concatenate together with other streams.
 * @param {Stream} stream2 A stream to concatenate together with other streams. Two
 * or more streams may be given as arguments.
 * @return {Stream}
 */
function concat() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new index_1.Stream(new ConcatProducer(streams));
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var FCIL = (function () {
    function FCIL(out, op) {
        this.out = out;
        this.op = op;
    }
    FCIL.prototype._n = function (t) {
        this.out._n(t);
    };
    FCIL.prototype._e = function (err) {
        this.out._e(err);
    };
    FCIL.prototype._c = function () {
        this.op.less();
    };
    return FCIL;
}());
var FlattenConcOperator = (function () {
    function FlattenConcOperator(ins) {
        this.ins = ins;
        this.type = 'flattenConcurrently';
        this.active = 1; // number of outers and inners that have not yet ended
        this.out = null;
    }
    FlattenConcOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    FlattenConcOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.active = 1;
        this.out = null;
    };
    FlattenConcOperator.prototype.less = function () {
        if (--this.active === 0) {
            var u = this.out;
            if (!u)
                return;
            u._c();
        }
    };
    FlattenConcOperator.prototype._n = function (s) {
        var u = this.out;
        if (!u)
            return;
        this.active++;
        s._add(new FCIL(u, this));
    };
    FlattenConcOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    FlattenConcOperator.prototype._c = function () {
        this.less();
    };
    return FlattenConcOperator;
}());
exports.FlattenConcOperator = FlattenConcOperator;
/**
 * Flattens a "stream of streams", handling multiple concurrent nested streams
 * simultaneously.
 *
 * If the input stream is a stream that emits streams, then this operator will
 * return an output stream which is a flat stream: emits regular events. The
 * flattening happens concurrently. It works like this: when the input stream
 * emits a nested stream, *flattenConcurrently* will start imitating that
 * nested one. When the next nested stream is emitted on the input stream,
 * *flattenConcurrently* will also imitate that new one, but will continue to
 * imitate the previous nested streams as well.
 *
 * Marble diagram:
 *
 * ```text
 * --+--------+---------------
 *   \        \
 *    \       ----1----2---3--
 *    --a--b----c----d--------
 *     flattenConcurrently
 * -----a--b----c-1--d-2---3--
 * ```
 *
 * @return {Stream}
 */
function flattenConcurrently(ins) {
    return new index_1.Stream(new FlattenConcOperator(ins));
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = flattenConcurrently;
//# sourceMappingURL=flattenConcurrently.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(65);
module.exports = __webpack_require__(64);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgY2M4ODNlMjE5YmM0ZTEzZWQ0YWYiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaXNvbGF0ZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmZhY2VzL2luZGV4LnRzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL3hzdHJlYW0tYWRhcHRlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3RyYW5zaXRpb24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9pcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvaWNvbi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2Zyb21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2h5cGVyc2NyaXB0LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy9pcy1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9Ccm93c2VyUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fcm9vdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21hdGNoZXMtc2VsZWN0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS92bm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9kaW1tZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL1Njb3BlQ2hlY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL3RyYW5zcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaGlzdG9yeS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaGlzdG9yeS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXItc3BsaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L2FycmF5LyMvY2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2dldG5hdGl2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5lc2NhcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guZm9yb3duL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmlzYXJndW1lbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tc2VsZWN0b3IvbGliL3NlbGVjdG9yUGFyc2VyLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tdG8taHRtbC9saWIvcGFyc2Utc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvdWkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL21lbnUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3hzdHJlYW0vZXh0cmEvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2V4dHJhL2RlbGF5LmpzIiwid2VicGFjazovLy8uL34veHN0cmVhbS9leHRyYS9kcm9wUmVwZWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9kb2NzLmxlc3MiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvYXBwLnRzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvQm9keURPTVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL0RvY3VtZW50RE9NU291cmNlLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvRWxlbWVudEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL0V2ZW50RGVsZWdhdG9yLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvSFRNTFNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL01haW5ET01Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9WTm9kZVdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9oeXBlcnNjcmlwdC1oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvaXNvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2lzb2xhdGVNb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9tYWtlRE9NRHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvbWFrZUhUTUxEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9tb2NrRE9NU291cmNlLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvbW9kdWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi9jYXB0dXJlQ2xpY2tzLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2hpc3RvcnkvbGliL21ha2VIaXN0b3J5RHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2hpc3RvcnkvbGliL3NlcnZlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUveHN0cmVhbS1ydW4vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL3hzdHJlYW0tcnVuL34vQGN5Y2xlL2Jhc2UvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvUm91dGVyU291cmNlLmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jeWNsaWMtcm91dGVyL2xpYi9tYWtlUm91dGVyRHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2QvYXV0by1iaW5kLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L21hdGgvc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvbWF0aC9zaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9tYXRoL3NpZ24vc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvbnVtYmVyL3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L251bWJlci90by1wb3MtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L19pdGVyYXRlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9jb3B5LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvbWFwLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9wcmltaXRpdmUtc2V0LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci9mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtaXRlcmF0b3IvZ2V0LmpzIiwid2VicGFjazovLy8uL34vZXM2LWl0ZXJhdG9yL2lzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vZXM2LWl0ZXJhdG9yL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtbWFwL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvbGliL2l0ZXJhdG9yLWtpbmRzLmpzIiwid2VicGFjazovLy8uL34vZXM2LW1hcC9saWIvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtbWFwL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL34vZXM2LXN5bWJvbC9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvaXMtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vZXM2LXN5bWJvbC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9IYXNoUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9SZWZyZXNoUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VCZWZvcmVVbmxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9iYXNlZmxhdHRlbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fYmFzZWZvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fYmFzZWluZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2Jhc2V1bmlxL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9iaW5kY2FsbGJhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2NhY2hlaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fY3JlYXRlY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guZGVidXJyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmtlYmFiY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLnJlc3RwYXJhbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC51bmlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC53b3Jkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9jbGFzc05hbWVGcm9tVk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9jb250YWluZXItZWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL2luaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL3N0eWxlLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tdG8taHRtbC9saWIvdm9pZC1lbGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9odG1sZG9tYXBpLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9tb2R1bGVzL2hlcm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9tb2R1bGVzL3Byb3BzLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL3NuYWJiZG9tLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vdGh1bmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N3aXRjaC1wYXRoL2xpYi9lczIwMTUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zd2l0Y2gtcGF0aC9saWIvZXMyMDE1L3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9pbmRleC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9sYXlvdXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvbGF5b3V0L3NpZGViYXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvcm91dGVyLnRzIiwid2VicGFjazovLy8uL2RvY3Mtc3JjL3JvdXRlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvYnJlYWRjcnVtYi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9maWVsZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9maWVsZHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL2Zvcm0vZm9ybS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9jb2x1bW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL2dyaWQvZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9yb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9tZXNzYWdlL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy90YWJsZS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvYnV0dG9uL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9jb250YWluZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2RpdmlkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2hlYWRlci9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvaW1hZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9sYWJlbC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvbGlzdC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvbG9hZGVyL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9zZWdtZW50L2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9zdGVwL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy90ZXh0Ym94L2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbnVtcy9pY29uVHlwZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvY2hlY2tib3gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZHJvcGRvd24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvbW9kYWwvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvcG9wdXAvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvcHJvZ3Jlc3MvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9zdGF0aXN0aWMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2V4dHJhL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3hzdHJlYW0vZXh0cmEvZmxhdHRlbkNvbmN1cnJlbnRseS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsV0FBVyxFQUFFO0FBQ2pELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHlCQUF5QixFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7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QTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxvQzs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0M7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsK0M7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUM7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvRUFBb0U7QUFDcEUsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUM7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDLEVBQUU7QUFDdEU7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0IsRUFBRTtBQUM3RSx3Q0FBd0MsbUVBQW1FLEVBQUU7QUFDN0c7QUFDQSxrQ0FBa0Msb0JBQW9CLEVBQUUsc0JBQXNCLEVBQUUseUJBQXlCLEVBQUUsRUFBRTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxtQzs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNQQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsMEJBQTBCLGtDQUFrQyxFQUFFO0FBQzlELENBQUM7Ozs7Ozs7O0FDN0JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDBCQUEwQixtQ0FBbUMsRUFBRTtBQUMvRCxDQUFDOzs7Ozs7OztBQ3BDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixZQUFZLE9BQU87QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNyTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjs7Ozs7Ozs7QUMxTUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7OztBQ3ZD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SSxRQUFRLENBQUM7UUFDeEIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLFNBQVMsSUFBSSxhQUFhLENBQUM7UUFDN0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLFNBQVMsSUFBSSxVQUFVLENBQUM7UUFDMUIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLFNBQVMsSUFBSSxTQUFTLENBQUM7UUFDekIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLFNBQVMsSUFBSSxRQUFRLENBQUM7UUFDeEIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ3BCLFNBQVMsSUFBSSxhQUFhLENBQUM7UUFDN0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLFNBQVMsSUFBSSxhQUFhLENBQUM7UUFDN0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLFNBQVMsSUFBSSxTQUFTLENBQUM7UUFDekIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLFNBQVMsSUFBSSxjQUFjLENBQUM7UUFDOUIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLFNBQVMsSUFBSSxVQUFVLENBQUM7UUFDMUIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLFNBQVMsSUFBSSxlQUFlLENBQUM7UUFDL0IsQ0FBQztRQUNELEVB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SSxVQUFVLENBQUM7UUFDMUIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLFNBQVMsSUFBSSxnQkFBZ0IsQ0FBQztRQUNoQyxDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDZixTQUFTLElBQUksT0FBTyxDQUFDO1FBQ3ZCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNoQixTQUFTLElBQUksUUFBUSxDQUFDO1FBQ3hCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuQixTQUFTLElBQUksV0FBVyxDQUFDO1FBQzNCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNqQixTQUFTLElBQUksU0FBUyxDQUFDO1FBQ3pCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuQixTQUFTLElBQUksV0FBVyxDQUFDO1FBQzNCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNsQixTQUFTLElBQUksVUFBVSxDQUFDO1FBQzFCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNsQixTQUFTLElBQUksVUFBVSxDQUFDO1FBQzFCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuQixTQUFTLElBQUksV0FBVyxDQUFDO1FBQzNCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNoQixTQUFTLElBQUksUUFBUSxDQUFDO1FBQ3hCLENBQUM7UUFDRCxF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLCtDIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMTUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGNjODgzZTIxOWJjNGUxM2VkNGFmIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBzeW1ib2xfb2JzZXJ2YWJsZV8xID0gcmVxdWlyZShcInN5bWJvbC1vYnNlcnZhYmxlXCIpO1xudmFyIE5PID0ge307XG5leHBvcnRzLk5PID0gTk87XG5mdW5jdGlvbiBub29wKCkgeyB9XG5mdW5jdGlvbiBjcChhKSB7XG4gICAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgICB2YXIgYiA9IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKVxuICAgICAgICBiW2ldID0gYVtpXTtcbiAgICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIGFuZChmMSwgZjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5kRm4odCkge1xuICAgICAgICByZXR1cm4gZjEodCkgJiYgZjIodCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF90cnkoYywgdCwgdSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjLmYodCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHUuX2UoZSk7XG4gICAgICAgIHJldHVybiBOTztcbiAgICB9XG59XG52YXIgTk9fSUwgPSB7XG4gICAgX246IG5vb3AsXG4gICAgX2U6IG5vb3AsXG4gICAgX2M6IG5vb3AsXG59O1xuZXhwb3J0cy5OT19JTCA9IE5PX0lMO1xuLy8gbXV0YXRlcyB0aGUgaW5wdXRcbmZ1bmN0aW9uIGludGVybmFsaXplUHJvZHVjZXIocHJvZHVjZXIpIHtcbiAgICBwcm9kdWNlci5fc3RhcnQgPSBmdW5jdGlvbiBfc3RhcnQoaWwpIHtcbiAgICAgICAgaWwubmV4dCA9IGlsLl9uO1xuICAgICAgICBpbC5lcnJvciA9IGlsLl9lO1xuICAgICAgICBpbC5jb21wbGV0ZSA9IGlsLl9jO1xuICAgICAgICB0aGlzLnN0YXJ0KGlsKTtcbiAgICB9O1xuICAgIHByb2R1Y2VyLl9zdG9wID0gcHJvZHVjZXIuc3RvcDtcbn1cbnZhciBTdHJlYW1TdWIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmVhbVN1Yihfc3RyZWFtLCBfbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtID0gX3N0cmVhbTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBfbGlzdGVuZXI7XG4gICAgfVxuICAgIFN0cmVhbVN1Yi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9saXN0ZW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gU3RyZWFtU3ViO1xufSgpKTtcbnZhciBPYnNlcnZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXIoX2xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gX2xpc3RlbmVyO1xuICAgIH1cbiAgICBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lci5fbih2YWx1ZSk7XG4gICAgfTtcbiAgICBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyLl9lKGVycik7XG4gICAgfTtcbiAgICBPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyLl9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZXI7XG59KCkpO1xudmFyIEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm9tT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmcm9tT2JzZXJ2YWJsZSc7XG4gICAgICAgIHRoaXMuaW5zID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgRnJvbU9ic2VydmFibGUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3ViID0gdGhpcy5pbnMuc3Vic2NyaWJlKG5ldyBPYnNlcnZlcihvdXQpKTtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHRoaXMuX3N1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgRnJvbU9ic2VydmFibGUucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc3ViKVxuICAgICAgICAgICAgdGhpcy5fc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbU9ic2VydmFibGU7XG59KCkpO1xudmFyIE1lcmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZShpbnNBcnIpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ21lcmdlJztcbiAgICAgICAgdGhpcy5pbnNBcnIgPSBpbnNBcnI7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuYWMgPSAwO1xuICAgIH1cbiAgICBNZXJnZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluc0FycjtcbiAgICAgICAgdmFyIEwgPSBzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hYyA9IEw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTDsgaSsrKVxuICAgICAgICAgICAgc1tpXS5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTWVyZ2UucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuaW5zQXJyO1xuICAgICAgICB2YXIgTCA9IHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgIHNbaV0uX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBNZXJnZS5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgtLXRoaXMuYWMgPD0gMCkge1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZTtcbn0oKSk7XG52YXIgQ29tYmluZUxpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21iaW5lTGlzdGVuZXIoaSwgb3V0LCBwKSB7XG4gICAgICAgIHRoaXMuaSA9IGk7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICBwLmlscy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBDb21iaW5lTGlzdGVuZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnAsIG91dCA9IHRoaXMub3V0O1xuICAgICAgICBpZiAob3V0ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHAudXAodCwgdGhpcy5pKSlcbiAgICAgICAgICAgIG91dC5fbihwLnZhbHMpO1xuICAgIH07XG4gICAgQ29tYmluZUxpc3RlbmVyLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMub3V0O1xuICAgICAgICBpZiAob3V0ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0Ll9lKGVycik7XG4gICAgfTtcbiAgICBDb21iaW5lTGlzdGVuZXIucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMucDtcbiAgICAgICAgaWYgKHAub3V0ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKC0tcC5OYyA9PT0gMClcbiAgICAgICAgICAgIHAub3V0Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tYmluZUxpc3RlbmVyO1xufSgpKTtcbnZhciBDb21iaW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21iaW5lKGluc0Fycikge1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29tYmluZSc7XG4gICAgICAgIHRoaXMuaW5zQXJyID0gaW5zQXJyO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmlscyA9IFtdO1xuICAgICAgICB0aGlzLk5jID0gdGhpcy5ObiA9IDA7XG4gICAgICAgIHRoaXMudmFscyA9IFtdO1xuICAgIH1cbiAgICBDb21iaW5lLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy52YWxzW2ldO1xuICAgICAgICB2YXIgTm4gPSAhdGhpcy5ObiA/IDAgOiB2ID09PSBOTyA/IC0tdGhpcy5ObiA6IHRoaXMuTm47XG4gICAgICAgIHRoaXMudmFsc1tpXSA9IHQ7XG4gICAgICAgIHJldHVybiBObiA9PT0gMDtcbiAgICB9O1xuICAgIENvbWJpbmUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbnNBcnI7XG4gICAgICAgIHZhciBuID0gdGhpcy5OYyA9IHRoaXMuTm4gPSBzLmxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHMgPSB0aGlzLnZhbHMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICBvdXQuX24oW10pO1xuICAgICAgICAgICAgb3V0Ll9jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHNbaV0gPSBOTztcbiAgICAgICAgICAgICAgICBzW2ldLl9hZGQobmV3IENvbWJpbmVMaXN0ZW5lcihpLCBvdXQsIHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbnNBcnI7XG4gICAgICAgIHZhciBuID0gcy5sZW5ndGg7XG4gICAgICAgIHZhciBpbHMgPSB0aGlzLmlscztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBzW2ldLl9yZW1vdmUoaWxzW2ldKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5pbHMgPSBbXTtcbiAgICAgICAgdGhpcy52YWxzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gQ29tYmluZTtcbn0oKSk7XG52YXIgRnJvbUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm9tQXJyYXkoYSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnJvbUFycmF5JztcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICB9XG4gICAgRnJvbUFycmF5LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGEubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgb3V0Ll9uKGFbaV0pO1xuICAgICAgICBvdXQuX2MoKTtcbiAgICB9O1xuICAgIEZyb21BcnJheS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbUFycmF5O1xufSgpKTtcbnZhciBGcm9tUHJvbWlzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJvbVByb21pc2UocCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnJvbVByb21pc2UnO1xuICAgICAgICB0aGlzLm9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgfVxuICAgIEZyb21Qcm9taXNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHZhciBwcm9kID0gdGhpcztcbiAgICAgICAgdGhpcy5vbiA9IHRydWU7XG4gICAgICAgIHRoaXMucC50aGVuKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAocHJvZC5vbikge1xuICAgICAgICAgICAgICAgIG91dC5fbih2KTtcbiAgICAgICAgICAgICAgICBvdXQuX2MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG91dC5fZShlKTtcbiAgICAgICAgfSkudGhlbihub29wLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGcm9tUHJvbWlzZS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub24gPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tUHJvbWlzZTtcbn0oKSk7XG52YXIgUGVyaW9kaWMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlcmlvZGljKHBlcmlvZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAncGVyaW9kaWMnO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElEID0gLTE7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgfVxuICAgIFBlcmlvZGljLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJ2YWxIYW5kbGVyKCkgeyBvdXQuX24oc2VsZi5pKyspOyB9XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGludGVydmFsSGFuZGxlciwgdGhpcy5wZXJpb2QpO1xuICAgIH07XG4gICAgUGVyaW9kaWMucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElEICE9PSAtMSlcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElEKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElEID0gLTE7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gUGVyaW9kaWM7XG59KCkpO1xudmFyIERlYnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJ1ZyhpbnMsIGFyZykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVidWcnO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5zID0gbm9vcDtcbiAgICAgICAgdGhpcy5sID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRoaXMubCA9IGFyZztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRoaXMucyA9IGFyZztcbiAgICB9XG4gICAgRGVidWcucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBEZWJ1Zy5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICBEZWJ1Zy5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzID0gdGhpcy5zLCBsID0gdGhpcy5sO1xuICAgICAgICBpZiAocyAhPT0gbm9vcCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB1Ll9lKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhsICsgJzonLCB0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29uc29sZS5sb2codCk7XG4gICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBEZWJ1Zy5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRGVidWcucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJ1Zztcbn0oKSk7XG52YXIgRHJvcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcChtYXgsIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZHJvcCc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5kcm9wcGVkID0gMDtcbiAgICB9XG4gICAgRHJvcC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5kcm9wcGVkID0gMDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIERyb3AucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgRHJvcC5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRyb3BwZWQrKyA+PSB0aGlzLm1heClcbiAgICAgICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBEcm9wLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBEcm9wLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcDtcbn0oKSk7XG52YXIgRW5kV2hlbkxpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmRXaGVuTGlzdGVuZXIob3V0LCBvcCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICBFbmRXaGVuTGlzdGVuZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wLmVuZCgpO1xuICAgIH07XG4gICAgRW5kV2hlbkxpc3RlbmVyLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5vdXQuX2UoZXJyKTtcbiAgICB9O1xuICAgIEVuZFdoZW5MaXN0ZW5lci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3AuZW5kKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5kV2hlbkxpc3RlbmVyO1xufSgpKTtcbnZhciBFbmRXaGVuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmRXaGVuKG8sIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZW5kV2hlbic7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm8gPSBvO1xuICAgICAgICB0aGlzLm9pbCA9IE5PX0lMO1xuICAgIH1cbiAgICBFbmRXaGVuLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm8uX2FkZCh0aGlzLm9pbCA9IG5ldyBFbmRXaGVuTGlzdGVuZXIob3V0LCB0aGlzKSk7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBFbmRXaGVuLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vLl9yZW1vdmUodGhpcy5vaWwpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm9pbCA9IE5PX0lMO1xuICAgIH07XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIEVuZFdoZW4ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9uKHQpO1xuICAgIH07XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5kV2hlbjtcbn0oKSk7XG52YXIgRmlsdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXIocGFzc2VzLCBpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZpbHRlcic7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmYgPSBwYXNzZXM7XG4gICAgfVxuICAgIEZpbHRlci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIEZpbHRlci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgciA9IF90cnkodGhpcywgdCwgdSk7XG4gICAgICAgIGlmIChyID09PSBOTyB8fCAhcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIEZpbHRlci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRmlsdGVyLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyO1xufSgpKTtcbnZhciBGbGF0dGVuTGlzdGVuZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZsYXR0ZW5MaXN0ZW5lcihvdXQsIG9wKSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIEZsYXR0ZW5MaXN0ZW5lci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLm91dC5fbih0KTtcbiAgICB9O1xuICAgIEZsYXR0ZW5MaXN0ZW5lci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMub3V0Ll9lKGVycik7XG4gICAgfTtcbiAgICBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wLmlubmVyID0gTk87XG4gICAgICAgIHRoaXMub3AubGVzcygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZsYXR0ZW5MaXN0ZW5lcjtcbn0oKSk7XG52YXIgRmxhdHRlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxhdHRlbihpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZsYXR0ZW4nO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgfVxuICAgIEZsYXR0ZW4ucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRmxhdHRlbi5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlubmVyICE9PSBOTylcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuX3JlbW92ZSh0aGlzLmlsKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgfTtcbiAgICBGbGF0dGVuLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5vcGVuICYmIHRoaXMuaW5uZXIgPT09IE5PKVxuICAgICAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgRmxhdHRlbi5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGlubmVyID0gX2EuaW5uZXIsIGlsID0gX2EuaWw7XG4gICAgICAgIGlmIChpbm5lciAhPT0gTk8gJiYgaWwgIT09IE5PX0lMKVxuICAgICAgICAgICAgaW5uZXIuX3JlbW92ZShpbCk7XG4gICAgICAgICh0aGlzLmlubmVyID0gcykuX2FkZCh0aGlzLmlsID0gbmV3IEZsYXR0ZW5MaXN0ZW5lcih1LCB0aGlzKSk7XG4gICAgfTtcbiAgICBGbGF0dGVuLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBGbGF0dGVuLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVzcygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZsYXR0ZW47XG59KCkpO1xudmFyIEZvbGQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvbGQoZiwgc2VlZCwgaW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmb2xkJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuZiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmKF90aGlzLmFjYywgdCk7IH07XG4gICAgICAgIHRoaXMuYWNjID0gdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgRm9sZC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5hY2MgPSB0aGlzLnNlZWQ7XG4gICAgICAgIG91dC5fbih0aGlzLmFjYyk7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5hY2MgPSB0aGlzLnNlZWQ7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHIgPSBfdHJ5KHRoaXMsIHQsIHUpO1xuICAgICAgICBpZiAociA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX24odGhpcy5hY2MgPSByKTtcbiAgICB9O1xuICAgIEZvbGQucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIEZvbGQucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBGb2xkO1xufSgpKTtcbnZhciBMYXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXN0KGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnbGFzdCc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmhhcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbCA9IE5PO1xuICAgIH1cbiAgICBMYXN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmhhcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTGFzdC5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMudmFsID0gTk87XG4gICAgfTtcbiAgICBMYXN0LnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuaGFzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWwgPSB0O1xuICAgIH07XG4gICAgTGFzdC5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgTGFzdC5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuaGFzKSB7XG4gICAgICAgICAgICB1Ll9uKHRoaXMudmFsKTtcbiAgICAgICAgICAgIHUuX2MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1Ll9lKG5ldyBFcnJvcignbGFzdCgpIGZhaWxlZCBiZWNhdXNlIGlucHV0IHN0cmVhbSBjb21wbGV0ZWQnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGFzdDtcbn0oKSk7XG52YXIgTWFwRmxhdHRlbkxpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBGbGF0dGVuTGlzdGVuZXIob3V0LCBvcCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICBNYXBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdGhpcy5vdXQuX24ocik7XG4gICAgfTtcbiAgICBNYXBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLm91dC5fZShlcnIpO1xuICAgIH07XG4gICAgTWFwRmxhdHRlbkxpc3RlbmVyLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcC5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLm9wLmxlc3MoKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBGbGF0dGVuTGlzdGVuZXI7XG59KCkpO1xudmFyIE1hcEZsYXR0ZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcEZsYXR0ZW4obWFwT3ApIHtcbiAgICAgICAgdGhpcy50eXBlID0gbWFwT3AudHlwZSArIFwiK2ZsYXR0ZW5cIjtcbiAgICAgICAgdGhpcy5pbnMgPSBtYXBPcC5pbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMubWFwT3AgPSBtYXBPcDtcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgfVxuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcE9wLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTWFwRmxhdHRlbi5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwT3AuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlubmVyICE9PSBOTylcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuX3JlbW92ZSh0aGlzLmlsKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgfTtcbiAgICBNYXBGbGF0dGVuLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMub3BlbiAmJiB0aGlzLmlubmVyID09PSBOTykge1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBpbm5lciA9IF9hLmlubmVyLCBpbCA9IF9hLmlsO1xuICAgICAgICB2YXIgcyA9IF90cnkodGhpcy5tYXBPcCwgdiwgdSk7XG4gICAgICAgIGlmIChzID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGlubmVyICE9PSBOTyAmJiBpbCAhPT0gTk9fSUwpXG4gICAgICAgICAgICBpbm5lci5fcmVtb3ZlKGlsKTtcbiAgICAgICAgKHRoaXMuaW5uZXIgPSBzKS5fYWRkKHRoaXMuaWwgPSBuZXcgTWFwRmxhdHRlbkxpc3RlbmVyKHUsIHRoaXMpKTtcbiAgICB9O1xuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZXNzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwRmxhdHRlbjtcbn0oKSk7XG52YXIgTWFwT3AgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcE9wKHByb2plY3QsIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnbWFwJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuZiA9IHByb2plY3Q7XG4gICAgfVxuICAgIE1hcE9wLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTWFwT3AucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgTWFwT3AucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgciA9IF90cnkodGhpcywgdCwgdSk7XG4gICAgICAgIGlmIChyID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbihyKTtcbiAgICB9O1xuICAgIE1hcE9wLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBNYXBPcC5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wO1xufSgpKTtcbnZhciBGaWx0ZXJNYXBGdXNpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXJNYXBGdXNpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyTWFwRnVzaW9uKHBhc3NlcywgcHJvamVjdCwgaW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb2plY3QsIGlucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdmaWx0ZXIrbWFwJztcbiAgICAgICAgX3RoaXMucGFzc2VzID0gcGFzc2VzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpbHRlck1hcEZ1c2lvbi5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAoIXRoaXMucGFzc2VzKHQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByID0gX3RyeSh0aGlzLCB0LCB1KTtcbiAgICAgICAgaWYgKHIgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9uKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlck1hcEZ1c2lvbjtcbn0oTWFwT3ApKTtcbnZhciBSZW1lbWJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVtZW1iZXIoaW5zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdyZW1lbWJlcic7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH1cbiAgICBSZW1lbWJlci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZChvdXQpO1xuICAgIH07XG4gICAgUmVtZW1iZXIucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMub3V0KTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIHJldHVybiBSZW1lbWJlcjtcbn0oKSk7XG52YXIgUmVwbGFjZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBsYWNlRXJyb3IocmVwbGFjZXIsIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVwbGFjZUVycm9yJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuZiA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICBSZXBsYWNlRXJyb3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBSZXBsYWNlRXJyb3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgUmVwbGFjZUVycm9yLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIFJlcGxhY2VFcnJvci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAodGhpcy5pbnMgPSB0aGlzLmYoZXJyKSkuX2FkZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdS5fZShlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwbGFjZUVycm9yLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwbGFjZUVycm9yO1xufSgpKTtcbnZhciBTdGFydFdpdGggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXJ0V2l0aChpbnMsIHZhbCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhcnRXaXRoJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgIH1cbiAgICBTdGFydFdpdGgucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3V0Ll9uKHRoaXMudmFsKTtcbiAgICAgICAgdGhpcy5pbnMuX2FkZChvdXQpO1xuICAgIH07XG4gICAgU3RhcnRXaXRoLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzLm91dCk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICByZXR1cm4gU3RhcnRXaXRoO1xufSgpKTtcbnZhciBUYWtlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlKG1heCwgaW5zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0YWtlJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB0aGlzLnRha2VuID0gMDtcbiAgICB9XG4gICAgVGFrZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy50YWtlbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1heCA8PSAwKVxuICAgICAgICAgICAgb3V0Ll9jKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBUYWtlLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIFRha2UucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbSA9ICsrdGhpcy50YWtlbjtcbiAgICAgICAgaWYgKG0gPCB0aGlzLm1heClcbiAgICAgICAgICAgIHUuX24odCk7XG4gICAgICAgIGVsc2UgaWYgKG0gPT09IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB1Ll9uKHQpO1xuICAgICAgICAgICAgdS5fYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWtlLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBUYWtlLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZTtcbn0oKSk7XG52YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJlYW0ocHJvZHVjZXIpIHtcbiAgICAgICAgdGhpcy5fcHJvZCA9IHByb2R1Y2VyIHx8IE5PO1xuICAgICAgICB0aGlzLl9pbHMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RvcElEID0gTk87XG4gICAgICAgIHRoaXMuX2RsID0gTk87XG4gICAgICAgIHRoaXMuX2QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gTk87XG4gICAgICAgIHRoaXMuX2VyciA9IE5PO1xuICAgIH1cbiAgICBTdHJlYW0ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9pbHM7XG4gICAgICAgIHZhciBMID0gYS5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9kKVxuICAgICAgICAgICAgdGhpcy5fZGwuX24odCk7XG4gICAgICAgIGlmIChMID09IDEpXG4gICAgICAgICAgICBhWzBdLl9uKHQpO1xuICAgICAgICBlbHNlIGlmIChMID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGIgPSBjcChhKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTDsgaSsrKVxuICAgICAgICAgICAgICAgIGJbaV0uX24odCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnIgIT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lcnIgPSBlcnI7XG4gICAgICAgIHZhciBhID0gdGhpcy5faWxzO1xuICAgICAgICB2YXIgTCA9IGEubGVuZ3RoO1xuICAgICAgICB0aGlzLl94KCk7XG4gICAgICAgIGlmICh0aGlzLl9kKVxuICAgICAgICAgICAgdGhpcy5fZGwuX2UoZXJyKTtcbiAgICAgICAgaWYgKEwgPT0gMSlcbiAgICAgICAgICAgIGFbMF0uX2UoZXJyKTtcbiAgICAgICAgZWxzZSBpZiAoTCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiID0gY3AoYSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgICAgICBiW2ldLl9lKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kICYmIEwgPT0gMClcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2VycjtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5faWxzO1xuICAgICAgICB2YXIgTCA9IGEubGVuZ3RoO1xuICAgICAgICB0aGlzLl94KCk7XG4gICAgICAgIGlmICh0aGlzLl9kKVxuICAgICAgICAgICAgdGhpcy5fZGwuX2MoKTtcbiAgICAgICAgaWYgKEwgPT0gMSlcbiAgICAgICAgICAgIGFbMF0uX2MoKTtcbiAgICAgICAgZWxzZSBpZiAoTCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiID0gY3AoYSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgICAgICBiW2ldLl9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fcHJvZCAhPT0gTk8pXG4gICAgICAgICAgICB0aGlzLl9wcm9kLl9zdG9wKCk7XG4gICAgICAgIHRoaXMuX2VyciA9IE5PO1xuICAgICAgICB0aGlzLl9pbHMgPSBbXTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX3N0b3BOb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdBUk5JTkc6IGNvZGUgdGhhdCBjYWxscyB0aGlzIG1ldGhvZCBzaG91bGRcbiAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgdGhpcy5fcHJvZCBpcyB2YWxpZCAobm90IGBOT2ApXG4gICAgICAgIHRoaXMuX3Byb2QuX3N0b3AoKTtcbiAgICAgICAgdGhpcy5fZXJyID0gTk87XG4gICAgICAgIHRoaXMuX3N0b3BJRCA9IE5PO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24gKGlsKSB7XG4gICAgICAgIHZhciB0YSA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgaWYgKHRhICE9PSBOTylcbiAgICAgICAgICAgIHJldHVybiB0YS5fYWRkKGlsKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9pbHM7XG4gICAgICAgIGEucHVzaChpbCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9zdG9wSUQgIT09IE5PKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcElEKTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BJRCA9IE5PO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9kO1xuICAgICAgICAgICAgaWYgKHAgIT09IE5PKVxuICAgICAgICAgICAgICAgIHAuX3N0YXJ0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAoaWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRhID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgICBpZiAodGEgIT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuIHRhLl9yZW1vdmUoaWwpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuX2lscztcbiAgICAgICAgdmFyIGkgPSBhLmluZGV4T2YoaWwpO1xuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9kICE9PSBOTyAmJiBhLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyID0gTk87XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc3RvcE5vdygpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJ1bmVDeWNsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgYWxsIHBhdGhzIHN0ZW1taW5nIGZyb20gYHRoaXNgIHN0cmVhbSBldmVudHVhbGx5IGVuZCBhdCBgdGhpc2BcbiAgICAvLyBzdHJlYW0sIHRoZW4gd2UgcmVtb3ZlIHRoZSBzaW5nbGUgbGlzdGVuZXIgb2YgYHRoaXNgIHN0cmVhbSwgdG9cbiAgICAvLyBmb3JjZSBpdCB0byBlbmQgaXRzIGV4ZWN1dGlvbiBhbmQgZGlzcG9zZSByZXNvdXJjZXMuIFRoaXMgbWV0aG9kXG4gICAgLy8gYXNzdW1lcyBhcyBhIHByZWNvbmRpdGlvbiB0aGF0IHRoaXMuX2lscyBoYXMganVzdCBvbmUgbGlzdGVuZXIuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5fcHJ1bmVDeWNsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNOb1NpbmtzKHRoaXMsIFtdKSlcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZSh0aGlzLl9pbHNbMF0pO1xuICAgIH07XG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgKnRoZXJlIGlzIG5vKiBwYXRoIHN0YXJ0aW5nIGZyb20gYHhgIHRoYXQgbGVhZHMgdG8gYW4gZW5kXG4gICAgLy8gbGlzdGVuZXIgKHNpbmspIGluIHRoZSBzdHJlYW0gZ3JhcGgsIGZvbGxvd2luZyBlZGdlcyBBLT5CIHdoZXJlIEIgaXMgYVxuICAgIC8vIGxpc3RlbmVyIG9mIEEuIFRoaXMgbWVhbnMgdGhlc2UgcGF0aHMgY29uc3RpdHV0ZSBhIGN5Y2xlIHNvbWVob3cuIElzIGdpdmVuXG4gICAgLy8gYSB0cmFjZSBvZiBhbGwgdmlzaXRlZCBub2RlcyBzbyBmYXIuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5faGFzTm9TaW5rcyA9IGZ1bmN0aW9uICh4LCB0cmFjZSkge1xuICAgICAgICBpZiAodHJhY2UuaW5kZXhPZih4KSAhPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoeC5vdXQgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoeC5vdXQgJiYgeC5vdXQgIT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc05vU2lua3MoeC5vdXQsIHRyYWNlLmNvbmNhdCh4KSk7XG4gICAgICAgIGVsc2UgaWYgKHguX2lscykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIE4gPSB4Ll9pbHMubGVuZ3RoOyBpIDwgTjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzTm9TaW5rcyh4Ll9pbHNbaV0sIHRyYWNlLmNvbmNhdCh4KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBNZW1vcnlTdHJlYW0gPyBNZW1vcnlTdHJlYW0gOiBTdHJlYW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgTGlzdGVuZXIgdG8gdGhlIFN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGlzdGVuZXJ9IGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lci5fbiA9IGxpc3RlbmVyLm5leHQgfHwgbm9vcDtcbiAgICAgICAgbGlzdGVuZXIuX2UgPSBsaXN0ZW5lci5lcnJvciB8fCBub29wO1xuICAgICAgICBsaXN0ZW5lci5fYyA9IGxpc3RlbmVyLmNvbXBsZXRlIHx8IG5vb3A7XG4gICAgICAgIHRoaXMuX2FkZChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgTGlzdGVuZXIgZnJvbSB0aGUgU3RyZWFtLCBhc3N1bWluZyB0aGUgTGlzdGVuZXIgd2FzIGFkZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMaXN0ZW5lcjxUPn0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgTGlzdGVuZXIgdG8gdGhlIFN0cmVhbSByZXR1cm5pbmcgYSBTdWJzY3JpcHRpb24gdG8gcmVtb3ZlIHRoYXRcbiAgICAgKiBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGlzdGVuZXJ9IGxpc3RlbmVyXG4gICAgICogQHJldHVybnMge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1TdWIodGhpcywgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGludGVyb3AgYmV0d2VlbiBtb3N0LmpzIGFuZCBSeEpTIDVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZVtzeW1ib2xfb2JzZXJ2YWJsZV8xLmRlZmF1bHRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RyZWFtIGdpdmVuIGEgUHJvZHVjZXIuXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtQcm9kdWNlcn0gcHJvZHVjZXIgQW4gb3B0aW9uYWwgUHJvZHVjZXIgdGhhdCBkaWN0YXRlcyBob3cgdG9cbiAgICAgKiBzdGFydCwgZ2VuZXJhdGUgZXZlbnRzLCBhbmQgc3RvcCB0aGUgU3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uY3JlYXRlID0gZnVuY3Rpb24gKHByb2R1Y2VyKSB7XG4gICAgICAgIGlmIChwcm9kdWNlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9kdWNlci5zdGFydCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgIHx8IHR5cGVvZiBwcm9kdWNlci5zdG9wICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZHVjZXIgcmVxdWlyZXMgYm90aCBzdGFydCBhbmQgc3RvcCBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIGludGVybmFsaXplUHJvZHVjZXIocHJvZHVjZXIpOyAvLyBtdXRhdGVzIHRoZSBpbnB1dFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKHByb2R1Y2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVtb3J5U3RyZWFtIGdpdmVuIGEgUHJvZHVjZXIuXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtQcm9kdWNlcn0gcHJvZHVjZXIgQW4gb3B0aW9uYWwgUHJvZHVjZXIgdGhhdCBkaWN0YXRlcyBob3cgdG9cbiAgICAgKiBzdGFydCwgZ2VuZXJhdGUgZXZlbnRzLCBhbmQgc3RvcCB0aGUgU3RyZWFtLlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uY3JlYXRlV2l0aE1lbW9yeSA9IGZ1bmN0aW9uIChwcm9kdWNlcikge1xuICAgICAgICBpZiAocHJvZHVjZXIpXG4gICAgICAgICAgICBpbnRlcm5hbGl6ZVByb2R1Y2VyKHByb2R1Y2VyKTsgLy8gbXV0YXRlcyB0aGUgaW5wdXRcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0ocHJvZHVjZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyB3aGVuIHN0YXJ0ZWQuIEl0IG5ldmVyIGVtaXRzIGFueSBldmVudC5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqICAgICAgICAgIG5ldmVyXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLm5ldmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbSh7IF9zdGFydDogbm9vcCwgX3N0b3A6IG5vb3AgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgZW1pdHMgdGhlIFwiY29tcGxldGVcIiBub3RpZmljYXRpb24gd2hlblxuICAgICAqIHN0YXJ0ZWQsIGFuZCB0aGF0J3MgaXQuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiBlbXB0eVxuICAgICAqIC18XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oe1xuICAgICAgICAgICAgX3N0YXJ0OiBmdW5jdGlvbiAoaWwpIHsgaWwuX2MoKTsgfSxcbiAgICAgICAgICAgIF9zdG9wOiBub29wLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTdHJlYW0gdGhhdCBpbW1lZGlhdGVseSBlbWl0cyBhbiBcImVycm9yXCIgbm90aWZpY2F0aW9uIHdpdGggdGhlXG4gICAgICogdmFsdWUgeW91IHBhc3NlZCBhcyB0aGUgYGVycm9yYCBhcmd1bWVudCB3aGVuIHRoZSBzdHJlYW0gc3RhcnRzLCBhbmQgdGhhdCdzXG4gICAgICogaXQuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiB0aHJvdyhYKVxuICAgICAqIC1YXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIGVycm9yIFRoZSBlcnJvciBldmVudCB0byBlbWl0IG9uIHRoZSBjcmVhdGVkIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKHtcbiAgICAgICAgICAgIF9zdGFydDogZnVuY3Rpb24gKGlsKSB7IGlsLl9lKGVycm9yKTsgfSxcbiAgICAgICAgICAgIF9zdG9wOiBub29wLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdHJlYW0gZnJvbSBhbiBBcnJheSwgUHJvbWlzZSwgb3IgYW4gT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fFByb21pc2V8T2JzZXJ2YWJsZX0gaW5wdXQgVGhlIGlucHV0IHRvIG1ha2UgYSBzdHJlYW0gZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLmZyb20gPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFtzeW1ib2xfb2JzZXJ2YWJsZV8xLmRlZmF1bHRdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tT2JzZXJ2YWJsZShpbnB1dCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tUHJvbWlzZShpbnB1dCk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tQXJyYXkoaW5wdXQpO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZSBvZiBpbnB1dCB0byBmcm9tKCkgbXVzdCBiZSBhbiBBcnJheSwgUHJvbWlzZSwgb3IgT2JzZXJ2YWJsZVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTdHJlYW0gdGhhdCBpbW1lZGlhdGVseSBlbWl0cyB0aGUgYXJndW1lbnRzIHRoYXQgeW91IGdpdmUgdG9cbiAgICAgKiAqb2YqLCB0aGVuIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIG9mKDEsMiwzKVxuICAgICAqIDEyM3xcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgeW91IHdhbnQgdG8gZW1pdCBhcyBhbiBldmVudCBvbiB0aGUgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgeW91IHdhbnQgdG8gZW1pdCBhcyBhbiBldmVudCBvbiB0aGUgc3RyZWFtLiBPbmVcbiAgICAgKiBvciBtb3JlIG9mIHRoZXNlIHZhbHVlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyZWFtLmZyb21BcnJheShpdGVtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBhcnJheSB0byBhIHN0cmVhbS4gVGhlIHJldHVybmVkIHN0cmVhbSB3aWxsIGVtaXQgc3luY2hyb25vdXNseVxuICAgICAqIGFsbCB0aGUgaXRlbXMgaW4gdGhlIGFycmF5LCBhbmQgdGhlbiBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIGZyb21BcnJheShbMSwyLDNdKVxuICAgICAqIDEyM3xcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgY29udmVydGVkIGFzIGEgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBGcm9tQXJyYXkoYXJyYXkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcHJvbWlzZSB0byBhIHN0cmVhbS4gVGhlIHJldHVybmVkIHN0cmVhbSB3aWxsIGVtaXQgdGhlIHJlc29sdmVkXG4gICAgICogdmFsdWUgb2YgdGhlIHByb21pc2UsIGFuZCB0aGVuIGNvbXBsZXRlLiBIb3dldmVyLCBpZiB0aGUgcHJvbWlzZSBpc1xuICAgICAqIHJlamVjdGVkLCB0aGUgc3RyZWFtIHdpbGwgZW1pdCB0aGUgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIGZyb21Qcm9taXNlKCAtLS0tNDIgKVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tNDJ8XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIFRoZSBwcm9taXNlIHRvIGJlIGNvbnZlcnRlZCBhcyBhIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IEZyb21Qcm9taXNlKHByb21pc2UpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIE9ic2VydmFibGUgaW50byBhIFN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0ge2FueX0gb2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSB0byBiZSBjb252ZXJ0ZWQgYXMgYSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5mcm9tT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYnMpIHtcbiAgICAgICAgaWYgKG9icy5lbmRXaGVuKVxuICAgICAgICAgICAgcmV0dXJuIG9icztcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IEZyb21PYnNlcnZhYmxlKG9icykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmVhbSB0aGF0IHBlcmlvZGljYWxseSBlbWl0cyBpbmNyZW1lbnRhbCBudW1iZXJzLCBldmVyeVxuICAgICAqIGBwZXJpb2RgIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqICAgICBwZXJpb2RpYygxMDAwKVxuICAgICAqIC0tLTAtLS0xLS0tMi0tLTMtLS00LS0tLi4uXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZCBUaGUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIHVzZSBhcyBhIHJhdGUgb2ZcbiAgICAgKiBlbWlzc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnBlcmlvZGljID0gZnVuY3Rpb24gKHBlcmlvZCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgUGVyaW9kaWMocGVyaW9kKSk7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9tYXAgPSBmdW5jdGlvbiAocHJvamVjdCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuX3Byb2Q7XG4gICAgICAgIHZhciBjdG9yID0gdGhpcy5jdG9yKCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgRmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKG5ldyBGaWx0ZXJNYXBGdXNpb24ocC5mLCBwcm9qZWN0LCBwLmlucykpO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IobmV3IE1hcE9wKHByb2plY3QsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZWFjaCBldmVudCBmcm9tIHRoZSBpbnB1dCBTdHJlYW0gdGhyb3VnaCBhIGBwcm9qZWN0YCBmdW5jdGlvbixcbiAgICAgKiB0byBnZXQgYSBTdHJlYW0gdGhhdCBlbWl0cyB0aG9zZSB0cmFuc2Zvcm1lZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0zLS01LS0tLS03LS0tLS0tXG4gICAgICogICAgbWFwKGkgPT4gaSAqIDEwKVxuICAgICAqIC0tMTAtLTMwLTUwLS0tLTcwLS0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2plY3QgQSBmdW5jdGlvbiBvZiB0eXBlIGAodDogVCkgPT4gVWAgdGhhdCB0YWtlcyBldmVudFxuICAgICAqIGB0YCBvZiB0eXBlIGBUYCBmcm9tIHRoZSBpbnB1dCBTdHJlYW0gYW5kIHByb2R1Y2VzIGFuIGV2ZW50IG9mIHR5cGUgYFVgLCB0b1xuICAgICAqIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBTdHJlYW0uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcChwcm9qZWN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0J3MgbGlrZSBgbWFwYCwgYnV0IHRyYW5zZm9ybXMgZWFjaCBpbnB1dCBldmVudCB0byBhbHdheXMgdGhlIHNhbWVcbiAgICAgKiBjb25zdGFudCB2YWx1ZSBvbiB0aGUgb3V0cHV0IFN0cmVhbS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tMS0tLTMtLTUtLS0tLTctLS0tLVxuICAgICAqICAgICAgIG1hcFRvKDEwKVxuICAgICAqIC0tMTAtLTEwLTEwLS0tLTEwLS0tLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHByb2plY3RlZFZhbHVlIEEgdmFsdWUgdG8gZW1pdCBvbiB0aGUgb3V0cHV0IFN0cmVhbSB3aGVuZXZlciB0aGVcbiAgICAgKiBpbnB1dCBTdHJlYW0gZW1pdHMgYW55IHZhbHVlLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLm1hcFRvID0gZnVuY3Rpb24gKHByb2plY3RlZFZhbHVlKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvamVjdGVkVmFsdWU7IH0pO1xuICAgICAgICB2YXIgb3AgPSBzLl9wcm9kO1xuICAgICAgICBvcC50eXBlID0gb3AudHlwZS5yZXBsYWNlKCdtYXAnLCAnbWFwVG8nKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmx5IGFsbG93cyBldmVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGdpdmVuIGJ5IHRoZSBgcGFzc2VzYCBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEVhY2ggZXZlbnQgZnJvbSB0aGUgaW5wdXQgc3RyZWFtIGlzIGdpdmVuIHRvIHRoZSBgcGFzc2VzYCBmdW5jdGlvbi4gSWYgdGhlXG4gICAgICogZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAsIHRoZSBldmVudCBpcyBmb3J3YXJkZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0sXG4gICAgICogb3RoZXJ3aXNlIGl0IGlzIGlnbm9yZWQgYW5kIG5vdCBmb3J3YXJkZWQuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0yLS0zLS0tLS00LS0tLS01LS0tNi0tNy04LS1cbiAgICAgKiAgICAgZmlsdGVyKGkgPT4gaSAlIDIgPT09IDApXG4gICAgICogLS0tLS0tMi0tLS0tLS0tNC0tLS0tLS0tLTYtLS0tOC0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXNzZXMgQSBmdW5jdGlvbiBvZiB0eXBlIGAodDogVCkgKz4gYm9vbGVhbmAgdGhhdCB0YWtlc1xuICAgICAqIGFuIGV2ZW50IGZyb20gdGhlIGlucHV0IHN0cmVhbSBhbmQgY2hlY2tzIGlmIGl0IHBhc3NlcywgYnkgcmV0dXJuaW5nIGFcbiAgICAgKiBib29sZWFuLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChwYXNzZXMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9kO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBGaWx0ZXIoYW5kKHAuZiwgcGFzc2VzKSwgcC5pbnMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IEZpbHRlcihwYXNzZXMsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExldHMgdGhlIGZpcnN0IGBhbW91bnRgIG1hbnkgZXZlbnRzIGZyb20gdGhlIGlucHV0IHN0cmVhbSBwYXNzIHRvIHRoZVxuICAgICAqIG91dHB1dCBzdHJlYW0sIHRoZW4gbWFrZXMgdGhlIG91dHB1dCBzdHJlYW0gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLWEtLS1iLS1jLS0tLWQtLS1lLS1cbiAgICAgKiAgICB0YWtlKDMpXG4gICAgICogLS1hLS0tYi0tY3xcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgSG93IG1hbnkgZXZlbnRzIHRvIGFsbG93IGZyb20gdGhlIGlucHV0IHN0cmVhbVxuICAgICAqIGJlZm9yZSBjb21wbGV0aW5nIHRoZSBvdXRwdXQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3RvcigpKShuZXcgVGFrZShhbW91bnQsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElnbm9yZXMgdGhlIGZpcnN0IGBhbW91bnRgIG1hbnkgZXZlbnRzIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgYW5kIHRoZW5cbiAgICAgKiBhZnRlciB0aGF0IHN0YXJ0cyBmb3J3YXJkaW5nIGV2ZW50cyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gdG8gdGhlIG91dHB1dFxuICAgICAqIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tYS0tLWItLWMtLS0tZC0tLWUtLVxuICAgICAqICAgICAgIGRyb3AoMylcbiAgICAgKiAtLS0tLS0tLS0tLS0tLWQtLS1lLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgSG93IG1hbnkgZXZlbnRzIHRvIGlnbm9yZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW1cbiAgICAgKiBiZWZvcmUgZm9yd2FyZGluZyBhbGwgZXZlbnRzIGZyb20gdGhlIGlucHV0IHN0cmVhbSB0byB0aGUgb3V0cHV0IHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgRHJvcChhbW91bnQsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGlucHV0IHN0cmVhbSBjb21wbGV0ZXMsIHRoZSBvdXRwdXQgc3RyZWFtIHdpbGwgZW1pdCB0aGUgbGFzdCBldmVudFxuICAgICAqIGVtaXR0ZWQgYnkgdGhlIGlucHV0IHN0cmVhbSwgYW5kIHRoZW4gd2lsbCBhbHNvIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS1hLS0tYi0tYy0tZC0tLS18XG4gICAgICogICAgICAgbGFzdCgpXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS1kfFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IExhc3QodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJlcGVuZHMgdGhlIGdpdmVuIGBpbml0aWFsYCB2YWx1ZSB0byB0aGUgc2VxdWVuY2Ugb2YgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlXG4gICAgICogaW5wdXQgc3RyZWFtLiBUaGUgcmV0dXJuZWQgc3RyZWFtIGlzIGEgTWVtb3J5U3RyZWFtLCB3aGljaCBtZWFucyBpdCBpc1xuICAgICAqIGFscmVhZHkgYHJlbWVtYmVyKClgJ2QuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLS0xLS0tMi0tLS0tMy0tLVxuICAgICAqICAgc3RhcnRXaXRoKDApXG4gICAgICogMC0tMS0tLTItLS0tLTMtLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbml0aWFsIFRoZSB2YWx1ZSBvciBldmVudCB0byBwcmVwZW5kLlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uIChpbml0aWFsKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtKG5ldyBTdGFydFdpdGgodGhpcywgaW5pdGlhbCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlcyBhbm90aGVyIHN0cmVhbSB0byBkZXRlcm1pbmUgd2hlbiB0byBjb21wbGV0ZSB0aGUgY3VycmVudCBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBnaXZlbiBgb3RoZXJgIHN0cmVhbSBlbWl0cyBhbiBldmVudCBvciBjb21wbGV0ZXMsIHRoZSBvdXRwdXRcbiAgICAgKiBzdHJlYW0gd2lsbCBjb21wbGV0ZS4gQmVmb3JlIHRoYXQgaGFwcGVucywgdGhlIG91dHB1dCBzdHJlYW0gd2lsbCBiZWhhdmVzXG4gICAgICogbGlrZSB0aGUgaW5wdXQgc3RyZWFtLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS0tMS0tLTItLS0tLTMtLTQtLS0tNS0tLS02LS0tXG4gICAgICogICBlbmRXaGVuKCAtLS0tLS0tLWEtLWItLXwgKVxuICAgICAqIC0tLTEtLS0yLS0tLS0zLS00LS18XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgU29tZSBvdGhlciBzdHJlYW0gdGhhdCBpcyB1c2VkIHRvIGtub3cgd2hlbiBzaG91bGQgdGhlIG91dHB1dFxuICAgICAqIHN0cmVhbSBvZiB0aGlzIG9wZXJhdG9yIGNvbXBsZXRlLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmVuZFdoZW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jdG9yKCkpKG5ldyBFbmRXaGVuKG90aGVyLCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcIkZvbGRzXCIgdGhlIHN0cmVhbSBvbnRvIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIENvbWJpbmVzIGV2ZW50cyBmcm9tIHRoZSBwYXN0IHRocm91Z2hvdXRcbiAgICAgKiB0aGUgZW50aXJlIGV4ZWN1dGlvbiBvZiB0aGUgaW5wdXQgc3RyZWFtLCBhbGxvd2luZyB5b3UgdG8gYWNjdW11bGF0ZSB0aGVtXG4gICAgICogdG9nZXRoZXIuIEl0J3MgZXNzZW50aWFsbHkgbGlrZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAuIFRoZSByZXR1cm5lZFxuICAgICAqIHN0cmVhbSBpcyBhIE1lbW9yeVN0cmVhbSwgd2hpY2ggbWVhbnMgaXQgaXMgYWxyZWFkeSBgcmVtZW1iZXIoKWAnZC5cbiAgICAgKlxuICAgICAqIFRoZSBvdXRwdXQgc3RyZWFtIHN0YXJ0cyBieSBlbWl0dGluZyB0aGUgYHNlZWRgIHdoaWNoIHlvdSBnaXZlIGFzIGFyZ3VtZW50LlxuICAgICAqIFRoZW4sIHdoZW4gYW4gZXZlbnQgaGFwcGVucyBvbiB0aGUgaW5wdXQgc3RyZWFtLCBpdCBpcyBjb21iaW5lZCB3aXRoIHRoYXRcbiAgICAgKiBzZWVkIHZhbHVlIHRocm91Z2ggdGhlIGBhY2N1bXVsYXRlYCBmdW5jdGlvbiwgYW5kIHRoZSBvdXRwdXQgdmFsdWUgaXNcbiAgICAgKiBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgc3RyZWFtLiBgZm9sZGAgcmVtZW1iZXJzIHRoYXQgb3V0cHV0IHZhbHVlIGFzIGBhY2NgXG4gICAgICogKFwiYWNjdW11bGF0b3JcIiksIGFuZCB0aGVuIHdoZW4gYSBuZXcgaW5wdXQgZXZlbnQgYHRgIGhhcHBlbnMsIGBhY2NgIHdpbGwgYmVcbiAgICAgKiBjb21iaW5lZCB3aXRoIHRoYXQgdG8gcHJvZHVjZSB0aGUgbmV3IGBhY2NgIGFuZCBzbyBmb3J0aC5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tLS0tLTEtLS0tLTEtLTItLS0tMS0tLS0xLS0tLS0tXG4gICAgICogICBmb2xkKChhY2MsIHgpID0+IGFjYyArIHgsIDMpXG4gICAgICogMy0tLS0tNC0tLS0tNS0tNy0tLS04LS0tLTktLS0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdGUgQSBmdW5jdGlvbiBvZiB0eXBlIGAoYWNjOiBSLCB0OiBUKSA9PiBSYCB0aGF0XG4gICAgICogdGFrZXMgdGhlIHByZXZpb3VzIGFjY3VtdWxhdGVkIHZhbHVlIGBhY2NgIGFuZCB0aGUgaW5jb21pbmcgZXZlbnQgZnJvbSB0aGVcbiAgICAgKiBpbnB1dCBzdHJlYW0gYW5kIHByb2R1Y2VzIHRoZSBuZXcgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIGluaXRpYWwgYWNjdW11bGF0ZWQgdmFsdWUsIG9mIHR5cGUgYFJgLlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiAoYWNjdW11bGF0ZSwgc2VlZCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVN0cmVhbShuZXcgRm9sZChhY2N1bXVsYXRlLCBzZWVkLCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbiBlcnJvciB3aXRoIGFub3RoZXIgc3RyZWFtLlxuICAgICAqXG4gICAgICogV2hlbiAoYW5kIGlmKSBhbiBlcnJvciBoYXBwZW5zIG9uIHRoZSBpbnB1dCBzdHJlYW0sIGluc3RlYWQgb2YgZm9yd2FyZGluZ1xuICAgICAqIHRoYXQgZXJyb3IgdG8gdGhlIG91dHB1dCBzdHJlYW0sICpyZXBsYWNlRXJyb3IqIHdpbGwgY2FsbCB0aGUgYHJlcGxhY2VgXG4gICAgICogZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgc3RyZWFtIHRoYXQgdGhlIG91dHB1dCBzdHJlYW0gd2lsbCByZXBsaWNhdGUuXG4gICAgICogQW5kLCBpbiBjYXNlIHRoYXQgbmV3IHN0cmVhbSBhbHNvIGVtaXRzIGFuIGVycm9yLCBgcmVwbGFjZWAgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhZ2FpbiB0byBnZXQgYW5vdGhlciBzdHJlYW0gdG8gc3RhcnQgcmVwbGljYXRpbmcuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0yLS0tLS0zLS00LS0tLS1YXG4gICAgICogICByZXBsYWNlRXJyb3IoICgpID0+IC0tMTAtLXwgKVxuICAgICAqIC0tMS0tLTItLS0tLTMtLTQtLS0tLS0tLTEwLS18XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXBsYWNlIEEgZnVuY3Rpb24gb2YgdHlwZSBgKGVycikgPT4gU3RyZWFtYCB0aGF0IHRha2VzXG4gICAgICogdGhlIGVycm9yIHRoYXQgb2NjdXJyZWQgb24gdGhlIGlucHV0IHN0cmVhbSBvciBvbiB0aGUgcHJldmlvdXMgcmVwbGFjZW1lbnRcbiAgICAgKiBzdHJlYW0gYW5kIHJldHVybnMgYSBuZXcgc3RyZWFtLiBUaGUgb3V0cHV0IHN0cmVhbSB3aWxsIGJlaGF2ZSBsaWtlIHRoZVxuICAgICAqIHN0cmVhbSB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5yZXBsYWNlRXJyb3IgPSBmdW5jdGlvbiAocmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmN0b3IoKSkobmV3IFJlcGxhY2VFcnJvcihyZXBsYWNlLCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIFwic3RyZWFtIG9mIHN0cmVhbXNcIiwgaGFuZGxpbmcgb25seSBvbmUgbmVzdGVkIHN0cmVhbSBhdCBhIHRpbWVcbiAgICAgKiAobm8gY29uY3VycmVuY3kpLlxuICAgICAqXG4gICAgICogSWYgdGhlIGlucHV0IHN0cmVhbSBpcyBhIHN0cmVhbSB0aGF0IGVtaXRzIHN0cmVhbXMsIHRoZW4gdGhpcyBvcGVyYXRvciB3aWxsXG4gICAgICogcmV0dXJuIGFuIG91dHB1dCBzdHJlYW0gd2hpY2ggaXMgYSBmbGF0IHN0cmVhbTogZW1pdHMgcmVndWxhciBldmVudHMuIFRoZVxuICAgICAqIGZsYXR0ZW5pbmcgaGFwcGVucyB3aXRob3V0IGNvbmN1cnJlbmN5LiBJdCB3b3JrcyBsaWtlIHRoaXM6IHdoZW4gdGhlIGlucHV0XG4gICAgICogc3RyZWFtIGVtaXRzIGEgbmVzdGVkIHN0cmVhbSwgKmZsYXR0ZW4qIHdpbGwgc3RhcnQgaW1pdGF0aW5nIHRoYXQgbmVzdGVkXG4gICAgICogb25lLiBIb3dldmVyLCBhcyBzb29uIGFzIHRoZSBuZXh0IG5lc3RlZCBzdHJlYW0gaXMgZW1pdHRlZCBvbiB0aGUgaW5wdXRcbiAgICAgKiBzdHJlYW0sICpmbGF0dGVuKiB3aWxsIGZvcmdldCB0aGUgcHJldmlvdXMgbmVzdGVkIG9uZSBpdCB3YXMgaW1pdGF0aW5nLCBhbmRcbiAgICAgKiB3aWxsIHN0YXJ0IGltaXRhdGluZyB0aGUgbmV3IG5lc3RlZCBvbmUuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLSstLS0tLS0tLSstLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgIFxcICAgICAgICBcXFxuICAgICAqICAgIFxcICAgICAgIC0tLS0xLS0tLTItLS0zLS1cbiAgICAgKiAgICAtLWEtLWItLS0tYy0tLS1kLS0tLS0tLS1cbiAgICAgKiAgICAgICAgICAgZmxhdHRlblxuICAgICAqIC0tLS0tYS0tYi0tLS0tLTEtLS0tMi0tLTMtLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9kO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShwIGluc3RhbmNlb2YgTWFwT3AgJiYgIShwIGluc3RhbmNlb2YgRmlsdGVyTWFwRnVzaW9uKSA/XG4gICAgICAgICAgICBuZXcgTWFwRmxhdHRlbihwKSA6XG4gICAgICAgICAgICBuZXcgRmxhdHRlbih0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXNzZXMgdGhlIGlucHV0IHN0cmVhbSB0byBhIGN1c3RvbSBvcGVyYXRvciwgdG8gcHJvZHVjZSBhbiBvdXRwdXQgc3RyZWFtLlxuICAgICAqXG4gICAgICogKmNvbXBvc2UqIGlzIGEgaGFuZHkgd2F5IG9mIHVzaW5nIGFuIGV4aXN0aW5nIGZ1bmN0aW9uIGluIGEgY2hhaW5lZCBzdHlsZS5cbiAgICAgKiBJbnN0ZWFkIG9mIHdyaXRpbmcgYG91dFN0cmVhbSA9IGYoaW5TdHJlYW0pYCB5b3UgY2FuIHdyaXRlXG4gICAgICogYG91dFN0cmVhbSA9IGluU3RyZWFtLmNvbXBvc2UoZilgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3BlcmF0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyZWFtIGFzIGlucHV0IGFuZFxuICAgICAqIHJldHVybnMgYSBzdHJlYW0gYXMgd2VsbC5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5jb21wb3NlID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb3V0cHV0IHN0cmVhbSB0aGF0IGJlaGF2ZXMgbGlrZSB0aGUgaW5wdXQgc3RyZWFtLCBidXQgYWxzb1xuICAgICAqIHJlbWVtYmVycyB0aGUgbW9zdCByZWNlbnQgZXZlbnQgdGhhdCBoYXBwZW5zIG9uIHRoZSBpbnB1dCBzdHJlYW0sIHNvIHRoYXQgYVxuICAgICAqIG5ld2x5IGFkZGVkIGxpc3RlbmVyIHdpbGwgaW1tZWRpYXRlbHkgcmVjZWl2ZSB0aGF0IG1lbW9yaXNlZCBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnJlbWVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVN0cmVhbShuZXcgUmVtZW1iZXIodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvdXRwdXQgc3RyZWFtIHRoYXQgaWRlbnRpY2FsbHkgYmVoYXZlcyBsaWtlIHRoZSBpbnB1dCBzdHJlYW0sXG4gICAgICogYnV0IGFsc28gcnVucyBhIGBzcHlgIGZ1bmN0aW9uIGZvIGVhY2ggZXZlbnQsIHRvIGhlbHAgeW91IGRlYnVnIHlvdXIgYXBwLlxuICAgICAqXG4gICAgICogKmRlYnVnKiB0YWtlcyBhIGBzcHlgIGZ1bmN0aW9uIGFzIGFyZ3VtZW50LCBhbmQgcnVucyB0aGF0IGZvciBlYWNoIGV2ZW50XG4gICAgICogaGFwcGVuaW5nIG9uIHRoZSBpbnB1dCBzdHJlYW0uIElmIHlvdSBkb24ndCBwcm92aWRlIHRoZSBgc3B5YCBhcmd1bWVudCxcbiAgICAgKiB0aGVuICpkZWJ1Zyogd2lsbCBqdXN0IGBjb25zb2xlLmxvZ2AgZWFjaCBldmVudC4gVGhpcyBoZWxwcyB5b3UgdG9cbiAgICAgKiB1bmRlcnN0YW5kIHRoZSBmbG93IG9mIGV2ZW50cyB0aHJvdWdoIHNvbWUgb3BlcmF0b3IgY2hhaW4uXG4gICAgICpcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGlmIHRoZSBvdXRwdXQgc3RyZWFtIGhhcyBubyBsaXN0ZW5lcnMsIHRoZW4gaXQgd2lsbCBub3RcbiAgICAgKiBzdGFydCwgd2hpY2ggbWVhbnMgYHNweWAgd2lsbCBuZXZlciBydW4gYmVjYXVzZSBubyBhY3R1YWwgZXZlbnQgaGFwcGVucyBpblxuICAgICAqIHRoYXQgY2FzZS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tMS0tLS0yLS0tLS0zLS0tLS00LS1cbiAgICAgKiAgICAgICAgIGRlYnVnXG4gICAgICogLS0xLS0tLTItLS0tLTMtLS0tLTQtLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGFiZWxPclNweSBBIHN0cmluZyB0byB1c2UgYXMgdGhlIGxhYmVsIHdoZW4gcHJpbnRpbmdcbiAgICAgKiBkZWJ1ZyBpbmZvcm1hdGlvbiBvbiB0aGUgY29uc29sZSwgb3IgYSAnc3B5JyBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGV2ZW50XG4gICAgICogYXMgYXJndW1lbnQsIGFuZCBkb2VzIG5vdCBuZWVkIHRvIHJldHVybiBhbnl0aGluZy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChsYWJlbE9yU3B5KSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3RvcigpKShuZXcgRGVidWcodGhpcywgbGFiZWxPclNweSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogKmltaXRhdGUqIGNoYW5nZXMgdGhpcyBjdXJyZW50IFN0cmVhbSB0byBlbWl0IHRoZSBzYW1lIGV2ZW50cyB0aGF0IHRoZVxuICAgICAqIGBvdGhlcmAgZ2l2ZW4gU3RyZWFtIGRvZXMuIFRoaXMgbWV0aG9kIHJldHVybnMgbm90aGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyB0byBhbGxvdyBvbmUgdGhpbmc6ICoqY2lyY3VsYXIgZGVwZW5kZW5jeSBvZiBzdHJlYW1zKiouXG4gICAgICogRm9yIGluc3RhbmNlLCBsZXQncyBpbWFnaW5lIHRoYXQgZm9yIHNvbWUgcmVhc29uIHlvdSBuZWVkIHRvIGNyZWF0ZSBhXG4gICAgICogY2lyY3VsYXIgZGVwZW5kZW5jeSB3aGVyZSBzdHJlYW0gYGZpcnN0JGAgZGVwZW5kcyBvbiBzdHJlYW0gYHNlY29uZCRgXG4gICAgICogd2hpY2ggaW4gdHVybiBkZXBlbmRzIG9uIGBmaXJzdCRgOlxuICAgICAqXG4gICAgICogPCEtLSBza2lwLWV4YW1wbGUgLS0+XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgZGVsYXkgZnJvbSAneHN0cmVhbS9leHRyYS9kZWxheSdcbiAgICAgKlxuICAgICAqIHZhciBmaXJzdCQgPSBzZWNvbmQkLm1hcCh4ID0+IHggKiAxMCkudGFrZSgzKTtcbiAgICAgKiB2YXIgc2Vjb25kJCA9IGZpcnN0JC5tYXAoeCA9PiB4ICsgMSkuc3RhcnRXaXRoKDEpLmNvbXBvc2UoZGVsYXkoMTAwKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCB0aGF0IGlzIGludmFsaWQgSmF2YVNjcmlwdCwgYmVjYXVzZSBgc2Vjb25kJGAgaXMgdW5kZWZpbmVkXG4gICAgICogb24gdGhlIGZpcnN0IGxpbmUuIFRoaXMgaXMgaG93ICppbWl0YXRlKiBjYW4gaGVscCBzb2x2ZSBpdDpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IGRlbGF5IGZyb20gJ3hzdHJlYW0vZXh0cmEvZGVsYXknXG4gICAgICpcbiAgICAgKiB2YXIgc2Vjb25kUHJveHkkID0geHMuY3JlYXRlKCk7XG4gICAgICogdmFyIGZpcnN0JCA9IHNlY29uZFByb3h5JC5tYXAoeCA9PiB4ICogMTApLnRha2UoMyk7XG4gICAgICogdmFyIHNlY29uZCQgPSBmaXJzdCQubWFwKHggPT4geCArIDEpLnN0YXJ0V2l0aCgxKS5jb21wb3NlKGRlbGF5KDEwMCkpO1xuICAgICAqIHNlY29uZFByb3h5JC5pbWl0YXRlKHNlY29uZCQpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2UgY3JlYXRlIGBzZWNvbmRQcm94eSRgIGJlZm9yZSB0aGUgb3RoZXJzLCBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0aGVcbiAgICAgKiBkZWNsYXJhdGlvbiBvZiBgZmlyc3QkYC4gVGhlbiwgYWZ0ZXIgYm90aCBgZmlyc3QkYCBhbmQgYHNlY29uZCRgIGFyZVxuICAgICAqIGRlZmluZWQsIHdlIGhvb2sgYHNlY29uZFByb3h5JGAgd2l0aCBgc2Vjb25kJGAgd2l0aCBgaW1pdGF0ZSgpYCB0byB0ZWxsXG4gICAgICogdGhhdCB0aGV5IGFyZSBcInRoZSBzYW1lXCIuIGBpbWl0YXRlYCB3aWxsIG5vdCB0cmlnZ2VyIHRoZSBzdGFydCBvZiBhbnlcbiAgICAgKiBzdHJlYW0sIGl0IGp1c3QgYmluZHMgYHNlY29uZFByb3h5JGAgYW5kIGBzZWNvbmQkYCB0b2dldGhlci5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgYW4gZXhhbXBsZSB3aGVyZSBgaW1pdGF0ZSgpYCBpcyBpbXBvcnRhbnQgaW4gQ3ljbGUuanNcbiAgICAgKiBhcHBsaWNhdGlvbnMuIEEgcGFyZW50IGNvbXBvbmVudCBjb250YWlucyBzb21lIGNoaWxkIGNvbXBvbmVudHMuIEEgY2hpbGRcbiAgICAgKiBoYXMgYW4gYWN0aW9uIHN0cmVhbSB3aGljaCBpcyBnaXZlbiB0byB0aGUgcGFyZW50IHRvIGRlZmluZSBpdHMgc3RhdGU6XG4gICAgICpcbiAgICAgKiA8IS0tIHNraXAtZXhhbXBsZSAtLT5cbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGNoaWxkQWN0aW9uUHJveHkkID0geHMuY3JlYXRlKCk7XG4gICAgICogY29uc3QgcGFyZW50ID0gUGFyZW50KHsuLi5zb3VyY2VzLCBjaGlsZEFjdGlvbiQ6IGNoaWxkQWN0aW9uUHJveHkkfSk7XG4gICAgICogY29uc3QgY2hpbGRBY3Rpb24kID0gcGFyZW50LnN0YXRlJC5tYXAocyA9PiBzLmNoaWxkLmFjdGlvbiQpLmZsYXR0ZW4oKTtcbiAgICAgKiBjaGlsZEFjdGlvblByb3h5JC5pbWl0YXRlKGNoaWxkQWN0aW9uJCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aG91Z2gsIHRoYXQgKipgaW1pdGF0ZSgpYCBkb2VzIG5vdCBzdXBwb3J0IE1lbW9yeVN0cmVhbXMqKi4gSWYgd2VcbiAgICAgKiB3b3VsZCBhdHRlbXB0IHRvIGltaXRhdGUgYSBNZW1vcnlTdHJlYW0gaW4gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCB3ZSB3b3VsZFxuICAgICAqIGVpdGhlciBnZXQgYSByYWNlIGNvbmRpdGlvbiAod2hlcmUgdGhlIHN5bXB0b20gd291bGQgYmUgXCJub3RoaW5nIGhhcHBlbnNcIilcbiAgICAgKiBvciBhbiBpbmZpbml0ZSBjeWNsaWMgZW1pc3Npb24gb2YgdmFsdWVzLiBJdCdzIHVzZWZ1bCB0byB0aGluayBhYm91dFxuICAgICAqIE1lbW9yeVN0cmVhbXMgYXMgY2VsbHMgaW4gYSBzcHJlYWRzaGVldC4gSXQgZG9lc24ndCBtYWtlIGFueSBzZW5zZSB0b1xuICAgICAqIGRlZmluZSBhIHNwcmVhZHNoZWV0IGNlbGwgYEExYCB3aXRoIGEgZm9ybXVsYSB0aGF0IGRlcGVuZHMgb24gYEIxYCBhbmRcbiAgICAgKiBjZWxsIGBCMWAgZGVmaW5lZCB3aXRoIGEgZm9ybXVsYSB0aGF0IGRlcGVuZHMgb24gYEExYC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBmaW5kIHlvdXJzZWxmIHdhbnRpbmcgdG8gdXNlIGBpbWl0YXRlKClgIHdpdGggYVxuICAgICAqIE1lbW9yeVN0cmVhbSwgeW91IHNob3VsZCByZXdvcmsgeW91ciBjb2RlIGFyb3VuZCBgaW1pdGF0ZSgpYCB0byB1c2UgYVxuICAgICAqIFN0cmVhbSBpbnN0ZWFkLiBMb29rIGZvciB0aGUgc3RyZWFtIGluIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5IHRoYXRcbiAgICAgKiByZXByZXNlbnRzIGFuIGV2ZW50IHN0cmVhbSwgYW5kIHRoYXQgd291bGQgYmUgYSBjYW5kaWRhdGUgZm9yIGNyZWF0aW5nIGFcbiAgICAgKiBwcm94eSBTdHJlYW0gd2hpY2ggdGhlbiBpbWl0YXRlcyB0aGUgdGFyZ2V0IFN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSB0YXJnZXQgVGhlIG90aGVyIHN0cmVhbSB0byBpbWl0YXRlIG9uIHRoZSBjdXJyZW50IG9uZS4gTXVzdFxuICAgICAqIG5vdCBiZSBhIE1lbW9yeVN0cmVhbS5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmltaXRhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNZW1vcnlTdHJlYW0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgTWVtb3J5U3RyZWFtIHdhcyBnaXZlbiB0byBpbWl0YXRlKCksIGJ1dCBpdCBvbmx5ICcgK1xuICAgICAgICAgICAgICAgICdzdXBwb3J0cyBhIFN0cmVhbS4gUmVhZCBtb3JlIGFib3V0IHRoaXMgcmVzdHJpY3Rpb24gaGVyZTogJyArXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9zdGFsdHoveHN0cmVhbSNmYXEnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBmb3IgKHZhciBpbHMgPSB0aGlzLl9pbHMsIE4gPSBpbHMubGVuZ3RoLCBpID0gMDsgaSA8IE47IGkrKylcbiAgICAgICAgICAgIHRhcmdldC5fYWRkKGlsc1tpXSk7XG4gICAgICAgIHRoaXMuX2lscyA9IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBTdHJlYW0gdG8gZW1pdCB0aGUgZ2l2ZW4gdmFsdWUgdG8gaXRzIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEFzIHRoZSBuYW1lIGluZGljYXRlcywgaWYgeW91IHVzZSB0aGlzLCB5b3UgYXJlIG1vc3QgbGlrZWx5IGRvaW5nIHNvbWV0aGluZ1xuICAgICAqIFRoZSBXcm9uZyBXYXkuIFBsZWFzZSB0cnkgdG8gdW5kZXJzdGFuZCB0aGUgcmVhY3RpdmUgd2F5IGJlZm9yZSB1c2luZyB0aGlzXG4gICAgICogbWV0aG9kLiBVc2UgaXQgb25seSB3aGVuIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgXCJuZXh0XCIgdmFsdWUgeW91IHdhbnQgdG8gYnJvYWRjYXN0IHRvIGFsbCBsaXN0ZW5lcnMgb2ZcbiAgICAgKiB0aGlzIFN0cmVhbS5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnNoYW1lZnVsbHlTZW5kTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9uKHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgU3RyZWFtIHRvIGVtaXQgdGhlIGdpdmVuIGVycm9yIHRvIGl0cyBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBBcyB0aGUgbmFtZSBpbmRpY2F0ZXMsIGlmIHlvdSB1c2UgdGhpcywgeW91IGFyZSBtb3N0IGxpa2VseSBkb2luZyBzb21ldGhpbmdcbiAgICAgKiBUaGUgV3JvbmcgV2F5LiBQbGVhc2UgdHJ5IHRvIHVuZGVyc3RhbmQgdGhlIHJlYWN0aXZlIHdheSBiZWZvcmUgdXNpbmcgdGhpc1xuICAgICAqIG1ldGhvZC4gVXNlIGl0IG9ubHkgd2hlbiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gZXJyb3IgVGhlIGVycm9yIHlvdSB3YW50IHRvIGJyb2FkY2FzdCB0byBhbGwgdGhlIGxpc3RlbmVycyBvZlxuICAgICAqIHRoaXMgU3RyZWFtLlxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuc2hhbWVmdWxseVNlbmRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLl9lKGVycm9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgU3RyZWFtIHRvIGVtaXQgdGhlIFwiY29tcGxldGVkXCIgZXZlbnQgdG8gaXRzIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEFzIHRoZSBuYW1lIGluZGljYXRlcywgaWYgeW91IHVzZSB0aGlzLCB5b3UgYXJlIG1vc3QgbGlrZWx5IGRvaW5nIHNvbWV0aGluZ1xuICAgICAqIFRoZSBXcm9uZyBXYXkuIFBsZWFzZSB0cnkgdG8gdW5kZXJzdGFuZCB0aGUgcmVhY3RpdmUgd2F5IGJlZm9yZSB1c2luZyB0aGlzXG4gICAgICogbWV0aG9kLiBVc2UgaXQgb25seSB3aGVuIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnNoYW1lZnVsbHlTZW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2MoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBcImRlYnVnXCIgbGlzdGVuZXIgdG8gdGhlIHN0cmVhbS4gVGhlcmUgY2FuIG9ubHkgYmUgb25lIGRlYnVnXG4gICAgICogbGlzdGVuZXIsIHRoYXQncyB3aHkgdGhpcyBpcyAnc2V0RGVidWdMaXN0ZW5lcicuIFRvIHJlbW92ZSB0aGUgZGVidWdcbiAgICAgKiBsaXN0ZW5lciwganVzdCBjYWxsIHNldERlYnVnTGlzdGVuZXIobnVsbCkuXG4gICAgICpcbiAgICAgKiBBIGRlYnVnIGxpc3RlbmVyIGlzIGxpa2UgYW55IG90aGVyIGxpc3RlbmVyLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgYVxuICAgICAqIGRlYnVnIGxpc3RlbmVyIGlzIFwic3RlYWx0aHlcIjogaXRzIHByZXNlbmNlL2Fic2VuY2UgZG9lcyBub3QgdHJpZ2dlciB0aGVcbiAgICAgKiBzdGFydC9zdG9wIG9mIHRoZSBzdHJlYW0gKG9yIHRoZSBwcm9kdWNlciBpbnNpZGUgdGhlIHN0cmVhbSkuIFRoaXMgaXNcbiAgICAgKiB1c2VmdWwgc28geW91IGNhbiBpbnNwZWN0IHdoYXQgaXMgZ29pbmcgb24gd2l0aG91dCBjaGFuZ2luZyB0aGUgYmVoYXZpb3JcbiAgICAgKiBvZiB0aGUgcHJvZ3JhbS4gSWYgeW91IGhhdmUgYW4gaWRsZSBzdHJlYW0gYW5kIHlvdSBhZGQgYSBub3JtYWwgbGlzdGVuZXIgdG9cbiAgICAgKiBpdCwgdGhlIHN0cmVhbSB3aWxsIHN0YXJ0IGV4ZWN1dGluZy4gQnV0IGlmIHlvdSBzZXQgYSBkZWJ1ZyBsaXN0ZW5lciBvbiBhblxuICAgICAqIGlkbGUgc3RyZWFtLCBpdCB3b24ndCBzdGFydCBleGVjdXRpbmcgKG5vdCB1bnRpbCB0aGUgZmlyc3Qgbm9ybWFsIGxpc3RlbmVyXG4gICAgICogaXMgYWRkZWQpLlxuICAgICAqXG4gICAgICogQXMgdGhlIG5hbWUgaW5kaWNhdGVzLCB3ZSBkb24ndCByZWNvbW1lbmQgdXNpbmcgdGhpcyBtZXRob2QgdG8gYnVpbGQgYXBwXG4gICAgICogbG9naWMuIEluIGZhY3QsIGluIG1vc3QgY2FzZXMgdGhlIGRlYnVnIG9wZXJhdG9yIHdvcmtzIGp1c3QgZmluZS4gT25seSB1c2VcbiAgICAgKiB0aGlzIG9uZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGlzdGVuZXI8VD59IGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5zZXREZWJ1Z0xpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RsID0gTk87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLl9uID0gbGlzdGVuZXIubmV4dCB8fCBub29wO1xuICAgICAgICAgICAgbGlzdGVuZXIuX2UgPSBsaXN0ZW5lci5lcnJvciB8fCBub29wO1xuICAgICAgICAgICAgbGlzdGVuZXIuX2MgPSBsaXN0ZW5lci5jb21wbGV0ZSB8fCBub29wO1xuICAgICAgICAgICAgdGhpcy5fZGwgPSBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0cmVhbTtcbn0oKSk7XG4vKipcbiAqIEJsZW5kcyBtdWx0aXBsZSBzdHJlYW1zIHRvZ2V0aGVyLCBlbWl0dGluZyBldmVudHMgZnJvbSBhbGwgb2YgdGhlbVxuICogY29uY3VycmVudGx5LlxuICpcbiAqICptZXJnZSogdGFrZXMgbXVsdGlwbGUgc3RyZWFtcyBhcyBhcmd1bWVudHMsIGFuZCBjcmVhdGVzIGEgc3RyZWFtIHRoYXRcbiAqIGJlaGF2ZXMgbGlrZSBlYWNoIG9mIHRoZSBhcmd1bWVudCBzdHJlYW1zLCBpbiBwYXJhbGxlbC5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLS0tMi0tLS0tMy0tLS0tLS0tNC0tLVxuICogLS0tLWEtLS0tLWItLS0tYy0tLWQtLS0tLS1cbiAqICAgICAgICAgICAgbWVyZ2VcbiAqIC0tMS1hLS0yLS1iLS0zLWMtLS1kLS00LS0tXG4gKiBgYGBcbiAqXG4gKiBAZmFjdG9yeSB0cnVlXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMSBBIHN0cmVhbSB0byBtZXJnZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMiBBIHN0cmVhbSB0byBtZXJnZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuIFR3b1xuICogb3IgbW9yZSBzdHJlYW1zIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cblN0cmVhbS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBzdHJlYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3RyZWFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgTWVyZ2Uoc3RyZWFtcykpO1xufTtcbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgaW5wdXQgc3RyZWFtcyB0b2dldGhlciB0byByZXR1cm4gYSBzdHJlYW0gd2hvc2UgZXZlbnRzXG4gKiBhcmUgYXJyYXlzIHRoYXQgY29sbGVjdCB0aGUgbGF0ZXN0IGV2ZW50cyBmcm9tIGVhY2ggaW5wdXQgc3RyZWFtLlxuICpcbiAqICpjb21iaW5lKiBpbnRlcm5hbGx5IHJlbWVtYmVycyB0aGUgbW9zdCByZWNlbnQgZXZlbnQgZnJvbSBlYWNoIG9mIHRoZSBpbnB1dFxuICogc3RyZWFtcy4gV2hlbiBhbnkgb2YgdGhlIGlucHV0IHN0cmVhbXMgZW1pdHMgYW4gZXZlbnQsIHRoYXQgZXZlbnQgdG9nZXRoZXJcbiAqIHdpdGggYWxsIHRoZSBvdGhlciBzYXZlZCBldmVudHMgYXJlIGNvbWJpbmVkIGludG8gYW4gYXJyYXkuIFRoYXQgYXJyYXkgd2lsbFxuICogYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IHN0cmVhbS4gSXQncyBlc3NlbnRpYWxseSBhIHdheSBvZiBqb2luaW5nIHRvZ2V0aGVyXG4gKiB0aGUgZXZlbnRzIGZyb20gbXVsdGlwbGUgc3RyZWFtcy5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLS0tMi0tLS0tMy0tLS0tLS0tNC0tLVxuICogLS0tLWEtLS0tLWItLS0tLWMtLWQtLS0tLS1cbiAqICAgICAgICAgIGNvbWJpbmVcbiAqIC0tLS0xYS0yYS0yYi0zYi0zYy0zZC00ZC0tXG4gKiBgYGBcbiAqXG4gKiBOb3RlOiB0byBtaW5pbWl6ZSBnYXJiYWdlIGNvbGxlY3Rpb24sICpjb21iaW5lKiB1c2VzIHRoZSBzYW1lIGFycmF5XG4gKiBpbnN0YW5jZSBmb3IgZWFjaCBlbWlzc2lvbi4gIElmIHlvdSBuZWVkIHRvIGNvbXBhcmUgZW1pc3Npb25zIG92ZXIgdGltZSxcbiAqIGNhY2hlIHRoZSB2YWx1ZXMgd2l0aCBgbWFwYCBmaXJzdDpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHBhaXJ3aXNlIGZyb20gJ3hzdHJlYW0vZXh0cmEvcGFpcndpc2UnXG4gKlxuICogY29uc3Qgc3RyZWFtMSA9IHhzLm9mKDEpO1xuICogY29uc3Qgc3RyZWFtMiA9IHhzLm9mKDIpO1xuICpcbiAqIHhzLmNvbWJpbmUoc3RyZWFtMSwgc3RyZWFtMikubWFwKFxuICogICBjb21iaW5lZEVtaXNzaW9ucyA9PiAoWyAuLi5jb21iaW5lZEVtaXNzaW9ucyBdKVxuICogKS5jb21wb3NlKHBhaXJ3aXNlKVxuICogYGBgXG4gKlxuICogQGZhY3RvcnkgdHJ1ZVxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTEgQSBzdHJlYW0gdG8gY29tYmluZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMiBBIHN0cmVhbSB0byBjb21iaW5lIHRvZ2V0aGVyIHdpdGggb3RoZXIgc3RyZWFtcy5cbiAqIE11bHRpcGxlIHN0cmVhbXMsIG5vdCBqdXN0IHR3bywgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50cy5cbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqL1xuU3RyZWFtLmNvbWJpbmUgPSBmdW5jdGlvbiBjb21iaW5lKCkge1xuICAgIHZhciBzdHJlYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3RyZWFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgQ29tYmluZShzdHJlYW1zKSk7XG59O1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG52YXIgTWVtb3J5U3RyZWFtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVtb3J5U3RyZWFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbW9yeVN0cmVhbShwcm9kdWNlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9kdWNlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2hhcyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLl92ID0geDtcbiAgICAgICAgdGhpcy5faGFzID0gdHJ1ZTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fbi5jYWxsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24gKGlsKSB7XG4gICAgICAgIHZhciB0YSA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgaWYgKHRhICE9PSBOTylcbiAgICAgICAgICAgIHJldHVybiB0YS5fYWRkKGlsKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9pbHM7XG4gICAgICAgIGEucHVzaChpbCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXMpXG4gICAgICAgICAgICAgICAgaWwuX24odGhpcy5fdik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0b3BJRCAhPT0gTk8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXMpXG4gICAgICAgICAgICAgICAgaWwuX24odGhpcy5fdik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcElEKTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BJRCA9IE5PO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2hhcylcbiAgICAgICAgICAgIGlsLl9uKHRoaXMuX3YpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5fcHJvZDtcbiAgICAgICAgICAgIGlmIChwICE9PSBOTylcbiAgICAgICAgICAgICAgICBwLl9zdGFydCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5fc3RvcE5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzID0gZmFsc2U7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0b3BOb3cuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuX3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhcyA9IGZhbHNlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl94LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAocHJvamVjdCk7XG4gICAgfTtcbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLm1hcFRvID0gZnVuY3Rpb24gKHByb2plY3RlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLm1hcFRvLmNhbGwodGhpcywgcHJvamVjdGVkVmFsdWUpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS50YWtlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50YWtlLmNhbGwodGhpcywgYW1vdW50KTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuZW5kV2hlbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbmRXaGVuLmNhbGwodGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5yZXBsYWNlRXJyb3IgPSBmdW5jdGlvbiAocmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZXBsYWNlRXJyb3IuY2FsbCh0aGlzLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUucmVtZW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChsYWJlbE9yU3B5KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlYnVnLmNhbGwodGhpcywgbGFiZWxPclNweSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVtb3J5U3RyZWFtO1xufShTdHJlYW0pKTtcbmV4cG9ydHMuTWVtb3J5U3RyZWFtID0gTWVtb3J5U3RyZWFtO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3hzdHJlYW0vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdGh1bmsgPSByZXF1aXJlKCdzbmFiYmRvbS90aHVuaycpO1xuZXhwb3J0cy50aHVuayA9IHRodW5rO1xuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIHRoZSBET00gZHJpdmVyIGZ1bmN0aW9uLlxuICpcbiAqIFRha2VzIGEgYGNvbnRhaW5lcmAgdG8gZGVmaW5lIHRoZSB0YXJnZXQgb24gdGhlIGV4aXN0aW5nIERPTSB3aGljaCB0aGlzXG4gKiBkcml2ZXIgd2lsbCBvcGVyYXRlIG9uLCBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBUaGVcbiAqIGlucHV0IHRvIHRoaXMgZHJpdmVyIGlzIGEgc3RyZWFtIG9mIHZpcnR1YWwgRE9NIG9iamVjdHMsIG9yIGluIG90aGVyIHdvcmRzLFxuICogU25hYmJkb20gXCJWTm9kZVwiIG9iamVjdHMuIFRoZSBvdXRwdXQgb2YgdGhpcyBkcml2ZXIgaXMgYSBcIkRPTVNvdXJjZVwiOiBhXG4gKiBjb2xsZWN0aW9uIG9mIE9ic2VydmFibGVzIHF1ZXJpZWQgd2l0aCB0aGUgbWV0aG9kcyBgc2VsZWN0KClgIGFuZCBgZXZlbnRzKClgLlxuICpcbiAqIGBET01Tb3VyY2Uuc2VsZWN0KHNlbGVjdG9yKWAgcmV0dXJucyBhIG5ldyBET01Tb3VyY2Ugd2l0aCBzY29wZSByZXN0cmljdGVkIHRvXG4gKiB0aGUgZWxlbWVudChzKSB0aGF0IG1hdGNoZXMgdGhlIENTUyBgc2VsZWN0b3JgIGdpdmVuLlxuICpcbiAqIGBET01Tb3VyY2UuZXZlbnRzKGV2ZW50VHlwZSwgb3B0aW9ucylgIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIG9mXG4gKiBgZXZlbnRUeXBlYCBoYXBwZW5pbmcgb24gdGhlIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGN1cnJlbnQgRE9NU291cmNlLiBUaGVcbiAqIGV2ZW50IG9iamVjdCBjb250YWlucyB0aGUgYG93bmVyVGFyZ2V0YCBwcm9wZXJ0eSB0aGF0IGJlaGF2ZXMgZXhhY3RseSBsaWtlXG4gKiBgY3VycmVudFRhcmdldGAuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBzb21lIGJyb3dzZXJzIGRvZXNuJ3QgYWxsb3dcbiAqIGBjdXJyZW50VGFyZ2V0YCBwcm9wZXJ0eSB0byBiZSBtdXRhdGVkLCBoZW5jZSBhIG5ldyBwcm9wZXJ0eSBpcyBjcmVhdGVkLiBUaGVcbiAqIHJldHVybmVkIHN0cmVhbSBpcyBhbiAqeHN0cmVhbSogU3RyZWFtIGlmIHlvdSB1c2UgYEBjeWNsZS94c3RyZWFtLXJ1bmAgdG8gcnVuXG4gKiB5b3VyIGFwcCB3aXRoIHRoaXMgZHJpdmVyLCBvciBpdCBpcyBhbiBSeEpTIE9ic2VydmFibGUgaWYgeW91IHVzZVxuICogYEBjeWNsZS9yeGpzLXJ1bmAsIGFuZCBzbyBmb3J0aC4gVGhlIGBvcHRpb25zYCBwYXJhbWV0ZXIgY2FuIGhhdmUgdGhlXG4gKiBwcm9wZXJ0eSBgdXNlQ2FwdHVyZWAsIHdoaWNoIGlzIGJ5IGRlZmF1bHQgYGZhbHNlYCwgZXhjZXB0IGl0IGlzIGB0cnVlYCBmb3JcbiAqIGV2ZW50IHR5cGVzIHRoYXQgZG8gbm90IGJ1YmJsZS4gUmVhZCBtb3JlIGhlcmVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyXG4gKiBhYm91dCB0aGUgYHVzZUNhcHR1cmVgIGFuZCBpdHMgcHVycG9zZS5cbiAqXG4gKiBgRE9NU291cmNlLmVsZW1lbnRzKClgIHJldHVybnMgYSBzdHJlYW0gb2YgdGhlIERPTSBlbGVtZW50KHMpIG1hdGNoZWQgYnkgdGhlXG4gKiBzZWxlY3RvcnMgaW4gdGhlIERPTVNvdXJjZS4gQWxzbywgYERPTVNvdXJjZS5zZWxlY3QoJzpyb290JykuZWxlbWVudHMoKWBcbiAqIHJldHVybnMgYSBzdHJlYW0gb2YgRE9NIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCAob3IgY29udGFpbmVyKSBvZlxuICogdGhlIGFwcCBvbiB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xIVE1MRWxlbWVudCl9IGNvbnRhaW5lciB0aGUgRE9NIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudFxuICogKG9yIHRoZSBlbGVtZW50IGl0c2VsZikgdG8gY29udGFpbiB0aGUgcmVuZGVyaW5nIG9mIHRoZSBWVHJlZXMuXG4gKiBAcGFyYW0ge0RPTURyaXZlck9wdGlvbnN9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggdHdvIG9wdGlvbmFsIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBtb2R1bGVzOiBhcnJheWAgb3ZlcnJpZGVzIGBAY3ljbGUvZG9tYCdzIGRlZmF1bHQgU25hYmJkb20gbW9kdWxlcyBhc1xuICogICAgIGFzIGRlZmluZWQgaW4gW2BzcmMvbW9kdWxlcy50c2BdKC4vc3JjL21vZHVsZXMudHMpLlxuICogICAtIGB0cmFuc3Bvc2l0aW9uOiBib29sZWFuYCBlbmFibGVzL2Rpc2FibGVzIHRyYW5zcG9zaXRpb24gb2YgaW5uZXIgc3RyZWFtc1xuICogICAgIGluIHRoZSB2aXJ0dWFsIERPTSB0cmVlLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBET00gZHJpdmVyIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gZXhwZWN0cyBhIHN0cmVhbSBvZlxuICogVk5vZGUgYXMgaW5wdXQsIGFuZCBvdXRwdXRzIHRoZSBET01Tb3VyY2Ugb2JqZWN0LlxuICogQGZ1bmN0aW9uIG1ha2VET01Ecml2ZXJcbiAqL1xudmFyIG1ha2VET01Ecml2ZXJfMSA9IHJlcXVpcmUoJy4vbWFrZURPTURyaXZlcicpO1xuZXhwb3J0cy5tYWtlRE9NRHJpdmVyID0gbWFrZURPTURyaXZlcl8xLm1ha2VET01Ecml2ZXI7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgdGhlIEhUTUwgZHJpdmVyIGZ1bmN0aW9uLlxuICpcbiAqIFRha2VzIGFuIGBlZmZlY3RgIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0IGFzIGFyZ3VtZW50cy4gVGhlXG4gKiBpbnB1dCB0byB0aGlzIGRyaXZlciBpcyBhIHN0cmVhbSBvZiB2aXJ0dWFsIERPTSBvYmplY3RzLCBvciBpbiBvdGhlciB3b3JkcyxcbiAqIFNuYWJiZG9tIFwiVk5vZGVcIiBvYmplY3RzLiBUaGUgb3V0cHV0IG9mIHRoaXMgZHJpdmVyIGlzIGEgXCJET01Tb3VyY2VcIjogYVxuICogY29sbGVjdGlvbiBvZiBPYnNlcnZhYmxlcyBxdWVyaWVkIHdpdGggdGhlIG1ldGhvZHMgYHNlbGVjdCgpYCBhbmQgYGV2ZW50cygpYC5cbiAqXG4gKiBUaGUgSFRNTCBEcml2ZXIgaXMgc3VwcGxlbWVudGFyeSB0byB0aGUgRE9NIERyaXZlci4gSW5zdGVhZCBvZiBwcm9kdWNpbmdcbiAqIGVsZW1lbnRzIG9uIHRoZSBET00sIGl0IGdlbmVyYXRlcyBIVE1MIGFzIHN0cmluZ3MgYW5kIGRvZXMgYSBzaWRlIGVmZmVjdCBvblxuICogdGhvc2UgSFRNTCBzdHJpbmdzLiBUaGF0IHNpZGUgZWZmZWN0IGlzIGRlc2NyaWJlZCBieSB0aGUgYGVmZmVjdGAgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBTbywgaWYgeW91IHdhbnQgdG8gdXNlIHRoZSBIVE1MIERyaXZlciBvbiB0aGUgc2VydmVyLXNpZGUgdG8gcmVuZGVyXG4gKiB5b3VyIGFwcGxpY2F0aW9uIGFzIEhUTUwgYW5kIHNlbmQgYXMgYSByZXNwb25zZSAod2hpY2ggaXMgdGhlIHR5cGljYWwgdXNlXG4gKiBjYXNlIGZvciB0aGUgSFRNTCBEcml2ZXIpLCB5b3UgbmVlZCB0byBwYXNzIHNvbWV0aGluZyBsaWtlIHRoZVxuICogYGh0bWwgPT4gcmVzcG9uc2Uuc2VuZChodG1sKWAgZnVuY3Rpb24gYXMgdGhlIGBlZmZlY3RgIGFyZ3VtZW50LiBUaGlzIHdheSxcbiAqIHRoZSBkcml2ZXIga25vd3Mgd2hhdCBzaWRlIGVmZmVjdCB0byBjYXVzZSBiYXNlZCBvbiB0aGUgSFRNTCBzdHJpbmcgaXQganVzdFxuICogcmVuZGVyZWQuXG4gKlxuICogVGhlIEhUTUwgZHJpdmVyIGlzIHVzZWZ1bCBvbmx5IGZvciB0aGF0IHNpZGUgZWZmZWN0IGluIHRoZSBgZWZmZWN0YCBjYWxsYmFjay5cbiAqIEl0IGNhbiBiZSBjb25zaWRlcmVkIGEgc2luay1vbmx5IGRyaXZlci4gSG93ZXZlciwgaW4gb3JkZXIgdG8gc2VydmUgYXMgYVxuICogdHJhbnNwYXJlbnQgcmVwbGFjZW1lbnQgdG8gdGhlIERPTSBEcml2ZXIgd2hlbiByZW5kZXJpbmcgZnJvbSB0aGUgc2VydmVyLCB0aGVcbiAqIEhUTUwgZHJpdmVyIHJldHVybnMgYSBzb3VyY2Ugb2JqZWN0IHRoYXQgYmVoYXZlcyBqdXN0IGxpa2UgdGhlIERPTVNvdXJjZS5cbiAqIFRoaXMgaGVscHMgcmV1c2UgdGhlIHNhbWUgYXBwbGljYXRpb24gdGhhdCBpcyB3cml0dGVuIGZvciB0aGUgRE9NIERyaXZlci5cbiAqIFRoaXMgZmFrZSBET01Tb3VyY2UgcmV0dXJucyBlbXB0eSBzdHJlYW1zIHdoZW4geW91IHF1ZXJ5IGl0LCBiZWNhdXNlIHRoZXJlXG4gKiBhcmUgbm8gdXNlciBldmVudHMgb24gdGhlIHNlcnZlci5cbiAqXG4gKiBgRE9NU291cmNlLnNlbGVjdChzZWxlY3RvcilgIHJldHVybnMgYSBuZXcgRE9NU291cmNlIHdpdGggc2NvcGUgcmVzdHJpY3RlZCB0b1xuICogdGhlIGVsZW1lbnQocykgdGhhdCBtYXRjaGVzIHRoZSBDU1MgYHNlbGVjdG9yYCBnaXZlbi5cbiAqXG4gKiBgRE9NU291cmNlLmV2ZW50cyhldmVudFR5cGUsIG9wdGlvbnMpYCByZXR1cm5zIGFuIGVtcHR5IHN0cmVhbS4gVGhlIHJldHVybmVkXG4gKiBzdHJlYW0gaXMgYW4gKnhzdHJlYW0qIFN0cmVhbSBpZiB5b3UgdXNlIGBAY3ljbGUveHN0cmVhbS1ydW5gIHRvIHJ1biB5b3VyIGFwcFxuICogd2l0aCB0aGlzIGRyaXZlciwgb3IgaXQgaXMgYW4gUnhKUyBPYnNlcnZhYmxlIGlmIHlvdSB1c2UgYEBjeWNsZS9yeGpzLXJ1bmAsXG4gKiBhbmQgc28gZm9ydGguXG4gKlxuICogYERPTVNvdXJjZS5lbGVtZW50cygpYCByZXR1cm5zIHRoZSBzdHJlYW0gb2YgSFRNTCBzdHJpbmcgcmVuZGVyZWQgZnJvbSB5b3VyXG4gKiBzaW5rIHZpcnR1YWwgRE9NIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlZmZlY3QgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyaW5nIG9mIHJlbmRlcmVkXG4gKiBIVE1MIGFzIGlucHV0IGFuZCBzaG91bGQgcnVuIGEgc2lkZSBlZmZlY3QsIHJldHVybmluZyBub3RoaW5nLlxuICogQHBhcmFtIHtIVE1MRHJpdmVyT3B0aW9uc30gb3B0aW9ucyBhbiBvYmplY3Qgd2l0aCBvbmUgb3B0aW9uYWwgcHJvcGVydHk6XG4gKiBgdHJhbnNwb3NpdGlvbjogYm9vbGVhbmAgZW5hYmxlcy9kaXNhYmxlcyB0cmFuc3Bvc2l0aW9uIG9mIGlubmVyIHN0cmVhbXMgaW5cbiAqIHRoZSB2aXJ0dWFsIERPTSB0cmVlLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBIVE1MIGRyaXZlciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIGV4cGVjdHMgYSBzdHJlYW0gb2ZcbiAqIFZOb2RlIGFzIGlucHV0LCBhbmQgb3V0cHV0cyB0aGUgRE9NU291cmNlIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBtYWtlSFRNTERyaXZlclxuICovXG52YXIgbWFrZUhUTUxEcml2ZXJfMSA9IHJlcXVpcmUoJy4vbWFrZUhUTUxEcml2ZXInKTtcbmV4cG9ydHMubWFrZUhUTUxEcml2ZXIgPSBtYWtlSFRNTERyaXZlcl8xLm1ha2VIVE1MRHJpdmVyO1xuLyoqXG4gKiBBIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2tlZCBET01Tb3VyY2Ugb2JqZWN0cywgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogVGFrZXMgYSBgc3RyZWFtQWRhcHRlcmAgYW5kIGEgYG1vY2tDb25maWdgIG9iamVjdCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zXG4gKiBhIERPTVNvdXJjZSB0aGF0IGNhbiBiZSBnaXZlbiB0byBhbnkgQ3ljbGUuanMgYXBwIHRoYXQgZXhwZWN0cyBhIERPTVNvdXJjZSBpblxuICogdGhlIHNvdXJjZXMsIGZvciB0ZXN0aW5nLlxuICpcbiAqIFRoZSBgc3RyZWFtQWRhcHRlcmAgcGFyYW1ldGVyIGlzIGEgcGFja2FnZSBzdWNoIGFzIGBAY3ljbGUveHN0cmVhbS1hZGFwdGVyYCxcbiAqIGBAY3ljbGUvcnhqcy1hZGFwdGVyYCwgZXRjLiBJbXBvcnQgaXQgYXMgYGltcG9ydCBhIGZyb20gJ0BjeWNsZS9yeC1hZGFwdGVyYCxcbiAqIHRoZW4gcHJvdmlkZSBpdCB0byBgbW9ja0RPTVNvdXJjZS4gVGhpcyBpcyBpbXBvcnRhbnQgc28gdGhlIERPTVNvdXJjZSBjcmVhdGVkXG4gKiBrbm93cyB3aGljaCBzdHJlYW0gbGlicmFyeSBzaG91bGQgaXQgdXNlIHRvIGV4cG9ydCBpdHMgc3RyZWFtcyB3aGVuIHlvdSBjYWxsXG4gKiBgRE9NU291cmNlLmV2ZW50cygpYCBmb3IgaW5zdGFuY2UuXG4gKlxuICogVGhlIGBtb2NrQ29uZmlnYCBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHNwZWNpZnlpbmcgc2VsZWN0b3JzLCBldmVudFR5cGVzIGFuZFxuICogdGhlaXIgc3RyZWFtcy4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZG9tU291cmNlID0gbW9ja0RPTVNvdXJjZShSeEFkYXB0ZXIsIHtcbiAqICAgJy5mb28nOiB7XG4gKiAgICAgJ2NsaWNrJzogUnguT2JzZXJ2YWJsZS5vZih7dGFyZ2V0OiB7fX0pLFxuICogICAgICdtb3VzZW92ZXInOiBSeC5PYnNlcnZhYmxlLm9mKHt0YXJnZXQ6IHt9fSksXG4gKiAgIH0sXG4gKiAgICcuYmFyJzoge1xuICogICAgICdzY3JvbGwnOiBSeC5PYnNlcnZhYmxlLm9mKHt0YXJnZXQ6IHt9fSksXG4gKiAgICAgZWxlbWVudHM6IFJ4Lk9ic2VydmFibGUub2Yoe3RhZ05hbWU6ICdkaXYnfSksXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzYWdlXG4gKiBjb25zdCBjbGljayQgPSBkb21Tb3VyY2Uuc2VsZWN0KCcuZm9vJykuZXZlbnRzKCdjbGljaycpO1xuICogY29uc3QgZWxlbWVudCQgPSBkb21Tb3VyY2Uuc2VsZWN0KCcuYmFyJykuZWxlbWVudHMoKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBtb2NrZWQgRE9NIFNvdXJjZSBzdXBwb3J0cyBpc29sYXRpb24uIEl0IGhhcyB0aGUgZnVuY3Rpb25zIGBpc29sYXRlU2lua2BcbiAqIGFuZCBgaXNvbGF0ZVNvdXJjZWAgYXR0YWNoZWQgdG8gaXQsIGFuZCBwZXJmb3JtcyBzaW1wbGUgaXNvbGF0aW9uIHVzaW5nXG4gKiBjbGFzc05hbWVzLiAqaXNvbGF0ZVNpbmsqIHdpdGggc2NvcGUgYGZvb2Agd2lsbCBhcHBlbmQgdGhlIGNsYXNzIGBfX19mb29gIHRvXG4gKiB0aGUgc3RyZWFtIG9mIHZpcnR1YWwgRE9NIG5vZGVzLCBhbmQgKmlzb2xhdGVTb3VyY2UqIHdpdGggc2NvcGUgYGZvb2Agd2lsbFxuICogcGVyZm9ybSBhIGNvbnZlbnRpb25hbCBgbW9ja2VkRE9NU291cmNlLnNlbGVjdCgnLl9fZm9vJylgIGNhbGwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vY2tDb25maWcgYW4gb2JqZWN0IHdoZXJlIGtleXMgYXJlIHNlbGVjdG9yIHN0cmluZ3NcbiAqIGFuZCB2YWx1ZXMgYXJlIG9iamVjdHMuIFRob3NlIG5lc3RlZCBvYmplY3RzIGhhdmUgYGV2ZW50VHlwZWAgc3RyaW5ncyBhcyBrZXlzXG4gKiBhbmQgdmFsdWVzIGFyZSBzdHJlYW1zIHlvdSBjcmVhdGVkLlxuICogQHJldHVybiB7T2JqZWN0fSBmYWtlIERPTSBzb3VyY2Ugb2JqZWN0LCB3aXRoIGFuIEFQSSBjb250YWluaW5nIGBzZWxlY3QoKWBcbiAqIGFuZCBgZXZlbnRzKClgIGFuZCBgZWxlbWVudHMoKWAgd2hpY2ggY2FuIGJlIHVzZWQganVzdCBsaWtlIHRoZSBET00gRHJpdmVyJ3NcbiAqIERPTVNvdXJjZS5cbiAqXG4gKiBAZnVuY3Rpb24gbW9ja0RPTVNvdXJjZVxuICovXG52YXIgbW9ja0RPTVNvdXJjZV8xID0gcmVxdWlyZSgnLi9tb2NrRE9NU291cmNlJyk7XG5leHBvcnRzLm1vY2tET01Tb3VyY2UgPSBtb2NrRE9NU291cmNlXzEubW9ja0RPTVNvdXJjZTtcbi8qKlxuICogVGhlIGh5cGVyc2NyaXB0IGZ1bmN0aW9uIGBoKClgIGlzIGEgZnVuY3Rpb24gdG8gY3JlYXRlIHZpcnR1YWwgRE9NIG9iamVjdHMsXG4gKiBhbHNvIGtub3duIGFzIFZOb2Rlcy4gQ2FsbFxuICpcbiAqIGBgYGpzXG4gKiBoKCdkaXYubXlDbGFzcycsIHtzdHlsZToge2NvbG9yOiAncmVkJ319LCBbXSlcbiAqIGBgYFxuICpcbiAqIHRvIGNyZWF0ZSBhIFZOb2RlIHRoYXQgcmVwcmVzZW50cyBhIGBESVZgIGVsZW1lbnQgd2l0aCBjbGFzc05hbWUgYG15Q2xhc3NgLFxuICogc3R5bGVkIHdpdGggcmVkIGNvbG9yLCBhbmQgbm8gY2hpbGRyZW4gYmVjYXVzZSB0aGUgYFtdYCBhcnJheSB3YXMgcGFzc2VkLiBUaGVcbiAqIEFQSSBpcyBgaCh0YWdPclNlbGVjdG9yLCBvcHRpb25hbERhdGEsIG9wdGlvbmFsQ2hpbGRyZW5PclRleHQpYC5cbiAqXG4gKiBIb3dldmVyLCB1c3VhbGx5IHlvdSBzaG91bGQgdXNlIFwiaHlwZXJzY3JpcHQgaGVscGVyc1wiLCB3aGljaCBhcmUgc2hvcnRjdXRcbiAqIGZ1bmN0aW9ucyBiYXNlZCBvbiBoeXBlcnNjcmlwdC4gVGhlcmUgaXMgb25lIGh5cGVyc2NyaXB0IGhlbHBlciBmdW5jdGlvbiBmb3JcbiAqIGVhY2ggRE9NIHRhZ05hbWUsIHN1Y2ggYXMgYGgxKClgLCBgaDIoKWAsIGBkaXYoKWAsIGBzcGFuKClgLCBgbGFiZWwoKWAsXG4gKiBgaW5wdXQoKWAuIEZvciBpbnN0YW5jZSwgdGhlIHByZXZpb3VzIGV4YW1wbGUgY291bGQgaGF2ZSBiZWVuIHdyaXR0ZW5cbiAqIGFzOlxuICpcbiAqIGBgYGpzXG4gKiBkaXYoJy5teUNsYXNzJywge3N0eWxlOiB7Y29sb3I6ICdyZWQnfX0sIFtdKVxuICogYGBgXG4gKlxuICogVGhlcmUgYXJlIGFsc28gU1ZHIGhlbHBlciBmdW5jdGlvbnMsIHdoaWNoIGFwcGx5IHRoZSBhcHByb3ByaWF0ZSBTVkdcbiAqIG5hbWVzcGFjZSB0byB0aGUgcmVzdWx0aW5nIGVsZW1lbnRzLiBgc3ZnKClgIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIHRvcC1tb3N0XG4gKiBTVkcgZWxlbWVudCwgYW5kIGBzdmcuZ2AsIGBzdmcucG9seWdvbmAsIGBzdmcuY2lyY2xlYCwgYHN2Zy5wYXRoYCBhcmUgZm9yXG4gKiBTVkctc3BlY2lmaWMgY2hpbGQgZWxlbWVudHMuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHN2Zyh7d2lkdGg6IDE1MCwgaGVpZ2h0OiAxNTB9LCBbXG4gKiAgIHN2Zy5wb2x5Z29uKHtcbiAqICAgICBhdHRyczoge1xuICogICAgICAgY2xhc3M6ICd0cmlhbmdsZScsXG4gKiAgICAgICBwb2ludHM6ICcyMCAwIDIwIDE1MCAxNTAgMjAnXG4gKiAgICAgfVxuICogICB9KVxuICogXSlcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvbiBoXG4gKi9cbnZhciBoeXBlcnNjcmlwdF8xID0gcmVxdWlyZSgnLi9oeXBlcnNjcmlwdCcpO1xuZXhwb3J0cy5oID0gaHlwZXJzY3JpcHRfMS5oO1xudmFyIGh5cGVyc2NyaXB0X2hlbHBlcnNfMSA9IHJlcXVpcmUoJy4vaHlwZXJzY3JpcHQtaGVscGVycycpO1xuZXhwb3J0cy5zdmcgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdmc7XG5leHBvcnRzLmEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hO1xuZXhwb3J0cy5hYmJyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYWJicjtcbmV4cG9ydHMuYWRkcmVzcyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmFkZHJlc3M7XG5leHBvcnRzLmFyZWEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hcmVhO1xuZXhwb3J0cy5hcnRpY2xlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYXJ0aWNsZTtcbmV4cG9ydHMuYXNpZGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hc2lkZTtcbmV4cG9ydHMuYXVkaW8gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hdWRpbztcbmV4cG9ydHMuYiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmI7XG5leHBvcnRzLmJhc2UgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iYXNlO1xuZXhwb3J0cy5iZGkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iZGk7XG5leHBvcnRzLmJkbyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJkbztcbmV4cG9ydHMuYmxvY2txdW90ZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJsb2NrcXVvdGU7XG5leHBvcnRzLmJvZHkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ib2R5O1xuZXhwb3J0cy5iciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJyO1xuZXhwb3J0cy5idXR0b24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5idXR0b247XG5leHBvcnRzLmNhbnZhcyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNhbnZhcztcbmV4cG9ydHMuY2FwdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNhcHRpb247XG5leHBvcnRzLmNpdGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5jaXRlO1xuZXhwb3J0cy5jb2RlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuY29kZTtcbmV4cG9ydHMuY29sID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuY29sO1xuZXhwb3J0cy5jb2xncm91cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNvbGdyb3VwO1xuZXhwb3J0cy5kZCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRkO1xuZXhwb3J0cy5kZWwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kZWw7XG5leHBvcnRzLmRmbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRmbjtcbmV4cG9ydHMuZGlyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGlyO1xuZXhwb3J0cy5kaXYgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kaXY7XG5leHBvcnRzLmRsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGw7XG5leHBvcnRzLmR0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZHQ7XG5leHBvcnRzLmVtID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZW07XG5leHBvcnRzLmVtYmVkID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZW1iZWQ7XG5leHBvcnRzLmZpZWxkc2V0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZmllbGRzZXQ7XG5leHBvcnRzLmZpZ2NhcHRpb24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5maWdjYXB0aW9uO1xuZXhwb3J0cy5maWd1cmUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5maWd1cmU7XG5leHBvcnRzLmZvb3RlciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmZvb3RlcjtcbmV4cG9ydHMuZm9ybSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmZvcm07XG5leHBvcnRzLmgxID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDE7XG5leHBvcnRzLmgyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDI7XG5leHBvcnRzLmgzID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDM7XG5leHBvcnRzLmg0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDQ7XG5leHBvcnRzLmg1ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDU7XG5leHBvcnRzLmg2ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDY7XG5leHBvcnRzLmhlYWQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5oZWFkO1xuZXhwb3J0cy5oZWFkZXIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5oZWFkZXI7XG5leHBvcnRzLmhncm91cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmhncm91cDtcbmV4cG9ydHMuaHIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ocjtcbmV4cG9ydHMuaHRtbCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmh0bWw7XG5leHBvcnRzLmkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pO1xuZXhwb3J0cy5pZnJhbWUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pZnJhbWU7XG5leHBvcnRzLmltZyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmltZztcbmV4cG9ydHMuaW5wdXQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pbnB1dDtcbmV4cG9ydHMuaW5zID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaW5zO1xuZXhwb3J0cy5rYmQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5rYmQ7XG5leHBvcnRzLmtleWdlbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmtleWdlbjtcbmV4cG9ydHMubGFiZWwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5sYWJlbDtcbmV4cG9ydHMubGVnZW5kID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubGVnZW5kO1xuZXhwb3J0cy5saSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmxpO1xuZXhwb3J0cy5saW5rID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubGluaztcbmV4cG9ydHMubWFpbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1haW47XG5leHBvcnRzLm1hcCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1hcDtcbmV4cG9ydHMubWFyayA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1hcms7XG5leHBvcnRzLm1lbnUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5tZW51O1xuZXhwb3J0cy5tZXRhID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubWV0YTtcbmV4cG9ydHMubmF2ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubmF2O1xuZXhwb3J0cy5ub3NjcmlwdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm5vc2NyaXB0O1xuZXhwb3J0cy5vYmplY3QgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5vYmplY3Q7XG5leHBvcnRzLm9sID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQub2w7XG5leHBvcnRzLm9wdGdyb3VwID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQub3B0Z3JvdXA7XG5leHBvcnRzLm9wdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm9wdGlvbjtcbmV4cG9ydHMucCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnA7XG5leHBvcnRzLnBhcmFtID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucGFyYW07XG5leHBvcnRzLnByZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnByZTtcbmV4cG9ydHMucHJvZ3Jlc3MgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5wcm9ncmVzcztcbmV4cG9ydHMucSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnE7XG5leHBvcnRzLnJwID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucnA7XG5leHBvcnRzLnJ0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucnQ7XG5leHBvcnRzLnJ1YnkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ydWJ5O1xuZXhwb3J0cy5zID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucztcbmV4cG9ydHMuc2FtcCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNhbXA7XG5leHBvcnRzLnNjcmlwdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNjcmlwdDtcbmV4cG9ydHMuc2VjdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNlY3Rpb247XG5leHBvcnRzLnNlbGVjdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNlbGVjdDtcbmV4cG9ydHMuc21hbGwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zbWFsbDtcbmV4cG9ydHMuc291cmNlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc291cmNlO1xuZXhwb3J0cy5zcGFuID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3BhbjtcbmV4cG9ydHMuc3Ryb25nID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3Ryb25nO1xuZXhwb3J0cy5zdHlsZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnN0eWxlO1xuZXhwb3J0cy5zdWIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdWI7XG5leHBvcnRzLnN1cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnN1cDtcbmV4cG9ydHMudGFibGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50YWJsZTtcbmV4cG9ydHMudGJvZHkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50Ym9keTtcbmV4cG9ydHMudGQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50ZDtcbmV4cG9ydHMudGV4dGFyZWEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50ZXh0YXJlYTtcbmV4cG9ydHMudGZvb3QgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50Zm9vdDtcbmV4cG9ydHMudGggPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aDtcbmV4cG9ydHMudGhlYWQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aGVhZDtcbmV4cG9ydHMudGl0bGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aXRsZTtcbmV4cG9ydHMudHIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50cjtcbmV4cG9ydHMudSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnU7XG5leHBvcnRzLnVsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudWw7XG5leHBvcnRzLnZpZGVvID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudmlkZW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXdTY29wZSgpIHtcbiAgICByZXR1cm4gXCJjeWNsZVwiICsgKytjb3VudGVyO1xufVxuZnVuY3Rpb24gY2hlY2tJc29sYXRlQXJncyhkYXRhZmxvd0NvbXBvbmVudCwgc2NvcGUpIHtcbiAgICBpZiAodHlwZW9mIGRhdGFmbG93Q29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gaXNvbGF0ZSgpIG11c3QgYmUgYSBcIiArXG4gICAgICAgICAgICBcIidkYXRhZmxvd0NvbXBvbmVudCcgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGlmIChzY29wZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgZ2l2ZW4gdG8gaXNvbGF0ZSgpIG11c3Qgbm90IGJlIG51bGxcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNvbGF0ZUFsbFNvdXJjZXMoc291cmNlcywgc2NvcGUpIHtcbiAgICB2YXIgc2NvcGVkU291cmNlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2VzKSB7XG4gICAgICAgIGlmIChzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkgJiYgc291cmNlc1trZXldXG4gICAgICAgICAgICAmJiB0eXBlb2Ygc291cmNlc1trZXldLmlzb2xhdGVTb3VyY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2NvcGVkU291cmNlc1trZXldID0gc291cmNlc1trZXldLmlzb2xhdGVTb3VyY2Uoc291cmNlc1trZXldLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBzY29wZWRTb3VyY2VzW2tleV0gPSBzb3VyY2VzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNvdXJjZXM7XG59XG5mdW5jdGlvbiBpc29sYXRlQWxsU2lua3Moc291cmNlcywgc2lua3MsIHNjb3BlKSB7XG4gICAgdmFyIHNjb3BlZFNpbmtzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHNpbmtzKSB7XG4gICAgICAgIGlmIChzaW5rcy5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAmJiBzb3VyY2VzW2tleV1cbiAgICAgICAgICAgICYmIHR5cGVvZiBzb3VyY2VzW2tleV0uaXNvbGF0ZVNpbmsgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2NvcGVkU2lua3Nba2V5XSA9IHNvdXJjZXNba2V5XS5pc29sYXRlU2luayhzaW5rc1trZXldLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2lua3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgc2NvcGVkU2lua3Nba2V5XSA9IHNpbmtzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNpbmtzO1xufVxuLyoqXG4gKiBUYWtlcyBhIGBkYXRhZmxvd0NvbXBvbmVudGAgZnVuY3Rpb24gYW5kIGFuIG9wdGlvbmFsIGBzY29wZWAgc3RyaW5nLCBhbmRcbiAqIHJldHVybnMgYSBzY29wZWQgdmVyc2lvbiBvZiB0aGUgYGRhdGFmbG93Q29tcG9uZW50YCBmdW5jdGlvbi5cbiAqXG4gKiBXaGVuIHRoZSBzY29wZWQgZGF0YWZsb3cgY29tcG9uZW50IGlzIGludm9rZWQsIGVhY2ggc291cmNlIHByb3ZpZGVkIHRvIHRoZVxuICogc2NvcGVkIGRhdGFmbG93Q29tcG9uZW50IGlzIGlzb2xhdGVkIHRvIHRoZSBzY29wZSB1c2luZ1xuICogYHNvdXJjZS5pc29sYXRlU291cmNlKHNvdXJjZSwgc2NvcGUpYCwgaWYgcG9zc2libGUuIExpa2V3aXNlLCB0aGUgc2lua3NcbiAqIHJldHVybmVkIGZyb20gdGhlIHNjb3BlZCBkYXRhZmxvdyBjb21wb25lbnQgYXJlIGlzb2xhdGUgdG8gdGhlIHNjb3BlIHVzaW5nXG4gKiBgc291cmNlLmlzb2xhdGVTaW5rKHNpbmssIHNjb3BlKWAuXG4gKlxuICogSWYgdGhlIGBzY29wZWAgaXMgbm90IHByb3ZpZGVkLCBhIG5ldyBzY29wZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZC5cbiAqIFRoaXMgbWVhbnMgdGhhdCB3aGlsZSAqKmBpc29sYXRlKGRhdGFmbG93Q29tcG9uZW50LCBzY29wZSlgIGlzIHB1cmUqKlxuICogKHJlZmVyZW50aWFsbHkgdHJhbnNwYXJlbnQpLCAqKmBpc29sYXRlKGRhdGFmbG93Q29tcG9uZW50KWAgaXMgaW1wdXJlKipcbiAqIChub3QgcmVmZXJlbnRpYWxseSB0cmFuc3BhcmVudCkuIFR3byBjYWxscyB0byBgaXNvbGF0ZShGb28sIGJhcilgIHdpbGxcbiAqIGdlbmVyYXRlIHR3byBpbmRpc3RpbmN0IGRhdGFmbG93IGNvbXBvbmVudHMuIEJ1dCwgdHdvIGNhbGxzIHRvIGBpc29sYXRlKEZvbylgXG4gKiB3aWxsIGdlbmVyYXRlIHR3byBkaXN0aW5jdCBkYXRhZmxvdyBjb21wb25lbnRzLlxuICpcbiAqIE5vdGUgdGhhdCBib3RoIGBpc29sYXRlU291cmNlKClgIGFuZCBgaXNvbGF0ZVNpbmsoKWAgYXJlIHN0YXRpYyBtZW1iZXJzIG9mXG4gKiBgc291cmNlYC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IGRyaXZlcnMgcHJvZHVjZSBgc291cmNlYCB3aGlsZSB0aGVcbiAqIGFwcGxpY2F0aW9uIHByb2R1Y2VzIGBzaW5rYCwgYW5kIGl0J3MgdGhlIGRyaXZlcidzIHJlc3BvbnNpYmlsaXR5IHRvXG4gKiBpbXBsZW1lbnQgYGlzb2xhdGVTb3VyY2UoKWAgYW5kIGBpc29sYXRlU2luaygpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkYXRhZmxvd0NvbXBvbmVudCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYHNvdXJjZXNgIGFzIGlucHV0XG4gKiBhbmQgb3V0cHV0cyBhIGNvbGxlY3Rpb24gb2YgYHNpbmtzYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzY29wZSBhbiBvcHRpb25hbCBzdHJpbmcgdGhhdCBpcyB1c2VkIHRvIGlzb2xhdGUgZWFjaFxuICogYHNvdXJjZXNgIGFuZCBgc2lua3NgIHdoZW4gdGhlIHJldHVybmVkIHNjb3BlZCBkYXRhZmxvdyBjb21wb25lbnQgaXMgaW52b2tlZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgc2NvcGVkIGRhdGFmbG93IGNvbXBvbmVudCBmdW5jdGlvbiB0aGF0LCBhcyB0aGVcbiAqIG9yaWdpbmFsIGBkYXRhZmxvd0NvbXBvbmVudGAgZnVuY3Rpb24sIHRha2VzIGBzb3VyY2VzYCBhbmQgcmV0dXJucyBgc2lua3NgLlxuICogQGZ1bmN0aW9uIGlzb2xhdGVcbiAqL1xuZnVuY3Rpb24gaXNvbGF0ZShjb21wb25lbnQsIHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBuZXdTY29wZSgpOyB9XG4gICAgY2hlY2tJc29sYXRlQXJncyhjb21wb25lbnQsIHNjb3BlKTtcbiAgICB2YXIgY29udmVydGVkU2NvcGUgPSB0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnID8gc2NvcGUgOiBzY29wZS50b1N0cmluZygpO1xuICAgIHJldHVybiBmdW5jdGlvbiBzY29wZWRDb21wb25lbnQoc291cmNlcykge1xuICAgICAgICB2YXIgcmVzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcmVzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcGVkU291cmNlcyA9IGlzb2xhdGVBbGxTb3VyY2VzKHNvdXJjZXMsIGNvbnZlcnRlZFNjb3BlKTtcbiAgICAgICAgdmFyIHNpbmtzID0gY29tcG9uZW50LmFwcGx5KHZvaWQgMCwgW3Njb3BlZFNvdXJjZXNdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIHZhciBzY29wZWRTaW5rcyA9IGlzb2xhdGVBbGxTaW5rcyhzb3VyY2VzLCBzaW5rcywgY29udmVydGVkU2NvcGUpO1xuICAgICAgICByZXR1cm4gc2NvcGVkU2lua3M7XG4gICAgfTtcbn1cbmlzb2xhdGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudGVyID0gMDsgfTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzb2xhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2lzb2xhdGUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCAqIGZyb20gXCIuL2ljb25UeXBlXCI7XG5cbmV4cG9ydCBlbnVtIFNpemUge1xuICBNaW5pLCBUaW55LCBTbWFsbCwgTWVkaXVtLCBMYXJnZSwgQmlnLCBIdWdlLCBNYXNzaXZlLCBGbHVpZFxufVxuXG5leHBvcnQgbmFtZXNwYWNlIFNpemUge1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUoc2l6ZTogU2l6ZSkge1xuICAgIHN3aXRjaChzaXplKSB7XG4gICAgICBjYXNlIFNpemUuTWluaTogcmV0dXJuIFwiIG1pbmlcIjtcbiAgICAgIGNhc2UgU2l6ZS5UaW55OiByZXR1cm4gXCIgdGlueVwiO1xuICAgICAgY2FzZSBTaXplLlNtYWxsOiByZXR1cm4gXCIgc21hbGxcIjtcbiAgICAgIGNhc2UgU2l6ZS5NZWRpdW06IHJldHVybiBcIiBtZWRpdW1cIjtcbiAgICAgIGNhc2UgU2l6ZS5MYXJnZTogcmV0dXJuIFwiIGxhcmdlXCI7XG4gICAgICBjYXNlIFNpemUuQmlnOiByZXR1cm4gXCIgYmlnXCI7XG4gICAgICBjYXNlIFNpemUuSHVnZTogcmV0dXJuIFwiIGh1Z2VcIjtcbiAgICAgIGNhc2UgU2l6ZS5NYXNzaXZlOiByZXR1cm4gXCIgbWFzc2l2ZVwiO1xuICAgICAgY2FzZSBTaXplLkZsdWlkOiByZXR1cm4gXCIgZmx1aWRcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBWZXJ0aWNhbEFsaWdubWVudCB7XG4gIFRvcCwgTWlkZGxlLCBCb3R0b21cbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZXJ0aWNhbEFsaWdubWVudCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShhbGlnbm1lbnQ6IFZlcnRpY2FsQWxpZ25tZW50KSB7XG4gICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuVG9wOiByZXR1cm4gXCIgdG9wIGFsaWduZWRcIjtcbiAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuTWlkZGxlOiByZXR1cm4gXCIgbWlkZGxlIGFsaWduZWRcIjtcbiAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOiByZXR1cm4gXCIgYm90dG9tIGFsaWduZWRcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBUZXh0QWxpZ25tZW50IHtcbiAgTGVmdCwgUmlnaHQsIENlbnRlciwgSnVzdGlmaWVkXG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGV4dEFsaWdubWVudCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShhbGlnbm1lbnQ6IFRleHRBbGlnbm1lbnQpIHtcbiAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgY2FzZSBUZXh0QWxpZ25tZW50LkxlZnQ6IHJldHVybiBcIiBsZWZ0IGFsaWduZWQuXCI7XG4gICAgICBjYXNlIFRleHRBbGlnbm1lbnQuUmlnaHQ6IHJldHVybiBcIiByaWdodCBhbGlnbmVkLlwiO1xuICAgICAgY2FzZSBUZXh0QWxpZ25tZW50LkNlbnRlcjogcmV0dXJuIFwiIGNlbnRlciBhbGlnbmVkXCI7XG4gICAgICBjYXNlIFRleHRBbGlnbm1lbnQuSnVzdGlmaWVkOiByZXR1cm4gXCIganVzdGlmaWVkXCI7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gRmxvYXQge1xuICBOb25lLCBSaWdodCwgTGVmdFxufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZsb2F0IHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGZsb2F0OiBGbG9hdCkge1xuICAgIHN3aXRjaCAoZmxvYXQpXG4gICAge1xuICAgICAgY2FzZSBGbG9hdC5MZWZ0OiByZXR1cm4gXCIgbGVmdCBmbG9hdGVkXCI7XG4gICAgICBjYXNlIEZsb2F0LlJpZ2h0OiByZXR1cm4gXCIgcmlnaHQgZmxvYXRlZFwiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBlbnVtIEF0dGFjaG1lbnQge1xuTm9uZSwgVG9wLCBUb3BSaWdodCwgVG9wTGVmdCwgQm90dG9tLCBCb3R0b21MZWZ0LCBCb3R0b21SaWdodCwgUmlnaHQsIExlZnRcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQpIHtcbiAgICBzd2l0Y2ggKGF0dGFjaG1lbnQpIHtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Ob25lOiByZXR1cm4gXCIgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Ub3A6IHJldHVybiBcIiB0b3AgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Cb3R0b206IHJldHVybiBcIiBib3R0b20gYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5MZWZ0OiByZXR1cm4gXCIgbGVmdCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LlJpZ2h0OiByZXR1cm4gXCIgcmlnaHQgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Ub3BSaWdodDogcmV0dXJuIFwiIHRvcCByaWdodCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LlRvcExlZnQ6IHJldHVybiBcIiB0b3AgbGVmdCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LkJvdHRvbUxlZnQ6IHJldHVybiBcIiBib3R0b20gbGVmdCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LkJvdHRvbVJpZ2h0OiByZXR1cm4gXCIgYm90dG9tIHJpZ2h0IGF0dGFjaGVkXCI7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gQ29sb3Ige1xuICBOb25lLCBQcmltYXJ5LCBTZWNvbmRhcnksIFN1Y2Nlc3MsIEluZm8sIFdhcm5pbmcsIEVycm9yXG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29sb3Ige1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUoY29sb3I6IENvbG9yKSB7XG4gICAgc3dpdGNoIChjb2xvcikge1xuICAgICAgY2FzZSBDb2xvci5QcmltYXJ5OiByZXR1cm4gXCIgcHJpbWFyeUNvbG9yZWRcIjtcbiAgICAgIGNhc2UgQ29sb3IuU2Vjb25kYXJ5OiByZXR1cm4gXCIgc2Vjb25kYXJ5Q29sb3JlZFwiO1xuICAgICAgY2FzZSBDb2xvci5TdWNjZXNzOiByZXR1cm4gXCIgc3VjY2Vzc0NvbG9yZWRcIjtcbiAgICAgIGNhc2UgQ29sb3IuSW5mbzogcmV0dXJuIFwiIGluZm9Db2xvcmVkXCI7XG4gICAgICBjYXNlIENvbG9yLldhcm5pbmc6IHJldHVybiBcIiB3YXJuaW5nQ29sb3JlZFwiO1xuICAgICAgY2FzZSBDb2xvci5FcnJvcjogcmV0dXJuIFwiIGVycm9yQ29sb3JlZCBcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBBbmltYXRpb24ge1xuICBCcm93c2UsIERyb3AsIEZhZGUsIEZsaXAsIFNjYWxlLCBGbHksIFNsaWRlLCBTd2luZyxcbiAgRmxhc2gsIFNoYWtlLCBCb3VuY2UsIFRhZGEsIFB1bHNlLCBKaWdnbGUsXG4gIE5vbmVcbn1cbmV4cG9ydCBuYW1lc3BhY2UgQW5pbWF0aW9uIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGFuaW06IEFuaW1hdGlvbikge1xuICAgIHN3aXRjaCAoYW5pbSlcbiAgICB7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5Ccm93c2U6IHJldHVybiBcIiBicm93c2VcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkRyb3A6IHJldHVybiBcIiBkcm9wXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5GYWRlOiByZXR1cm4gXCIgZmFkZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uRmxpcDogcmV0dXJuIFwiIGZsaXBcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLlNjYWxlOiByZXR1cm4gXCIgc2NhbGVcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkZseTogcmV0dXJuIFwiIGZseVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uU2xpZGU6IHJldHVybiBcIiBzbGlkZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uU3dpbmc6IHJldHVybiBcIiBzd2luZ1wiO1xuICAgICAgY2FzZSBBbmltYXRpb24uRmxhc2g6IHJldHVybiBcIiBmbGFzaFwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uU2hha2U6IHJldHVybiBcIiBzaGFrZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uQm91bmNlOiByZXR1cm4gXCIgYm91bmNlXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5UYWRhOiByZXR1cm4gXCIgdGFkYVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uUHVsc2U6IHJldHVybiBcIiBwdWxzZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uSmlnZ2xlOiByZXR1cm4gXCIgamlnZ2xlXCI7XG4gICAgfVxuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBpc1N0YXRpYyhhbmltOiBBbmltYXRpb24pOiBCb29sZWFuIHtcbiAgICBjb25zdCBzdGF0aWNBbmltYXRpb25zID0gW0FuaW1hdGlvbi5GbGFzaCwgQW5pbWF0aW9uLlNoYWtlLFxuICAgICAgQW5pbWF0aW9uLkJvdW5jZSwgQW5pbWF0aW9uLlRhZGEsIEFuaW1hdGlvbi5QdWxzZSwgQW5pbWF0aW9uLkppZ2dsZV07XG4gICAgcmV0dXJuIHN0YXRpY0FuaW1hdGlvbnMuaW5kZXhPZihhbmltKSAhPT0gLTE7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIGlzRGlyZWN0aW9uYWwoYW5pbTogQW5pbWF0aW9uKTogQm9vbGVhbiB7XG4gICAgY29uc3QgZGlyZWN0aW9uQW5pbWF0aW9ucyA9IFtBbmltYXRpb24uQnJvd3NlLCBBbmltYXRpb24uRmFkZSxcbiAgICAgIEFuaW1hdGlvbi5GbHksIEFuaW1hdGlvbi5TbGlkZSwgQW5pbWF0aW9uLlN3aW5nXTtcbiAgICByZXR1cm4gZGlyZWN0aW9uQW5pbWF0aW9ucy5pbmRleE9mKGFuaW0pICE9PSAtMTtcbiAgfVxufVxuXG5leHBvcnQgZW51bSBEaXJlY3Rpb24ge1xuICBJbiwgT3V0LCBOb25lXG59XG5leHBvcnQgbmFtZXNwYWNlIERpcmVjdGlvbiB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZSAoZGlyZWN0aW9uOiBEaXJlY3Rpb24pe1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5JbiA/IFwiIGluXCIgOiBcIiBvdXRcIjtcbiAgfVxufVxuXG5leHBvcnQgZW51bSBBbmltYXRpb25EaXJlY3Rpb24ge1xuICBVcCwgRG93biwgTGVmdCwgUmlnaHRcbn1cbmV4cG9ydCBuYW1lc3BhY2UgQW5pbWF0aW9uRGlyZWN0aW9uIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGRpcjogQW5pbWF0aW9uRGlyZWN0aW9uKSB7XG4gICAgc3dpdGNoIChkaXIpIHtcbiAgICAgIGNhc2UgQW5pbWF0aW9uRGlyZWN0aW9uLlVwOiByZXR1cm4gXCIgdXBcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uRGlyZWN0aW9uLkRvd246IHJldHVybiBcIiBkb3duXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbkRpcmVjdGlvbi5MZWZ0OiByZXR1cm4gXCIgbGVmdFwiO1xuICAgICAgY2FzZSBBbmltYXRpb25EaXJlY3Rpb24uUmlnaHQ6IHJldHVybiBcIiByaWdodFwiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZW51bXMvaW5kZXgudHMiLCJpbXBvcnQge0RPTVNvdXJjZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmV4cG9ydCB7RE9NU291cmNlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHtWTm9kZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmV4cG9ydCB7Vk5vZGV9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMsIHtTdHJlYW19IGZyb20gXCJ4c3RyZWFtXCI7XG5cbmV4cG9ydCB0eXBlIERPTUNvbnRlbnQgPSBTdHJpbmcgfCBWTm9kZVtdO1xuZXhwb3J0IHR5cGUgRXZlbnRTZWxlY3RvciA9ICh0eXBlOnN0cmluZykgPT4gU3RyZWFtPEV2ZW50PjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRE9NQ29udGVudChjb250ZW50KSA6IGNvbnRlbnQgaXMgRE9NQ29udGVudCB7XG4gIGlmICghY29udGVudCl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YoY29udGVudCkgPT09IFwic3RyaW5nXCIpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YoQXJyYXkpKSB7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZW50WzBdLnNlbCAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UCxDPiB7XG4gIERPTTogRE9NU291cmNlO1xuICBwcm9wcyQ/OiB4czxQPjtcbiAgY29udGVudCQ/OiB4czxDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UCxDLEU+IHtcbiAgRE9NOiBET01Tb3VyY2U7XG4gIHByb3BzJD86IHhzPFA+O1xuICBjb250ZW50JD86IHhzPEM+O1xuICBleHRyYXMkPzogeHM8RT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFQsQSxDPiB7XG4gIERPTTogRE9NU291cmNlO1xuICB0YXJnZXQkOiB4czxUPjtcbiAgYXJncyQ/OiB4czxBPjtcbiAgY29udGVudCQ/OiB4czxDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gIERPTTogeHM8Vk5vZGU+O1xuICBFdmVudHM6IEV2ZW50U2VsZWN0b3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZhbHVlQ29tcG9uZW50U2lua3M8Vj4gZXh0ZW5kcyBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gIHZhbHVlJDogeHM8Vj47XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW50ZXJmYWNlcy9pbmRleC50cyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciBYU3RyZWFtQWRhcHRlciA9IHtcbiAgICBhZGFwdDogZnVuY3Rpb24gKG9yaWdpblN0cmVhbSwgb3JpZ2luU3RyZWFtU3Vic2NyaWJlKSB7XG4gICAgICAgIGlmIChYU3RyZWFtQWRhcHRlci5pc1ZhbGlkU3RyZWFtKG9yaWdpblN0cmVhbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5TdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB2YXIgZGlzcG9zZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdC5jcmVhdGUoe1xuICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBvdXQ7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSA9IG9yaWdpblN0cmVhbVN1YnNjcmliZShvcmlnaW5TdHJlYW0sIG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1ha2VTdWJqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSB4c3RyZWFtXzEuZGVmYXVsdC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHgpIHsgc3RyZWFtLnNoYW1lZnVsbHlTZW5kTmV4dCh4KTsgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHN0cmVhbS5zaGFtZWZ1bGx5U2VuZEVycm9yKGVycik7IH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyBzdHJlYW0uc2hhbWVmdWxseVNlbmRDb21wbGV0ZSgpOyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBvYnNlcnZlcjogb2JzZXJ2ZXIsIHN0cmVhbTogc3RyZWFtIH07XG4gICAgfSxcbiAgICByZW1lbWJlcjogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnJlbWVtYmVyKCk7XG4gICAgfSxcbiAgICBpc1ZhbGlkU3RyZWFtOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHN0cmVhbS5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHN0cmVhbS5zaGFtZWZ1bGx5U2VuZE5leHQgPT09ICdmdW5jdGlvbicpO1xuICAgIH0sXG4gICAgc3RyZWFtU3Vic2NyaWJlOiBmdW5jdGlvbiAoc3RyZWFtLCBvYnNlcnZlcikge1xuICAgICAgICBzdHJlYW0uYWRkTGlzdGVuZXIob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyZWFtLnJlbW92ZUxpc3RlbmVyKG9ic2VydmVyKTsgfTtcbiAgICB9LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFhTdHJlYW1BZGFwdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS94c3RyZWFtLWFkYXB0ZXIvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZXhwb3J0cy5nZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBleHBvcnRzLnN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5hZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoID0gZXhwb3J0cy5pc0Fic29sdXRlUGF0aCA9IHVuZGVmaW5lZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpc0Fic29sdXRlUGF0aCA9IGV4cG9ydHMuaXNBYnNvbHV0ZVBhdGggPSBmdW5jdGlvbiBpc0Fic29sdXRlUGF0aChwYXRoKSB7XG4gIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbnZhciBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoID0gZXhwb3J0cy5hZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoID0gZnVuY3Rpb24gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBrZXksIHZhbHVlKSB7XG4gIHZhciBfcGFyc2VQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuXG4gIHZhciBwYXRobmFtZSA9IF9wYXJzZVBhdGgucGF0aG5hbWU7XG4gIHZhciBzZWFyY2ggPSBfcGFyc2VQYXRoLnNlYXJjaDtcbiAgdmFyIGhhc2ggPSBfcGFyc2VQYXRoLmhhc2g7XG5cblxuICByZXR1cm4gY3JlYXRlUGF0aCh7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoICsgKHNlYXJjaC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIGtleSArICc9JyArIHZhbHVlLFxuICAgIGhhc2g6IGhhc2hcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBleHBvcnRzLnN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZnVuY3Rpb24gc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHZhciBfcGFyc2VQYXRoMiA9IHBhcnNlUGF0aChwYXRoKTtcblxuICB2YXIgcGF0aG5hbWUgPSBfcGFyc2VQYXRoMi5wYXRobmFtZTtcbiAgdmFyIHNlYXJjaCA9IF9wYXJzZVBhdGgyLnNlYXJjaDtcbiAgdmFyIGhhc2ggPSBfcGFyc2VQYXRoMi5oYXNoO1xuXG5cbiAgcmV0dXJuIGNyZWF0ZVBhdGgoe1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaC5yZXBsYWNlKG5ldyBSZWdFeHAoJyhbPyZdKScgKyBrZXkgKyAnPVthLXpBLVowLTldKygmPyknKSwgZnVuY3Rpb24gKG1hdGNoLCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIHByZWZpeCA9PT0gJz8nID8gcHJlZml4IDogc3VmZml4O1xuICAgIH0pLFxuICAgIGhhc2g6IGhhc2hcbiAgfSk7XG59O1xuXG52YXIgZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5nZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBmdW5jdGlvbiBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHZhciBfcGFyc2VQYXRoMyA9IHBhcnNlUGF0aChwYXRoKTtcblxuICB2YXIgc2VhcmNoID0gX3BhcnNlUGF0aDMuc2VhcmNoO1xuXG4gIHZhciBtYXRjaCA9IHNlYXJjaC5tYXRjaChuZXcgUmVnRXhwKCdbPyZdJyArIGtleSArICc9KFthLXpBLVowLTldKyknKSk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn07XG5cbnZhciBleHRyYWN0UGF0aCA9IGZ1bmN0aW9uIGV4dHJhY3RQYXRoKHN0cmluZykge1xuICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oaHR0cHM/Oik/XFwvXFwvW15cXC9dKi8pO1xuICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IHN0cmluZyA6IHN0cmluZy5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbn07XG5cbnZhciBwYXJzZVBhdGggPSBleHBvcnRzLnBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IGV4dHJhY3RQYXRoKHBhdGgpO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkocGF0aCA9PT0gcGF0aG5hbWUsICdBIHBhdGggbXVzdCBiZSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggb25seSwgbm90IGEgZnVsbCBVUkwgbGlrZSBcIiVzXCInLCBwYXRoKSA6IHZvaWQgMDtcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICBpZiAocGF0aG5hbWUgPT09ICcnKSBwYXRobmFtZSA9ICcvJztcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoXG4gIH07XG59O1xuXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgaWYgKGxvY2F0aW9uID09IG51bGwgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoO1xuXG4gIGlmIChoYXNoKSBwYXRoICs9IGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtWTm9kZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB4cywge1N0cmVhbX0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBmbGF0dGVuQ29uY3VycmVudGx5IGZyb20gXCJ4c3RyZWFtL2V4dHJhL2ZsYXR0ZW5Db25jdXJyZW50bHlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoQ2xhc3NMaXN0KHRhcmdldDogVk5vZGUsIGNsYXNzZXM6IHN0cmluZ1tdLCBjbGFzc2VzVG9BZGQ6IHN0cmluZykge1xuICBsZXQgY2xhc3NOYW1lID0gXCJcIjtcbiAgaWYgKHRhcmdldC5kYXRhKSB7XG4gICAgbGV0IHByb3BzID0gdGFyZ2V0LmRhdGEucHJvcHMgPyB0YXJnZXQuZGF0YS5wcm9wcyA6IHsgY2xhc3NOYW1lOiB0YXJnZXQuc2VsLnNwbGl0KFwiLlwiKS5qb2luKFwiIFwiKX07XG4gICAgbGV0IGNsYXNzTGlzdCA9IHByb3BzLmNsYXNzTmFtZS5zcGxpdChcIiBcIikgYXMgQXJyYXk8c3RyaW5nPjtcbiAgICBjbGFzc0xpc3QuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSBpdGVtICsgXCIgXCI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xhc3NOYW1lICs9IGNsYXNzZXNUb0FkZDtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5kYXRhLCB7XG4gICAgXCJwcm9wc1wiOiB7XG4gICAgICBjbGFzc05hbWVcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEFkZHMgb25lIFZOb2RlIHRvIGFub3RoZXIgYW5kIGhhbmRsZXMgdXBkYXRlcyBmb3Igc3RyZWFtIGJ5IHJlcGxhY2luZyBiYXNlZCBvbiB0aGUgaWRlbnRpZmllciBjbGFzcy5cbiAqIEBwYXJhbSAge1ZOb2RlfSAgZWxlbWVudCAgICBUaGUgZWxlbWVudCB0byBiZSBhZGRlZC5cbiAqIEBwYXJhbSAge1ZOb2RlfSAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IGZvciB0aGUgZWxlbWVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmeWluZyBjbGFzcyBmb3IgdGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIHRhcmdldCBlbGVtZW50J3MgY2hpbGRyZW4gd2l0aCB0aGUgZWxlbWVudCBhZGRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVsZW1lbnQoZWxlbWVudDogVk5vZGUsIHRhcmdldDogVk5vZGUsIGlkZW50aWZpZXI6IHN0cmluZyk6IEFycmF5PFZOb2RlPiB7XG4gIGxldCBjID0gW107XG4gIGlmICh0YXJnZXQuY2hpbGRyZW4pIHtcbiAgICBjID0gdGFyZ2V0LmNoaWxkcmVuO1xuICB9XG4gIGlmICh0YXJnZXQudGV4dCkge1xuICAgIGMucHVzaCh0YXJnZXQudGV4dCk7XG4gIH1cbiAgZm9yKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGQgPSBjW2ldO1xuICAgIGxldCBjUHJvcHMgPSBjaGlsZC5kYXRhID8gY2hpbGQuZGF0YS5wcm9wcyA/IGNoaWxkLmRhdGEucHJvcHMgOiB7fSA6IHt9O1xuICAgIGlmICh0eXBlb2YoY2hpbGQpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZihjUHJvcHMuY2xhc3NOYW1lKSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB7XG4gICAgICBsZXQgY2xhc3NMaXN0ID0gY2hpbGQuZGF0YS5wcm9wcy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpIGFzIEFycmF5PHN0cmluZz47XG4gICAgICBmb3IgKGxldCBzIG9mIGNsYXNzTGlzdCkge1xuICAgICAgICBpZiAocyA9PT0gaWRlbnRpZmllcilcbiAgICAgICAge1xuICAgICAgICAgIGMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGMucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGM7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW55dGhpbmcgdG8gYSBzdHJlYW1cbiAqIEBwYXJhbSAge2FueX0gb2JqIC0gVGhlIG9iamVjdC5cbiAqIEByZXR1cm4ge1N0cmVhbTxhbnk+fSBUaGUgb2JqZWN0IGFzIGEgc3RyZWFtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNTdHJlYW0ob2JqKTogU3RyZWFtPGFueT4ge1xuICBpZiAodHlwZW9mKG9iaikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mKG9iai5hZGRMaXN0ZW5lcikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCIpe1xuICAgICAgICBsZXQgaXNTdHJlYW1zID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgc3Vib2JqIG9mIG9iaikge1xuICAgICAgICAgIGlmICh0eXBlb2Yoc3Vib2JqLmFkZExpc3RlbmVyKSAhPT0gXCJmdW5jdGlvblwiKXtcbiAgICAgICAgICAgIGlzU3RyZWFtcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJlYW1zKSB7XG4gICAgICAgICAgcmV0dXJuIHhzLmNvbWJpbmUuYXBwbHkodGhpcywgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geHMub2Yob2JqKTtcbiAgfVxuICByZXR1cm4geHMub2YoXCJcIik7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb2Ygb2JqZWN0cyB0byBhIHN0cmVhbSBvZiBhbiBBcnJheS5cbiAqIEBwYXJhbSAge2FueX0gLi4ub2JqcyAgIFRoZSBvYmplY3RzIHRvIGluY2x1ZGUgaW4gdGhlIHN0cmVhbVxuICogQHJldHVybiB7U3RyZWFtPGFueVtdPn0gVGhlIG9iamVjdHMgYXMgYSBzdHJlYW0gb2YgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0FycmF5U3RyZWFtKC4uLm9ianMpIDogU3RyZWFtPGFueVtdPiB7XG4gIGxldCBzdHJlYW1zID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICBzdHJlYW1zID0gc3RyZWFtcy5tYXAob2JqID0+IGFzU3RyZWFtKG9iaikpO1xuICByZXR1cm4geHMuY29tYmluZS5hcHBseSh0aGlzLCBzdHJlYW1zKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVucyBhIHN0cmVhbSBvZiBhbiBhcnJheSBvZiBzdHJlYW1zIGludG8gYSBzdHJlYW0gb2YgYW4gYXJyYXkuXG4gKiBAcGFyYW0gIHtTdHJlYW08U3RyZWFtPGFueT5bXT59IHN0cmVhbSBUaGUgc3RyZWFtIHRvIGZsYXR0ZW5cbiAqIEByZXR1cm4ge1N0cmVhbTxhbnlbXT59ICAgICAgICAgICAgICAgIFRoZSBmbGF0dGVuZWQgc3RyZWFtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblN0cmVhbUFycmF5KHN0cmVhbTogU3RyZWFtPFN0cmVhbTxhbnk+W10+KSA6IFN0cmVhbTxhbnlbXT4ge1xuICByZXR1cm4gZmxhdHRlbkNvbmN1cnJlbnRseShcbiAgICBzdHJlYW0ubWFwKGNoaWxkcmVuID0+IHhzLmNvbWJpbmUuYXBwbHkodGhpcywgY2hpbGRyZW4pXG4gIClcbiAgKSBhcyBTdHJlYW08YW55W10+O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgbmF0dXJhbCBudW1iZXIgYmV0d2VlbiAxLTE2IHRvIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICBUaGF0IG51bWJlciBhcyB0ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtVG9UZXh0KG51bTogbnVtYmVyKSA6IHN0cmluZyB7XG4gIHN3aXRjaChudW0pIHtcbiAgICBjYXNlIDE6IHJldHVybiBcIiBvbmVcIjtcbiAgICBjYXNlIDI6IHJldHVybiBcIiB0d29cIjtcbiAgICBjYXNlIDM6IHJldHVybiBcIiB0aHJlZVwiO1xuICAgIGNhc2UgNDogcmV0dXJuIFwiIGZvdXJcIjtcbiAgICBjYXNlIDU6IHJldHVybiBcIiBmaXZlXCI7XG4gICAgY2FzZSA2OiByZXR1cm4gXCIgc2l4XCI7XG4gICAgY2FzZSA3OiByZXR1cm4gXCIgc2V2ZW5cIjtcbiAgICBjYXNlIDg6IHJldHVybiBcIiBlaWdodFwiO1xuICAgIGNhc2UgOTogcmV0dXJuIFwiIG5pbmVcIjtcbiAgICBjYXNlIDEwOiByZXR1cm4gXCIgdGVuXCI7XG4gICAgY2FzZSAxMTogcmV0dXJuIFwiIGVsZXZlblwiO1xuICAgIGNhc2UgMTI6IHJldHVybiBcIiB0d2VsdmVcIjtcbiAgICBjYXNlIDEzOiByZXR1cm4gXCIgdGhpcnRlZW5cIjtcbiAgICBjYXNlIDE0OiByZXR1cm4gXCIgZm91cnRlZW5cIjtcbiAgICBjYXNlIDE1OiByZXR1cm4gXCIgZmlmdGVlblwiO1xuICAgIGNhc2UgMTY6IHJldHVybiBcIiBzaXh0ZWVuXCI7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9pbmRleC50cyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9hc3NpZ24nKVxuICAsIG5vcm1hbGl6ZU9wdHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucycpXG4gICwgaXNDYWxsYWJsZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlJylcbiAgLCBjb250YWlucyAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucycpXG5cbiAgLCBkO1xuXG5kID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZHNjciwgdmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCB3LCBvcHRpb25zLCBkZXNjO1xuXHRpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB8fCAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSkge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHcgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ3cnKTtcblx0fVxuXG5cdGRlc2MgPSB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlLCB3cml0YWJsZTogdyB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuZC5ncyA9IGZ1bmN0aW9uIChkc2NyLCBnZXQsIHNldC8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IGdldDtcblx0XHRnZXQgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbM107XG5cdH1cblx0aWYgKGdldCA9PSBudWxsKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKGdldCkpIHtcblx0XHRvcHRpb25zID0gZ2V0O1xuXHRcdGdldCA9IHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChzZXQgPT0gbnVsbCkge1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdH1cblxuXHRkZXNjID0geyBnZXQ6IGdldCwgc2V0OiBzZXQsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMuc3RhdGVzQXJlRXF1YWwgPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVRdWVyeSA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVRdWVyeSA9IGV4cG9ydHMuY3JlYXRlUXVlcnkgPSBmdW5jdGlvbiBjcmVhdGVRdWVyeShwcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoT2JqZWN0LmNyZWF0ZShudWxsKSwgcHJvcHMpO1xufTtcblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKCkge1xuICB2YXIgaW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnLycgOiBhcmd1bWVudHNbMF07XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBvYmplY3QgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShpbnB1dCkgOiBpbnB1dDtcblxuICB2YXIgcGF0aG5hbWUgPSBvYmplY3QucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gb2JqZWN0LnNlYXJjaCB8fCAnJztcbiAgdmFyIGhhc2ggPSBvYmplY3QuaGFzaCB8fCAnJztcbiAgdmFyIHN0YXRlID0gb2JqZWN0LnN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGtleToga2V5XG4gIH07XG59O1xuXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gaXNEYXRlKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnZhciBzdGF0ZXNBcmVFcXVhbCA9IGV4cG9ydHMuc3RhdGVzQXJlRXF1YWwgPSBmdW5jdGlvbiBzdGF0ZXNBcmVFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgdHlwZW9mQSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKTtcbiAgdmFyIHR5cGVvZkIgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKHR5cGVvZkEgIT09IHR5cGVvZkIpIHJldHVybiBmYWxzZTtcblxuICAhKHR5cGVvZkEgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBtdXN0IG5vdCBzdG9yZSBmdW5jdGlvbnMgaW4gbG9jYXRpb24gc3RhdGUnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gTm90IHRoZSBzYW1lIG9iamVjdCwgYnV0IHNhbWUgdHlwZS5cbiAgaWYgKHR5cGVvZkEgPT09ICdvYmplY3QnKSB7XG4gICAgISEoaXNEYXRlKGEpICYmIGlzRGF0ZShiKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IG11c3Qgbm90IHN0b3JlIERhdGUgb2JqZWN0cyBpbiBsb2NhdGlvbiBzdGF0ZScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkgcmV0dXJuIE9iamVjdC5rZXlzKGEpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBzdGF0ZXNBcmVFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBzdGF0ZXNBcmVFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBBbGwgb3RoZXIgc2VyaWFsaXphYmxlIHR5cGVzIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbilcbiAgLy8gc2hvdWxkIGJlIHN0cmljdCBlcXVhbC5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEua2V5ID09PSBiLmtleSAmJlxuICAvLyBhLmFjdGlvbiA9PT0gYi5hY3Rpb24gJiYgLy8gRGlmZmVyZW50IGFjdGlvbiAhPT0gbG9jYXRpb24gY2hhbmdlLlxuICBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBzdGF0ZXNBcmVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0xvY2F0aW9uVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFZOb2RlLCBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IEFuaW1hdGlvbiwgQW5pbWF0aW9uRGlyZWN0aW9uLCBEaXJlY3Rpb24gfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBUcmFuc2l0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2l0aW9uIHtcbiAgICBhbmltYXRpb246IEFuaW1hdGlvbjtcbiAgICBkaXJlY3Rpb24/OiBEaXJlY3Rpb247XG4gICAgYW5pbWF0aW9uRGlyZWN0aW9uPzogQW5pbWF0aW9uRGlyZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdHJhbnNpdGlvbiB3cmFwcGVyIGZvciBhbmltYXRpbmcgZG9tIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyB0YXJnZXRzOiBWTm9kZVxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOiB7fSBvZlxuICAgKiAgIGFuaW1hdGlvbjogQW5pbWF0aW9uIC0gVGhlIGFuaW1hdGlvbiB0byB1c2UuXG4gICAqICAgZGlyZWN0aW9uPzogRGlyZWN0aW9uIC0gV2V0aGVyIHRvIGFuaW1hdGUgdG8gdmlzaWJsZSBvciBpbnZpc2libGUuXG4gICAqICAgYW5pbWF0aW9uRGlyZWN0aW9uPzogQW5pbWF0aW9uRGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICogRGlzcmVnYXJkcyBhbnkgY29udGVudC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFZOb2RlLCBUcmFuc2l0aW9uLCBhbnk+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFZOb2RlLCBUcmFuc2l0aW9uLCBhbnk+KSB7XG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnRyYW5zaXRpb25cIikuZXZlbnRzKHR5cGUpO1xuICAgICAgc291cmNlcy5hcmdzJCA9IHNvdXJjZXMuYXJncyQgPyBzb3VyY2VzLmFyZ3MkIDogeHMub2YoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IERpcmVjdGlvbi5PdXQgfSk7XG5cbiAgICAgIGxldCBhbmltYXRpb25FbmQkID0gZXZ0KFwiYW5pbWF0aW9uZW5kXCIpLm1hcChldnQgPT4gKHtcbiAgICAgICAgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSxcbiAgICAgICAgZGlyZWN0aW9uOiAoZXZ0LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQpLmNsYXNzTGlzdC5jb250YWlucyhcIm91dFwiKSA/IERpcmVjdGlvbi5PdXQgOiBEaXJlY3Rpb24uSW5cbiAgICAgIH0pKSBhcyBTdHJlYW08VHJhbnNpdGlvbj47XG4gICAgICBsZXQgYW5pbWF0aW9uJCA9IHhzLm1lcmdlKHNvdXJjZXMuYXJncyQsIGFuaW1hdGlvbkVuZCQpO1xuXG4gICAgICBsZXQgdlRyZWUkID0geHMuY29tYmluZShhbmltYXRpb24kLCBzb3VyY2VzLnRhcmdldCQpLm1hcChcbiAgICAgICAgKFt0cmFuc2l0aW9uLCB0YXJnZXRdKSA9PiByZW5kZXIodGFyZ2V0LCB0cmFuc2l0aW9uKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIudHJhbnNpdGlvblwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHRyYW5zaXRpb24gd3JhcHBlciBmb3IgYW5pbWF0aW5nIGRvbSBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdGFyZ2V0czogVk5vZGVcbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czoge30gb2ZcbiAgICogICBhbmltYXRpb246IEFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdG8gdXNlLlxuICAgKiAgIGRpcmVjdGlvbj86IERpcmVjdGlvbiAtIFdldGhlciB0byBhbmltYXRlIHRvIHZpc2libGUgb3IgaW52aXNpYmxlLlxuICAgKiAgIGFuaW1hdGlvbkRpcmVjdGlvbj86IEFuaW1hdGlvbkRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gZm9yIHRoZSBhbmltYXRpb24uXG4gICAqIERpc3JlZ2FyZHMgYW55IGNvbnRlbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHRhcmdldDogVk5vZGUsIGFyZ3M6IFRyYW5zaXRpb24gPSB7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUgfSk6IFZOb2RlIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJcIiwgYztcbiAgICBpZiAodGFyZ2V0LmRhdGEpIHtcbiAgICAgIGxldCBjbGFzc0xpc3QgPSB0YXJnZXQuZGF0YS5wcm9wcy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpIGFzIEFycmF5PHN0cmluZz47XG4gICAgICBjbGFzc0xpc3QuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKFtcImhpZGRlblwiLCBcInZpc2libGVcIiwgXCJhbmltYXRpbmdcIiwgXCJ0cmFuc2l0aW9uXCJdLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgY2xhc3NOYW1lICs9IGl0ZW0gKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBnZXRDbGFzc05hbWUoYXJncyk7XG4gICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5kYXRhLCB7XG4gICAgICBcInByb3BzXCI6IHtcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhcmdldC5jaGlsZHJlbikge1xuICAgICAgYyA9IHRhcmdldC5jaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKHRhcmdldC50ZXh0KSB7XG4gICAgICBjID0gdGFyZ2V0LnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBoKHRhcmdldC5zZWwsIGRhdGEsIGMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZSh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKTogc3RyaW5nIHtcbiAgICBpZiAodHJhbnNpdGlvbi5hbmltYXRpb24gPT09IEFuaW1hdGlvbi5Ob25lKSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbi5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5PdXQgPyBcInRyYW5zaXRpb24gaGlkZGVuXCIgOiBcInRyYW5zaXRpb24gdmlzaWJsZVwiO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uID0gQW5pbWF0aW9uLlRvQ2xhc3NuYW1lKHRyYW5zaXRpb24uYW5pbWF0aW9uKTtcbiAgICBpZiAoQW5pbWF0aW9uLmlzU3RhdGljKHRyYW5zaXRpb24uYW5pbWF0aW9uKSkge1xuICAgICAgcmV0dXJuIFwidmlzaWJsZSBhbmltYXRpbmcgdHJhbnNpdGlvbiBcIiArIGFuaW1hdGlvbjtcbiAgICB9XG4gICAgbGV0IGRpcmVjdGlvbiA9IERpcmVjdGlvbi5Ub0NsYXNzbmFtZSh0cmFuc2l0aW9uLmRpcmVjdGlvbik7XG4gICAgaWYgKEFuaW1hdGlvbi5pc0RpcmVjdGlvbmFsKHRyYW5zaXRpb24uYW5pbWF0aW9uKSkge1xuICAgICAgYW5pbWF0aW9uICs9IEFuaW1hdGlvbkRpcmVjdGlvbi5Ub0NsYXNzbmFtZSh0cmFuc2l0aW9uLmFuaW1hdGlvbkRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBcInZpc2libGUgdHJhbnNpdGlvbiBhbmltYXRpbmcgXCIgKyBkaXJlY3Rpb24gKyBhbmltYXRpb247XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL3RyYW5zaXRpb24vaW5kZXgudHMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwib2JqZWN0XCIgP1xuICAgICAgICBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBvYmogaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IDpcbiAgICAgICAgb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmXG4gICAgICAgICAgICAob2JqLm5vZGVUeXBlID09PSAxIHx8IG9iai5ub2RlVHlwZSA9PT0gMTEpICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLm5vZGVOYW1lID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0cy5TQ09QRV9QUkVGSVggPSBcIiQkQ1lDTEVET00kJC1cIjtcbmZ1bmN0aW9uIGdldEVsZW1lbnQoc2VsZWN0b3JzKSB7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSB0eXBlb2Ygc2VsZWN0b3JzID09PSAnc3RyaW5nJyA/XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKSA6XG4gICAgICAgIHNlbGVjdG9ycztcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9ycyA9PT0gJ3N0cmluZycgJiYgZG9tRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVuZGVyIGludG8gdW5rbm93biBlbGVtZW50IGBcIiArIHNlbGVjdG9ycyArIFwiYFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQgbmVpdGhlciBhIFwiICtcbiAgICAgICAgICAgIFwic2VsZWN0b3Igc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5leHBvcnRzLmdldEVsZW1lbnQgPSBnZXRFbGVtZW50O1xuZnVuY3Rpb24gZ2V0U2NvcGUobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIG5hbWVzcGFjZVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmluZGV4T2YoZXhwb3J0cy5TQ09QRV9QUkVGSVgpID4gLTE7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVwbGFjZShleHBvcnRzLlNDT1BFX1BSRUZJWCwgJycpOyB9KVxuICAgICAgICAuam9pbihcIi1cIik7XG59XG5leHBvcnRzLmdldFNjb3BlID0gZ2V0U2NvcGU7XG5mdW5jdGlvbiBnZXRTZWxlY3RvcnMobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIG5hbWVzcGFjZS5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuaW5kZXhPZihleHBvcnRzLlNDT1BFX1BSRUZJWCkgPT09IC0xOyB9KS5qb2luKFwiIFwiKTtcbn1cbmV4cG9ydHMuZ2V0U2VsZWN0b3JzID0gZ2V0U2VsZWN0b3JzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKCkgPyBTeW1ib2wgOiByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXN5bWJvbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG52YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBleHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW52YXJpYW50L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnB1c2guXG4gKi9cbnZhciBQVVNIID0gZXhwb3J0cy5QVVNIID0gJ1BVU0gnO1xuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5yZXBsYWNlLlxuICovXG52YXIgUkVQTEFDRSA9IGV4cG9ydHMuUkVQTEFDRSA9ICdSRVBMQUNFJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gZXhwb3J0cy5QT1AgPSAnUE9QJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvQWN0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5OiBBcnJheS5pc0FycmF5LFxuICBwcmltaXRpdmU6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcyA9PT0gJ251bWJlcic7IH0sXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL2lzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgQ29sb3IsIFNpemUsIEljb25UeXBlIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgaSB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgSWNvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGJ1dHRvbj86IGJvb2xlYW47XG4gICAgYm9yZGVyZWQ/OiBib29sZWFuO1xuICAgIGNpcmN1bGFyPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgZml0dGVkPzogYm9vbGVhbjtcbiAgICBsaW5rPzogYm9vbGVhbjtcbiAgICBmbGlwcGVkPzogYm9vbGVhbjtcbiAgICByb3RhdGVkPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgICBzaXplPzogU2l6ZTtcbiAgfVxuICAvKipcbiAgICogQW4gaWNvbiBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgaWNvbnMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogIGJ1dHRvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gZGlzcGxheSB3ZWxsIG9uIGJ1dHRvbnNcbiAgICogXHRib3JkZXJlZD86IGJvb2xlYW4gLSBBZGRzIGEgYm9yZGVyIGFyb3VuZCB0aGUgaWNvbi5cbiAgICogXHRjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIGNpcmN1bGFyLlxuICAgKiBcdGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqIFx0bG9hZGluZz86IGJvb2xlYW4gLSBSb3RhdGVzIHRoZSBpY29uIHRvIGFsbG93IGl0IHRvIGJlIHVzZWQgZm9yIGxvYWRlcnMuXG4gICAqIFx0Zml0dGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiBmb3IgdGlnaHQgZml0cy5cbiAgICogXHRsaW5rPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgY2xpY2thYmxlLlxuICAgKiBcdGZsaXBwZWQ/OiBib29sZWFuIC0gRmxpcHMgdGhlIGljb24uXG4gICAqIFx0cm90YXRlZD86IGJvb2xlYW4gLSBSb3RhdGVzIHRoZSBpY29uLlxuICAgKiBcdGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgb24gZGFyayBiYWNrZ3JvdW5kLlxuICAgKiBcdGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGljb24uXG4gICAqIFx0c2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgaWNvbi5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogSWNvblR5cGVcbiAgICogQHBhcmFtICB7Q29tcG9uZW50U291cmNlc30gc291cmNlcyAtIFRoZSBjb21wb25lbnQncyBzb3VyY2VzLlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnRTaW5rc30gVGhlIEljb24gY29tcG9uZW50LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBJY29uVHlwZT4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBJY29uVHlwZT4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHsgdHlwZTogXCJcIiB9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKDApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpXG4gICAgICAgICAgLm1hcCgoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KSksXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5pY29uXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGljb24gY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGljb25zLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogIGJ1dHRvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gZGlzcGxheSB3ZWxsIG9uIGJ1dHRvbnNcbiAgICogXHRib3JkZXJlZD86IGJvb2xlYW4gLSBBZGRzIGEgYm9yZGVyIGFyb3VuZCB0aGUgaWNvbi5cbiAgICogXHRjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIGNpcmN1bGFyLlxuICAgKiBcdGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqIFx0bG9hZGluZz86IGJvb2xlYW4gLSBSb3RhdGVzIHRoZSBpY29uIHRvIGFsbG93IGl0IHRvIGJlIHVzZWQgZm9yIGxvYWRlcnMuXG4gICAqIFx0Zml0dGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiBmb3IgdGlnaHQgZml0cy5cbiAgICogXHRsaW5rPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgY2xpY2thYmxlLlxuICAgKiBcdGZsaXBwZWQ/OiBib29sZWFuIC0gRmxpcHMgdGhlIGljb24uXG4gICAqIFx0cm90YXRlZD86IGJvb2xlYW4gLSBSb3RhdGVzIHRoZSBpY29uLlxuICAgKiBcdGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgb24gZGFyayBiYWNrZ3JvdW5kLlxuICAgKiBcdGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGljb24uXG4gICAqIFx0c2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgaWNvbi5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogSWNvblR5cGVcbiAgICogQHBhcmFtICB7Q29tcG9uZW50U291cmNlc30gc291cmNlcyAtIFRoZSBjb21wb25lbnQncyBzb3VyY2VzLlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnRTaW5rc30gVGhlIEljb24gY29tcG9uZW50LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IEljb25UeXBlID0ge30sIGM6IEljb25UeXBlID0gLTEpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNQcm9wcyhwT3JDKSA/IHBPckMgOiB7fTtcbiAgICBsZXQgY29udGVudCA9IGlzUHJvcHMocE9yQykgPyBjIDogcE9yQztcbiAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRDbGFzc25hbWUocHJvcHMsIGNvbnRlbnQpO1xuICAgIHJldHVybiBjbGFzc05hbWUgIT09IFwidWkgaWNvblwiID8gaSh7IHByb3BzOiB7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0gfSkgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMsIGNvbnRlbnQ6IEljb25UeXBlKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5idXR0b24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBidXR0b25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmJvcmRlcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYm9yZGVyZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5maXR0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmaXR0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxpbmspIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsaW5rXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbGlwcGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZmxpcHBlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucm90YXRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJvdGF0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBJY29uVHlwZS5Ub0NsYXNzbmFtZShjb250ZW50KTtcbiAgICByZXR1cm4gY2xhc3NOYW1lICsgXCIgaWNvblwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQcm9wcyhwcm9wcyk6IHByb3BzIGlzIFByb3BzIHtcbiAgICByZXR1cm4gdHlwZW9mIChwcm9wcykgPT09IFwib2JqZWN0XCI7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9pY29uL2luZGV4LnRzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xuZnVuY3Rpb24gZnJvbUV2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSwgdXNlQ2FwdHVyZSkge1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB2b2lkIDApIHsgdXNlQ2FwdHVyZSA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHhzdHJlYW1fMS5TdHJlYW0uY3JlYXRlKHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBmdW5jdGlvbiBuZXh0KGV2ZW50KSB7IGxpc3RlbmVyLm5leHQoZXZlbnQpOyB9O1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLm5leHQsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLm5leHQsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5mcm9tRXZlbnQgPSBmcm9tRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL2Zyb21FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXMgPSByZXF1aXJlKCdzbmFiYmRvbS9pcycpO1xudmFyIHZub2RlID0gcmVxdWlyZSgnc25hYmJkb20vdm5vZGUnKTtcbmZ1bmN0aW9uIGlzR2VuZXJpY1N0cmVhbSh4KSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHgpICYmIHR5cGVvZiB4Lm1hcCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gbXV0YXRlU3RyZWFtV2l0aE5TKHZOb2RlKSB7XG4gICAgYWRkTlModk5vZGUuZGF0YSwgdk5vZGUuY2hpbGRyZW4sIHZOb2RlLnNlbCk7XG4gICAgcmV0dXJuIHZOb2RlO1xufVxuZnVuY3Rpb24gYWRkTlMoZGF0YSwgY2hpbGRyZW4sIHNlbGVjdG9yKSB7XG4gICAgZGF0YS5ucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbiAgICBpZiAoc2VsZWN0b3IgIT09IFwidGV4dFwiICYmIHNlbGVjdG9yICE9PSBcImZvcmVpZ25PYmplY3RcIiAmJlxuICAgICAgICB0eXBlb2YgY2hpbGRyZW4gIT09ICd1bmRlZmluZWQnICYmIGlzLmFycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaXNHZW5lcmljU3RyZWFtKGNoaWxkcmVuW2ldKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gY2hpbGRyZW5baV0ubWFwKG11dGF0ZVN0cmVhbVdpdGhOUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGROUyhjaGlsZHJlbltpXS5kYXRhLCBjaGlsZHJlbltpXS5jaGlsZHJlbiwgY2hpbGRyZW5baV0uc2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGgoc2VsLCBiLCBjKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgY2hpbGRyZW47XG4gICAgdmFyIHRleHQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgZGF0YSA9IGI7XG4gICAgICAgIGlmIChpcy5hcnJheShjKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShjKSkge1xuICAgICAgICAgICAgdGV4dCA9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAoaXMuYXJyYXkoYikpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYikpIHtcbiAgICAgICAgICAgIHRleHQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmFycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpcy5wcmltaXRpdmUoY2hpbGRyZW5baV0pKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSB2bm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbFswXSA9PT0gJ3MnICYmIHNlbFsxXSA9PT0gJ3YnICYmIHNlbFsyXSA9PT0gJ2cnKSB7XG4gICAgICAgIGFkZE5TKGRhdGEsIGNoaWxkcmVuLCBzZWwpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUoc2VsLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgdW5kZWZpbmVkKTtcbn1cbmV4cG9ydHMuaCA9IGg7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oeXBlcnNjcmlwdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvaHlwZXJzY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4gICwgaWQgPSB0b1N0cmluZy5jYWxsKChmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAodG9TdHJpbmcuY2FsbCh4KSA9PT0gaWQpOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3QuYXNzaWduXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuICAsIGlkID0gdG9TdHJpbmcuY2FsbCgnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0cmV0dXJuICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHx8ICh4ICYmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpICYmXG5cdFx0KCh4IGluc3RhbmNlb2YgU3RyaW5nKSB8fCAodG9TdHJpbmcuY2FsbCh4KSA9PT0gaWQpKSkgfHwgZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvc3RyaW5nL2lzLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xlYXIgICAgPSByZXF1aXJlKCdlczUtZXh0L2FycmF5LyMvY2xlYXInKVxuICAsIGFzc2lnbiAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCB2YWx1ZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcbiAgLCBkICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIGF1dG9CaW5kID0gcmVxdWlyZSgnZC9hdXRvLWJpbmQnKVxuICAsIFN5bWJvbCAgID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIEl0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdG9yID0gZnVuY3Rpb24gKGxpc3QsIGNvbnRleHQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEl0ZXJhdG9yKSkgcmV0dXJuIG5ldyBJdGVyYXRvcihsaXN0LCBjb250ZXh0KTtcblx0ZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0X19saXN0X186IGQoJ3cnLCB2YWx1ZShsaXN0KSksXG5cdFx0X19jb250ZXh0X186IGQoJ3cnLCBjb250ZXh0KSxcblx0XHRfX25leHRJbmRleF9fOiBkKCd3JywgMClcblx0fSk7XG5cdGlmICghY29udGV4dCkgcmV0dXJuO1xuXHRjYWxsYWJsZShjb250ZXh0Lm9uKTtcblx0Y29udGV4dC5vbignX2FkZCcsIHRoaXMuX29uQWRkKTtcblx0Y29udGV4dC5vbignX2RlbGV0ZScsIHRoaXMuX29uRGVsZXRlKTtcblx0Y29udGV4dC5vbignX2NsZWFyJywgdGhpcy5fb25DbGVhcik7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEl0ZXJhdG9yLnByb3RvdHlwZSwgYXNzaWduKHtcblx0Y29uc3RydWN0b3I6IGQoSXRlcmF0b3IpLFxuXHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGk7XG5cdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm47XG5cdFx0aWYgKHRoaXMuX19yZWRvX18pIHtcblx0XHRcdGkgPSB0aGlzLl9fcmVkb19fLnNoaWZ0KCk7XG5cdFx0XHRpZiAoaSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA8IHRoaXMuX19saXN0X18ubGVuZ3RoKSByZXR1cm4gdGhpcy5fX25leHRJbmRleF9fKys7XG5cdFx0dGhpcy5fdW5CaW5kKCk7XG5cdH0pLFxuXHRuZXh0OiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NyZWF0ZVJlc3VsdCh0aGlzLl9uZXh0KCkpOyB9KSxcblx0X2NyZWF0ZVJlc3VsdDogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmIChpID09PSB1bmRlZmluZWQpIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcblx0XHRyZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX3Jlc29sdmUoaSkgfTtcblx0fSksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLl9fbGlzdF9fW2ldOyB9KSxcblx0X3VuQmluZDogZChmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fX2xpc3RfXyA9IG51bGw7XG5cdFx0ZGVsZXRlIHRoaXMuX19yZWRvX187XG5cdFx0aWYgKCF0aGlzLl9fY29udGV4dF9fKSByZXR1cm47XG5cdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoJ19hZGQnLCB0aGlzLl9vbkFkZCk7XG5cdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoJ19kZWxldGUnLCB0aGlzLl9vbkRlbGV0ZSk7XG5cdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoJ19jbGVhcicsIHRoaXMuX29uQ2xlYXIpO1xuXHRcdHRoaXMuX19jb250ZXh0X18gPSBudWxsO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgSXRlcmF0b3JdJzsgfSlcbn0sIGF1dG9CaW5kKHtcblx0X29uQWRkOiBkKGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHQrK3RoaXMuX19uZXh0SW5kZXhfXztcblx0XHRpZiAoIXRoaXMuX19yZWRvX18pIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX3JlZG9fXycsIGQoJ2MnLCBbaW5kZXhdKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX19yZWRvX18uZm9yRWFjaChmdW5jdGlvbiAocmVkbywgaSkge1xuXHRcdFx0aWYgKHJlZG8gPj0gaW5kZXgpIHRoaXMuX19yZWRvX19baV0gPSArK3JlZG87XG5cdFx0fSwgdGhpcyk7XG5cdFx0dGhpcy5fX3JlZG9fXy5wdXNoKGluZGV4KTtcblx0fSksXG5cdF9vbkRlbGV0ZTogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHR2YXIgaTtcblx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0LS10aGlzLl9fbmV4dEluZGV4X187XG5cdFx0aWYgKCF0aGlzLl9fcmVkb19fKSByZXR1cm47XG5cdFx0aSA9IHRoaXMuX19yZWRvX18uaW5kZXhPZihpbmRleCk7XG5cdFx0aWYgKGkgIT09IC0xKSB0aGlzLl9fcmVkb19fLnNwbGljZShpLCAxKTtcblx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGkpIHtcblx0XHRcdGlmIChyZWRvID4gaW5kZXgpIHRoaXMuX19yZWRvX19baV0gPSAtLXJlZG87XG5cdFx0fSwgdGhpcyk7XG5cdH0pLFxuXHRfb25DbGVhcjogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX19yZWRvX18pIGNsZWFyLmNhbGwodGhpcy5fX3JlZG9fXyk7XG5cdFx0dGhpcy5fX25leHRJbmRleF9fID0gMDtcblx0fSlcbn0pKSk7XG5cbmRlZmluZVByb3BlcnR5KEl0ZXJhdG9yLnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCBkKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXM7XG59KSk7XG5kZWZpbmVQcm9wZXJ0eShJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgZCgnJywgJ0l0ZXJhdG9yJykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1pdGVyYXRvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nbyA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1hbGVydCAqL1xuXG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcblxudmFyIF9jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIF9jcmVhdGVMb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgdmFyIGtleSA9IGhpc3RvcnlTdGF0ZSAmJiBoaXN0b3J5U3RhdGUua2V5O1xuXG4gIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHtcbiAgICBwYXRobmFtZTogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgIHNlYXJjaDogd2luZG93LmxvY2F0aW9uLnNlYXJjaCxcbiAgICBoYXNoOiB3aW5kb3cubG9jYXRpb24uaGFzaCxcbiAgICBzdGF0ZToga2V5ID8gKDAsIF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKShrZXkpIDogdW5kZWZpbmVkXG4gIH0sIHVuZGVmaW5lZCwga2V5KTtcbn07XG5cbnZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgdmFyIGhpc3RvcnlTdGF0ZSA9IHZvaWQgMDtcbiAgdHJ5IHtcbiAgICBoaXN0b3J5U3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tamFja3Nvbi9oaXN0b3J5L3B1bGwvMjg5XG4gICAgaGlzdG9yeVN0YXRlID0ge307XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSk7XG59O1xuXG52YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IGV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldFVzZXJDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07XG5cbnZhciBzdGFydExpc3RlbmVyID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZnVuY3Rpb24gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIGlmIChldmVudC5zdGF0ZSAhPT0gdW5kZWZpbmVkKSAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0XG4gICAgICBsaXN0ZW5lcihfY3JlYXRlTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG4gIH07XG59O1xuXG52YXIgdXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdXBkYXRlU3RhdGUpIHtcbiAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cblxuICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkgKDAsIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKShrZXksIHN0YXRlKTtcblxuICB1cGRhdGVTdGF0ZSh7IGtleToga2V5IH0sICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSk7XG59O1xuXG52YXIgcHVzaExvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBmdW5jdGlvbiAoc3RhdGUsIHBhdGgpIHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCBudWxsLCBwYXRoKTtcbiAgfSk7XG59O1xuXG52YXIgcmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBmdW5jdGlvbiAoc3RhdGUsIHBhdGgpIHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBudWxsLCBwYXRoKTtcbiAgfSk7XG59O1xuXG52YXIgZ28gPSBleHBvcnRzLmdvID0gZnVuY3Rpb24gZ28obikge1xuICBpZiAobikgd2luZG93Lmhpc3RvcnkuZ28obik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9Ccm93c2VyUHJvdG9jb2wuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBjYW5Vc2VET00gPSBleHBvcnRzLmNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBvcHRpb25zLmdldEN1cnJlbnRMb2NhdGlvbjtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBvcHRpb25zLmdldFVzZXJDb25maXJtYXRpb247XG4gIHZhciBwdXNoTG9jYXRpb24gPSBvcHRpb25zLnB1c2hMb2NhdGlvbjtcbiAgdmFyIHJlcGxhY2VMb2NhdGlvbiA9IG9wdGlvbnMucmVwbGFjZUxvY2F0aW9uO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIga2V5TGVuZ3RoID0gb3B0aW9ucy5rZXlMZW5ndGg7XG5cblxuICB2YXIgY3VycmVudExvY2F0aW9uID0gdm9pZCAwO1xuICB2YXIgcGVuZGluZ0xvY2F0aW9uID0gdm9pZCAwO1xuICB2YXIgYmVmb3JlTGlzdGVuZXJzID0gW107XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGFsbEtleXMgPSBbXTtcblxuICB2YXIgZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24gZ2V0Q3VycmVudEluZGV4KCkge1xuICAgIGlmIChwZW5kaW5nTG9jYXRpb24gJiYgcGVuZGluZ0xvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm4gYWxsS2V5cy5pbmRleE9mKHBlbmRpbmdMb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKGN1cnJlbnRMb2NhdGlvbikgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihjdXJyZW50TG9jYXRpb24ua2V5KTtcblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICB2YXIgdXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pIHtcbiAgICBjdXJyZW50TG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG5cbiAgICB2YXIgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG5cbiAgICBpZiAoY3VycmVudExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgYWxsS2V5cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxsS2V5cy5zbGljZSgwLCBjdXJyZW50SW5kZXggKyAxKSksIFtjdXJyZW50TG9jYXRpb24ua2V5XSk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5SRVBMQUNFKSB7XG4gICAgICBhbGxLZXlzW2N1cnJlbnRJbmRleF0gPSBjdXJyZW50TG9jYXRpb24ua2V5O1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyKGN1cnJlbnRMb2NhdGlvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGJlZm9yZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmVmb3JlTGlzdGVuZXJzID0gYmVmb3JlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykoYmVmb3JlTGlzdGVuZXJzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICAoMCwgX3J1blRyYW5zaXRpb25Ib29rMi5kZWZhdWx0KShiZWZvcmVMaXN0ZW5lcnNbaW5kZXhdLCBsb2NhdGlvbiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgPyBkb25lKHJlc3VsdCkgOiBuZXh0KCk7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKGdldFVzZXJDb25maXJtYXRpb24gJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGdldFVzZXJDb25maXJtYXRpb24obWVzc2FnZSwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG9rICE9PSBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8obmV4dExvY2F0aW9uKSB7XG4gICAgaWYgKGN1cnJlbnRMb2NhdGlvbiAmJiAoMCwgX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWwpKGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uKSB8fCBwZW5kaW5nTG9jYXRpb24gJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShwZW5kaW5nTG9jYXRpb24sIG5leHRMb2NhdGlvbikpIHJldHVybjsgLy8gTm90aGluZyB0byBkb1xuXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgY29uZmlybVRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkIGR1cmluZyBjb25maXJtYXRpb25cblxuICAgICAgcGVuZGluZ0xvY2F0aW9uID0gbnVsbDtcblxuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIC8vIFRyZWF0IFBVU0ggdG8gc2FtZSBwYXRoIGxpa2UgUkVQTEFDRSB0byBiZSBjb25zaXN0ZW50IHdpdGggYnJvd3NlcnNcbiAgICAgICAgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgICAgICB2YXIgcHJldlBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShjdXJyZW50TG9jYXRpb24pO1xuICAgICAgICAgIHZhciBuZXh0UGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKG5leHRMb2NhdGlvbik7XG5cbiAgICAgICAgICBpZiAobmV4dFBhdGggPT09IHByZXZQYXRoICYmICgwLCBfTG9jYXRpb25VdGlscy5zdGF0ZXNBcmVFcXVhbCkoY3VycmVudExvY2F0aW9uLnN0YXRlLCBuZXh0TG9jYXRpb24uc3RhdGUpKSBuZXh0TG9jYXRpb24uYWN0aW9uID0gX0FjdGlvbnMuUkVQTEFDRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgICAgICB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgICAgICBpZiAocHVzaExvY2F0aW9uKG5leHRMb2NhdGlvbikgIT09IGZhbHNlKSB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgICAgICBpZiAocmVwbGFjZUxvY2F0aW9uKG5leHRMb2NhdGlvbikgIT09IGZhbHNlKSB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRMb2NhdGlvbiAmJiBuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihjdXJyZW50TG9jYXRpb24ua2V5KTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGFsbEtleXMuaW5kZXhPZihuZXh0TG9jYXRpb24ua2V5KTtcblxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSAmJiBuZXh0SW5kZXggIT09IC0xKSBnbyhwcmV2SW5kZXggLSBuZXh0SW5kZXgpOyAvLyBSZXN0b3JlIHRoZSBVUkxcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2goaW5wdXQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGlucHV0LCBfQWN0aW9ucy5QVVNIKSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGlucHV0KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihpbnB1dCwgX0FjdGlvbnMuUkVQTEFDRSkpO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoIHx8IDYpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBjcmVhdGVLZXkoKSA6IGFyZ3VtZW50c1syXTtcbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShsb2NhdGlvbiwgYWN0aW9uLCBrZXkpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgdHJhbnNpdGlvblRvOiB0cmFuc2l0aW9uVG8sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjcmVhdGVLZXk6IGNyZWF0ZUtleSxcbiAgICBjcmVhdGVQYXRoOiBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb25cbiAgfTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBydW5UcmFuc2l0aW9uSG9vayA9IGZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Ib29rKGhvb2ssIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0ID0gaG9vayhsb2NhdGlvbiwgY2FsbGJhY2spO1xuXG4gIGlmIChob29rLmxlbmd0aCA8IDIpIHtcbiAgICAvLyBBc3N1bWUgdGhlIGhvb2sgcnVucyBzeW5jaHJvbm91c2x5IGFuZCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcmV0dXJuIHZhbHVlLlxuICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkocmVzdWx0ID09PSB1bmRlZmluZWQsICdZb3Ugc2hvdWxkIG5vdCBcInJldHVyblwiIGluIGEgdHJhbnNpdGlvbiBob29rIHdpdGggYSBjYWxsYmFjayBhcmd1bWVudDsgJyArICdjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJ1blRyYW5zaXRpb25Ib29rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cbnZhciBvYmplY3RUeXBlcyA9IHtcbiAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgJ29iamVjdCc6IHRydWVcbn07XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAob2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUpXG4gID8gZXhwb3J0c1xuICA6IHVuZGVmaW5lZDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSAob2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUpXG4gID8gbW9kdWxlXG4gIDogdW5kZWZpbmVkO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSBjaGVja0dsb2JhbChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xudmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuXG4vKiogRGV0ZWN0IGB0aGlzYCBhcyB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHRoaXNdICYmIHRoaXMpO1xuXG4vKipcbiAqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gKlxuICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0J3MgdGhlIGdsb2JhbCBvYmplY3QgdG8gYXZvaWQgR3JlYXNlbW9ua2V5J3NcbiAqIHJlc3RyaWN0ZWQgYHdpbmRvd2Agb2JqZWN0LCBvdGhlcndpc2UgdGhlIGB3aW5kb3dgIG9iamVjdCBpcyB1c2VkLlxuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHxcbiAgKChmcmVlV2luZG93ICE9PSAodGhpc0dsb2JhbCAmJiB0aGlzR2xvYmFsLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8XG4gICAgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgYHZhbHVlYCBpZiBpdCdzIGEgZ2xvYmFsIG9iamVjdCwgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9yb290L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xudmFyIHZlbmRvciA9IHByb3RvLm1hdGNoZXNcbiAgfHwgcHJvdG8ubWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubXNNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ub01hdGNoZXNTZWxlY3RvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaDtcblxuLyoqXG4gKiBNYXRjaCBgZWxgIHRvIGBzZWxlY3RvcmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKHZlbmRvcikgcmV0dXJuIHZlbmRvci5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gIHZhciBub2RlcyA9IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0gPT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWF0Y2hlcy1zZWxlY3Rvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCBlbG0pIHtcbiAgdmFyIGtleSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGRhdGEua2V5O1xuICByZXR1cm4ge3NlbDogc2VsLCBkYXRhOiBkYXRhLCBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgdGV4dDogdGV4dCwgZWxtOiBlbG0sIGtleToga2V5fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vdm5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7RE9NQ29udGVudCwgSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgVk5vZGUsIEV2ZW50U2VsZWN0b3J9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IHtBbmltYXRpb24sIERpcmVjdGlvbn0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQge2gsIGRpdn0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIm1vZHVsZXMvdHJhbnNpdGlvblwiO1xuaW1wb3J0IHtwYXRjaENsYXNzTGlzdCwgYWRkRWxlbWVudH0gZnJvbSBcInV0aWxzXCI7XG47XG5cbmV4cG9ydCBuYW1lc3BhY2UgRGltbWVyIHtcbiAgLyoqXG4gICAqIEEgZGltbWVyIHdyYXBwZXIgdG8gc2hvdyBleHRyYSBoaWRkZW4gY29udGVudCBvbiBhbiBlbGVtZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiB0YXJnZXQ6XG4gICAqICAgVk5vZGUgLSBUaGUgZWxlbWVudCB0byBhdHRhY2ggdGhlIGRpbW1lciB0by5cbiAgICogICBcIlBhZ2VcIiAtIENyZWF0ZXMgYSBkaW1tZXIgZm9yIHRoZSBlbnRpcmUgcGFnZS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgYXJnczogQm9vbGVhblxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqIEBwYXJhbSAge0NvbXBvbmVudFNvdXJjZXN9IHNvdXJjZXMgVGhlIENvbXBvbmVudCdzIHNvdXJjZXMuXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudFNpbmtzfSBUaGUgRGltbWVyIENvbXBvbmVudC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFN0cmluZ3xWTm9kZSwgYm9vbGVhbiwgRE9NQ29udGVudD4sIGludmVydCQgPSB4cy5vZihmYWxzZSkpXG4gICAgOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXM8U3RyaW5nfFZOb2RlLCBib29sZWFuLCBET01Db250ZW50Pikge1xuICAgICAgY29uc3QgZXZ0ID0gKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5kaW1tYWJsZVwiKS5ldmVudHModHlwZSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcbiAgICAgIHNvdXJjZXMuYXJncyQgPSBzb3VyY2VzLmFyZ3MkID8gc291cmNlcy5hcmdzJCA6IG9uSG92ZXIoZXZ0KTtcblxuICAgICAgY29uc3QgdGFyZ2V0JCA9IHNvdXJjZXMudGFyZ2V0JC5yZW1lbWJlcigpO1xuICAgICAgY29uc3QgYWN0aXZlJCA9IHNvdXJjZXMuYXJncyQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0gYWN0aXZlJFxuICAgICAgICAuZm9sZCgocHJldkFuaW0sIGFjdGl2ZSkgPT4gcHJldkFuaW0uZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTm9uZVxuICAgICAgICAgID8gKHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBhY3RpdmUgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0fSlcbiAgICAgICAgICA6IHsgYW5pbWF0aW9uOiBBbmltYXRpb24uRmFkZSwgZGlyZWN0aW9uOiBhY3RpdmUgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0XG4gICAgICAgICAgfVxuICAgICAgICAsICh7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogRGlyZWN0aW9uLk5vbmUgfSkpO1xuICAgICAgY29uc3QgY29udGVudCQgPSB4cy5jb21iaW5lKHNvdXJjZXMuY29udGVudCQsIHRhcmdldCQsIGludmVydCQpXG4gICAgICAgIC5tYXAoKFtjb250ZW50LCB0YXJnZXQsIGludmVydGVkXSkgPT4gcmVuZGVyKGNvbnRlbnQsIHRhcmdldCwgaW52ZXJ0ZWQpKTtcbiAgICAgIGNvbnN0IGFuaW1hdGVkQ29udGVudCA9IFRyYW5zaXRpb24ucnVuKHtET006IHNvdXJjZXMuRE9NLCBhcmdzJDogdHJhbnNpdGlvbiQsIHRhcmdldCQ6IGNvbnRlbnQkfSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUodGFyZ2V0JCwgYW5pbWF0ZWRDb250ZW50LkRPTSwgYWN0aXZlJClcbiAgICAgICAgLm1hcCgoW3RhcmdldCwgY29udGVudCwgYWN0aXZlXSkgPT4gZGltRWxlbWVudCh0YXJnZXQsIGNvbnRlbnQsIGFjdGl2ZSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogYW5pbWF0ZWRDb250ZW50LkV2ZW50cyxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIoY29udGVudDogRE9NQ29udGVudCA9IFwiXCIsIHRhcmdldDogU3RyaW5nfFZOb2RlID0gXCJwYWdlXCIsIGludmVydGVkID0gZmFsc2UpIDogVk5vZGUge1xuICAgIHJldHVybiB0YXJnZXQgPT09IFwicGFnZVwiXG4gICAgICA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ1aSBcIiArIChpbnZlcnRlZCA/IFwiaW52ZXJ0ZWQgXCIgOiBcIlwiKSArICBcImRpbW1lciBtb2RhbHMgcGFnZSBkaW1tZXJcIn19LCBjb250ZW50KVxuICAgICAgOiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidWkgXCIgKyAoaW52ZXJ0ZWQgPyBcImludmVydGVkIFwiIDogXCJcIikgKyBcInRhcmdldHRlZCBkaW1tZXJcIn19LCBbXG4gICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImNvbnRlbnRcIn19LCBbXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY2VudGVyXCJ9fSwgXG4gICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkhvdmVyKGV2ZW50czogRXZlbnRTZWxlY3Rvcikge1xuICAgIHJldHVybiB4cy5tZXJnZShldmVudHMoXCJtb3VzZWVudGVyXCIpLCBldmVudHMoXCJtb3VzZWxlYXZlXCIpKVxuICAgICAgLm1hcChldnQgPT4gKGV2dCBhcyBNb3VzZUV2ZW50KS50eXBlID09PSBcIm1vdXNlZW50ZXJcIikuc3RhcnRXaXRoKGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBkaW1FbGVtZW50KHRhcmdldE9yU3RyaW5nOiBWTm9kZSB8IHN0cmluZywgY29udGVudDogVk5vZGUsIGFjdGl2ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IGlzUGFnZSA9IHR5cGVvZih0YXJnZXRPclN0cmluZykgPT09IFwic3RyaW5nXCI7XG4gICAgbGV0IHRhcmdldCA9IGlzUGFnZSA/IGNvbnRlbnQgOiB0YXJnZXRPclN0cmluZyBhcyBWTm9kZTtcbiAgICBsZXQgY2xhc3NOYW1lID0gaXNQYWdlID8gXCJcIiA6IFwiZGltbWFibGVcIiwgYztcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gaXNQYWdlID8gXCJhY3RpdmVcIjogXCIgZGltbWVkXCI7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBwYXRjaENsYXNzTGlzdCh0YXJnZXQsIFtcImRpbW1hYmxlXCIsIFwiZGltbWVkXCIsIFwiaW52ZXJ0ZWRcIiwgXCJhY3RpdmVcIl0sIGNsYXNzTmFtZSk7XG4gICAgaWYgKGlzUGFnZSkge1xuICAgICAgaWYgKHRhcmdldC5jaGlsZHJlbikge1xuICAgICAgICBjID0gdGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGFyZ2V0LnRleHQpIHtcbiAgICAgICAgYyA9IHRhcmdldC50ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGMgPSBhZGRFbGVtZW50KGNvbnRlbnQsIHRhcmdldCwgXCJ0YXJnZXR0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBoKHRhcmdldC5zZWwsIGRhdGEsIGMpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kdWxlcy9kaW1tZXIvaW5kZXgudHMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFNjb3BlQ2hlY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NvcGVDaGVja2VyKHNjb3BlLCBpc29sYXRlTW9kdWxlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5pc29sYXRlTW9kdWxlID0gaXNvbGF0ZU1vZHVsZTtcbiAgICB9XG4gICAgU2NvcGVDaGVja2VyLnByb3RvdHlwZS5pc1N0cmljdGx5SW5Sb290U2NvcGUgPSBmdW5jdGlvbiAobGVhZikge1xuICAgICAgICBmb3IgKHZhciBlbCA9IGxlYWY7IGVsOyBlbCA9IGVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXMuaXNvbGF0ZU1vZHVsZS5pc0lzb2xhdGVkRWxlbWVudChlbCk7XG4gICAgICAgICAgICBpZiAoc2NvcGUgJiYgc2NvcGUgIT09IHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBTY29wZUNoZWNrZXI7XG59KCkpO1xuZXhwb3J0cy5TY29wZUNoZWNrZXIgPSBTY29wZUNoZWNrZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY29wZUNoZWNrZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL1Njb3BlQ2hlY2tlci5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xuZnVuY3Rpb24gY3JlYXRlVlRyZWUodm5vZGUsIGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsOiB2bm9kZS5zZWwsXG4gICAgICAgIGRhdGE6IHZub2RlLmRhdGEsXG4gICAgICAgIHRleHQ6IHZub2RlLnRleHQsXG4gICAgICAgIGVsbTogdm5vZGUuZWxtLFxuICAgICAgICBrZXk6IHZub2RlLmtleSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlVHJhbnNwb3NlVk5vZGUocnVuU3RyZWFtQWRhcHRlcikge1xuICAgIGZ1bmN0aW9uIGludGVybmFsVHJhbnNwb3NlVk5vZGUodm5vZGUpIHtcbiAgICAgICAgaWYgKCF2bm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm5vZGUgJiYgdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnN0YXRpYykge1xuICAgICAgICAgICAgcmV0dXJuIHhzdHJlYW1fMS5kZWZhdWx0Lm9mKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5TdHJlYW1BZGFwdGVyLmlzVmFsaWRTdHJlYW0odm5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgeHNTdHJlYW0gPSB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LmFkYXB0KHZub2RlLCBydW5TdHJlYW1BZGFwdGVyLnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgICAgICByZXR1cm4geHNTdHJlYW0ubWFwKGludGVybmFsVHJhbnNwb3NlVk5vZGUpLmZsYXR0ZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygdm5vZGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmICghdm5vZGUuY2hpbGRyZW4gfHwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhzdHJlYW1fMS5kZWZhdWx0Lm9mKHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2bm9kZUNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAubWFwKGludGVybmFsVHJhbnNwb3NlVk5vZGUpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gbnVsbDsgfSk7XG4gICAgICAgICAgICBpZiAodm5vZGVDaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQub2YoY3JlYXRlVlRyZWUodm5vZGUsIFtdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQuY29tYmluZS5hcHBseSh4c3RyZWFtXzEuZGVmYXVsdCwgdm5vZGVDaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY2hpbGRyZW4pIHsgcmV0dXJuIGNyZWF0ZVZUcmVlKHZub2RlLCBjaGlsZHJlbi5zbGljZSgpKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmhhbmRsZWQgdlRyZWUgVmFsdWVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc3Bvc2VWTm9kZSh2bm9kZSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxUcmFuc3Bvc2VWTm9kZSh2bm9kZSk7XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZVRyYW5zcG9zZVZOb2RlID0gbWFrZVRyYW5zcG9zZVZOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3NpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvdHJhbnNwb3NpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEhpc3RvcnkgZHJpdmVyIGZhY3RvcnlcbiAqXG4gKiBUaGlzIGlzIGEgZnVuY3Rpb24gd2hpY2gsIHdoZW4gY2FsbGVkLCByZXR1cm5zIGEgSGlzdG9yeSBEcml2ZXIgZm9yIEN5Y2xlLmpzXG4gKiBhcHBzLiBUaGUgZHJpdmVyIGlzIGFsc28gYSBmdW5jdGlvbiwgYW5kIGl0IHRha2VzIGEgc3RyZWFtIG9mIG5ldyBsb2NhdGlvbnNcbiAqIChzdHJpbmdzIHJlcHJlc2VudGluZyBwYXRobmFtZXMgb3IgbG9jYXRpb24gb2JqZWN0cykgYXMgaW5wdXQsIGFuZCBvdXRwdXRzXG4gKiBhbm90aGVyIHN0cmVhbSBvZiBsb2NhdGlvbnMgdGhhdCB3ZXJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtIaXN0b3J5fSBoaXN0b3J5IHRoZSBIaXN0b3J5IG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBoaXN0b3J5IGxpYnJhcnkuXG4gKiBUaGlzIG9iamVjdCBpcyB1c3VhbGx5IGNyZWF0ZWQgdGhyb3VnaCBgY3JlYXRlQnJvd3Nlckhpc3RvcnkoKWAgb3JcbiAqIGBjcmVhdGVIYXNoSGlzdG9yeSgpYCBvciBgY3JlYXRlTWVtb3J5SGlzdG9yeSgpYCBmcm9tIHRoZSBgaGlzdG9yeWAgbGlicmFyeS5cbiAqIEFsdGVybmF0aXZlbHksIHlvdSBtYXkgdXNlIGBjcmVhdGVTZXJ2ZXJIaXN0b3J5YCBmcm9tIHRoaXMgbGlicmFyeS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIHNvbWUgb3B0aW9ucyBzcGVjaWZpYyB0byB0aGlzIGRyaXZlci5cbiAqIE9wdGlvbnMgbWF5IGJlOiBgY2FwdHVyZWAsIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBkcml2ZXIgc2hvdWxkXG4gKiBpbnRlcmNlcHQgYW5kIGhhbmRsZSBhbnkgY2xpY2sgZXZlbnQgdGhhdCBsZWFkcyB0byBhIGxpbmssIGxpa2Ugb24gYW4gYDxhPmBcbiAqIGVsZW1lbnQ7IGBvbkVycm9yYCwgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGVycm9yIGFzIGFyZ3VtZW50IGFuZFxuICogaGFuZGxlcyBpdCwgdXNlIHRoaXMgdG8gY29uZmlndXJlIHdoYXQgdG8gZG8gd2l0aCBkcml2ZXIgZXJyb3JzLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBIaXN0b3J5IERyaXZlciBmdW5jdGlvblxuICogQGZ1bmN0aW9uIG1ha2VIaXN0b3J5RHJpdmVyXG4gKi9cbnZhciBtYWtlSGlzdG9yeURyaXZlcl8xID0gcmVxdWlyZSgnLi9tYWtlSGlzdG9yeURyaXZlcicpO1xuZXhwb3J0cy5tYWtlSGlzdG9yeURyaXZlciA9IG1ha2VIaXN0b3J5RHJpdmVyXzEubWFrZUhpc3RvcnlEcml2ZXI7XG4vKipcbiAqIENyZWF0ZXMgYSBcIlNlcnZlckhpc3RvcnlcIiBvYmplY3Qgc2ltaWxhciB0byB0aGUgSGlzdG9yeSBvYmplY3RzIHRoYXQgdGhlXG4gKiBgaGlzdG9yeWAgbGlicmFyeSBjYW4gY3JlYXRlLiBVc2UgdGhpcyB3aGVuIHlvdSB3YW50IHRvIHN1cHBvcnQgc2VydmVyLXNpZGVcbiAqIHJlbmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGxvY2F0aW9uIHRoaXMgbWF5IGJlIGVpdGhlciBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlXG4gKiBwYXRobmFtZSwgb3IgYSBsb2NhdGlvbiBvYmplY3Qgd2l0aCBmaWVsZHMgbGlrZSBgcGF0aG5hbWVgLCBgc2VhcmNoYCxcbiAqIGBxdWVyeWAsIGBzdGF0ZWAsIGBhY3Rpb25gLCBga2V5YCwgYGhhc2hgLCBldGMuXG4gKiBAcmV0dXJuIHtvYmplY3R9IGEgSGlzdG9yeSBvYmplY3QuXG4gKiBAZnVuY3Rpb24gY3JlYXRlU2VydmVySGlzdG9yeVxuICovXG52YXIgc2VydmVySGlzdG9yeV8xID0gcmVxdWlyZSgnLi9zZXJ2ZXJIaXN0b3J5Jyk7XG5leHBvcnRzLmNyZWF0ZVNlcnZlckhpc3RvcnkgPSBzZXJ2ZXJIaXN0b3J5XzEuY3JlYXRlU2VydmVySGlzdG9yeTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gdXRpbF8xLnN1cHBvcnRzSGlzdG9yeTtcbmV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSB1dGlsXzEuY3JlYXRlTG9jYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2hpc3RvcnkvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5mdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHxcbiAgICAgICAgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICAgICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXG4gICAgICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5O1xudmFyIGxvY2F0aW9uRGVmYXVsdHMgPSB7XG4gICAgcGF0aG5hbWU6ICcvJyxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGhhc2g6ICcnLFxuICAgIHNlYXJjaDogJycsXG4gICAgc3RhdGU6IHVuZGVmaW5lZCxcbiAgICBrZXk6IG51bGwsXG4gICAgcXVlcnk6IG51bGwsXG59O1xuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gb2JqZWN0QXNzaWduKHt9LCBsb2NhdGlvbkRlZmF1bHRzLCB7IHBhdGhuYW1lOiBsb2NhdGlvbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdEFzc2lnbih7fSwgbG9jYXRpb25EZWZhdWx0cywgbG9jYXRpb24pO1xufVxuZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2hpc3RvcnkvbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQ3Jvc3MtQnJvd3NlciBTcGxpdCAxLjEuMVxuICogQ29weXJpZ2h0IDIwMDctMjAxMiBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cbiAqIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIEVDTUFTY3JpcHQgY29tcGxpYW50LCB1bmlmb3JtIGNyb3NzLWJyb3dzZXIgc3BsaXQgbWV0aG9kXG4gKi9cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nIHNlcGFyYXRvci4gTWF0Y2hlcyBvZiB0aGVcbiAqIHNlcGFyYXRvciBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHQgYXJyYXkuIEhvd2V2ZXIsIGlmIGBzZXBhcmF0b3JgIGlzIGEgcmVnZXggdGhhdCBjb250YWluc1xuICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxuICogRml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseVxuICogY3Jvc3MtYnJvd3Nlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2VcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnKTtcbiAqIC8vIC0+IFsnYScsICdiJywgJ2MnLCAnZCddXG4gKlxuICogLy8gV2l0aCBsaW1pdFxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcsIDIpO1xuICogLy8gLT4gWydhJywgJ2InXVxuICpcbiAqIC8vIEJhY2tyZWZlcmVuY2VzIGluIHJlc3VsdCBhcnJheVxuICogc3BsaXQoJy4ud29yZDEgd29yZDIuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcbiAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJyAnLCAnd29yZCcsICcyJywgJy4uJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gc3BsaXQodW5kZWYpIHtcblxuICB2YXIgbmF0aXZlU3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LFxuICAgIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoXCJcIilbMV0gPT09IHVuZGVmLFxuICAgIC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgc2VsZjtcblxuICBzZWxmID0gZnVuY3Rpb24oc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBgbmF0aXZlU3BsaXRgXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSBcIltvYmplY3QgUmVnRXhwXVwiKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHIsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLm11bHRpbGluZSA/IFwibVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLmV4dGVuZGVkID8gXCJ4XCIgOiBcIlwiKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKSxcbiAgICAgIC8vIEZpcmVmb3ggMytcbiAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyBcImdcIiksXG4gICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgIHN0ciArPSBcIlwiOyAvLyBUeXBlLWNvbnZlcnRcbiAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VwYXJhdG9yLnNvdXJjZSArIFwiJCg/IVxcXFxzKVwiLCBmbGFncyk7XG4gICAgfVxuICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgKi9cbiAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZiA/IC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgIGxpbWl0ID4+PiAwOyAvLyBUb1VpbnQzMihsaW1pdClcbiAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHIpKSB7XG4gICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoXCJcIikpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyLXNwbGl0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJbnNwaXJlZCBieSBHb29nbGUgQ2xvc3VyZTpcbi8vIGh0dHA6Ly9jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vc3ZuL2RvY3MvXG4vLyBjbG9zdXJlX2dvb2dfYXJyYXlfYXJyYXkuanMuaHRtbCNnb29nLmFycmF5LmNsZWFyXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbHVlID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YWx1ZSh0aGlzKS5sZW5ndGggPSAwO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9hcnJheS8jL2NsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAsIHggPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLypjdXN0b21DcmVhdGUqLykge1xuXHR2YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2Zcblx0ICAsIGN1c3RvbUNyZWF0ZSA9IGFyZ3VtZW50c1swXSB8fCBjcmVhdGU7XG5cdGlmICh0eXBlb2Ygc2V0UHJvdG90eXBlT2YgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIGdldFByb3RvdHlwZU9mKHNldFByb3RvdHlwZU9mKGN1c3RvbUNyZWF0ZShudWxsKSwgeCkpID09PSB4O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBCaWcgdGhhbmtzIHRvIEBXZWJSZWZsZWN0aW9uIGZvciBzb3J0aW5nIHRoaXMgb3V0XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uLzU1OTM1NTRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgICAgICA9IHJlcXVpcmUoJy4uL2lzLW9iamVjdCcpXG4gICwgdmFsdWUgICAgICAgICA9IHJlcXVpcmUoJy4uL3ZhbGlkLXZhbHVlJylcblxuICAsIGlzUHJvdG90eXBlT2YgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2ZcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIG51bGxEZXNjID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSxcblx0XHR2YWx1ZTogdW5kZWZpbmVkIH1cbiAgLCB2YWxpZGF0ZTtcblxudmFsaWRhdGUgPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0dmFsdWUob2JqKTtcblx0aWYgKChwcm90b3R5cGUgPT09IG51bGwpIHx8IGlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiBvYmo7XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3RvdHlwZSBtdXN0IGJlIG51bGwgb3IgYW4gb2JqZWN0Jyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdHZhciBmbiwgc2V0O1xuXHRpZiAoIXN0YXR1cykgcmV0dXJuIG51bGw7XG5cdGlmIChzdGF0dXMubGV2ZWwgPT09IDIpIHtcblx0XHRpZiAoc3RhdHVzLnNldCkge1xuXHRcdFx0c2V0ID0gc3RhdHVzLnNldDtcblx0XHRcdGZuID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdFx0XHRcdHNldC5jYWxsKHZhbGlkYXRlKG9iaiwgcHJvdG90eXBlKSwgcHJvdG90eXBlKTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZuID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdFx0XHRcdHZhbGlkYXRlKG9iaiwgcHJvdG90eXBlKS5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmbiA9IGZ1bmN0aW9uIHNlbGYob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdHZhciBpc051bGxCYXNlO1xuXHRcdFx0dmFsaWRhdGUob2JqLCBwcm90b3R5cGUpO1xuXHRcdFx0aXNOdWxsQmFzZSA9IGlzUHJvdG90eXBlT2YuY2FsbChzZWxmLm51bGxQb2x5ZmlsbCwgb2JqKTtcblx0XHRcdGlmIChpc051bGxCYXNlKSBkZWxldGUgc2VsZi5udWxsUG9seWZpbGwuX19wcm90b19fO1xuXHRcdFx0aWYgKHByb3RvdHlwZSA9PT0gbnVsbCkgcHJvdG90eXBlID0gc2VsZi5udWxsUG9seWZpbGw7XG5cdFx0XHRvYmouX19wcm90b19fID0gcHJvdG90eXBlO1xuXHRcdFx0aWYgKGlzTnVsbEJhc2UpIGRlZmluZVByb3BlcnR5KHNlbGYubnVsbFBvbHlmaWxsLCAnX19wcm90b19fJywgbnVsbERlc2MpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdsZXZlbCcsIHsgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogc3RhdHVzLmxldmVsIH0pO1xufSgoZnVuY3Rpb24gKCkge1xuXHR2YXIgeCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHkgPSB7fSwgc2V0XG5cdCAgLCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJyk7XG5cblx0aWYgKGRlc2MpIHtcblx0XHR0cnkge1xuXHRcdFx0c2V0ID0gZGVzYy5zZXQ7IC8vIE9wZXJhIGNyYXNoZXMgYXQgdGhpcyBwb2ludFxuXHRcdFx0c2V0LmNhbGwoeCwgeSk7XG5cdFx0fSBjYXRjaCAoaWdub3JlKSB7IH1cblx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID09PSB5KSByZXR1cm4geyBzZXQ6IHNldCwgbGV2ZWw6IDIgfTtcblx0fVxuXG5cdHguX19wcm90b19fID0geTtcblx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0geSkgcmV0dXJuIHsgbGV2ZWw6IDIgfTtcblxuXHR4ID0ge307XG5cdHguX19wcm90b19fID0geTtcblx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0geSkgcmV0dXJuIHsgbGV2ZWw6IDEgfTtcblxuXHRyZXR1cm4gZmFsc2U7XG59KCkpKSk7XG5cbnJlcXVpcmUoJy4uL2NyZWF0ZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2Yvc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gU3RyaW5nLnByb3RvdHlwZS5jb250YWluc1xuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSXRlcmFibGUgPSByZXF1aXJlKCcuL2lzLWl0ZXJhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LWl0ZXJhdG9yL3ZhbGlkLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKCkgPyBNYXAgOiByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LW1hcC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkU3RhdGUgPSBleHBvcnRzLnNhdmVTdGF0ZSA9IHVuZGVmaW5lZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBRdW90YUV4Y2VlZGVkRXJyb3JzID0gWydRdW90YUV4Y2VlZGVkRXJyb3InLCAnUVVPVEFfRVhDRUVERURfRVJSJ107IC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG5cblxudmFyIFNlY3VyaXR5RXJyb3IgPSAnU2VjdXJpdHlFcnJvcic7XG52YXIgS2V5UHJlZml4ID0gJ0BASGlzdG9yeS8nO1xuXG52YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICByZXR1cm4gS2V5UHJlZml4ICsga2V5O1xufTtcblxudmFyIHNhdmVTdGF0ZSA9IGV4cG9ydHMuc2F2ZVN0YXRlID0gZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgaWYgKCF3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAvLyBTZXNzaW9uIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBvciBoaWRkZW4uXG4gICAgLy8gc2Vzc2lvblN0b3JhZ2UgaXMgdW5kZWZpbmVkIGluIEludGVybmV0IEV4cGxvcmVyIHdoZW4gc2VydmVkIHZpYSBmaWxlIHByb3RvY29sLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgZHVlIHRvIHNlY3VyaXR5IHNldHRpbmdzJykgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoUXVvdGFFeGNlZWRlZEVycm9ycy5pbmRleE9mKGVycm9yLm5hbWUpID49IDAgJiYgd2luZG93LnNlc3Npb25TdG9yYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gU2FmYXJpIFwicHJpdmF0ZSBtb2RlXCIgdGhyb3dzIFF1b3RhRXhjZWVkZWRFcnJvci5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGluIFNhZmFyaSBwcml2YXRlIG1vZGUnKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG52YXIgcmVhZFN0YXRlID0gZXhwb3J0cy5yZWFkU3RhdGUgPSBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gIHZhciBqc29uID0gdm9pZCAwO1xuICB0cnkge1xuICAgIGpzb24gPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVLZXkoa2V5KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHJlYWQgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgZHVlIHRvIHNlY3VyaXR5IHNldHRpbmdzJykgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIEpTT04uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0RPTVN0YXRlU3RvcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy45LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9nZXRuYXRpdmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMi4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciByb290ID0gcmVxdWlyZSgnbG9kYXNoLl9yb290Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInYF0vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICdgJzogJyYjOTY7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVIdG1sQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGh0bWxFc2NhcGVzW2Nocl07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBTeW1ib2wgPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IG9uZS4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBmb3IgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gU3ltYm9sID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiIGluIGBzdHJpbmdgIHRvXG4gKiB0aGVpciBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gKiBTZWUgW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQmFja3RpY2tzIGFyZSBlc2NhcGVkIGJlY2F1c2UgaW4gSUUgPCA5LCB0aGV5IGNhbiBicmVhayBvdXQgb2ZcbiAqIGF0dHJpYnV0ZSB2YWx1ZXMgb3IgSFRNTCBjb21tZW50cy4gU2VlIFsjNTldKGh0dHBzOi8vaHRtbDVzZWMub3JnLyM1OSksXG4gKiBbIzEwMl0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwMiksIFsjMTA4XShodHRwczovL2h0bWw1c2VjLm9yZy8jMTA4KSwgYW5kXG4gKiBbIzEzM10oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEzMykgb2YgdGhlIFtIVE1MNSBTZWN1cml0eSBDaGVhdHNoZWV0XShodHRwczovL2h0bWw1c2VjLm9yZy8pXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXMgW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKVxuICogdG8gcmVkdWNlIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guZXNjYXBlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjAuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJhc2VGb3IgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vmb3InKSxcbiAgICBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKCdsb2Rhc2guX2JpbmRjYWxsYmFjaycpLFxuICAgIGtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9yT3duYCBvciBgXy5mb3JPd25SaWdodGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGb3JPd24ob2JqZWN0RnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgIGlmICh0eXBlb2YgaXRlcmF0ZWUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSk7XG4gIH07XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBpbnZva2luZyBgaXRlcmF0ZWVgXG4gKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBsb2dzICdhJyBhbmQgJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbnZhciBmb3JPd24gPSBjcmVhdGVGb3JPd24oYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yT3duO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5mb3Jvd24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjQgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzZWxlY3RvclBhcnNlcjtcblxudmFyIF9icm93c2VyU3BsaXQgPSByZXF1aXJlKCdicm93c2VyLXNwbGl0Jyk7XG5cbnZhciBfYnJvd3NlclNwbGl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jyb3dzZXJTcGxpdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjbGFzc0lkU3BsaXQgPSAvKFtcXC4jXT9bYS16QS1aMC05XFx1MDA3Ri1cXHVGRkZGXzotXSspLztcbnZhciBub3RDbGFzc0lkID0gL15cXC58Iy87XG5cbmZ1bmN0aW9uIHNlbGVjdG9yUGFyc2VyKCkge1xuICB2YXIgc2VsZWN0b3IgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnJyA6IGFyZ3VtZW50c1swXTtcblxuICB2YXIgdGFnTmFtZSA9IHZvaWQgMDtcbiAgdmFyIGlkID0gJyc7XG4gIHZhciBjbGFzc2VzID0gW107XG5cbiAgdmFyIHRhZ1BhcnRzID0gKDAsIF9icm93c2VyU3BsaXQyLmRlZmF1bHQpKHNlbGVjdG9yLCBjbGFzc0lkU3BsaXQpO1xuXG4gIGlmIChub3RDbGFzc0lkLnRlc3QodGFnUGFydHNbMV0pIHx8IHNlbGVjdG9yID09PSAnJykge1xuICAgIHRhZ05hbWUgPSAnZGl2JztcbiAgfVxuXG4gIHZhciBwYXJ0ID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgdmFyIGkgPSB2b2lkIDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHRhZ1BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydCA9IHRhZ1BhcnRzW2ldO1xuXG4gICAgaWYgKCFwYXJ0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gcGFydC5jaGFyQXQoMCk7XG5cbiAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgIHRhZ05hbWUgPSBwYXJ0O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy4nKSB7XG4gICAgICBjbGFzc2VzLnB1c2gocGFydC5zdWJzdHJpbmcoMSwgcGFydC5sZW5ndGgpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcjJykge1xuICAgICAgaWQgPSBwYXJ0LnN1YnN0cmluZygxLCBwYXJ0Lmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMuam9pbignICcpXG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9zZWxlY3RvclBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBodHRwczovL2dpdGh1Yi5jb20vTWF0dC1Fc2NoL3ZpcnR1YWwtZG9tL2Jsb2IvbWFzdGVyL3ZpcnR1YWwtaHlwZXJzY3JpcHQvcGFyc2UtdGFnLmpzXG5cbnZhciBzcGxpdCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3BsaXQnKTtcblxudmFyIGNsYXNzSWRTcGxpdCA9IC8oW1xcLiNdP1thLXpBLVowLTlcXHUwMDdGLVxcdUZGRkZfOi1dKykvO1xudmFyIG5vdENsYXNzSWQgPSAvXlxcLnwjLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVNlbGVjdG9yKHNlbGVjdG9yLCB1cHBlcikge1xuICBzZWxlY3RvciA9IHNlbGVjdG9yIHx8ICcnO1xuICB2YXIgdGFnTmFtZTtcbiAgdmFyIGlkID0gJyc7XG4gIHZhciBjbGFzc2VzID0gW107XG5cbiAgdmFyIHRhZ1BhcnRzID0gc3BsaXQoc2VsZWN0b3IsIGNsYXNzSWRTcGxpdCk7XG5cbiAgaWYgKG5vdENsYXNzSWQudGVzdCh0YWdQYXJ0c1sxXSkgfHwgc2VsZWN0b3IgPT09ICcnKSB7XG4gICAgdGFnTmFtZSA9ICdkaXYnO1xuICB9XG5cbiAgdmFyIHBhcnQsIHR5cGUsIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHRhZ1BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydCA9IHRhZ1BhcnRzW2ldO1xuXG4gICAgaWYgKCFwYXJ0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gcGFydC5jaGFyQXQoMCk7XG5cbiAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgIHRhZ05hbWUgPSBwYXJ0O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy4nKSB7XG4gICAgICBjbGFzc2VzLnB1c2gocGFydC5zdWJzdHJpbmcoMSwgcGFydC5sZW5ndGgpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcjJykge1xuICAgICAgaWQgPSBwYXJ0LnN1YnN0cmluZygxLCBwYXJ0Lmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWdOYW1lOiB1cHBlciA9PT0gdHJ1ZSA/IHRhZ05hbWUudG9VcHBlckNhc2UoKSA6IHRhZ05hbWUsXG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKCcgJylcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL3BhcnNlLXNlbGVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgKiBmcm9tIFwiLi4vc3JjXCI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy91aS50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJVmFsdWVDb21wb25lbnRTaW5rcyB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgU2l6ZSwgQXR0YWNobWVudCwgRmxvYXQgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCJ1dGlsc1wiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYsIGEgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVudSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHN1Ym1lbnU/OiBib29sZWFuO1xuICAgIHNlY29uZGFyeT86IGJvb2xlYW47XG4gICAgcG9pbnRpbmc/OiBib29sZWFuO1xuICAgIHRhYnVsYXI/OiBib29sZWFuO1xuICAgIHRleHQ/OiBib29sZWFuO1xuICAgIHZlcnRpY2FsPzogYm9vbGVhbjtcbiAgICBwYWdpbmF0aW9uPzogYm9vbGVhbjtcbiAgICBmaXhlZD86IGJvb2xlYW47XG4gICAgc3RhY2thYmxlPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgaWNvbj86IGJvb2xlYW47XG4gICAgbGFiZWxsZWQ/OiBib29sZWFuO1xuICAgIGNvbXBhY3Q/OiBib29sZWFuO1xuICAgIGV2ZW5seURpdmlkZWQ/OiBib29sZWFuO1xuICAgIGJvcmRlcmxlc3M/OiBib29sZWFuO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cbiAgZXhwb3J0IHR5cGUgQ29udGVudCA9IEFycmF5PE1lbnVJdGVtPjtcbiAgZXhwb3J0IGludGVyZmFjZSBNZW51SXRlbSB7XG4gICAgbGluaz86IGJvb2xlYW47XG4gICAgZG93bj86IGJvb2xlYW47XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgaGVhZGVyPzogYm9vbGVhbjtcbiAgICBmaXR0ZWQ/OiBib29sZWFuO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgICBocmVmPzogc3RyaW5nO1xuICAgIGJvZHk6IERPTUNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWVudSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgYW4gYXNzb3J0bWVudCBvZiBpdGVtcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIFx0c2Vjb25kYXJ5PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBkZS1lbXBoYXNpemUgaXRzIGNvbnRlbnQuXG4gICAqIFx0cG9pbnRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGJlIHBvaW50aW5nIHRvIG5lYXJieSBjb250ZW50LlxuICAgKiBcdHRhYnVsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGJlIHN1aXRlZCBmb3IgdGFicy5cbiAgICogXHR0ZXh0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBmb3IgdGV4dCBjb250ZW50LlxuICAgKiBcdHZlcnRpY2FsPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBkaXNwbGF5IGl0cyBjb250ZW50IHZlcnRpY2FsbHkuXG4gICAqIFx0cGFnaW5hdGlvbj86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZW51IGNvbnRlbnQgdG8gcHJlc2VudCBsaW5rcyB0byBwYWdlcyBvZiBjb250ZW50LlxuICAgKiBcdGZpeGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBhcHBlYXIgZml4ZWQgdG8gaXRzIGNvbnRleHQuXG4gICAqIFx0c3RhY2thYmxlPzogYm9vbGVhbiAtIEVuc3VyZXMgdGhlIG1lbnUgY29udGVudCBzdGFja3Mgb24gbW9iaWxlIHJlc29sdXRpb25zLlxuICAgKiBcdGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBoYXZlIGl0cyBjb2xvcnMgaW52ZXJ0ZWQuXG4gICAqIFx0aWNvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgZm9yIGljb24gY29udGVudC5cbiAgICogXHRsYWJlbGxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgZm9yIGxhYmVsbGVkIGljb24gY29udGVudC5cbiAgICogXHRjb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBzbyB0aGF0IGl0IHRha2VzIG9ubHkgdGhlIGFtb3VudCBvZiBzcGFjZSBuZWNjZXNhcnkuXG4gICAqIFx0ZXZlbmx5RGl2aWRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCBpdHMgY29udGVudCBpcyBldmVubHkgZGl2aWRlZC5cbiAgICogXHRib3JkZXJsZXNzPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBzbyB0aGF0IHRoZXJlIGFyZSBubyBib3JkZXJzIGJldHdlZW4gaXRzIGNvbnRlbnQuXG4gICAqIFx0Y29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbWVudS5cbiAgICogXHRhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFRoZSBhdHRhY2htZW50IG9mIHRoZSBtZW51LlxuICAgKiBcdHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIG1lbnUuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEFycmF5IG9mIHt9XG4gICAqIFx0bGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYXBwZWFyIGNsaWNrYWJsZS5cbiAgICogXHRkb3duPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0byBhcHBlYXIgcHJlc3NlZC5cbiAgICogXHRhY3RpdmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGJlIG1vcmUgcHJvbm91bmNlZC5cbiAgICogXHRkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiBcdGhlYWRlcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdGV4dCB0byBiZSBtb3JlIHByb25vdW5jZWQuXG4gICAqIFx0Zml0dGVkPzogYm9vbGVhbiAtIFJlbW92ZXMgdGhlIHBhZGRpbmcgb2YgdGhlIGl0ZW0uXG4gICAqICAgICAgICAgaWNvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gZm9yIGljb24gY29udGVudC5cbiAgICogXHRjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBpdGVtLlxuICAgKiBcdGZsb2F0PyBGbG9hdCAtIFRoZSBhbGlnbm1lbnQgb2YgdGhlIGl0ZW0uXG4gICAqIFx0aHJlZj86IHN0cmluZyAtIFRoZSBsaW5rIGZvciB0aGUgaXRlbS5cbiAgICogXHRib2R5OiBET01Db250ZW50IC0gVGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KTogSVZhbHVlQ29tcG9uZW50U2lua3M8Q29udGVudD4ge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcblxuICAgICAgY29uc3QgY2xpY2skID0gc291cmNlcy5ET00uc2VsZWN0KFwiLnVpLm1lbnUgPiAuaXRlbVwiKS5ldmVudHMoXCJjbGlja1wiKTtcbiAgICAgIGNvbnN0IGl0ZW1zJCA9IHNvdXJjZXMuY29udGVudCQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IGNsaWNrZWRJZCQgPSBjbGljayQubWFwKGV2ID0+IHBhcnNlSW50KChldiBhcyBhbnkpLmN1cnJlbnRUYXJnZXQuaWQpKVxuICAgICAgICAuZmlsdGVyKG4gPT4gIWlzTmFOKG4pICYmIHR5cGVvZiAobikgIT09IFwidW5kZWZpbmVkXCIpO1xuICAgICAgY29uc3QgY2xpY2tlZEl0ZW0kID0gaXRlbXMkLm1hcChpdGVtcyA9PiBjbGlja2VkSWQkLm1hcChpZCA9PiBpdGVtc1tpZF0pKS5mbGF0dGVuKClcbiAgICAgICAgLmZpbHRlcihpdGVtID0+ICFpdGVtLmRpc2FibGVkKTtcblxuICAgICAgY29uc3QgdnRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgaXRlbXMkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2dHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5tZW51XCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgICAgdmFsdWUkOiBjbGlja2VkSXRlbSRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1lbnUgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGFuIGFzc29ydG1lbnQgb2YgaXRlbXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiBcdHNlY29uZGFyeT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gZGUtZW1waGFzaXplIGl0cyBjb250ZW50LlxuICAgKiBcdHBvaW50aW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBiZSBwb2ludGluZyB0byBuZWFyYnkgY29udGVudC5cbiAgICogXHR0YWJ1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBiZSBzdWl0ZWQgZm9yIHRhYnMuXG4gICAqIFx0dGV4dD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgZm9yIHRleHQgY29udGVudC5cbiAgICogXHR2ZXJ0aWNhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gZGlzcGxheSBpdHMgY29udGVudCB2ZXJ0aWNhbGx5LlxuICAgKiBcdHBhZ2luYXRpb24/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVudSBjb250ZW50IHRvIHByZXNlbnQgbGlua3MgdG8gcGFnZXMgb2YgY29udGVudC5cbiAgICogXHRmaXhlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gYXBwZWFyIGZpeGVkIHRvIGl0cyBjb250ZXh0LlxuICAgKiBcdHN0YWNrYWJsZT86IGJvb2xlYW4gLSBFbnN1cmVzIHRoZSBtZW51IGNvbnRlbnQgc3RhY2tzIG9uIG1vYmlsZSByZXNvbHV0aW9ucy5cbiAgICogXHRpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gaGF2ZSBpdHMgY29sb3JzIGludmVydGVkLlxuICAgKiBcdGljb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IGZvciBpY29uIGNvbnRlbnQuXG4gICAqIFx0bGFiZWxsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IGZvciBsYWJlbGxlZCBpY29uIGNvbnRlbnQuXG4gICAqIFx0Y29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCBpdCB0YWtlcyBvbmx5IHRoZSBhbW91bnQgb2Ygc3BhY2UgbmVjY2VzYXJ5LlxuICAgKiBcdGV2ZW5seURpdmlkZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHNvIHRoYXQgaXRzIGNvbnRlbnQgaXMgZXZlbmx5IGRpdmlkZWQuXG4gICAqIFx0Ym9yZGVybGVzcz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCB0aGVyZSBhcmUgbm8gYm9yZGVycyBiZXR3ZWVuIGl0cyBjb250ZW50LlxuICAgKiBcdGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIG1lbnUuXG4gICAqIFx0YXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBUaGUgYXR0YWNobWVudCBvZiB0aGUgbWVudS5cbiAgICogXHRzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBtZW51LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiBcdGxpbms/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGFwcGVhciBjbGlja2FibGUuXG4gICAqIFx0ZG93bj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYXBwZWFyIHByZXNzZWQuXG4gICAqIFx0YWN0aXZlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0byBiZSBtb3JlIHByb25vdW5jZWQuXG4gICAqIFx0ZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogXHRoZWFkZXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRleHQgdG8gYmUgbW9yZSBwcm9ub3VuY2VkLlxuICAgKiBcdGZpdHRlZD86IGJvb2xlYW4gLSBSZW1vdmVzIHRoZSBwYWRkaW5nIG9mIHRoZSBpdGVtLlxuICAgKiAgaWNvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gZm9yIGljb24gY29udGVudC5cbiAgICogXHRjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBpdGVtLlxuICAgKiBcdGZsb2F0PyBGbG9hdCAtIFRoZSBhbGlnbm1lbnQgb2YgdGhlIGl0ZW0uXG4gICAqIFx0aHJlZj86IHN0cmluZyAtIFRoZSBsaW5rIGZvciB0aGUgaXRlbS5cbiAgICogXHRib2R5OiBET01Db250ZW50IC0gVGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgQ29udGVudCA9IHt9LCBjOiBDb250ZW50ID0gW10pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gKHBPckMgaW5zdGFuY2VvZiBBcnJheSkgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSAocE9yQyBpbnN0YW5jZW9mIEFycmF5KSA/IHBPckMgOiBjO1xuICAgIGxldCBpdGVtcyA9IGNvbnRlbnQubWFwKGl0ZW0gPT4gaXRlbS5ocmVmXG4gICAgICA/IGEoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldEl0ZW1DbGFzc25hbWUoaXRlbSksIGlkOiBjb250ZW50LmluZGV4T2YoaXRlbSksIGhyZWY6IGl0ZW0uaHJlZiB9IH0sIGl0ZW0uYm9keSlcbiAgICAgIDogZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRJdGVtQ2xhc3NuYW1lKGl0ZW0pLCBpZDogY29udGVudC5pbmRleE9mKGl0ZW0pIH0gfSwgaXRlbS5ib2R5KVxuICAgICk7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzLCBjb250ZW50Lmxlbmd0aCkgfSB9LCBpdGVtcyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcywgbGVuZ3RoOiBudW1iZXIpIHtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmICghcHJvcHMuc3VibWVudSkge1xuICAgICAgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2Vjb25kYXJ5KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2Vjb25kYXJ5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wb2ludGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHBvaW50aW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWJ1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdGFidWxhclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGV4dCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRleHRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBhZ2luYXRpb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwYWdpbmF0aW9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5maXhlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZpeGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zdGFja2FibGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzdGFja2FibGVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmljb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpY29uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sYWJlbGxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxhYmVsbGVkIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXBhY3QpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb21wYWN0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ib3JkZXJsZXNzKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYm9yZGVybGVzc1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZXZlbmx5RGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChsZW5ndGgpICsgXCIgaXRlbVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmF0dGFjaG1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQXR0YWNobWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hdHRhY2htZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgbWVudVwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SXRlbUNsYXNzbmFtZShpdGVtOiBNZW51SXRlbSkge1xuICAgIGxldCBjbGFzc05hbWUgPSBcIlwiO1xuICAgIGlmIChpdGVtLmRvd24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkb3duXCI7XG4gICAgfVxuICAgIGlmIChpdGVtLmFjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuICAgIH1cbiAgICBpZiAoaXRlbS5oZWFkZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBoZWFkZXJcIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uZml0dGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxseSBmaXR0ZWRcIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0ubGluaykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxpbmtcIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChpdGVtLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKGl0ZW0uZmxvYXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChpdGVtLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKGl0ZW0uY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgaXRlbVwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9tZW51L2luZGV4LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIERlYm91bmNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYm91bmNlT3BlcmF0b3IoZHQsIGlucykge1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVib3VuY2UnO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIH1cbiAgICBEZWJvdW5jZU9wZXJhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgfTtcbiAgICBEZWJvdW5jZU9wZXJhdG9yLnByb3RvdHlwZS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLmlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICAgICAgdS5fbih0KTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZU9wZXJhdG9yLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogRGVsYXlzIGV2ZW50cyB1bnRpbCBhIGNlcnRhaW4gYW1vdW50IG9mIHNpbGVuY2UgaGFzIHBhc3NlZC4gSWYgdGhhdCB0aW1lc3BhblxuICogb2Ygc2lsZW5jZSBpcyBub3QgbWV0IHRoZSBldmVudCBpcyBkcm9wcGVkLlxuICpcbiAqIE1hcmJsZSBkaWFncmFtOlxuICpcbiAqIGBgYHRleHRcbiAqIC0tMS0tLS0yLS0zLS00LS0tLTV8XG4gKiAgICAgZGVib3VuY2UoNjApXG4gKiAtLS0tLTEtLS0tLS0tLS0tNC0tfFxuICogYGBgXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IGZyb21EaWFncmFtIGZyb20gJ3hzdHJlYW0vZXh0cmEvZnJvbURpYWdyYW0nXG4gKiBpbXBvcnQgZGVib3VuY2UgZnJvbSAneHN0cmVhbS9leHRyYS9kZWJvdW5jZSdcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSBmcm9tRGlhZ3JhbSgnLS0xLS0tLTItLTMtLTQtLS0tNXwnKVxuICogIC5jb21wb3NlKGRlYm91bmNlKDYwKSlcbiAqXG4gKiBzdHJlYW0uYWRkTGlzdGVuZXIoe1xuICogICBuZXh0OiBpID0+IGNvbnNvbGUubG9nKGkpLFxuICogICBlcnJvcjogZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdjb21wbGV0ZWQnKVxuICogfSlcbiAqIGBgYFxuICpcbiAqIGBgYHRleHRcbiAqID4gMVxuICogPiA0XG4gKiA+IGNvbXBsZXRlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZCBUaGUgYW1vdW50IG9mIHNpbGVuY2UgcmVxdWlyZWQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShwZXJpb2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVib3VuY2VPcGVyYXRvcihpbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlN0cmVhbShuZXcgRGVib3VuY2VPcGVyYXRvcihwZXJpb2QsIGlucykpO1xuICAgIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWJvdW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2V4dHJhL2RlYm91bmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIERlbGF5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5T3BlcmF0b3IoZHQsIGlucykge1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVsYXknO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgfVxuICAgIERlbGF5T3BlcmF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgIH07XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHUuX24odCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1Ll9lKGVycik7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIERlbGF5cyBwZXJpb2RpYyBldmVudHMgYnkgYSBnaXZlbiB0aW1lIHBlcmlvZC5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAxLS0tLTItLTMtLTQtLS0tNXxcbiAqICAgICBkZWxheSg2MClcbiAqIC0tLTEtLS0tMi0tMy0tNC0tLS01fFxuICogYGBgXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IGZyb21EaWFncmFtIGZyb20gJ3hzdHJlYW0vZXh0cmEvZnJvbURpYWdyYW0nXG4gKiBpbXBvcnQgZGVsYXkgZnJvbSAneHN0cmVhbS9leHRyYS9kZWxheSdcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSBmcm9tRGlhZ3JhbSgnMS0tLS0yLS0zLS00LS0tLTV8JylcbiAqICAuY29tcG9zZShkZWxheSg2MCkpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IDEgIChhZnRlciA2MCBtcylcbiAqID4gMiAgKGFmdGVyIDE2MCBtcylcbiAqID4gMyAgKGFmdGVyIDIyMCBtcylcbiAqID4gNCAgKGFmdGVyIDI4MCBtcylcbiAqID4gNSAgKGFmdGVyIDM4MCBtcylcbiAqID4gY29tcGxldGVkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIFRoZSBhbW91bnQgb2Ygc2lsZW5jZSByZXF1aXJlZCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGRlbGF5KHBlcmlvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheU9wZXJhdG9yKGlucykge1xuICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU3RyZWFtKG5ldyBEZWxheU9wZXJhdG9yKHBlcmlvZCwgaW5zKSk7XG4gICAgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3hzdHJlYW0vZXh0cmEvZGVsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG52YXIgZW1wdHkgPSB7fTtcbnZhciBEcm9wUmVwZWF0c09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcm9wUmVwZWF0c09wZXJhdG9yKGlucywgZm4pIHtcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Ryb3BSZXBlYXRzJztcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnYgPSBlbXB0eTtcbiAgICB9XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIERyb3BSZXBlYXRzT3BlcmF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgICAgIHRoaXMudiA9IGVtcHR5O1xuICAgIH07XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuaXNFcSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZuID8gdGhpcy5mbih4LCB5KSA6IHggPT09IHk7XG4gICAgfTtcbiAgICBEcm9wUmVwZWF0c09wZXJhdG9yLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnY7XG4gICAgICAgIGlmICh2ICE9PSBlbXB0eSAmJiB0aGlzLmlzRXEodCwgdikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudiA9IEFycmF5LmlzQXJyYXkodCkgPyB0LnNsaWNlKCkgOiB0O1xuICAgICAgICB1Ll9uKHQpO1xuICAgIH07XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIERyb3BSZXBlYXRzT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5Ecm9wUmVwZWF0c09wZXJhdG9yID0gRHJvcFJlcGVhdHNPcGVyYXRvcjtcbi8qKlxuICogRHJvcHMgY29uc2VjdXRpdmUgZHVwbGljYXRlIHZhbHVlcyBpbiBhIHN0cmVhbS5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLTItLTEtLTEtLTEtLTItLTMtLTQtLTMtLTN8XG4gKiAgICAgZHJvcFJlcGVhdHNcbiAqIC0tMS0tMi0tMS0tLS0tLS0tMi0tMy0tNC0tMy0tLXxcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBkcm9wUmVwZWF0cyBmcm9tICd4c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzJ1xuICpcbiAqIGNvbnN0IHN0cmVhbSA9IHhzLm9mKDEsIDIsIDEsIDEsIDEsIDIsIDMsIDQsIDMsIDMpXG4gKiAgIC5jb21wb3NlKGRyb3BSZXBlYXRzKCkpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IDFcbiAqID4gMlxuICogPiAxXG4gKiA+IDJcbiAqID4gM1xuICogPiA0XG4gKiA+IDNcbiAqID4gY29tcGxldGVkXG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlIHdpdGggYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbjpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IGRyb3BSZXBlYXRzIGZyb20gJ3hzdHJlYW0vZXh0cmEvZHJvcFJlcGVhdHMnXG4gKlxuICogY29uc3Qgc3RyZWFtID0geHMub2YoJ2EnLCAnYicsICdhJywgJ0EnLCAnQicsICdiJylcbiAqICAgLmNvbXBvc2UoZHJvcFJlcGVhdHMoKHgsIHkpID0+IHgudG9Mb3dlckNhc2UoKSA9PT0geS50b0xvd2VyQ2FzZSgpKSlcbiAqXG4gKiBzdHJlYW0uYWRkTGlzdGVuZXIoe1xuICogICBuZXh0OiBpID0+IGNvbnNvbGUubG9nKGkpLFxuICogICBlcnJvcjogZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdjb21wbGV0ZWQnKVxuICogfSlcbiAqIGBgYFxuICpcbiAqIGBgYHRleHRcbiAqID4gYVxuICogPiBiXG4gKiA+IGFcbiAqID4gQlxuICogPiBjb21wbGV0ZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGlzRXF1YWwgQW4gb3B0aW9uYWwgZnVuY3Rpb24gb2YgdHlwZVxuICogYCh4OiBULCB5OiBUKSA9PiBib29sZWFuYCB0aGF0IHRha2VzIGFuIGV2ZW50IGZyb20gdGhlIGlucHV0IHN0cmVhbSBhbmRcbiAqIGNoZWNrcyBpZiBpdCBpcyBlcXVhbCB0byBwcmV2aW91cyBldmVudCwgYnkgcmV0dXJuaW5nIGEgYm9vbGVhbi5cbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqL1xuZnVuY3Rpb24gZHJvcFJlcGVhdHMoaXNFcXVhbCkge1xuICAgIGlmIChpc0VxdWFsID09PSB2b2lkIDApIHsgaXNFcXVhbCA9IHZvaWQgMDsgfVxuICAgIHJldHVybiBmdW5jdGlvbiBkcm9wUmVwZWF0c09wZXJhdG9yKGlucykge1xuICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU3RyZWFtKG5ldyBEcm9wUmVwZWF0c09wZXJhdG9yKGlucywgaXNFcXVhbCkpO1xuICAgIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkcm9wUmVwZWF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3BSZXBlYXRzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9jcy1zcmMvZG9jcy5sZXNzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBydW4gfSBmcm9tIFwiQGN5Y2xlL3hzdHJlYW0tcnVuXCI7XG5pbXBvcnQgeyBtYWtlRE9NRHJpdmVyIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7IG1ha2VSb3V0ZXJEcml2ZXIsIHN1cHBvcnRzSGlzdG9yeSB9IGZyb20gXCJjeWNsaWMtcm91dGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBzd2l0Y2hQYXRoIGZyb20gXCJzd2l0Y2gtcGF0aFwiO1xuXG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL3JvdXRlclwiO1xuaW1wb3J0IHJvdXRlcyBmcm9tIFwiLi9yb3V0ZXNcIjtcbmltcG9ydCB7TGF5b3V0fSBmcm9tIFwiLi9sYXlvdXRcIjtcblxuY29uc3QgaGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeSgpXG4gID8gW2NyZWF0ZUhpc3RvcnkoKSwgc3dpdGNoUGF0aF1cbiAgOiBbY3JlYXRlSGFzaEhpc3RvcnkoKSwgc3dpdGNoUGF0aF07XG5cbmZ1bmN0aW9uIGFwcChkcml2ZXJzKSB7XG4gIGNvbnN0IHBhZ2UgPSBSb3V0ZXIoT2JqZWN0LmFzc2lnbih7fSwgZHJpdmVycywge3JvdXRlc30pKTtcbiAgY29uc3QgbGF5b3V0ID0gTGF5b3V0LnJ1bihkcml2ZXJzLCBwYWdlKTtcbiAgY29uc3Qgc2lua3MgPSB7XG4gICAgRE9NOiBsYXlvdXQuRE9NLFxuICAgIHJvdXRlcjogeHMubWVyZ2UocGFnZS5yb3V0ZXIsIGxheW91dC5yb3V0ZXIpLFxuICB9O1xuICByZXR1cm4gc2lua3M7XG59XG5cbnJ1bihhcHAsIHtcbiAgRE9NOiBtYWtlRE9NRHJpdmVyKFwiLmFwcFwiKSxcbiAgcm91dGVyOiBtYWtlUm91dGVyRHJpdmVyLmFwcGx5KG51bGwsIGhpc3RvcnkpLFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy9hcHAudHMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKCcuL2Zyb21FdmVudCcpO1xudmFyIEJvZHlET01Tb3VyY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvZHlET01Tb3VyY2UoX3J1blN0cmVhbUFkYXB0ZXIsIF9uYW1lKSB7XG4gICAgICAgIHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIgPSBfcnVuU3RyZWFtQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICAgIH1cbiAgICBCb2R5RE9NU291cmNlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbmFsaXR5IGlzIHN0aWxsIHVuZGVmaW5lZC91bmRlY2lkZWQuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQm9keURPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydW5TQSA9IHRoaXMuX3J1blN0cmVhbUFkYXB0ZXI7XG4gICAgICAgIHZhciBvdXQgPSBydW5TQS5yZW1lbWJlcihydW5TQS5hZGFwdCh4c3RyZWFtXzEuZGVmYXVsdC5vZihkb2N1bWVudC5ib2R5KSwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIEJvZHlET01Tb3VyY2UucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHN0cmVhbTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMudXNlQ2FwdHVyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBmcm9tRXZlbnRfMS5mcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgZXZlbnRUeXBlLCBvcHRpb25zLnVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50KGRvY3VtZW50LmJvZHksIGV2ZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIuYWRhcHQoc3RyZWFtLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICByZXR1cm4gQm9keURPTVNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLkJvZHlET01Tb3VyY2UgPSBCb2R5RE9NU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9keURPTVNvdXJjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvQm9keURPTVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIGZyb21FdmVudF8xID0gcmVxdWlyZSgnLi9mcm9tRXZlbnQnKTtcbnZhciBEb2N1bWVudERPTVNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnRET01Tb3VyY2UoX3J1blN0cmVhbUFkYXB0ZXIsIF9uYW1lKSB7XG4gICAgICAgIHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIgPSBfcnVuU3RyZWFtQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICAgIH1cbiAgICBEb2N1bWVudERPTVNvdXJjZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBzdGlsbCB1bmRlZmluZWQvdW5kZWNpZGVkLlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERvY3VtZW50RE9NU291cmNlLnByb3RvdHlwZS5lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJ1blNBID0gdGhpcy5fcnVuU3RyZWFtQWRhcHRlcjtcbiAgICAgICAgdmFyIG91dCA9IHJ1blNBLnJlbWVtYmVyKHJ1blNBLmFkYXB0KHhzdHJlYW1fMS5kZWZhdWx0Lm9mKGRvY3VtZW50KSwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIERvY3VtZW50RE9NU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnVzZUNhcHR1cmUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3RyZWFtID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50KGRvY3VtZW50LCBldmVudFR5cGUsIG9wdGlvbnMudXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBmcm9tRXZlbnRfMS5mcm9tRXZlbnQoZG9jdW1lbnQsIGV2ZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIuYWRhcHQoc3RyZWFtLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jdW1lbnRET01Tb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5Eb2N1bWVudERPTVNvdXJjZSA9IERvY3VtZW50RE9NU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG9jdW1lbnRET01Tb3VyY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL0RvY3VtZW50RE9NU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTY29wZUNoZWNrZXJfMSA9IHJlcXVpcmUoJy4vU2NvcGVDaGVja2VyJyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBtYXRjaGVzU2VsZWN0b3I7XG50cnkge1xuICAgIG1hdGNoZXNTZWxlY3RvciA9IHJlcXVpcmUoXCJtYXRjaGVzLXNlbGVjdG9yXCIpO1xufVxuY2F0Y2ggKGUpIHtcbiAgICBtYXRjaGVzU2VsZWN0b3IgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiB0b0VsQXJyYXkoaW5wdXQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5wdXQpO1xufVxudmFyIEVsZW1lbnRGaW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRGaW5kZXIobmFtZXNwYWNlLCBpc29sYXRlTW9kdWxlKSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLmlzb2xhdGVNb2R1bGUgPSBpc29sYXRlTW9kdWxlO1xuICAgIH1cbiAgICBFbGVtZW50RmluZGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHJvb3RFbGVtZW50KSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICAgICAgaWYgKG5hbWVzcGFjZS5qb2luKFwiXCIpID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjb3BlID0gdXRpbHNfMS5nZXRTY29wZShuYW1lc3BhY2UpO1xuICAgICAgICB2YXIgc2NvcGVDaGVja2VyID0gbmV3IFNjb3BlQ2hlY2tlcl8xLlNjb3BlQ2hlY2tlcihzY29wZSwgdGhpcy5pc29sYXRlTW9kdWxlKTtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdXRpbHNfMS5nZXRTZWxlY3RvcnMobmFtZXNwYWNlKTtcbiAgICAgICAgdmFyIHRvcE5vZGUgPSByb290RWxlbWVudDtcbiAgICAgICAgdmFyIHRvcE5vZGVNYXRjaGVzID0gW107XG4gICAgICAgIGlmIChzY29wZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b3BOb2RlID0gdGhpcy5pc29sYXRlTW9kdWxlLmdldElzb2xhdGVkRWxlbWVudChzY29wZSkgfHwgcm9vdEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgJiYgbWF0Y2hlc1NlbGVjdG9yKHRvcE5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHRvcE5vZGVNYXRjaGVzLnB1c2godG9wTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvRWxBcnJheSh0b3BOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxuICAgICAgICAgICAgLmZpbHRlcihzY29wZUNoZWNrZXIuaXNTdHJpY3RseUluUm9vdFNjb3BlLCBzY29wZUNoZWNrZXIpXG4gICAgICAgICAgICAuY29uY2F0KHRvcE5vZGVNYXRjaGVzKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50RmluZGVyO1xufSgpKTtcbmV4cG9ydHMuRWxlbWVudEZpbmRlciA9IEVsZW1lbnRGaW5kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGVtZW50RmluZGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9FbGVtZW50RmluZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTY29wZUNoZWNrZXJfMSA9IHJlcXVpcmUoJy4vU2NvcGVDaGVja2VyJyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBtYXRjaGVzU2VsZWN0b3I7XG50cnkge1xuICAgIG1hdGNoZXNTZWxlY3RvciA9IHJlcXVpcmUoXCJtYXRjaGVzLXNlbGVjdG9yXCIpO1xufVxuY2F0Y2ggKGUpIHtcbiAgICBtYXRjaGVzU2VsZWN0b3IgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG59XG52YXIgZ0Rlc3RpbmF0aW9uSWQgPSAwO1xuZnVuY3Rpb24gZmluZERlc3RpbmF0aW9uSWQoYXJyLCBzZWFyY2hJZCkge1xuICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgdmFyIG1heEluZGV4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGN1cnJlbnRJbmRleDtcbiAgICB2YXIgY3VycmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgY3VycmVudEVsZW1lbnQgPSBhcnJbY3VycmVudEluZGV4XTtcbiAgICAgICAgdmFyIGN1cnJlbnRJZCA9IGN1cnJlbnRFbGVtZW50LmRlc3RpbmF0aW9uSWQ7XG4gICAgICAgIGlmIChjdXJyZW50SWQgPCBzZWFyY2hJZCkge1xuICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJZCA+IHNlYXJjaElkKSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogQXR0YWNoZXMgYW4gYWN0dWFsIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBET00gcm9vdCBlbGVtZW50LFxuICogaGFuZGxlcyBcImRlc3RpbmF0aW9uc1wiIChpbnRlcmVzdGVkIERPTVNvdXJjZSBvdXRwdXQgc3ViamVjdHMpLCBhbmQgYnViYmxpbmcuXG4gKi9cbnZhciBFdmVudERlbGVnYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnREZWxlZ2F0b3IodG9wRWxlbWVudCwgZXZlbnRUeXBlLCB1c2VDYXB0dXJlLCBpc29sYXRlTW9kdWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudG9wRWxlbWVudCA9IHRvcEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB0aGlzLnVzZUNhcHR1cmUgPSB1c2VDYXB0dXJlO1xuICAgICAgICB0aGlzLmlzb2xhdGVNb2R1bGUgPSBpc29sYXRlTW9kdWxlO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnJvb2YgPSB0b3BFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmICh1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5jYXB0dXJlKGV2KTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9tTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmJ1YmJsZShldik7IH07XG4gICAgICAgIH1cbiAgICAgICAgdG9wRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgdGhpcy5kb21MaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgfVxuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbiAocmF3RXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRvcEVsZW1lbnQuY29udGFpbnMocmF3RXZlbnQuY3VycmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXYgPSB0aGlzLnBhdGNoRXZlbnQocmF3RXZlbnQpO1xuICAgICAgICBmb3IgKHZhciBlbCA9IGV2LnRhcmdldDsgZWwgJiYgZWwgIT09IHRoaXMucm9vZjsgZWwgPSBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudG9wRWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldi5wcm9wYWdhdGlvbkhhc0JlZW5TdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXRjaEV2ZW50QWdhaW5zdERlc3RpbmF0aW9ucyhlbCwgZXYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUubWF0Y2hFdmVudEFnYWluc3REZXN0aW5hdGlvbnMgPSBmdW5jdGlvbiAoZWwsIGV2KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5kZXN0aW5hdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHRoaXMuZGVzdGluYXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKCFkZXN0LnNjb3BlQ2hlY2tlci5pc1N0cmljdGx5SW5Sb290U2NvcGUoZWwpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGVsLCBkZXN0LnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlRXZlbnRDdXJyZW50VGFyZ2V0KGV2LCBlbCk7XG4gICAgICAgICAgICAgICAgZGVzdC5zdWJqZWN0Ll9uKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLmNhcHR1cmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLmRlc3RpbmF0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gdGhpcy5kZXN0aW5hdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGV2LnRhcmdldCwgZGVzdC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBkZXN0LnN1YmplY3QuX24oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUuYWRkRGVzdGluYXRpb24gPSBmdW5jdGlvbiAoc3ViamVjdCwgbmFtZXNwYWNlLCBkZXN0aW5hdGlvbklkKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHV0aWxzXzEuZ2V0U2NvcGUobmFtZXNwYWNlKTtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdXRpbHNfMS5nZXRTZWxlY3RvcnMobmFtZXNwYWNlKTtcbiAgICAgICAgdmFyIHNjb3BlQ2hlY2tlciA9IG5ldyBTY29wZUNoZWNrZXJfMS5TY29wZUNoZWNrZXIoc2NvcGUsIHRoaXMuaXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25zLnB1c2goeyBzdWJqZWN0OiBzdWJqZWN0LCBzY29wZUNoZWNrZXI6IHNjb3BlQ2hlY2tlciwgc2VsZWN0b3I6IHNlbGVjdG9yLCBkZXN0aW5hdGlvbklkOiBkZXN0aW5hdGlvbklkIH0pO1xuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLmNyZWF0ZURlc3RpbmF0aW9uSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnRGVzdGluYXRpb25JZCsrO1xuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLnJlbW92ZURlc3RpbmF0aW9uSWQgPSBmdW5jdGlvbiAoZGVzdGluYXRpb25JZCkge1xuICAgICAgICB2YXIgaSA9IGZpbmREZXN0aW5hdGlvbklkKHRoaXMuZGVzdGluYXRpb25zLCBkZXN0aW5hdGlvbklkKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUucGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHBFdmVudC5wcm9wYWdhdGlvbkhhc0JlZW5TdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBvbGRTdG9wUHJvcGFnYXRpb24gPSBwRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICBwRXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgICAgb2xkU3RvcFByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0aW9uSGFzQmVlblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcEV2ZW50O1xuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLm11dGF0ZUV2ZW50Q3VycmVudFRhcmdldCA9IGZ1bmN0aW9uIChldmVudCwgY3VycmVudFRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VycmVudFRhcmdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwbGVhc2UgdXNlIGV2ZW50Lm93bmVyVGFyZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50Lm93bmVyVGFyZ2V0ID0gY3VycmVudFRhcmdldEVsZW1lbnQ7XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUudXBkYXRlVG9wRWxlbWVudCA9IGZ1bmN0aW9uIChuZXdUb3BFbGVtZW50KSB7XG4gICAgICAgIHRoaXMudG9wRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRUeXBlLCB0aGlzLmRvbUxpc3RlbmVyLCB0aGlzLnVzZUNhcHR1cmUpO1xuICAgICAgICBuZXdUb3BFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFR5cGUsIHRoaXMuZG9tTGlzdGVuZXIsIHRoaXMudXNlQ2FwdHVyZSk7XG4gICAgICAgIHRoaXMudG9wRWxlbWVudCA9IG5ld1RvcEVsZW1lbnQ7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnREZWxlZ2F0b3I7XG59KCkpO1xuZXhwb3J0cy5FdmVudERlbGVnYXRvciA9IEV2ZW50RGVsZWdhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnREZWxlZ2F0b3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL0V2ZW50RGVsZWdhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgSFRNTFNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSFRNTFNvdXJjZShodG1sJCwgcnVuU0EsIF9uYW1lKSB7XG4gICAgICAgIHRoaXMucnVuU0EgPSBydW5TQTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICAgICAgICB0aGlzLl9odG1sJCA9IGh0bWwkO1xuICAgICAgICB0aGlzLl9lbXB0eSQgPSBydW5TQS5hZGFwdCh4c3RyZWFtXzEuZGVmYXVsdC5lbXB0eSgpLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSk7XG4gICAgfVxuICAgIEhUTUxTb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5ydW5TQS5hZGFwdCh0aGlzLl9odG1sJCwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgSFRNTFNvdXJjZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgSFRNTFNvdXJjZSh4c3RyZWFtXzEuZGVmYXVsdC5lbXB0eSgpLCB0aGlzLnJ1blNBLCB0aGlzLl9uYW1lKTtcbiAgICB9O1xuICAgIEhUTUxTb3VyY2UucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX2VtcHR5JDtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBIVE1MU291cmNlO1xufSgpKTtcbmV4cG9ydHMuSFRNTFNvdXJjZSA9IEhUTUxTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MU291cmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9IVE1MU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciBEb2N1bWVudERPTVNvdXJjZV8xID0gcmVxdWlyZSgnLi9Eb2N1bWVudERPTVNvdXJjZScpO1xudmFyIEJvZHlET01Tb3VyY2VfMSA9IHJlcXVpcmUoJy4vQm9keURPTVNvdXJjZScpO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciBFbGVtZW50RmluZGVyXzEgPSByZXF1aXJlKCcuL0VsZW1lbnRGaW5kZXInKTtcbnZhciBmcm9tRXZlbnRfMSA9IHJlcXVpcmUoJy4vZnJvbUV2ZW50Jyk7XG52YXIgaXNvbGF0ZV8xID0gcmVxdWlyZSgnLi9pc29sYXRlJyk7XG52YXIgRXZlbnREZWxlZ2F0b3JfMSA9IHJlcXVpcmUoJy4vRXZlbnREZWxlZ2F0b3InKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG1hdGNoZXNTZWxlY3RvcjtcbnRyeSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yID0gcmVxdWlyZShcIm1hdGNoZXMtc2VsZWN0b3JcIik7XG59XG5jYXRjaCAoZSkge1xuICAgIG1hdGNoZXNTZWxlY3RvciA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbn1cbnZhciBldmVudFR5cGVzVGhhdERvbnRCdWJibGUgPSBbXG4gICAgXCJibHVyXCIsXG4gICAgXCJjYW5wbGF5XCIsXG4gICAgXCJjYW5wbGF5dGhyb3VnaFwiLFxuICAgIFwiY2hhbmdlXCIsXG4gICAgXCJkdXJhdGlvbmNoYW5nZVwiLFxuICAgIFwiZW1wdGllZFwiLFxuICAgIFwiZW5kZWRcIixcbiAgICBcImZvY3VzXCIsXG4gICAgXCJsb2FkXCIsXG4gICAgXCJsb2FkZWRkYXRhXCIsXG4gICAgXCJsb2FkZWRtZXRhZGF0YVwiLFxuICAgIFwibW91c2VlbnRlclwiLFxuICAgIFwibW91c2VsZWF2ZVwiLFxuICAgIFwicGF1c2VcIixcbiAgICBcInBsYXlcIixcbiAgICBcInBsYXlpbmdcIixcbiAgICBcInJhdGVjaGFuZ2VcIixcbiAgICBcInJlc2V0XCIsXG4gICAgXCJzY3JvbGxcIixcbiAgICBcInNlZWtlZFwiLFxuICAgIFwic2Vla2luZ1wiLFxuICAgIFwic3RhbGxlZFwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJzdXNwZW5kXCIsXG4gICAgXCJ0aW1ldXBkYXRlXCIsXG4gICAgXCJ1bmxvYWRcIixcbiAgICBcInZvbHVtZWNoYW5nZVwiLFxuICAgIFwid2FpdGluZ1wiLFxuXTtcbmZ1bmN0aW9uIGRldGVybWluZVVzZUNhcHR1cmUoZXZlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy51c2VDYXB0dXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzdWx0ID0gb3B0aW9ucy51c2VDYXB0dXJlO1xuICAgIH1cbiAgICBpZiAoZXZlbnRUeXBlc1RoYXREb250QnViYmxlLmluZGV4T2YoZXZlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbHRlckJhc2VkT25Jc29sYXRpb24oZG9tU291cmNlLCBzY29wZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBmaWx0ZXJCYXNlZE9uSXNvbGF0aW9uT3BlcmF0b3Iocm9vdEVsZW1lbnQkKSB7XG4gICAgICAgIHJldHVybiByb290RWxlbWVudCRcbiAgICAgICAgICAgIC5mb2xkKGZ1bmN0aW9uIHNob3VsZFBhc3Moc3RhdGUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBoYXNJc29sYXRlZCA9ICEhZG9tU291cmNlLl9pc29sYXRlTW9kdWxlLmdldElzb2xhdGVkRWxlbWVudChzY29wZSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkUGFzcyA9IGhhc0lzb2xhdGVkICYmICFzdGF0ZS5oYWRJc29sYXRlZE11dGFibGU7XG4gICAgICAgICAgICByZXR1cm4geyBoYWRJc29sYXRlZE11dGFibGU6IGhhc0lzb2xhdGVkLCBzaG91bGRQYXNzOiBzaG91bGRQYXNzLCBlbGVtZW50OiBlbGVtZW50IH07XG4gICAgICAgIH0sIHsgaGFkSXNvbGF0ZWRNdXRhYmxlOiBmYWxzZSwgc2hvdWxkUGFzczogZmFsc2UsIGVsZW1lbnQ6IG51bGwgfSlcbiAgICAgICAgICAgIC5kcm9wKDEpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnNob3VsZFBhc3M7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmVsZW1lbnQ7IH0pO1xuICAgIH07XG59XG52YXIgTWFpbkRPTVNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFpbkRPTVNvdXJjZShfcm9vdEVsZW1lbnQkLCBfc2FuaXRhdGlvbiQsIF9ydW5TdHJlYW1BZGFwdGVyLCBfbmFtZXNwYWNlLCBfaXNvbGF0ZU1vZHVsZSwgX2RlbGVnYXRvcnMsIF9uYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChfbmFtZXNwYWNlID09PSB2b2lkIDApIHsgX25hbWVzcGFjZSA9IFtdOyB9XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50JCA9IF9yb290RWxlbWVudCQ7XG4gICAgICAgIHRoaXMuX3Nhbml0YXRpb24kID0gX3Nhbml0YXRpb24kO1xuICAgICAgICB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyID0gX3J1blN0cmVhbUFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IF9uYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuX2lzb2xhdGVNb2R1bGUgPSBfaXNvbGF0ZU1vZHVsZTtcbiAgICAgICAgdGhpcy5fZGVsZWdhdG9ycyA9IF9kZWxlZ2F0b3JzO1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgICAgIHRoaXMuX19KQU5JX0VWQUtBTExJT19XRV9XSUxMX01JU1NfWU9VX1BMRUFTRV9DT01FX0JBQ0tfRVZFTlRVQUxMWSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fSkFOSV9FVkFLQUxMSU9fV0VfV0lMTF9NSVNTX1lPVV9QTEVBU0VfQ09NRV9CQUNLX0VWRU5UVUFMTFkgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzb2xhdGVTb3VyY2UgPSBpc29sYXRlXzEuaXNvbGF0ZVNvdXJjZTtcbiAgICAgICAgdGhpcy5pc29sYXRlU2luayA9IGZ1bmN0aW9uIChzaW5rLCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nU2NvcGUgPSB1dGlsc18xLmdldFNjb3BlKF90aGlzLl9uYW1lc3BhY2UpO1xuICAgICAgICAgICAgdmFyIGRlZXBlclNjb3BlID0gW2V4aXN0aW5nU2NvcGUsIHNjb3BlXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICEheDsgfSkuam9pbignLScpO1xuICAgICAgICAgICAgcmV0dXJuIGlzb2xhdGVfMS5pc29sYXRlU2luayhzaW5rLCBkZWVwZXJTY29wZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE1haW5ET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0cHV0JDtcbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG91dHB1dCQgPSB0aGlzLl9yb290RWxlbWVudCQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudEZpbmRlcl8xID0gbmV3IEVsZW1lbnRGaW5kZXJfMS5FbGVtZW50RmluZGVyKHRoaXMuX25hbWVzcGFjZSwgdGhpcy5faXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgICAgICBvdXRwdXQkID0gdGhpcy5fcm9vdEVsZW1lbnQkLm1hcChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsZW1lbnRGaW5kZXJfMS5jYWxsKGVsKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1blNBID0gdGhpcy5fcnVuU3RyZWFtQWRhcHRlcjtcbiAgICAgICAgdmFyIG91dCA9IHJ1blNBLnJlbWVtYmVyKHJ1blNBLmFkYXB0KG91dHB1dCQsIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUsIFwibmFtZXNwYWNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYWluRE9NU291cmNlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRPTSBkcml2ZXIncyBzZWxlY3QoKSBleHBlY3RzIHRoZSBhcmd1bWVudCB0byBiZSBhIFwiICtcbiAgICAgICAgICAgICAgICBcInN0cmluZyBhcyBhIENTUyBzZWxlY3RvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRET01Tb3VyY2VfMS5Eb2N1bWVudERPTVNvdXJjZSh0aGlzLl9ydW5TdHJlYW1BZGFwdGVyLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb2R5RE9NU291cmNlXzEuQm9keURPTVNvdXJjZSh0aGlzLl9ydW5TdHJlYW1BZGFwdGVyLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJpbW1lZFNlbGVjdG9yID0gc2VsZWN0b3IudHJpbSgpO1xuICAgICAgICB2YXIgY2hpbGROYW1lc3BhY2UgPSB0cmltbWVkU2VsZWN0b3IgPT09IFwiOnJvb3RcIiA/XG4gICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2UgOlxuICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlLmNvbmNhdCh0cmltbWVkU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gbmV3IE1haW5ET01Tb3VyY2UodGhpcy5fcm9vdEVsZW1lbnQkLCB0aGlzLl9zYW5pdGF0aW9uJCwgdGhpcy5fcnVuU3RyZWFtQWRhcHRlciwgY2hpbGROYW1lc3BhY2UsIHRoaXMuX2lzb2xhdGVNb2R1bGUsIHRoaXMuX2RlbGVnYXRvcnMsIHRoaXMuX25hbWUpO1xuICAgIH07XG4gICAgTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50VHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRE9NIGRyaXZlcidzIGV2ZW50cygpIGV4cGVjdHMgYXJndW1lbnQgdG8gYmUgYSBcIiArXG4gICAgICAgICAgICAgICAgXCJzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VDYXB0dXJlID0gZGV0ZXJtaW5lVXNlQ2FwdHVyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlO1xuICAgICAgICB2YXIgc2NvcGUgPSB1dGlsc18xLmdldFNjb3BlKG5hbWVzcGFjZSk7XG4gICAgICAgIHZhciBrZXlQYXJ0cyA9IFtldmVudFR5cGUsIHVzZUNhcHR1cmVdO1xuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIGtleVBhcnRzLnB1c2goc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBrZXlQYXJ0cy5qb2luKCd+Jyk7XG4gICAgICAgIHZhciBkb21Tb3VyY2UgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnQkO1xuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50JCA9IHRoaXMuX3Jvb3RFbGVtZW50JFxuICAgICAgICAgICAgICAgIC5jb21wb3NlKGZpbHRlckJhc2VkT25Jc29sYXRpb24oZG9tU291cmNlLCBzY29wZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQkID0gdGhpcy5fcm9vdEVsZW1lbnQkLnRha2UoMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50JCA9IHJvb3RFbGVtZW50JFxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiBzZXR1cEV2ZW50RGVsZWdhdG9yT25Ub3BFbGVtZW50KHJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBFdmVudCBsaXN0ZW5lciBqdXN0IGZvciB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21FdmVudF8xLmZyb21FdmVudChyb290RWxlbWVudCwgZXZlbnRUeXBlLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV2ZW50IGxpc3RlbmVyIG9uIHRoZSB0b3AgZWxlbWVudCBhcyBhbiBFdmVudERlbGVnYXRvclxuICAgICAgICAgICAgdmFyIGRlbGVnYXRvcnMgPSBkb21Tb3VyY2UuX2RlbGVnYXRvcnM7XG4gICAgICAgICAgICB2YXIgdG9wID0gZG9tU291cmNlLl9pc29sYXRlTW9kdWxlLmdldElzb2xhdGVkRWxlbWVudChzY29wZSkgfHwgcm9vdEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgZGVsZWdhdG9yO1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRvcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0b3IgPSBkZWxlZ2F0b3JzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGRlbGVnYXRvci51cGRhdGVUb3BFbGVtZW50KHRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0b3IgPSBuZXcgRXZlbnREZWxlZ2F0b3JfMS5FdmVudERlbGVnYXRvcih0b3AsIGV2ZW50VHlwZSwgdXNlQ2FwdHVyZSwgZG9tU291cmNlLl9pc29sYXRlTW9kdWxlKTtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0b3JzLnNldChrZXksIGRlbGVnYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBkb21Tb3VyY2UuX2lzb2xhdGVNb2R1bGUuYWRkRXZlbnREZWxlZ2F0b3Ioc2NvcGUsIGRlbGVnYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb25JZCA9IGRlbGVnYXRvci5jcmVhdGVEZXN0aW5hdGlvbklkKCk7XG4gICAgICAgICAgICB2YXIgc3ViamVjdCA9IHhzdHJlYW1fMS5kZWZhdWx0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgncmVxdWVzdElkbGVDYWxsYmFjaycgaW4gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0b3IucmVtb3ZlRGVzdGluYXRpb25JZChkZXN0aW5hdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdG9yLnJlbW92ZURlc3RpbmF0aW9uSWQoZGVzdGluYXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxlZ2F0b3IuYWRkRGVzdGluYXRpb24oc3ViamVjdCwgbmFtZXNwYWNlLCBkZXN0aW5hdGlvbklkKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZsYXR0ZW4oKTtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIuYWRhcHQoZXZlbnQkLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IGRvbVNvdXJjZS5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIE1haW5ET01Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Nhbml0YXRpb24kLnNoYW1lZnVsbHlTZW5kTmV4dCgnJyk7XG4gICAgICAgIHRoaXMuX2lzb2xhdGVNb2R1bGUucmVzZXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluRE9NU291cmNlO1xufSgpKTtcbmV4cG9ydHMuTWFpbkRPTVNvdXJjZSA9IE1haW5ET01Tb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYWluRE9NU291cmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9NYWluRE9NU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBoeXBlcnNjcmlwdF8xID0gcmVxdWlyZSgnLi9oeXBlcnNjcmlwdCcpO1xudmFyIGNsYXNzTmFtZUZyb21WTm9kZV8xID0gcmVxdWlyZSgnc25hYmJkb20tc2VsZWN0b3IvbGliL2NsYXNzTmFtZUZyb21WTm9kZScpO1xudmFyIHNlbGVjdG9yUGFyc2VyXzEgPSByZXF1aXJlKCdzbmFiYmRvbS1zZWxlY3Rvci9saWIvc2VsZWN0b3JQYXJzZXInKTtcbnZhciBWTm9kZVdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZOb2RlV3JhcHBlcihyb290RWxlbWVudCkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG4gICAgfVxuICAgIFZOb2RlV3JhcHBlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgICB2YXIgX2EgPSBzZWxlY3RvclBhcnNlcl8xLmRlZmF1bHQodm5vZGUuc2VsKSwgc2VsZWN0b3JUYWdOYW1lID0gX2EudGFnTmFtZSwgc2VsZWN0b3JJZCA9IF9hLmlkO1xuICAgICAgICB2YXIgdk5vZGVDbGFzc05hbWUgPSBjbGFzc05hbWVGcm9tVk5vZGVfMS5kZWZhdWx0KHZub2RlKTtcbiAgICAgICAgdmFyIHZOb2RlRGF0YSA9IHZub2RlLmRhdGEgfHwge307XG4gICAgICAgIHZhciB2Tm9kZURhdGFQcm9wcyA9IHZOb2RlRGF0YS5wcm9wcyB8fCB7fTtcbiAgICAgICAgdmFyIF9iID0gdk5vZGVEYXRhUHJvcHMuaWQsIHZOb2RlSWQgPSBfYiA9PT0gdm9pZCAwID8gc2VsZWN0b3JJZCA6IF9iO1xuICAgICAgICB2YXIgaXNWTm9kZUFuZFJvb3RFbGVtZW50SWRlbnRpY2FsID0gdk5vZGVJZC50b1VwcGVyQ2FzZSgpID09PSB0aGlzLnJvb3RFbGVtZW50LmlkLnRvVXBwZXJDYXNlKCkgJiZcbiAgICAgICAgICAgIHNlbGVjdG9yVGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSB0aGlzLnJvb3RFbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSAmJlxuICAgICAgICAgICAgdk5vZGVDbGFzc05hbWUudG9VcHBlckNhc2UoKSA9PT0gdGhpcy5yb290RWxlbWVudC5jbGFzc05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGlzVk5vZGVBbmRSb290RWxlbWVudElkZW50aWNhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYyA9IHRoaXMucm9vdEVsZW1lbnQsIHRhZ05hbWUgPSBfYy50YWdOYW1lLCBpZCA9IF9jLmlkLCBjbGFzc05hbWUgPSBfYy5jbGFzc05hbWU7XG4gICAgICAgIHZhciBlbGVtZW50SWQgPSBpZCA/IFwiI1wiICsgaWQgOiBcIlwiO1xuICAgICAgICB2YXIgZWxlbWVudENsYXNzTmFtZSA9IGNsYXNzTmFtZSA/XG4gICAgICAgICAgICBcIi5cIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcIi5cIikgOiBcIlwiO1xuICAgICAgICByZXR1cm4gaHlwZXJzY3JpcHRfMS5oKFwiXCIgKyB0YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyBlbGVtZW50SWQgKyBlbGVtZW50Q2xhc3NOYW1lLCB7fSwgW1xuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgcmV0dXJuIFZOb2RlV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlZOb2RlV3JhcHBlciA9IFZOb2RlV3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZOb2RlV3JhcHBlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvVk5vZGVXcmFwcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBoeXBlcnNjcmlwdF8xID0gcmVxdWlyZSgnLi9oeXBlcnNjcmlwdCcpO1xuZnVuY3Rpb24gaXNWYWxpZFN0cmluZyhwYXJhbSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnICYmIHBhcmFtLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBpc1NlbGVjdG9yKHBhcmFtKSB7XG4gICAgcmV0dXJuIGlzVmFsaWRTdHJpbmcocGFyYW0pICYmIChwYXJhbVswXSA9PT0gJy4nIHx8IHBhcmFtWzBdID09PSAnIycpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFnRnVuY3Rpb24odGFnTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBoeXBlcnNjcmlwdChmaXJzdCwgYiwgYykge1xuICAgICAgICBpZiAoaXNTZWxlY3RvcihmaXJzdCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh5cGVyc2NyaXB0XzEuaCh0YWdOYW1lICsgZmlyc3QsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh5cGVyc2NyaXB0XzEuaCh0YWdOYW1lICsgZmlyc3QsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh5cGVyc2NyaXB0XzEuaCh0YWdOYW1lICsgZmlyc3QsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghIWIpIHtcbiAgICAgICAgICAgIHJldHVybiBoeXBlcnNjcmlwdF8xLmgodGFnTmFtZSwgZmlyc3QsIGIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEhZmlyc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoeXBlcnNjcmlwdF8xLmgodGFnTmFtZSwgZmlyc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGh5cGVyc2NyaXB0XzEuaCh0YWdOYW1lLCB7fSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIFNWR19UQUdfTkFNRVMgPSBbXG4gICAgJ2EnLCAnYWx0R2x5cGgnLCAnYWx0R2x5cGhEZWYnLCAnYWx0R2x5cGhJdGVtJywgJ2FuaW1hdGUnLCAnYW5pbWF0ZUNvbG9yJyxcbiAgICAnYW5pbWF0ZU1vdGlvbicsICdhbmltYXRlVHJhbnNmb3JtJywgJ2NpcmNsZScsICdjbGlwUGF0aCcsICdjb2xvclByb2ZpbGUnLFxuICAgICdjdXJzb3InLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JyxcbiAgICAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJyxcbiAgICAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLFxuICAgICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJyxcbiAgICAnZmVNb3JwaG9sb2d5JywgJ2ZlT2Zmc2V0JywgJ2ZlUG9pbnRMaWdodCcsICdmZVNwZWN1bGFyTGlnaHRpbmcnLFxuICAgICdmZVNwb3RsaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJywgJ2ZpbHRlcicsICdmb250JywgJ2ZvbnRGYWNlJyxcbiAgICAnZm9udEZhY2VGb3JtYXQnLCAnZm9udEZhY2VOYW1lJywgJ2ZvbnRGYWNlU3JjJywgJ2ZvbnRGYWNlVXJpJyxcbiAgICAnZm9yZWlnbk9iamVjdCcsICdnJywgJ2dseXBoJywgJ2dseXBoUmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLFxuICAgICdsaW5lYXJHcmFkaWVudCcsICdtYXJrZXInLCAnbWFzaycsICdtZXRhZGF0YScsICdtaXNzaW5nR2x5cGgnLCAnbXBhdGgnLFxuICAgICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3NjcmlwdCcsXG4gICAgJ3NldCcsICdzdG9wJywgJ3N0eWxlJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0UGF0aCcsICd0aXRsZScsXG4gICAgJ3RyZWYnLCAndHNwYW4nLCAndXNlJywgJ3ZpZXcnLCAndmtlcm4nLFxuXTtcbnZhciBzdmcgPSBjcmVhdGVUYWdGdW5jdGlvbignc3ZnJyk7XG5TVkdfVEFHX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgIHN2Z1t0YWddID0gY3JlYXRlVGFnRnVuY3Rpb24odGFnKTtcbn0pO1xudmFyIFRBR19OQU1FUyA9IFtcbiAgICAnYScsICdhYmJyJywgJ2FkZHJlc3MnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2F1ZGlvJywgJ2InLCAnYmFzZScsXG4gICAgJ2JkaScsICdiZG8nLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsXG4gICAgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGVsJywgJ2RmbicsICdkaXInLCAnZGl2JywgJ2RsJyxcbiAgICAnZHQnLCAnZW0nLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLFxuICAgICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsXG4gICAgJ2knLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdsZWdlbmQnLFxuICAgICdsaScsICdsaW5rJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWVudScsICdtZXRhJywgJ25hdicsICdub3NjcmlwdCcsXG4gICAgJ29iamVjdCcsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAncCcsICdwYXJhbScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsXG4gICAgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzbWFsbCcsXG4gICAgJ3NvdXJjZScsICdzcGFuJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VwJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJyxcbiAgICAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndScsICd1bCcsICd2aWRlbycsXG5dO1xudmFyIGV4cG9ydGVkID0geyBTVkdfVEFHX05BTUVTOiBTVkdfVEFHX05BTUVTLCBUQUdfTkFNRVM6IFRBR19OQU1FUywgc3ZnOiBzdmcsIGlzU2VsZWN0b3I6IGlzU2VsZWN0b3IsIGNyZWF0ZVRhZ0Z1bmN0aW9uOiBjcmVhdGVUYWdGdW5jdGlvbiB9O1xuVEFHX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICBleHBvcnRlZFtuXSA9IGNyZWF0ZVRhZ0Z1bmN0aW9uKG4pO1xufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh5cGVyc2NyaXB0LWhlbHBlcnMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL2h5cGVyc2NyaXB0LWhlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5mdW5jdGlvbiBpc29sYXRlU291cmNlKHNvdXJjZSwgc2NvcGUpIHtcbiAgICByZXR1cm4gc291cmNlLnNlbGVjdCh1dGlsc18xLlNDT1BFX1BSRUZJWCArIHNjb3BlKTtcbn1cbmV4cG9ydHMuaXNvbGF0ZVNvdXJjZSA9IGlzb2xhdGVTb3VyY2U7XG5mdW5jdGlvbiBpc29sYXRlU2luayhzaW5rLCBzY29wZSkge1xuICAgIHJldHVybiBzaW5rLm1hcChmdW5jdGlvbiAodlRyZWUpIHtcbiAgICAgICAgaWYgKHZUcmVlLmRhdGEgJiYgdlRyZWUuZGF0YS5pc29sYXRlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdTY29wZSA9IHZUcmVlLmRhdGEuaXNvbGF0ZS5yZXBsYWNlKC8oY3ljbGV8XFwtKS9nLCAnJyk7XG4gICAgICAgICAgICB2YXIgX3Njb3BlID0gc2NvcGUucmVwbGFjZSgvKGN5Y2xlfFxcLSkvZywgJycpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlSW50KGV4aXN0aW5nU2NvcGUpKVxuICAgICAgICAgICAgICAgIHx8IGlzTmFOKHBhcnNlSW50KF9zY29wZSkpXG4gICAgICAgICAgICAgICAgfHwgZXhpc3RpbmdTY29wZSA+IF9zY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2VHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2VHJlZS5kYXRhID0gdlRyZWUuZGF0YSB8fCB7fTtcbiAgICAgICAgdlRyZWUuZGF0YS5pc29sYXRlID0gc2NvcGU7XG4gICAgICAgIGlmICh0eXBlb2YgdlRyZWUua2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdlRyZWUua2V5ID0gdXRpbHNfMS5TQ09QRV9QUkVGSVggKyBzY29wZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdlRyZWU7XG4gICAgfSk7XG59XG5leHBvcnRzLmlzb2xhdGVTaW5rID0gaXNvbGF0ZVNpbms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc29sYXRlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9pc29sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXBQb2x5ZmlsbCA9IHJlcXVpcmUoJ2VzNi1tYXAnKTtcbnZhciBJc29sYXRlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJc29sYXRlTW9kdWxlKGlzb2xhdGVkRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5pc29sYXRlZEVsZW1lbnRzID0gaXNvbGF0ZWRFbGVtZW50cztcbiAgICAgICAgdGhpcy5ldmVudERlbGVnYXRvcnMgPSBuZXcgTWFwUG9seWZpbGwoKTtcbiAgICB9XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuc2V0U2NvcGUgPSBmdW5jdGlvbiAoZWxtLCBzY29wZSkge1xuICAgICAgICB0aGlzLmlzb2xhdGVkRWxlbWVudHMuc2V0KHNjb3BlLCBlbG0pO1xuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUucmVtb3ZlU2NvcGUgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5pc29sYXRlZEVsZW1lbnRzLmRlbGV0ZShzY29wZSk7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5jbGVhbnVwVk5vZGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLCBlbG0gPSBfYS5lbG07XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB2YXIgc2NvcGUgPSBkYXRhLmlzb2xhdGUgfHwgJyc7XG4gICAgICAgIHZhciBpc0N1cnJlbnRFbG0gPSB0aGlzLmlzb2xhdGVkRWxlbWVudHMuZ2V0KHNjb3BlKSA9PT0gZWxtO1xuICAgICAgICBpZiAoc2NvcGUgJiYgaXNDdXJyZW50RWxtKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RGVsZWdhdG9ycy5nZXQoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERlbGVnYXRvcnMuc2V0KHNjb3BlLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLmdldElzb2xhdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29sYXRlZEVsZW1lbnRzLmdldChzY29wZSk7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5pc0lzb2xhdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pc29sYXRlZEVsZW1lbnRzLmVudHJpZXMoKTtcbiAgICAgICAgZm9yICh2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpOyAhIXJlc3VsdC52YWx1ZTsgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZXN1bHQudmFsdWUsIHNjb3BlID0gX2FbMF0sIGVsZW1lbnQgPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChlbG0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuYWRkRXZlbnREZWxlZ2F0b3IgPSBmdW5jdGlvbiAoc2NvcGUsIGV2ZW50RGVsZWdhdG9yKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0b3JzID0gdGhpcy5ldmVudERlbGVnYXRvcnMuZ2V0KHNjb3BlKTtcbiAgICAgICAgaWYgKCFkZWxlZ2F0b3JzKSB7XG4gICAgICAgICAgICBkZWxlZ2F0b3JzID0gW107XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGVsZWdhdG9ycy5zZXQoc2NvcGUsIGRlbGVnYXRvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGVnYXRvcnNbZGVsZWdhdG9ycy5sZW5ndGhdID0gZXZlbnREZWxlZ2F0b3I7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc29sYXRlZEVsZW1lbnRzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5jcmVhdGVNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKG9sZFZOb2RlLCB2Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IG9sZFZOb2RlLmRhdGEsIG9sZERhdGEgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYTtcbiAgICAgICAgICAgICAgICB2YXIgZWxtID0gdk5vZGUuZWxtLCBfYiA9IHZOb2RlLmRhdGEsIGRhdGEgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2NvcGUgPSBvbGREYXRhLmlzb2xhdGUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSBkYXRhLmlzb2xhdGUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZVNjb3BlKG9sZFNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFNjb3BlKGVsbSwgc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdG9ycyA9IHNlbGYuZXZlbnREZWxlZ2F0b3JzLmdldChzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVsZWdhdG9ycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRvcnNbaV0udXBkYXRlVG9wRWxlbWVudChlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbGVnYXRvcnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ldmVudERlbGVnYXRvcnMuc2V0KHNjb3BlLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9sZFNjb3BlICYmICFzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAob2xkVk5vZGUsIHZOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gb2xkVk5vZGUuZGF0YSwgb2xkRGF0YSA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hO1xuICAgICAgICAgICAgICAgIHZhciBlbG0gPSB2Tm9kZS5lbG0sIF9iID0gdk5vZGUuZGF0YSwgZGF0YSA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTY29wZSA9IG9sZERhdGEuaXNvbGF0ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBzY29wZSA9IGRhdGEuaXNvbGF0ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChzY29wZSAmJiBzY29wZSAhPT0gb2xkU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZVNjb3BlKG9sZFNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFNjb3BlKGVsbSwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkU2NvcGUgJiYgIXNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlU2NvcGUoc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICh2Tm9kZSwgY2IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFudXBWTm9kZSh2Tm9kZSk7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAodk5vZGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFudXBWTm9kZSh2Tm9kZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIElzb2xhdGVNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5Jc29sYXRlTW9kdWxlID0gSXNvbGF0ZU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzb2xhdGVNb2R1bGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL2lzb2xhdGVNb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNuYWJiZG9tXzEgPSByZXF1aXJlKCdzbmFiYmRvbScpO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciBNYWluRE9NU291cmNlXzEgPSByZXF1aXJlKCcuL01haW5ET01Tb3VyY2UnKTtcbnZhciBWTm9kZVdyYXBwZXJfMSA9IHJlcXVpcmUoJy4vVk5vZGVXcmFwcGVyJyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBtb2R1bGVzXzEgPSByZXF1aXJlKCcuL21vZHVsZXMnKTtcbnZhciBpc29sYXRlTW9kdWxlXzEgPSByZXF1aXJlKCcuL2lzb2xhdGVNb2R1bGUnKTtcbnZhciB0cmFuc3Bvc2l0aW9uXzEgPSByZXF1aXJlKCcuL3RyYW5zcG9zaXRpb24nKTtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciBNYXBQb2x5ZmlsbCA9IHJlcXVpcmUoJ2VzNi1tYXAnKTtcbmZ1bmN0aW9uIG1ha2VET01Ecml2ZXJJbnB1dEd1YXJkKG1vZHVsZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kdWxlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uYWwgbW9kdWxlcyBvcHRpb24gbXVzdCBiZSBcIiArXG4gICAgICAgICAgICBcImFuIGFycmF5IGZvciBzbmFiYmRvbSBtb2R1bGVzXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvbURyaXZlcklucHV0R3VhcmQodmlldyQpIHtcbiAgICBpZiAoIXZpZXckXG4gICAgICAgIHx8IHR5cGVvZiB2aWV3JC5hZGRMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiXG4gICAgICAgIHx8IHR5cGVvZiB2aWV3JC5mb2xkICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIERPTSBkcml2ZXIgZnVuY3Rpb24gZXhwZWN0cyBhcyBpbnB1dCBhIFN0cmVhbSBvZiBcIiArXG4gICAgICAgICAgICBcInZpcnR1YWwgRE9NIGVsZW1lbnRzXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VET01Ecml2ZXIoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdmFyIHRyYW5zcG9zaXRpb24gPSBvcHRpb25zLnRyYW5zcG9zaXRpb24gfHwgZmFsc2U7XG4gICAgdmFyIG1vZHVsZXMgPSBvcHRpb25zLm1vZHVsZXMgfHwgbW9kdWxlc18xLmRlZmF1bHQ7XG4gICAgdmFyIGlzb2xhdGVNb2R1bGUgPSBuZXcgaXNvbGF0ZU1vZHVsZV8xLklzb2xhdGVNb2R1bGUoKG5ldyBNYXBQb2x5ZmlsbCgpKSk7XG4gICAgdmFyIHBhdGNoID0gc25hYmJkb21fMS5pbml0KFtpc29sYXRlTW9kdWxlLmNyZWF0ZU1vZHVsZSgpXS5jb25jYXQobW9kdWxlcykpO1xuICAgIHZhciByb290RWxlbWVudCA9IHV0aWxzXzEuZ2V0RWxlbWVudChjb250YWluZXIpO1xuICAgIHZhciB2bm9kZVdyYXBwZXIgPSBuZXcgVk5vZGVXcmFwcGVyXzEuVk5vZGVXcmFwcGVyKHJvb3RFbGVtZW50KTtcbiAgICB2YXIgZGVsZWdhdG9ycyA9IG5ldyBNYXBQb2x5ZmlsbCgpO1xuICAgIG1ha2VET01Ecml2ZXJJbnB1dEd1YXJkKG1vZHVsZXMpO1xuICAgIGZ1bmN0aW9uIERPTURyaXZlcih2bm9kZSQsIHJ1blN0cmVhbUFkYXB0ZXIsIG5hbWUpIHtcbiAgICAgICAgZG9tRHJpdmVySW5wdXRHdWFyZCh2bm9kZSQpO1xuICAgICAgICB2YXIgdHJhbnNwb3NlVk5vZGUgPSB0cmFuc3Bvc2l0aW9uXzEubWFrZVRyYW5zcG9zZVZOb2RlKHJ1blN0cmVhbUFkYXB0ZXIpO1xuICAgICAgICB2YXIgcHJlcHJvY2Vzc2VkVk5vZGUkID0gKHRyYW5zcG9zaXRpb24gPyB2bm9kZSQubWFwKHRyYW5zcG9zZVZOb2RlKS5mbGF0dGVuKCkgOiB2bm9kZSQpO1xuICAgICAgICB2YXIgc2FuaXRhdGlvbiQgPSB4c3RyZWFtXzEuZGVmYXVsdC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50JCA9IHhzdHJlYW1fMS5kZWZhdWx0Lm1lcmdlKHByZXByb2Nlc3NlZFZOb2RlJC5lbmRXaGVuKHNhbml0YXRpb24kKSwgc2FuaXRhdGlvbiQpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2bm9kZSkgeyByZXR1cm4gdm5vZGVXcmFwcGVyLmNhbGwodm5vZGUpOyB9KVxuICAgICAgICAgICAgLmZvbGQocGF0Y2gsIHJvb3RFbGVtZW50KVxuICAgICAgICAgICAgLmRyb3AoMSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gdW53cmFwRWxlbWVudEZyb21WTm9kZSh2bm9kZSkgeyByZXR1cm4gdm5vZGUuZWxtOyB9KVxuICAgICAgICAgICAgLmNvbXBvc2UoZnVuY3Rpb24gKHN0cmVhbSkgeyByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQubWVyZ2Uoc3RyZWFtLCB4c3RyZWFtXzEuZGVmYXVsdC5uZXZlcigpKTsgfSkgLy8gZG9uJ3QgY29tcGxldGUgdGhpcyBzdHJlYW1cbiAgICAgICAgICAgIC5zdGFydFdpdGgocm9vdEVsZW1lbnQpO1xuICAgICAgICByb290RWxlbWVudCQuYWRkTGlzdGVuZXIoeyBuZXh0OiBmdW5jdGlvbiAoKSB7IH0sIGVycm9yOiBmdW5jdGlvbiAoKSB7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IH0gfSk7XG4gICAgICAgIHJldHVybiBuZXcgTWFpbkRPTVNvdXJjZV8xLk1haW5ET01Tb3VyY2Uocm9vdEVsZW1lbnQkLCBzYW5pdGF0aW9uJCwgcnVuU3RyZWFtQWRhcHRlciwgW10sIGlzb2xhdGVNb2R1bGUsIGRlbGVnYXRvcnMsIG5hbWUpO1xuICAgIH1cbiAgICA7XG4gICAgRE9NRHJpdmVyLnN0cmVhbUFkYXB0ZXIgPSB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0O1xuICAgIHJldHVybiBET01Ecml2ZXI7XG59XG5leHBvcnRzLm1ha2VET01Ecml2ZXIgPSBtYWtlRE9NRHJpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZURPTURyaXZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvbWFrZURPTURyaXZlci5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgdHJhbnNwb3NpdGlvbl8xID0gcmVxdWlyZSgnLi90cmFuc3Bvc2l0aW9uJyk7XG52YXIgSFRNTFNvdXJjZV8xID0gcmVxdWlyZSgnLi9IVE1MU291cmNlJyk7XG52YXIgdG9IVE1MID0gcmVxdWlyZSgnc25hYmJkb20tdG8taHRtbCcpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5mdW5jdGlvbiBtYWtlSFRNTERyaXZlcihlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgdHJhbnNwb3NpdGlvbiA9IG9wdGlvbnMudHJhbnNwb3NpdGlvbiB8fCBmYWxzZTtcbiAgICBmdW5jdGlvbiBodG1sRHJpdmVyKHZub2RlJCwgcnVuU3RyZWFtQWRhcHRlciwgbmFtZSkge1xuICAgICAgICB2YXIgdHJhbnNwb3NlVk5vZGUgPSB0cmFuc3Bvc2l0aW9uXzEubWFrZVRyYW5zcG9zZVZOb2RlKHJ1blN0cmVhbUFkYXB0ZXIpO1xuICAgICAgICB2YXIgcHJlcHJvY2Vzc2VkVk5vZGUkID0gKHRyYW5zcG9zaXRpb24gPyB2bm9kZSQubWFwKHRyYW5zcG9zZVZOb2RlKS5mbGF0dGVuKCkgOiB2bm9kZSQpO1xuICAgICAgICB2YXIgaHRtbCQgPSBwcmVwcm9jZXNzZWRWTm9kZSQubWFwKHRvSFRNTCk7XG4gICAgICAgIGh0bWwkLmFkZExpc3RlbmVyKHtcbiAgICAgICAgICAgIG5leHQ6IGVmZmVjdCB8fCBub29wLFxuICAgICAgICAgICAgZXJyb3I6IG5vb3AsXG4gICAgICAgICAgICBjb21wbGV0ZTogbm9vcCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSFRNTFNvdXJjZV8xLkhUTUxTb3VyY2UoaHRtbCQsIHJ1blN0cmVhbUFkYXB0ZXIsIG5hbWUpO1xuICAgIH1cbiAgICA7XG4gICAgaHRtbERyaXZlci5zdHJlYW1BZGFwdGVyID0geHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdDtcbiAgICByZXR1cm4gaHRtbERyaXZlcjtcbn1cbmV4cG9ydHMubWFrZUhUTUxEcml2ZXIgPSBtYWtlSFRNTERyaXZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2VIVE1MRHJpdmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9tYWtlSFRNTERyaXZlci5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xudmFyIFNDT1BFX1BSRUZJWCA9ICdfX18nO1xudmFyIE1vY2tlZERPTVNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9ja2VkRE9NU291cmNlKF9zdHJlYW1BZGFwdGVyLCBfbW9ja0NvbmZpZykge1xuICAgICAgICB0aGlzLl9zdHJlYW1BZGFwdGVyID0gX3N0cmVhbUFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX21vY2tDb25maWcgPSBfbW9ja0NvbmZpZztcbiAgICAgICAgaWYgKF9tb2NrQ29uZmlnLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9tb2NrQ29uZmlnLmVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfc3RyZWFtQWRhcHRlci5hZGFwdCh4c3RyZWFtXzEuZGVmYXVsdC5lbXB0eSgpLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTW9ja2VkRE9NU291cmNlLnByb3RvdHlwZS5lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX2VsZW1lbnRzO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSAnTW9ja2VkRE9NJztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIE1vY2tlZERPTVNvdXJjZS5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW9ja0NvbmZpZyA9IHRoaXMuX21vY2tDb25maWc7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobW9ja0NvbmZpZyk7XG4gICAgICAgIHZhciBrZXlzTGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRfMSA9IG1vY2tDb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICBvdXRfMS5faXNDeWNsZVNvdXJjZSA9ICdNb2NrZWRET00nO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gdGhpcy5fc3RyZWFtQWRhcHRlci5hZGFwdCh4c3RyZWFtXzEuZGVmYXVsdC5lbXB0eSgpLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9ICdNb2NrZWRET00nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTW9ja2VkRE9NU291cmNlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIG1vY2tDb25maWcgPSB0aGlzLl9tb2NrQ29uZmlnO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vY2tDb25maWcpO1xuICAgICAgICB2YXIga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9ja2VkRE9NU291cmNlKHRoaXMuX3N0cmVhbUFkYXB0ZXIsIG1vY2tDb25maWdba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNb2NrZWRET01Tb3VyY2UodGhpcy5fc3RyZWFtQWRhcHRlciwge30pO1xuICAgIH07XG4gICAgTW9ja2VkRE9NU291cmNlLnByb3RvdHlwZS5pc29sYXRlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zZWxlY3QoJy4nICsgU0NPUEVfUFJFRklYICsgc2NvcGUpO1xuICAgIH07XG4gICAgTW9ja2VkRE9NU291cmNlLnByb3RvdHlwZS5pc29sYXRlU2luayA9IGZ1bmN0aW9uIChzaW5rLCBzY29wZSkge1xuICAgICAgICByZXR1cm4gc2luay5tYXAoZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICAgICAgICBpZiAodm5vZGUuc2VsICYmIHZub2RlLnNlbC5pbmRleE9mKFNDT1BFX1BSRUZJWCArIHNjb3BlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5zZWwgKz0gXCIuXCIgKyBTQ09QRV9QUkVGSVggKyBzY29wZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1vY2tlZERPTVNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLk1vY2tlZERPTVNvdXJjZSA9IE1vY2tlZERPTVNvdXJjZTtcbmZ1bmN0aW9uIG1vY2tET01Tb3VyY2Uoc3RyZWFtQWRhcHRlciwgbW9ja0NvbmZpZykge1xuICAgIHJldHVybiBuZXcgTW9ja2VkRE9NU291cmNlKHN0cmVhbUFkYXB0ZXIsIG1vY2tDb25maWcpO1xufVxuZXhwb3J0cy5tb2NrRE9NU291cmNlID0gbW9ja0RPTVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vY2tET01Tb3VyY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL21vY2tET01Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIENsYXNzTW9kdWxlID0gcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9jbGFzcycpO1xuZXhwb3J0cy5DbGFzc01vZHVsZSA9IENsYXNzTW9kdWxlO1xudmFyIFByb3BzTW9kdWxlID0gcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9wcm9wcycpO1xuZXhwb3J0cy5Qcm9wc01vZHVsZSA9IFByb3BzTW9kdWxlO1xudmFyIEF0dHJzTW9kdWxlID0gcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9hdHRyaWJ1dGVzJyk7XG5leHBvcnRzLkF0dHJzTW9kdWxlID0gQXR0cnNNb2R1bGU7XG52YXIgRXZlbnRzTW9kdWxlID0gcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9ldmVudGxpc3RlbmVycycpO1xuZXhwb3J0cy5FdmVudHNNb2R1bGUgPSBFdmVudHNNb2R1bGU7XG52YXIgU3R5bGVNb2R1bGUgPSByZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL3N0eWxlJyk7XG5leHBvcnRzLlN0eWxlTW9kdWxlID0gU3R5bGVNb2R1bGU7XG52YXIgSGVyb01vZHVsZSA9IHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvaGVybycpO1xuZXhwb3J0cy5IZXJvTW9kdWxlID0gSGVyb01vZHVsZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFtTdHlsZU1vZHVsZSwgQ2xhc3NNb2R1bGUsIFByb3BzTW9kdWxlLCBBdHRyc01vZHVsZV07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9tb2R1bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjbGlja0V2ZW50ID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBkb2N1bWVudCAmJiBkb2N1bWVudC5vbnRvdWNoc3RhcnQgP1xuICAgICd0b3VjaHN0YXJ0JyA6ICdjbGljayc7XG5mdW5jdGlvbiB3aGljaChldikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlID0gZXYgfHwgd2luZG93LmV2ZW50O1xuICAgIHJldHVybiBlLndoaWNoID09PSBudWxsID8gZS5idXR0b24gOiBlLndoaWNoO1xufVxuZnVuY3Rpb24gc2FtZU9yaWdpbihocmVmKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWYgJiYgaHJlZi5pbmRleE9mKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pID09PSAwO1xufVxuZnVuY3Rpb24gbWFrZUNsaWNrTGlzdGVuZXIocHVzaCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGlja0xpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIGlmICh3aGljaChldmVudCkgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZSAhPT0gJ0EnKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVOYW1lICE9PSAnQScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJykgfHxcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2V4dGVybmFsJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LnRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5rID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgaWYgKGxpbmsgJiYgbGluay5pbmRleE9mKCdtYWlsdG86JykgPiAtMSB8fCBsaW5rLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKGVsZW1lbnQuaHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgcGF0aG5hbWUgPSBlbGVtZW50LnBhdGhuYW1lLCBzZWFyY2ggPSBlbGVtZW50LnNlYXJjaCwgX2EgPSBlbGVtZW50Lmhhc2gsIGhhc2ggPSBfYSA9PT0gdm9pZCAwID8gJycgOiBfYTtcbiAgICAgICAgcHVzaChwYXRobmFtZSArIHNlYXJjaCArIGhhc2gpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjYXB0dXJlQ2xpY2tzKHB1c2gpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBtYWtlQ2xpY2tMaXN0ZW5lcihwdXNoKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihjbGlja0V2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FwdHVyZUNsaWNrcyA9IGNhcHR1cmVDbGlja3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXB0dXJlQ2xpY2tzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvaGlzdG9yeS9saWIvY2FwdHVyZUNsaWNrcy5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY2FwdHVyZUNsaWNrc18xID0gcmVxdWlyZSgnLi9jYXB0dXJlQ2xpY2tzJyk7XG5mdW5jdGlvbiBtYWtlVXBkYXRlSGlzdG9yeShoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZUhpc3RvcnkobG9jYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaChoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gc3Vwb3J0IHRoaW5ncyBsaWtlIGhpc3RvcnkucmVwbGFjZSgpXG4gICAgICAgICAgICB2YXIgX2EgPSBsb2NhdGlvbi50eXBlLCB0eXBlID0gX2EgPT09IHZvaWQgMCA/ICdwdXNoJyA6IF9hO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdnbycpIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5W3R5cGVdKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpc3RvcnlbdHlwZV0obG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5IERyaXZlciBpbnB1dCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuICcgK1xuICAgICAgICAgICAgICAgICdvYmplY3QgYnV0IHJlY2VpdmVkICR7dHlwZW9mIHVybH0nKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvckZuKGVycikge1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUhpc3RvcnlEcml2ZXIoaGlzdG9yeSwgb3B0aW9ucykge1xuICAgIGlmICghaGlzdG9yeSB8fCB0eXBlb2YgaGlzdG9yeSAhPT0gJ29iamVjdCdcbiAgICAgICAgfHwgdHlwZW9mIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24gIT09ICdmdW5jdGlvbidcbiAgICAgICAgfHwgdHlwZW9mIGhpc3RvcnkuY3JlYXRlSHJlZiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICB8fCB0eXBlb2YgaGlzdG9yeS5saXN0ZW4gIT09ICdmdW5jdGlvbidcbiAgICAgICAgfHwgdHlwZW9mIGhpc3RvcnkucHVzaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYWtlSGlzdG9yeURyaXZlciByZXF1aXJlcyBhbiB2YWxpZCBoaXN0b3J5IG9iamVjdCAnICtcbiAgICAgICAgICAgICdjb250YWluaW5nIGNyZWF0ZUxvY2F0aW9uKCksIGNyZWF0ZUhyZWYoKSwgcHVzaCgpLCBhbmQgbGlzdGVuKCkgbWV0aG9kcycpO1xuICAgIH1cbiAgICB2YXIgY2FwdHVyZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jYXB0dXJlIHx8IGZhbHNlO1xuICAgIHZhciBvbkVycm9yID0gb3B0aW9ucyAmJiBvcHRpb25zLm9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3JGbjtcbiAgICByZXR1cm4gZnVuY3Rpb24gaGlzdG9yeURyaXZlcihzaW5rJCwgcnVuU0EpIHtcbiAgICAgICAgdmFyIF9hID0gcnVuU0EubWFrZVN1YmplY3QoKSwgb2JzZXJ2ZXIgPSBfYS5vYnNlcnZlciwgc3RyZWFtID0gX2Euc3RyZWFtO1xuICAgICAgICB2YXIgaGlzdG9yeSQgPSBydW5TQS5yZW1lbWJlcihzdHJlYW1cbiAgICAgICAgICAgIC5zdGFydFdpdGgoaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbikpO1xuICAgICAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQobG9jYXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBoaXN0b3J5LmFkZENvbXBsZXRlQ2FsbGJhY2sgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICYmIHR5cGVvZiBoaXN0b3J5LmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBoaXN0b3J5LmFkZENvbXBsZXRlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW5TQS5zdHJlYW1TdWJzY3JpYmUoc2luayQsIHtcbiAgICAgICAgICAgIG5leHQ6IG1ha2VVcGRhdGVIaXN0b3J5KGhpc3RvcnkpLFxuICAgICAgICAgICAgZXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgICAgY2FwdHVyZUNsaWNrc18xLmNhcHR1cmVDbGlja3MoZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgaGlzdG9yeS5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGhpc3RvcnkkLmNyZWF0ZUhyZWYgPSBmdW5jdGlvbiAoaHJlZikgeyByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKGhyZWYpOyB9O1xuICAgICAgICBoaXN0b3J5JC5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIChsb2NhdGlvbikgeyByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7IH07XG4gICAgICAgIHJldHVybiBoaXN0b3J5JDtcbiAgICB9O1xufVxuZXhwb3J0cy5tYWtlSGlzdG9yeURyaXZlciA9IG1ha2VIaXN0b3J5RHJpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZUhpc3RvcnlEcml2ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi9tYWtlSGlzdG9yeURyaXZlci5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgU2VydmVySGlzdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmVySGlzdG9yeShjdXJyZW50TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5vb3AoKSB7IHJldHVybiB2b2lkIDA7IH07XG4gICAgfTtcbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBnaXZlbiBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgYmVmb3JlIHB1c2hpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tpXSh1dGlsXzEuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnB1c2gobG9jYXRpb24pO1xuICAgIH07XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgfTtcbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRMb2NhdGlvbjtcbiAgICB9O1xuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLmFkZENvbXBsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVDYWxsYmFjayA9IGNvbXBsZXRlO1xuICAgIH07XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlQ2FsbGJhY2soKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXJ2ZXJIaXN0b3J5O1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhpc3RvcnkobG9jKSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJIaXN0b3J5KGxvYyA/IHV0aWxfMS5jcmVhdGVMb2NhdGlvbihsb2MpIDogbnVsbCk7XG59XG5leHBvcnRzLmNyZWF0ZVNlcnZlckhpc3RvcnkgPSBjcmVhdGVTZXJ2ZXJIaXN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVySGlzdG9yeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2hpc3RvcnkvbGliL3NlcnZlckhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGJhc2VfMSA9IHJlcXVpcmUoJ0BjeWNsZS9iYXNlJyk7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG4vKipcbiAqIFRha2VzIGEgYG1haW5gIGZ1bmN0aW9uIGFuZCBjaXJjdWxhcmx5IGNvbm5lY3RzIGl0IHRvIHRoZSBnaXZlbiBjb2xsZWN0aW9uXG4gKiBvZiBkcml2ZXIgZnVuY3Rpb25zLlxuICpcbiAqICoqRXhhbXBsZToqKlxuICogYGBganNcbiAqIGltcG9ydCB7cnVufSBmcm9tICdAY3ljbGUveHN0cmVhbS1ydW4nO1xuICogY29uc3QgZGlzcG9zZSA9IHJ1bihtYWluLCBkcml2ZXJzKTtcbiAqIC8vIC4uLlxuICogZGlzcG9zZSgpO1xuICogYGBgXG4gKlxuICogVGhlIGBtYWluYCBmdW5jdGlvbiBleHBlY3RzIGEgY29sbGVjdGlvbiBvZiBcInNvdXJjZVwiIHN0cmVhbXMgKHJldHVybmVkIGZyb21cbiAqIGRyaXZlcnMpIGFzIGlucHV0LCBhbmQgc2hvdWxkIHJldHVybiBhIGNvbGxlY3Rpb24gb2YgXCJzaW5rXCIgc3RyZWFtcyAodG8gYmVcbiAqIGdpdmVuIHRvIGRyaXZlcnMpLiBBIFwiY29sbGVjdGlvbiBvZiBzdHJlYW1zXCIgaXMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aGVyZVxuICoga2V5cyBtYXRjaCB0aGUgZHJpdmVyIG5hbWVzIHJlZ2lzdGVyZWQgYnkgdGhlIGBkcml2ZXJzYCBvYmplY3QsIGFuZCB2YWx1ZXNcbiAqIGFyZSB0aGUgc3RyZWFtcy4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24gb2YgZWFjaCBkcml2ZXIgdG8gc2VlIG1vcmVcbiAqIGRldGFpbHMgb24gd2hhdCB0eXBlcyBvZiBzb3VyY2VzIGl0IG91dHB1dHMgYW5kIHNpbmtzIGl0IHJlY2VpdmVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1haW4gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGBzb3VyY2VzYCBhcyBpbnB1dCBhbmQgb3V0cHV0c1xuICogYHNpbmtzYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkcml2ZXJzIGFuIG9iamVjdCB3aGVyZSBrZXlzIGFyZSBkcml2ZXIgbmFtZXMgYW5kIHZhbHVlc1xuICogYXJlIGRyaXZlciBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBkaXNwb3NlIGZ1bmN0aW9uLCB1c2VkIHRvIHRlcm1pbmF0ZSB0aGUgZXhlY3V0aW9uIG9mIHRoZVxuICogQ3ljbGUuanMgcHJvZ3JhbSwgY2xlYW5pbmcgdXAgcmVzb3VyY2VzIHVzZWQuXG4gKiBAZnVuY3Rpb24gcnVuXG4gKi9cbmZ1bmN0aW9uIHJ1bihtYWluLCBkcml2ZXJzKSB7XG4gICAgdmFyIF9hID0gYmFzZV8xLmRlZmF1bHQobWFpbiwgZHJpdmVycywgeyBzdHJlYW1BZGFwdGVyOiB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0IH0pLCBydW4gPSBfYS5ydW4sIHNpbmtzID0gX2Euc2lua3M7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1snQ3ljbGVqc0RldlRvb2xfc3RhcnRHcmFwaFNlcmlhbGl6ZXInXSkge1xuICAgICAgICB3aW5kb3dbJ0N5Y2xlanNEZXZUb29sX3N0YXJ0R3JhcGhTZXJpYWxpemVyJ10oc2lua3MpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuKCk7XG59XG5leHBvcnRzLnJ1biA9IHJ1bjtcbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHByZXBhcmVzIHRoZSBDeWNsZSBhcHBsaWNhdGlvbiB0byBiZSBleGVjdXRlZC4gVGFrZXMgYSBgbWFpbmBcbiAqIGZ1bmN0aW9uIGFuZCBwcmVwYXJlcyB0byBjaXJjdWxhcmx5IGNvbm5lY3RzIGl0IHRvIHRoZSBnaXZlbiBjb2xsZWN0aW9uIG9mXG4gKiBkcml2ZXIgZnVuY3Rpb25zLiBBcyBhbiBvdXRwdXQsIGBDeWNsZSgpYCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRocmVlXG4gKiBwcm9wZXJ0aWVzOiBgc291cmNlc2AsIGBzaW5rc2AgYW5kIGBydW5gLiBPbmx5IHdoZW4gYHJ1bigpYCBpcyBjYWxsZWQgd2lsbFxuICogdGhlIGFwcGxpY2F0aW9uIGFjdHVhbGx5IGV4ZWN1dGUuIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBydW4oKWAgZm9yXG4gKiBtb3JlIGRldGFpbHMuXG4gKlxuICogKipFeGFtcGxlOioqXG4gKiBgYGBqc1xuICogaW1wb3J0IEN5Y2xlIGZyb20gJ0BjeWNsZS94c3RyZWFtLXJ1bic7XG4gKiBjb25zdCB7c291cmNlcywgc2lua3MsIHJ1bn0gPSBDeWNsZShtYWluLCBkcml2ZXJzKTtcbiAqIC8vIC4uLlxuICogY29uc3QgZGlzcG9zZSA9IHJ1bigpOyAvLyBFeGVjdXRlcyB0aGUgYXBwbGljYXRpb25cbiAqIC8vIC4uLlxuICogZGlzcG9zZSgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWFpbiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYHNvdXJjZXNgIGFzIGlucHV0IGFuZCBvdXRwdXRzXG4gKiBgc2lua3NgLlxuICogQHBhcmFtIHtPYmplY3R9IGRyaXZlcnMgYW4gb2JqZWN0IHdoZXJlIGtleXMgYXJlIGRyaXZlciBuYW1lcyBhbmQgdmFsdWVzXG4gKiBhcmUgZHJpdmVyIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IHdpdGggdGhyZWUgcHJvcGVydGllczogYHNvdXJjZXNgLCBgc2lua3NgIGFuZFxuICogYHJ1bmAuIGBzb3VyY2VzYCBpcyB0aGUgY29sbGVjdGlvbiBvZiBkcml2ZXIgc291cmNlcywgYHNpbmtzYCBpcyB0aGVcbiAqIGNvbGxlY3Rpb24gb2YgZHJpdmVyIHNpbmtzLCB0aGVzZSBjYW4gYmUgdXNlZCBmb3IgZGVidWdnaW5nIG9yIHRlc3RpbmcuIGBydW5gXG4gKiBpcyB0aGUgZnVuY3Rpb24gdGhhdCBvbmNlIGNhbGxlZCB3aWxsIGV4ZWN1dGUgdGhlIGFwcGxpY2F0aW9uLlxuICogQGZ1bmN0aW9uIEN5Y2xlXG4gKi9cbnZhciBDeWNsZSA9IGZ1bmN0aW9uIChtYWluLCBkcml2ZXJzKSB7XG4gICAgdmFyIG91dCA9IGJhc2VfMS5kZWZhdWx0KG1haW4sIGRyaXZlcnMsIHsgc3RyZWFtQWRhcHRlcjogeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdCB9KTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93WydDeWNsZWpzRGV2VG9vbF9zdGFydEdyYXBoU2VyaWFsaXplciddKSB7XG4gICAgICAgIHdpbmRvd1snQ3ljbGVqc0RldlRvb2xfc3RhcnRHcmFwaFNlcmlhbGl6ZXInXShvdXQuc2lua3MpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbkN5Y2xlLnJ1biA9IHJ1bjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEN5Y2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS94c3RyZWFtLXJ1bi9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbG9nVG9Db25zb2xlRXJyb3IoZXJyKSB7XG4gICAgdmFyIHRhcmdldCA9IGVyci5zdGFjayB8fCBlcnI7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlU2lua1Byb3hpZXMoZHJpdmVycywgc3RyZWFtQWRhcHRlcikge1xuICAgIHZhciBzaW5rUHJveGllcyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWVfMSBpbiBkcml2ZXJzKSB7XG4gICAgICAgIGlmIChkcml2ZXJzLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcbiAgICAgICAgICAgIHZhciBzdWJqZWN0ID0gc3RyZWFtQWRhcHRlci5tYWtlU3ViamVjdCgpO1xuICAgICAgICAgICAgdmFyIGRyaXZlclN0cmVhbUFkYXB0ZXIgPSBkcml2ZXJzW25hbWVfMV0uc3RyZWFtQWRhcHRlciB8fCBzdHJlYW1BZGFwdGVyO1xuICAgICAgICAgICAgdmFyIHN0cmVhbSA9IGRyaXZlclN0cmVhbUFkYXB0ZXIuYWRhcHQoc3ViamVjdC5zdHJlYW0sIHN0cmVhbUFkYXB0ZXIuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgICAgIHNpbmtQcm94aWVzW25hbWVfMV0gPSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IHN1YmplY3Qub2JzZXJ2ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW5rUHJveGllcztcbn1cbmZ1bmN0aW9uIGNhbGxEcml2ZXJzKGRyaXZlcnMsIHNpbmtQcm94aWVzLCBzdHJlYW1BZGFwdGVyKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lXzIgaW4gZHJpdmVycykge1xuICAgICAgICBpZiAoZHJpdmVycy5oYXNPd25Qcm9wZXJ0eShuYW1lXzIpKSB7XG4gICAgICAgICAgICB2YXIgZHJpdmVyT3V0cHV0ID0gZHJpdmVyc1tuYW1lXzJdKHNpbmtQcm94aWVzW25hbWVfMl0uc3RyZWFtLCBzdHJlYW1BZGFwdGVyLCBuYW1lXzIpO1xuICAgICAgICAgICAgdmFyIGRyaXZlclN0cmVhbUFkYXB0ZXIgPSBkcml2ZXJzW25hbWVfMl0uc3RyZWFtQWRhcHRlcjtcbiAgICAgICAgICAgIGlmIChkcml2ZXJTdHJlYW1BZGFwdGVyICYmIGRyaXZlclN0cmVhbUFkYXB0ZXIuaXNWYWxpZFN0cmVhbShkcml2ZXJPdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlc1tuYW1lXzJdID0gc3RyZWFtQWRhcHRlci5hZGFwdChkcml2ZXJPdXRwdXQsIGRyaXZlclN0cmVhbUFkYXB0ZXIuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZXNbbmFtZV8yXSA9IGRyaXZlck91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VzW25hbWVfMl0gJiYgdHlwZW9mIHNvdXJjZXNbbmFtZV8yXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzW25hbWVfMl0uX2lzQ3ljbGVTb3VyY2UgPSBuYW1lXzI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiByZXBsaWNhdGVNYW55KHNpbmtzLCBzaW5rUHJveGllcywgc3RyZWFtQWRhcHRlcikge1xuICAgIHZhciBzaW5rTmFtZXMgPSBPYmplY3Qua2V5cyhzaW5rcykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhIXNpbmtQcm94aWVzW25hbWVdOyB9KTtcbiAgICB2YXIgYnVmZmVycyA9IHt9O1xuICAgIHZhciByZXBsaWNhdG9ycyA9IHt9O1xuICAgIHNpbmtOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGJ1ZmZlcnNbbmFtZV0gPSB7IG5leHQ6IFtdLCBlcnJvcjogW10sIGNvbXBsZXRlOiBbXSB9O1xuICAgICAgICByZXBsaWNhdG9yc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBidWZmZXJzW25hbWVdLm5leHQucHVzaCh4KTsgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gYnVmZmVyc1tuYW1lXS5lcnJvci5wdXNoKHgpOyB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBidWZmZXJzW25hbWVdLmNvbXBsZXRlLnB1c2goeCk7IH0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBzaW5rTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1BZGFwdGVyLnN0cmVhbVN1YnNjcmliZShzaW5rc1tuYW1lXSwge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5uZXh0KHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nVG9Db25zb2xlRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJlcGxpY2F0b3JzW25hbWVdLmNvbXBsZXRlKHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGRpc3Bvc2VGdW5jdGlvbnMgPSBzdWJzY3JpcHRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7IH0pO1xuICAgIHNpbmtOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHNpbmtQcm94aWVzW25hbWVdLm9ic2VydmVyO1xuICAgICAgICB2YXIgbmV4dCA9IG9ic2VydmVyLm5leHQ7XG4gICAgICAgIHZhciBlcnJvciA9IG9ic2VydmVyLmVycm9yO1xuICAgICAgICB2YXIgY29tcGxldGUgPSBvYnNlcnZlci5jb21wbGV0ZTtcbiAgICAgICAgYnVmZmVyc1tuYW1lXS5uZXh0LmZvckVhY2gobmV4dCk7XG4gICAgICAgIGJ1ZmZlcnNbbmFtZV0uZXJyb3IuZm9yRWFjaChlcnJvcik7XG4gICAgICAgIGJ1ZmZlcnNbbmFtZV0uY29tcGxldGUuZm9yRWFjaChjb21wbGV0ZSk7XG4gICAgICAgIHJlcGxpY2F0b3JzW25hbWVdLm5leHQgPSBuZXh0O1xuICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpc3Bvc2VGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGlzcG9zZSkgeyByZXR1cm4gZGlzcG9zZSgpOyB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZGlzcG9zZVNvdXJjZXMoc291cmNlcykge1xuICAgIGZvciAodmFyIGsgaW4gc291cmNlcykge1xuICAgICAgICBpZiAoc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrKSAmJiBzb3VyY2VzW2tdXG4gICAgICAgICAgICAmJiB0eXBlb2Ygc291cmNlc1trXS5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzb3VyY2VzW2tdLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBpc09iamVjdEVtcHR5ID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7IH07XG5mdW5jdGlvbiBDeWNsZShtYWluLCBkcml2ZXJzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBtYWluICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gQ3ljbGUgbXVzdCBiZSB0aGUgJ21haW4nIFwiICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRyaXZlcnMgIT09IFwib2JqZWN0XCIgfHwgZHJpdmVycyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgZ2l2ZW4gdG8gQ3ljbGUgbXVzdCBiZSBhbiBvYmplY3QgXCIgK1xuICAgICAgICAgICAgXCJ3aXRoIGRyaXZlciBmdW5jdGlvbnMgYXMgcHJvcGVydGllcy5cIik7XG4gICAgfVxuICAgIGlmIChpc09iamVjdEVtcHR5KGRyaXZlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBnaXZlbiB0byBDeWNsZSBtdXN0IGJlIGFuIG9iamVjdCBcIiArXG4gICAgICAgICAgICBcIndpdGggYXQgbGVhc3Qgb25lIGRyaXZlciBmdW5jdGlvbiBkZWNsYXJlZCBhcyBhIHByb3BlcnR5LlwiKTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbUFkYXB0ZXIgPSBvcHRpb25zLnN0cmVhbUFkYXB0ZXI7XG4gICAgaWYgKCFzdHJlYW1BZGFwdGVyIHx8IGlzT2JqZWN0RW1wdHkoc3RyZWFtQWRhcHRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcmQgYXJndW1lbnQgZ2l2ZW4gdG8gQ3ljbGUgbXVzdCBiZSBhbiBvcHRpb25zIG9iamVjdCBcIiArXG4gICAgICAgICAgICBcIndpdGggdGhlIHN0cmVhbUFkYXB0ZXIga2V5IHN1cHBsaWVkIHdpdGggYSB2YWxpZCBzdHJlYW0gYWRhcHRlci5cIik7XG4gICAgfVxuICAgIHZhciBzaW5rUHJveGllcyA9IG1ha2VTaW5rUHJveGllcyhkcml2ZXJzLCBzdHJlYW1BZGFwdGVyKTtcbiAgICB2YXIgc291cmNlcyA9IGNhbGxEcml2ZXJzKGRyaXZlcnMsIHNpbmtQcm94aWVzLCBzdHJlYW1BZGFwdGVyKTtcbiAgICB2YXIgc2lua3MgPSBtYWluKHNvdXJjZXMpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuQ3ljbGVqcyA9IHsgc2lua3M6IHNpbmtzIH07XG4gICAgfVxuICAgIHZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXNwb3NlUmVwbGljYXRpb24gPSByZXBsaWNhdGVNYW55KHNpbmtzLCBzaW5rUHJveGllcywgc3RyZWFtQWRhcHRlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkaXNwb3NlU291cmNlcyhzb3VyY2VzKTtcbiAgICAgICAgICAgIGRpc3Bvc2VSZXBsaWNhdGlvbigpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgc2lua3M6IHNpbmtzLCBzb3VyY2VzOiBzb3VyY2VzLCBydW46IHJ1biB9O1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ3ljbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL3hzdHJlYW0tcnVuL34vQGN5Y2xlL2Jhc2UvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5mdW5jdGlvbiBpc1N0cmljdGx5SW5TY29wZShuYW1lc3BhY2UsIHBhdGgpIHtcbiAgICB2YXIgcGF0aFBhcnRzID0gdXRpbC5zcGxpdFBhdGgocGF0aCk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZS5ldmVyeShmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICByZXR1cm4gcGF0aFBhcnRzW2ldID09PSB2O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmlsdGVyZWRQYXRoKG5hbWVzcGFjZSwgcGF0aCkge1xuICAgIHZhciBwYXRoUGFydHMgPSB1dGlsLnNwbGl0UGF0aChwYXRoKTtcbiAgICByZXR1cm4gJy8nICsgdXRpbC5maWx0ZXJQYXRoKHBhdGhQYXJ0cywgbmFtZXNwYWNlKTtcbn1cbnZhciBSb3V0ZXJTb3VyY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlclNvdXJjZShoaXN0b3J5JCwgX25hbWVzcGFjZSwgX2NyZWF0ZUhyZWYsIF9ydW5TQSwgX3JvdXRlTWF0Y2hlcikge1xuICAgICAgICB0aGlzLmhpc3RvcnkkID0gaGlzdG9yeSQ7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IF9uYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUhyZWYgPSBfY3JlYXRlSHJlZjtcbiAgICAgICAgdGhpcy5fcnVuU0EgPSBfcnVuU0E7XG4gICAgICAgIHRoaXMuX3JvdXRlTWF0Y2hlciA9IF9yb3V0ZU1hdGNoZXI7XG4gICAgfVxuICAgIFJvdXRlclNvdXJjZS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICB2YXIgc2NvcGVkTmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlLmNvbmNhdCh1dGlsLnNwbGl0UGF0aChwYXRobmFtZSkpO1xuICAgICAgICB2YXIgc2NvcGVkSGlzdG9yeSQgPSB0aGlzLl9ydW5TQS5yZW1lbWJlcih0aGlzLmhpc3RvcnkkXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9wYXRoID0gX2EucGF0aG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpY3RseUluU2NvcGUoc2NvcGVkTmFtZXNwYWNlLCBfcGF0aCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGNyZWF0ZUhyZWYgPSB0aGlzLl9jcmVhdGVIcmVmO1xuICAgICAgICByZXR1cm4gbmV3IFJvdXRlclNvdXJjZShzY29wZWRIaXN0b3J5JCwgc2NvcGVkTmFtZXNwYWNlLCBjcmVhdGVIcmVmLCB0aGlzLl9ydW5TQSwgdGhpcy5fcm91dGVNYXRjaGVyKTtcbiAgICB9O1xuICAgIFJvdXRlclNvdXJjZS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKHJvdXRlcywgcm91dGVNYXRjaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLl9uYW1lc3BhY2U7XG4gICAgICAgIHZhciBfY3JlYXRlSHJlZiA9IHRoaXMuX2NyZWF0ZUhyZWY7XG4gICAgICAgIHZhciBjcmVhdGVIcmVmID0gdXRpbC5tYWtlQ3JlYXRlSHJlZihuYW1lc3BhY2UsIF9jcmVhdGVIcmVmKTtcbiAgICAgICAgdmFyIG1hdGNoJCA9IHRoaXMuX3J1blNBLnJlbWVtYmVyKHRoaXMuaGlzdG9yeSRcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlciA9IHJvdXRlTWF0Y2hlciB8fCBfdGhpcy5fcm91dGVNYXRjaGVyO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkUGF0aCA9IGdldEZpbHRlcmVkUGF0aChuYW1lc3BhY2UsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIHZhciBfYSA9IG1hdGNoZXIoZmlsdGVyZWRQYXRoLCByb3V0ZXMpLCBwYXRoID0gX2EucGF0aCwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSwgbG9jYXRpb246IGxvY2F0aW9uLCBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmIH07XG4gICAgICAgIH0pKTtcbiAgICAgICAgbWF0Y2gkLmNyZWF0ZUhyZWYgPSBjcmVhdGVIcmVmO1xuICAgICAgICByZXR1cm4gbWF0Y2gkO1xuICAgIH07XG4gICAgUm91dGVyU291cmNlLnByb3RvdHlwZS5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwubWFrZUNyZWF0ZUhyZWYodGhpcy5fbmFtZXNwYWNlLCB0aGlzLl9jcmVhdGVIcmVmKShwYXRoKTtcbiAgICB9O1xuICAgIHJldHVybiBSb3V0ZXJTb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5Sb3V0ZXJTb3VyY2UgPSBSb3V0ZXJTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3V0ZXJTb3VyY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2N5Y2xpYy1yb3V0ZXIvbGliL1JvdXRlclNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWFrZVJvdXRlckRyaXZlcl8xID0gcmVxdWlyZSgnLi9tYWtlUm91dGVyRHJpdmVyJyk7XG5leHBvcnRzLm1ha2VSb3V0ZXJEcml2ZXIgPSBtYWtlUm91dGVyRHJpdmVyXzEubWFrZVJvdXRlckRyaXZlcjtcbnZhciBoaXN0b3J5XzEgPSByZXF1aXJlKCdAY3ljbGUvaGlzdG9yeScpO1xuZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBoaXN0b3J5XzEuc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGhpc3RvcnlfMS5jcmVhdGVMb2NhdGlvbjtcbmV4cG9ydHMuY3JlYXRlU2VydmVySGlzdG9yeSA9IGhpc3RvcnlfMS5jcmVhdGVTZXJ2ZXJIaXN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2N5Y2xpYy1yb3V0ZXIvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBoaXN0b3J5XzEgPSByZXF1aXJlKCdAY3ljbGUvaGlzdG9yeScpO1xudmFyIFJvdXRlclNvdXJjZV8xID0gcmVxdWlyZSgnLi9Sb3V0ZXJTb3VyY2UnKTtcbi8qKlxuICogSW5zdGFudGlhdGVzIGFuIG5ldyByb3V0ZXIgZHJpdmVyIGZ1bmN0aW9uIHVzaW5nIHRoZSBzYW1lIGFyZ3VtZW50cyByZXF1aXJlZFxuICogYnkgQGN5Y2xlL2hpc3RvcnkuXG4gKiBAcHVibGljXG4gKiBAbWV0aG9kIG1ha2VSb3V0ZXJEcml2ZXJcbiAqIEByZXR1cm4ge3JvdXRlckRyaXZlcn0gVGhlIHJvdXRlciBkcml2ZXIgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gbWFrZVJvdXRlckRyaXZlcihoaXN0b3J5LCByb3V0ZU1hdGNoZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdG9yeURyaXZlciA9IGhpc3RvcnlfMS5tYWtlSGlzdG9yeURyaXZlcihoaXN0b3J5LCBvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWN0dWFsIHJvdXRlciBkcml2ZXIuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0eXBlZGVmIHtyb3V0ZXJEcml2ZXJ9XG4gICAgICogQG5hbWUgcm91dGVyRHJpdmVyXG4gICAgICogQG1ldGhvZCByb3V0ZXJEcml2ZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJlYW08c3RyaW5nfExvY2F0aW9uPn0gc2luayQgLSBUaGlzIGlzIHRoZSBzYW1lIGlucHV0IHRoYXQgdGhlXG4gICAgICogaGlzdG9yeSBkcml2ZXIgd291bGQgZXhwZWN0LlxuICAgICAqIEByZXR1cm4ge3JvdXRlckFQSX1cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gcm91dGVyRHJpdmVyKHNpbmskLCBydW5TQSkge1xuICAgICAgICB2YXIgaGlzdG9yeSQgPSBydW5TQS5yZW1lbWJlcihoaXN0b3J5RHJpdmVyKHNpbmskLCBydW5TQSkpO1xuICAgICAgICByZXR1cm4gbmV3IFJvdXRlclNvdXJjZV8xLlJvdXRlclNvdXJjZShoaXN0b3J5JCwgW10sIGhpc3RvcnkuY3JlYXRlSHJlZiwgcnVuU0EsIHJvdXRlTWF0Y2hlcik7XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZVJvdXRlckRyaXZlciA9IG1ha2VSb3V0ZXJEcml2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlUm91dGVyRHJpdmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jeWNsaWMtcm91dGVyL2xpYi9tYWtlUm91dGVyRHJpdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHNwbGl0UGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubGVuZ3RoID4gMDsgfSk7XG59XG5leHBvcnRzLnNwbGl0UGF0aCA9IHNwbGl0UGF0aDtcbmZ1bmN0aW9uIGZpbHRlclBhdGgocGF0aFBhcnRzLCBuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gcGF0aFBhcnRzLmZpbHRlcihmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gbmFtZXNwYWNlLmluZGV4T2YocGFydCkgPCAwOyB9KS5qb2luKCcvJyk7XG59XG5leHBvcnRzLmZpbHRlclBhdGggPSBmaWx0ZXJQYXRoO1xudmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiAocGFyYW0sIHZhbHVlKSB7IHJldHVybiBwYXJhbVswXSA9PT0gdmFsdWU7IH07XG52YXIgc3RhcnRzV2l0aDIgPSBmdW5jdGlvbiAocGFyYW0sIHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgcmV0dXJuIHBhcmFtWzBdID09PSB2YWx1ZTEgJiYgcGFyYW1bMV0gPT09IHZhbHVlMjtcbn07XG5mdW5jdGlvbiBtYWtlQ3JlYXRlSHJlZihuYW1lc3BhY2UsIF9jcmVhdGVIcmVmKSB7XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgSFJFRnMgdGhhdCBhcmUgcHJvcGVybHkgbmFtZXNwYWNlZFxuICAgICAqIEB0eXBlZGVmIHtjcmVhdGVIcmVmfVxuICAgICAqIEBuYW1lIGNyZWF0ZUhyZWZcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUhyZWZcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGggLSB0aGUgSFJFRiB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnRcbiAgICAgKiBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGEgZnVsbHkgcXVhbGlmaWVkIEhSRUYgY29tcG9zZWQgZnJvbSB0aGUgY3VycmVudFxuICAgICAqIG5hbWVzcGFjZSBhbmQgdGhlIHBhdGggcHJvdmlkZWRcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSHJlZihwYXRoKSB7XG4gICAgICAgIHZhciBmdWxsUGF0aCA9IFwiXCIgKyBuYW1lc3BhY2Uuam9pbignLycpICsgcGF0aDtcbiAgICAgICAgcmV0dXJuIHN0YXJ0c1dpdGgoZnVsbFBhdGgsICcvJykgfHwgc3RhcnRzV2l0aDIoZnVsbFBhdGgsICcjJywgJy8nKVxuICAgICAgICAgICAgPyBfY3JlYXRlSHJlZihmdWxsUGF0aClcbiAgICAgICAgICAgIDogX2NyZWF0ZUhyZWYoJy8nICsgZnVsbFBhdGgpO1xuICAgIH07XG59XG5leHBvcnRzLm1ha2VDcmVhdGVIcmVmID0gbWFrZUNyZWF0ZUhyZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jeWNsaWMtcm91dGVyL2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb3B5ICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvY29weScpXG4gICwgbWFwICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L21hcCcpXG4gICwgY2FsbGFibGUgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCB2YWxpZFZhbHVlID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuXG4gICwgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlZmluZTtcblxuZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlc2MsIGJpbmRUbykge1xuXHR2YXIgdmFsdWUgPSB2YWxpZFZhbHVlKGRlc2MpICYmIGNhbGxhYmxlKGRlc2MudmFsdWUpLCBkZ3M7XG5cdGRncyA9IGNvcHkoZGVzYyk7XG5cdGRlbGV0ZSBkZ3Mud3JpdGFibGU7XG5cdGRlbGV0ZSBkZ3MudmFsdWU7XG5cdGRncy5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHJldHVybiB2YWx1ZTtcblx0XHRkZXNjLnZhbHVlID0gYmluZC5jYWxsKHZhbHVlLCAoYmluZFRvID09IG51bGwpID8gdGhpcyA6IHRoaXNbYmluZFRvXSk7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZGVzYyk7XG5cdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdH07XG5cdHJldHVybiBkZ3M7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm9wcy8qLCBiaW5kVG8qLykge1xuXHR2YXIgYmluZFRvID0gYXJndW1lbnRzWzFdO1xuXHRyZXR1cm4gbWFwKHByb3BzLCBmdW5jdGlvbiAoZGVzYywgbmFtZSkge1xuXHRcdHJldHVybiBkZWZpbmUobmFtZSwgZGVzYywgYmluZFRvKTtcblx0fSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QvYXV0by1iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1Bvc0ludCA9IHJlcXVpcmUoJy4uLy4uL251bWJlci90by1wb3MtaW50ZWdlcicpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWUnKVxuXG4gICwgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXgqLykge1xuXHR2YXIgaSwgbCwgZnJvbUluZGV4LCB2YWw7XG5cdGlmIChzZWFyY2hFbGVtZW50ID09PSBzZWFyY2hFbGVtZW50KSB7IC8vanNsaW50OiBpZ25vcmVcblx0XHRyZXR1cm4gaW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cblx0bCA9IHRvUG9zSW50KHZhbHVlKHRoaXMpLmxlbmd0aCk7XG5cdGZyb21JbmRleCA9IGFyZ3VtZW50c1sxXTtcblx0aWYgKGlzTmFOKGZyb21JbmRleCkpIGZyb21JbmRleCA9IDA7XG5cdGVsc2UgaWYgKGZyb21JbmRleCA+PSAwKSBmcm9tSW5kZXggPSBmbG9vcihmcm9tSW5kZXgpO1xuXHRlbHNlIGZyb21JbmRleCA9IHRvUG9zSW50KHRoaXMubGVuZ3RoKSAtIGZsb29yKGFicyhmcm9tSW5kZXgpKTtcblxuXHRmb3IgKGkgPSBmcm9tSW5kZXg7IGkgPCBsOyArK2kpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSkge1xuXHRcdFx0dmFsID0gdGhpc1tpXTtcblx0XHRcdGlmICh2YWwgIT09IHZhbCkgcmV0dXJuIGk7IC8vanNsaW50OiBpZ25vcmVcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L2FycmF5LyMvZS1pbmRleC1vZi5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gTWF0aC5zaWduXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9tYXRoL3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzaWduID0gTWF0aC5zaWduO1xuXHRpZiAodHlwZW9mIHNpZ24gIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICgoc2lnbigxMCkgPT09IDEpICYmIChzaWduKC0yMCkgPT09IC0xKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvbWF0aC9zaWduL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblx0aWYgKGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgPT09IDApKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiAodmFsdWUgPiAwKSA/IDEgOiAtMTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9tYXRoL3NpZ24vc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4uL21hdGgvc2lnbicpXG5cbiAgLCBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gMDtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAoKHZhbHVlID09PSAwKSB8fCAhaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiBzaWduKHZhbHVlKSAqIGZsb29yKGFicyh2YWx1ZSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L251bWJlci90by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvLWludGVnZXInKVxuXG4gICwgbWF4ID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBtYXgoMCwgdG9JbnRlZ2VyKHZhbHVlKSk7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9udW1iZXIvdG8tcG9zLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEludGVybmFsIG1ldGhvZCwgdXNlZCBieSBpdGVyYXRpb24gZnVuY3Rpb25zLlxuLy8gQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBrZXktdmFsdWUgcGFpciBmb3VuZCBpbiBvYmplY3Rcbi8vIE9wdGlvbmFsbHkgdGFrZXMgY29tcGFyZUZuIHRvIGl0ZXJhdGUgb2JqZWN0IGluIHNwZWNpZmljIG9yZGVyXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxhYmxlID0gcmVxdWlyZSgnLi92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKCcuL3ZhbGlkLXZhbHVlJylcblxuICAsIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLCBrZXlzID0gT2JqZWN0LmtleXNcbiAgLCBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgZGVmVmFsKSB7XG5cdHJldHVybiBmdW5jdGlvbiAob2JqLCBjYi8qLCB0aGlzQXJnLCBjb21wYXJlRm4qLykge1xuXHRcdHZhciBsaXN0LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdLCBjb21wYXJlRm4gPSBhcmd1bWVudHNbM107XG5cdFx0b2JqID0gT2JqZWN0KHZhbHVlKG9iaikpO1xuXHRcdGNhbGxhYmxlKGNiKTtcblxuXHRcdGxpc3QgPSBrZXlzKG9iaik7XG5cdFx0aWYgKGNvbXBhcmVGbikge1xuXHRcdFx0bGlzdC5zb3J0KCh0eXBlb2YgY29tcGFyZUZuID09PSAnZnVuY3Rpb24nKSA/IGJpbmQuY2FsbChjb21wYXJlRm4sIG9iaikgOiB1bmRlZmluZWQpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykgbWV0aG9kID0gbGlzdFttZXRob2RdO1xuXHRcdHJldHVybiBjYWxsLmNhbGwobWV0aG9kLCBsaXN0LCBmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuXHRcdFx0aWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KSkgcmV0dXJuIGRlZlZhbDtcblx0XHRcdHJldHVybiBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIG9ialtrZXldLCBrZXksIG9iaiwgaW5kZXgpO1xuXHRcdH0pO1xuXHR9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9faXRlcmF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sIG9iajtcblx0aWYgKHR5cGVvZiBhc3NpZ24gIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0b2JqID0geyBmb286ICdyYXonIH07XG5cdGFzc2lnbihvYmosIHsgYmFyOiAnZHdhJyB9LCB7IHRyenk6ICd0cnp5JyB9KTtcblx0cmV0dXJuIChvYmouZm9vICsgb2JqLmJhciArIG9iai50cnp5KSA9PT0gJ3JhemR3YXRyenknO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgID0gcmVxdWlyZSgnLi4va2V5cycpXG4gICwgdmFsdWUgPSByZXF1aXJlKCcuLi92YWxpZC12YWx1ZScpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVzdCwgc3JjLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGwgPSBtYXgoYXJndW1lbnRzLmxlbmd0aCwgMiksIGFzc2lnbjtcblx0ZGVzdCA9IE9iamVjdCh2YWx1ZShkZXN0KSk7XG5cdGFzc2lnbiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR0cnkgeyBkZXN0W2tleV0gPSBzcmNba2V5XTsgfSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlO1xuXHRcdH1cblx0fTtcblx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL2Fzc2lnbicpXG4gICwgdmFsdWUgID0gcmVxdWlyZSgnLi92YWxpZC12YWx1ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcblx0dmFyIGNvcHkgPSBPYmplY3QodmFsdWUob2JqKSk7XG5cdGlmIChjb3B5ICE9PSBvYmopIHJldHVybiBjb3B5O1xuXHRyZXR1cm4gYXNzaWduKHt9LCBvYmopO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9jb3B5LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXb3JrYXJvdW5kIGZvciBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yODA0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIHNoaW07XG5cbmlmICghcmVxdWlyZSgnLi9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkJykoKSkge1xuXHRzaGltID0gcmVxdWlyZSgnLi9zZXQtcHJvdG90eXBlLW9mL3NoaW0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgbnVsbE9iamVjdCwgcHJvcHMsIGRlc2M7XG5cdGlmICghc2hpbSkgcmV0dXJuIGNyZWF0ZTtcblx0aWYgKHNoaW0ubGV2ZWwgIT09IDEpIHJldHVybiBjcmVhdGU7XG5cblx0bnVsbE9iamVjdCA9IHt9O1xuXHRwcm9wcyA9IHt9O1xuXHRkZXNjID0geyBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsXG5cdFx0dmFsdWU6IHVuZGVmaW5lZCB9O1xuXHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG5cdFx0XHRwcm9wc1tuYW1lXSA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWQgfTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJvcHNbbmFtZV0gPSBkZXNjO1xuXHR9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobnVsbE9iamVjdCwgcHJvcHMpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaGltLCAnbnVsbFBvbHlmaWxsJywgeyBjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBudWxsT2JqZWN0IH0pO1xuXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wcykge1xuXHRcdHJldHVybiBjcmVhdGUoKHByb3RvdHlwZSA9PT0gbnVsbCkgPyBudWxsT2JqZWN0IDogcHJvdG90eXBlLCBwcm9wcyk7XG5cdH07XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyYXRlJykoJ2ZvckVhY2gnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9mb3ItZWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIERlcHJlY2F0ZWRcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXAgPSB7IGZ1bmN0aW9uOiB0cnVlLCBvYmplY3Q6IHRydWUgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4gKCh4ICE9IG51bGwpICYmIG1hcFt0eXBlb2YgeF0pIHx8IGZhbHNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3Qua2V5c1xuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdE9iamVjdC5rZXlzKCdwcmltaXRpdmUnKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdHJldHVybiBrZXlzKG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogT2JqZWN0KG9iamVjdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsYWJsZSA9IHJlcXVpcmUoJy4vdmFsaWQtY2FsbGFibGUnKVxuICAsIGZvckVhY2ggID0gcmVxdWlyZSgnLi9mb3ItZWFjaCcpXG5cbiAgLCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgY2IvKiwgdGhpc0FyZyovKSB7XG5cdHZhciBvID0ge30sIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XG5cdGNhbGxhYmxlKGNiKTtcblx0Zm9yRWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmosIGluZGV4KSB7XG5cdFx0b1trZXldID0gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB2YWx1ZSwga2V5LCBvYmosIGluZGV4KTtcblx0fSk7XG5cdHJldHVybiBvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbnZhciBwcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgb2JqKSB7XG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIHNyYykgb2JqW2tleV0gPSBzcmNba2V5XTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMvKiwg4oCmb3B0aW9ucyovKSB7XG5cdHZhciByZXN1bHQgPSBjcmVhdGUobnVsbCk7XG5cdGZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMgPT0gbnVsbCkgcmV0dXJuO1xuXHRcdHByb2Nlc3MoT2JqZWN0KG9wdGlvbnMpLCByZXN1bHQpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZy8qLCDigKZhcmdzKi8pIHtcblx0dmFyIHNldCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG5hbWUpIHsgc2V0W25hbWVdID0gdHJ1ZTsgfSk7XG5cdHJldHVybiBzZXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L3ByaW1pdGl2ZS1zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHIgPSAncmF6ZHdhdHJ6eSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHN0ci5jb250YWlucyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKChzdHIuY29udGFpbnMoJ2R3YScpID09PSB0cnVlKSAmJiAoc3RyLmNvbnRhaW5zKCdmb28nKSA9PT0gZmFsc2UpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZy8qLCBwb3NpdGlvbiovKSB7XG5cdHJldHVybiBpbmRleE9mLmNhbGwodGhpcywgc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pID4gLTE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgY29udGFpbnMgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zJylcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnLi8nKVxuXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBBcnJheUl0ZXJhdG9yO1xuXG5BcnJheUl0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBraW5kKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBBcnJheUl0ZXJhdG9yKSkgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKGFyciwga2luZCk7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgYXJyKTtcblx0aWYgKCFraW5kKSBraW5kID0gJ3ZhbHVlJztcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCAna2V5K3ZhbHVlJykpIGtpbmQgPSAna2V5K3ZhbHVlJztcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCAna2V5JykpIGtpbmQgPSAna2V5Jztcblx0ZWxzZSBraW5kID0gJ3ZhbHVlJztcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fa2luZF9fJywgZCgnJywga2luZCkpO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoQXJyYXlJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG5BcnJheUl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKEFycmF5SXRlcmF0b3IpLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAndmFsdWUnKSByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gJ2tleSt2YWx1ZScpIHJldHVybiBbaSwgdGhpcy5fX2xpc3RfX1tpXV07XG5cdFx0cmV0dXJuIGk7XG5cdH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBBcnJheSBJdGVyYXRvcl0nOyB9KVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LWl0ZXJhdG9yL2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50cycpXG4gICwgY2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgaXNTdHJpbmcgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy9pcy1zdHJpbmcnKVxuICAsIGdldCAgICAgICAgID0gcmVxdWlyZSgnLi9nZXQnKVxuXG4gICwgaXNBcnJheSA9IEFycmF5LmlzQXJyYXksIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNiLyosIHRoaXNBcmcqLykge1xuXHR2YXIgbW9kZSwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXSwgcmVzdWx0LCBkb0JyZWFrLCBicm9rZW4sIGksIGwsIGNoYXIsIGNvZGU7XG5cdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIG1vZGUgPSAnYXJyYXknO1xuXHRlbHNlIGlmIChpc1N0cmluZyhpdGVyYWJsZSkpIG1vZGUgPSAnc3RyaW5nJztcblx0ZWxzZSBpdGVyYWJsZSA9IGdldChpdGVyYWJsZSk7XG5cblx0Y2FsbGFibGUoY2IpO1xuXHRkb0JyZWFrID0gZnVuY3Rpb24gKCkgeyBicm9rZW4gPSB0cnVlOyB9O1xuXHRpZiAobW9kZSA9PT0gJ2FycmF5Jykge1xuXHRcdHNvbWUuY2FsbChpdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBkb0JyZWFrKTtcblx0XHRcdGlmIChicm9rZW4pIHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAobW9kZSA9PT0gJ3N0cmluZycpIHtcblx0XHRsID0gaXRlcmFibGUubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0XHRcdGNoYXIgPSBpdGVyYWJsZVtpXTtcblx0XHRcdGlmICgoaSArIDEpIDwgbCkge1xuXHRcdFx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRpZiAoKGNvZGUgPj0gMHhEODAwKSAmJiAoY29kZSA8PSAweERCRkYpKSBjaGFyICs9IGl0ZXJhYmxlWysraV07XG5cdFx0XHR9XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIGNoYXIsIGRvQnJlYWspO1xuXHRcdFx0aWYgKGJyb2tlbikgYnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRyZXN1bHQgPSBpdGVyYWJsZS5uZXh0KCk7XG5cblx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgcmVzdWx0LnZhbHVlLCBkb0JyZWFrKTtcblx0XHRpZiAoYnJva2VuKSByZXR1cm47XG5cdFx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1pdGVyYXRvci9mb3Itb2YuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoJ2VzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzJylcbiAgLCBpc1N0cmluZyAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nL2lzLXN0cmluZycpXG4gICwgQXJyYXlJdGVyYXRvciAgPSByZXF1aXJlKCcuL2FycmF5JylcbiAgLCBTdHJpbmdJdGVyYXRvciA9IHJlcXVpcmUoJy4vc3RyaW5nJylcbiAgLCBpdGVyYWJsZSAgICAgICA9IHJlcXVpcmUoJy4vdmFsaWQtaXRlcmFibGUnKVxuICAsIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpLml0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKHR5cGVvZiBpdGVyYWJsZShvYmopW2l0ZXJhdG9yU3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG9ialtpdGVyYXRvclN5bWJvbF0oKTtcblx0aWYgKGlzQXJndW1lbnRzKG9iaikpIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xuXHRpZiAoaXNTdHJpbmcob2JqKSkgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcihvYmopO1xuXHRyZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LWl0ZXJhdG9yL2dldC5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZSgnZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMnKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nJylcbiAgLCBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS5pdGVyYXRvclxuXG4gICwgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGlmIChpc0FycmF5KHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdGlmIChpc1N0cmluZyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNBcmd1bWVudHModmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuICh0eXBlb2YgdmFsdWVbaXRlcmF0b3JTeW1ib2xdID09PSAnZnVuY3Rpb24nKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LWl0ZXJhdG9yL2lzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhhbmtzIEBtYXRoaWFzYnluZW5zXG4vLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUjaXRlcmF0aW5nLW92ZXItc3ltYm9sc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCcuLycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIFN0cmluZ0l0ZXJhdG9yO1xuXG5TdHJpbmdJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyaW5nSXRlcmF0b3IpKSByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKHN0cik7XG5cdHN0ciA9IFN0cmluZyhzdHIpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIHN0cik7XG5cdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2xlbmd0aF9fJywgZCgnJywgc3RyLmxlbmd0aCkpO1xuXG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihTdHJpbmdJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG5TdHJpbmdJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChTdHJpbmdJdGVyYXRvciksXG5cdF9uZXh0OiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX19saXN0X18pIHJldHVybjtcblx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fIDwgdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gdGhpcy5fX25leHRJbmRleF9fKys7XG5cdFx0dGhpcy5fdW5CaW5kKCk7XG5cdH0pLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdHZhciBjaGFyID0gdGhpcy5fX2xpc3RfX1tpXSwgY29kZTtcblx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fID09PSB0aGlzLl9fbGVuZ3RoX18pIHJldHVybiBjaGFyO1xuXHRcdGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cdFx0aWYgKChjb2RlID49IDB4RDgwMCkgJiYgKGNvZGUgPD0gMHhEQkZGKSkgcmV0dXJuIGNoYXIgKyB0aGlzLl9fbGlzdF9fW3RoaXMuX19uZXh0SW5kZXhfXysrXTtcblx0XHRyZXR1cm4gY2hhcjtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IFN0cmluZyBJdGVyYXRvcl0nOyB9KVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LWl0ZXJhdG9yL3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHRyeSB7XG5cdFx0Ly8gV2ViS2l0IGRvZXNuJ3Qgc3VwcG9ydCBhcmd1bWVudHMgYW5kIGNyYXNoZXNcblx0XHRtYXAgPSBuZXcgTWFwKFtbJ3JheicsICdvbmUnXSwgWydkd2EnLCAndHdvJ10sIFsndHJ6eScsICd0aHJlZSddXSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKFN0cmluZyhtYXApICE9PSAnW29iamVjdCBNYXBdJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAobWFwLnNpemUgIT09IDMpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuY2xlYXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZGVsZXRlICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmVudHJpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5nZXQgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuaGFzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmtleXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuc2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLnZhbHVlcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG5cdGl0ZXJhdG9yID0gbWFwLmVudHJpZXMoKTtcblx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRpZiAocmVzdWx0LmRvbmUgIT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdGlmICghcmVzdWx0LnZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMF0gIT09ICdyYXonKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMV0gIT09ICdvbmUnKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1tYXAvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBFeHBvcnRzIHRydWUgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgbmF0aXZlIGBNYXBgIGltcGxlbWVudGF0aW9uLFxuLy8gd2hhdGV2ZXIgdGhhdCBpcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgTWFwKCkpID09PSAnW29iamVjdCBNYXBdJyk7XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1tYXAvaXMtbmF0aXZlLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ByaW1pdGl2ZS1zZXQnKSgna2V5Jyxcblx0J3ZhbHVlJywgJ2tleSt2YWx1ZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1tYXAvbGliL2l0ZXJhdG9yLWtpbmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yJylcbiAgLCB0b1N0cmluZ1RhZ1N5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS50b1N0cmluZ1RhZ1xuICAsIGtpbmRzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9pdGVyYXRvci1raW5kcycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCB1bkJpbmQgPSBJdGVyYXRvci5wcm90b3R5cGUuX3VuQmluZFxuICAsIE1hcEl0ZXJhdG9yO1xuXG5NYXBJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hcCwga2luZCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwSXRlcmF0b3IpKSByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKG1hcCwga2luZCk7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgbWFwLl9fbWFwS2V5c0RhdGFfXywgbWFwKTtcblx0aWYgKCFraW5kIHx8ICFraW5kc1traW5kXSkga2luZCA9ICdrZXkrdmFsdWUnO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2tpbmRfXzogZCgnJywga2luZCksXG5cdFx0X192YWx1ZXNfXzogZCgndycsIG1hcC5fX21hcFZhbHVlc0RhdGFfXylcblx0fSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG5NYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChNYXBJdGVyYXRvciksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICd2YWx1ZScpIHJldHVybiB0aGlzLl9fdmFsdWVzX19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICdrZXknKSByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRyZXR1cm4gW3RoaXMuX19saXN0X19baV0sIHRoaXMuX192YWx1ZXNfX1tpXV07XG5cdH0pLFxuXHRfdW5CaW5kOiBkKGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9fdmFsdWVzX18gPSBudWxsO1xuXHRcdHVuQmluZC5jYWxsKHRoaXMpO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7IH0pXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBJdGVyYXRvci5wcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLFxuXHRkKCdjJywgJ01hcCBJdGVyYXRvcicpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtbWFwL2xpYi9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsZWFyICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2NsZWFyJylcbiAgLCBlSW5kZXhPZiAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mJylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGNhbGxhYmxlICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbGlkVmFsdWUgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgZWUgICAgICAgICAgICAgPSByZXF1aXJlKCdldmVudC1lbWl0dGVyJylcbiAgLCBTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKVxuICAsIGl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL3ZhbGlkLWl0ZXJhYmxlJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci9mb3Itb2YnKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0b3InKVxuICAsIGlzTmF0aXZlICAgICAgID0gcmVxdWlyZSgnLi9pcy1uYXRpdmUtaW1wbGVtZW50ZWQnKVxuXG4gICwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAsIE1hcFBvbHk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwUG9seSA9IGZ1bmN0aW9uICgvKml0ZXJhYmxlKi8pIHtcblx0dmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdLCBrZXlzLCB2YWx1ZXMsIHNlbGY7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXBQb2x5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgcmVxdWlyZXMgXFwnbmV3XFwnJyk7XG5cdGlmIChpc05hdGl2ZSAmJiBzZXRQcm90b3R5cGVPZiAmJiAoTWFwICE9PSBNYXBQb2x5KSkge1xuXHRcdHNlbGYgPSBzZXRQcm90b3R5cGVPZihuZXcgTWFwKCksIGdldFByb3RvdHlwZU9mKHRoaXMpKTtcblx0fSBlbHNlIHtcblx0XHRzZWxmID0gdGhpcztcblx0fVxuXHRpZiAoaXRlcmFibGUgIT0gbnVsbCkgaXRlcmF0b3IoaXRlcmFibGUpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHtcblx0XHRfX21hcEtleXNEYXRhX186IGQoJ2MnLCBrZXlzID0gW10pLFxuXHRcdF9fbWFwVmFsdWVzRGF0YV9fOiBkKCdjJywgdmFsdWVzID0gW10pXG5cdH0pO1xuXHRpZiAoIWl0ZXJhYmxlKSByZXR1cm4gc2VsZjtcblx0Zm9yT2YoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciBrZXkgPSB2YWxpZFZhbHVlKHZhbHVlKVswXTtcblx0XHR2YWx1ZSA9IHZhbHVlWzFdO1xuXHRcdGlmIChlSW5kZXhPZi5jYWxsKGtleXMsIGtleSkgIT09IC0xKSByZXR1cm47XG5cdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0dmFsdWVzLnB1c2godmFsdWUpO1xuXHR9LCBzZWxmKTtcblx0cmV0dXJuIHNlbGY7XG59O1xuXG5pZiAoaXNOYXRpdmUpIHtcblx0aWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBQb2x5LCBNYXApO1xuXHRNYXBQb2x5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTWFwLnByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBkKE1hcFBvbHkpXG5cdH0pO1xufVxuXG5lZShkZWZpbmVQcm9wZXJ0aWVzKE1hcFBvbHkucHJvdG90eXBlLCB7XG5cdGNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX19tYXBLZXlzRGF0YV9fLmxlbmd0aCkgcmV0dXJuO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18pO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcFZhbHVlc0RhdGFfXyk7XG5cdFx0dGhpcy5lbWl0KCdfY2xlYXInKTtcblx0fSksXG5cdGRlbGV0ZTogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KTtcblx0XHRpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cdFx0dGhpcy5fX21hcEtleXNEYXRhX18uc3BsaWNlKGluZGV4LCAxKTtcblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5lbWl0KCdfZGVsZXRlJywgaW5kZXgsIGtleSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pLFxuXHRlbnRyaWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7IH0pLFxuXHRmb3JFYWNoOiBkKGZ1bmN0aW9uIChjYi8qLCB0aGlzQXJnKi8pIHtcblx0XHR2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXSwgaXRlcmF0b3IsIHJlc3VsdDtcblx0XHRjYWxsYWJsZShjYik7XG5cdFx0aXRlcmF0b3IgPSB0aGlzLmVudHJpZXMoKTtcblx0XHRyZXN1bHQgPSBpdGVyYXRvci5fbmV4dCgpO1xuXHRcdHdoaWxlIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW3Jlc3VsdF0sXG5cdFx0XHRcdHRoaXMuX19tYXBLZXlzRGF0YV9fW3Jlc3VsdF0sIHRoaXMpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IuX25leHQoKTtcblx0XHR9XG5cdH0pLFxuXHRnZXQ6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuXHRcdHJldHVybiB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XTtcblx0fSksXG5cdGhhczogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIChlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpICE9PSAtMSk7XG5cdH0pLFxuXHRrZXlzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5Jyk7IH0pLFxuXHRzZXQ6IGQoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpLCBlbWl0O1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fX21hcEtleXNEYXRhX18ucHVzaChrZXkpIC0gMTtcblx0XHRcdGVtaXQgPSB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XSA9IHZhbHVlO1xuXHRcdGlmIChlbWl0KSB0aGlzLmVtaXQoJ19hZGQnLCBpbmRleCwga2V5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSksXG5cdHNpemU6IGQuZ3MoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX21hcEtleXNEYXRhX18ubGVuZ3RoOyB9KSxcblx0dmFsdWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAndmFsdWUnKTsgfSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IE1hcF0nOyB9KVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFBvbHkucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIGQoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwUG9seS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgZCgnYycsICdNYXAnKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LW1hcC9wb2x5ZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkVHlwZXMgPSB7IG9iamVjdDogdHJ1ZSwgc3ltYm9sOiB0cnVlIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRzeW1ib2wgPSBTeW1ib2woJ3Rlc3Qgc3ltYm9sJyk7XG5cdHRyeSB7IFN0cmluZyhzeW1ib2wpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIFJldHVybiAndHJ1ZScgYWxzbyBmb3IgcG9seWZpbGxzXG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLml0ZXJhdG9yXSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZV0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWddKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1zeW1ib2wvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0aWYgKCF4KSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3N5bWJvbCcpIHJldHVybiB0cnVlO1xuXHRpZiAoIXguY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblx0aWYgKHguY29uc3RydWN0b3IubmFtZSAhPT0gJ1N5bWJvbCcpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICh4W3guY29uc3RydWN0b3IudG9TdHJpbmdUYWddID09PSAnU3ltYm9sJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1zeW1ib2wvaXMtc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gRVMyMDE1IFN5bWJvbCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQgKG9yIHBhcnRpYWxseSBzdXBwb3J0IGl0KVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIHZhbGlkYXRlU3ltYm9sID0gcmVxdWlyZSgnLi92YWxpZGF0ZS1zeW1ib2wnKVxuXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIG9ialByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGVcbiAgLCBOYXRpdmVTeW1ib2wsIFN5bWJvbFBvbHlmaWxsLCBIaWRkZW5TeW1ib2wsIGdsb2JhbFN5bWJvbHMgPSBjcmVhdGUobnVsbClcbiAgLCBpc05hdGl2ZVNhZmU7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdE5hdGl2ZVN5bWJvbCA9IFN5bWJvbDtcblx0dHJ5IHtcblx0XHRTdHJpbmcoTmF0aXZlU3ltYm9sKCkpO1xuXHRcdGlzTmF0aXZlU2FmZSA9IHRydWU7XG5cdH0gY2F0Y2ggKGlnbm9yZSkge31cbn1cblxudmFyIGdlbmVyYXRlTmFtZSA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBjcmVhdGVkID0gY3JlYXRlKG51bGwpO1xuXHRyZXR1cm4gZnVuY3Rpb24gKGRlc2MpIHtcblx0XHR2YXIgcG9zdGZpeCA9IDAsIG5hbWUsIGllMTFCdWdXb3JrYXJvdW5kO1xuXHRcdHdoaWxlIChjcmVhdGVkW2Rlc2MgKyAocG9zdGZpeCB8fCAnJyldKSArK3Bvc3RmaXg7XG5cdFx0ZGVzYyArPSAocG9zdGZpeCB8fCAnJyk7XG5cdFx0Y3JlYXRlZFtkZXNjXSA9IHRydWU7XG5cdFx0bmFtZSA9ICdAQCcgKyBkZXNjO1xuXHRcdGRlZmluZVByb3BlcnR5KG9ialByb3RvdHlwZSwgbmFtZSwgZC5ncyhudWxsLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdC8vIEZvciBJRTExIGlzc3VlIHNlZTpcblx0XHRcdC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrZGV0YWlsL3ZpZXcvMTkyODUwOC9cblx0XHRcdC8vICAgIGllMTEtYnJva2VuLWdldHRlcnMtb24tZG9tLW9iamVjdHNcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpa29vL2VzNi1zeW1ib2wvaXNzdWVzLzEyXG5cdFx0XHRpZiAoaWUxMUJ1Z1dvcmthcm91bmQpIHJldHVybjtcblx0XHRcdGllMTFCdWdXb3JrYXJvdW5kID0gdHJ1ZTtcblx0XHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIGQodmFsdWUpKTtcblx0XHRcdGllMTFCdWdXb3JrYXJvdW5kID0gZmFsc2U7XG5cdFx0fSkpO1xuXHRcdHJldHVybiBuYW1lO1xuXHR9O1xufSgpKTtcblxuLy8gSW50ZXJuYWwgY29uc3RydWN0b3IgKG5vdCBvbmUgZXhwb3NlZCkgZm9yIGNyZWF0aW5nIFN5bWJvbCBpbnN0YW5jZXMuXG4vLyBUaGlzIG9uZSBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGBzb21lU3ltYm9sIGluc3RhbmNlb2YgU3ltYm9sYCBhbHdheXMgcmV0dXJuIGZhbHNlXG5IaWRkZW5TeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcblx0aWYgKHRoaXMgaW5zdGFuY2VvZiBIaWRkZW5TeW1ib2wpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGVFcnJvcjogU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG5cdHJldHVybiBTeW1ib2xQb2x5ZmlsbChkZXNjcmlwdGlvbik7XG59O1xuXG4vLyBFeHBvc2VkIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyAocmV0dXJucyBpbnN0YW5jZXMgb2YgSGlkZGVuU3ltYm9sKVxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xQb2x5ZmlsbCA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignVHlwZUVycm9yOiBTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcblx0aWYgKGlzTmF0aXZlU2FmZSkgcmV0dXJuIE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG5cdHN5bWJvbCA9IGNyZWF0ZShIaWRkZW5TeW1ib2wucHJvdG90eXBlKTtcblx0ZGVzY3JpcHRpb24gPSAoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKGRlc2NyaXB0aW9uKSk7XG5cdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzKHN5bWJvbCwge1xuXHRcdF9fZGVzY3JpcHRpb25fXzogZCgnJywgZGVzY3JpcHRpb24pLFxuXHRcdF9fbmFtZV9fOiBkKCcnLCBnZW5lcmF0ZU5hbWUoZGVzY3JpcHRpb24pKVxuXHR9KTtcbn07XG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLCB7XG5cdGZvcjogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aWYgKGdsb2JhbFN5bWJvbHNba2V5XSkgcmV0dXJuIGdsb2JhbFN5bWJvbHNba2V5XTtcblx0XHRyZXR1cm4gKGdsb2JhbFN5bWJvbHNba2V5XSA9IFN5bWJvbFBvbHlmaWxsKFN0cmluZyhrZXkpKSk7XG5cdH0pLFxuXHRrZXlGb3I6IGQoZnVuY3Rpb24gKHMpIHtcblx0XHR2YXIga2V5O1xuXHRcdHZhbGlkYXRlU3ltYm9sKHMpO1xuXHRcdGZvciAoa2V5IGluIGdsb2JhbFN5bWJvbHMpIGlmIChnbG9iYWxTeW1ib2xzW2tleV0gPT09IHMpIHJldHVybiBrZXk7XG5cdH0pLFxuXG5cdC8vIElmIHRoZXJlJ3MgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIGdpdmVuIHN5bWJvbCwgbGV0J3MgZmFsbGJhY2sgdG8gaXRcblx0Ly8gdG8gZW5zdXJlIHByb3BlciBpbnRlcm9wZXJhYmlsaXR5IHdpdGggb3RoZXIgbmF0aXZlIGZ1bmN0aW9ucyBlLmcuIEFycmF5LmZyb21cblx0aGFzSW5zdGFuY2U6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLmhhc0luc3RhbmNlKSB8fCBTeW1ib2xQb2x5ZmlsbCgnaGFzSW5zdGFuY2UnKSksXG5cdGlzQ29uY2F0U3ByZWFkYWJsZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlKSB8fFxuXHRcdFN5bWJvbFBvbHlmaWxsKCdpc0NvbmNhdFNwcmVhZGFibGUnKSksXG5cdGl0ZXJhdG9yOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pdGVyYXRvcikgfHwgU3ltYm9sUG9seWZpbGwoJ2l0ZXJhdG9yJykpLFxuXHRtYXRjaDogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wubWF0Y2gpIHx8IFN5bWJvbFBvbHlmaWxsKCdtYXRjaCcpKSxcblx0cmVwbGFjZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wucmVwbGFjZSkgfHwgU3ltYm9sUG9seWZpbGwoJ3JlcGxhY2UnKSksXG5cdHNlYXJjaDogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc2VhcmNoKSB8fCBTeW1ib2xQb2x5ZmlsbCgnc2VhcmNoJykpLFxuXHRzcGVjaWVzOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zcGVjaWVzKSB8fCBTeW1ib2xQb2x5ZmlsbCgnc3BlY2llcycpKSxcblx0c3BsaXQ6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwbGl0KSB8fCBTeW1ib2xQb2x5ZmlsbCgnc3BsaXQnKSksXG5cdHRvUHJpbWl0aXZlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC50b1ByaW1pdGl2ZSkgfHwgU3ltYm9sUG9seWZpbGwoJ3RvUHJpbWl0aXZlJykpLFxuXHR0b1N0cmluZ1RhZzogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudG9TdHJpbmdUYWcpIHx8IFN5bWJvbFBvbHlmaWxsKCd0b1N0cmluZ1RhZycpKSxcblx0dW5zY29wYWJsZXM6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnVuc2NvcGFibGVzKSB8fCBTeW1ib2xQb2x5ZmlsbCgndW5zY29wYWJsZXMnKSlcbn0pO1xuXG4vLyBJbnRlcm5hbCB0d2Vha3MgZm9yIHJlYWwgc3ltYm9sIHByb2R1Y2VyXG5kZWZpbmVQcm9wZXJ0aWVzKEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoU3ltYm9sUG9seWZpbGwpLFxuXHR0b1N0cmluZzogZCgnJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX25hbWVfXzsgfSlcbn0pO1xuXG4vLyBQcm9wZXIgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBleHBvc2VkIG9uIFN5bWJvbC5wcm90b3R5cGVcbi8vIFRoZXkgd29uJ3QgYmUgYWNjZXNzaWJsZSBvbiBwcm9kdWNlZCBzeW1ib2wgaW5zdGFuY2VzIGFzIHRoZXkgZGVyaXZlIGZyb20gSGlkZGVuU3ltYm9sLnByb3RvdHlwZVxuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIHtcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1N5bWJvbCAoJyArIHZhbGlkYXRlU3ltYm9sKHRoaXMpLl9fZGVzY3JpcHRpb25fXyArICcpJzsgfSksXG5cdHZhbHVlT2Y6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVTeW1ib2wodGhpcyk7IH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmUsIGQoJycsIGZ1bmN0aW9uICgpIHtcblx0dmFyIHN5bWJvbCA9IHZhbGlkYXRlU3ltYm9sKHRoaXMpO1xuXHRpZiAodHlwZW9mIHN5bWJvbCA9PT0gJ3N5bWJvbCcpIHJldHVybiBzeW1ib2w7XG5cdHJldHVybiBzeW1ib2wudG9TdHJpbmcoKTtcbn0pKTtcbmRlZmluZVByb3BlcnR5KFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIGQoJ2MnLCAnU3ltYm9sJykpO1xuXG4vLyBQcm9wZXIgaW1wbGVtZW50YXRvbiBvZiB0b1ByaW1pdGl2ZSBhbmQgdG9TdHJpbmdUYWcgZm9yIHJldHVybmVkIHN5bWJvbCBpbnN0YW5jZXNcbmRlZmluZVByb3BlcnR5KEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLFxuXHRkKCdjJywgU3ltYm9sUG9seWZpbGwucHJvdG90eXBlW1N5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnXSkpO1xuXG4vLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0byBkZWZpbmUgYHRvUHJpbWl0aXZlYCBhcyBsYXN0IG9uZSwgYXMgc29tZSBpbXBsZW1lbnRhdGlvbnNcbi8vIGltcGxlbWVudCBgdG9QcmltaXRpdmVgIG5hdGl2ZWx5IHdpdGhvdXQgaW1wbGVtZW50aW5nIGB0b1N0cmluZ1RhZ2AgKG9yIG90aGVyIHNwZWNpZmllZCBzeW1ib2xzKVxuLy8gQW5kIHRoYXQgbWF5IGludm9rZSBlcnJvciBpbiBkZWZpbml0aW9uIGZsb3c6XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpa29vL2VzNi1zeW1ib2wvaXNzdWVzLzEzI2lzc3VlY29tbWVudC0xNjQxNDYxNDlcbmRlZmluZVByb3BlcnR5KEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlLFxuXHRkKCdjJywgU3ltYm9sUG9seWZpbGwucHJvdG90eXBlW1N5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlXSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1zeW1ib2wvcG9seWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXMtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNTeW1ib2wodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGEgc3ltYm9sXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcblxuICAsIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cblxuICAsIG9uLCBvbmNlLCBvZmYsIGVtaXQsIG1ldGhvZHMsIGRlc2NyaXB0b3JzLCBiYXNlO1xuXG5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkge1xuXHRcdGRhdGEgPSBkZXNjcmlwdG9yLnZhbHVlID0gY3JlYXRlKG51bGwpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2VlX18nLCBkZXNjcmlwdG9yKTtcblx0XHRkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRkYXRhID0gdGhpcy5fX2VlX187XG5cdH1cblx0aWYgKCFkYXRhW3R5cGVdKSBkYXRhW3R5cGVdID0gbGlzdGVuZXI7XG5cdGVsc2UgaWYgKHR5cGVvZiBkYXRhW3R5cGVdID09PSAnb2JqZWN0JykgZGF0YVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0ZWxzZSBkYXRhW3R5cGVdID0gW2RhdGFbdHlwZV0sIGxpc3RlbmVyXTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIG9uY2UsIHNlbGY7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXHRzZWxmID0gdGhpcztcblx0b24uY2FsbCh0aGlzLCB0eXBlLCBvbmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdG9mZi5jYWxsKHNlbGYsIHR5cGUsIG9uY2UpO1xuXHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdG9uY2UuX19lZU9uY2VMaXN0ZW5lcl9fID0gbGlzdGVuZXI7XG5cdHJldHVybiB0aGlzO1xufTtcblxub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhLCBsaXN0ZW5lcnMsIGNhbmRpZGF0ZSwgaTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuIHRoaXM7XG5cdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0aWYgKCFkYXRhW3R5cGVdKSByZXR1cm4gdGhpcztcblx0bGlzdGVuZXJzID0gZGF0YVt0eXBlXTtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKGkgPSAwOyAoY2FuZGlkYXRlID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoKGNhbmRpZGF0ZSA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdFx0KGNhbmRpZGF0ZS5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMikgZGF0YVt0eXBlXSA9IGxpc3RlbmVyc1tpID8gMCA6IDFdO1xuXHRcdFx0XHRlbHNlIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgobGlzdGVuZXJzID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0KGxpc3RlbmVycy5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0ZGVsZXRlIGRhdGFbdHlwZV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dmFyIGksIGwsIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIGFyZ3M7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuO1xuXHRsaXN0ZW5lcnMgPSB0aGlzLl9fZWVfX1t0eXBlXTtcblx0aWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuXHRcdGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdGZvciAoaSA9IDA7IChsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdH1cblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH1cbn07XG5cbm1ldGhvZHMgPSB7XG5cdG9uOiBvbixcblx0b25jZTogb25jZSxcblx0b2ZmOiBvZmYsXG5cdGVtaXQ6IGVtaXRcbn07XG5cbmRlc2NyaXB0b3JzID0ge1xuXHRvbjogZChvbiksXG5cdG9uY2U6IGQob25jZSksXG5cdG9mZjogZChvZmYpLFxuXHRlbWl0OiBkKGVtaXQpXG59O1xuXG5iYXNlID0gZGVmaW5lUHJvcGVydGllcyh7fSwgZGVzY3JpcHRvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAobykge1xuXHRyZXR1cm4gKG8gPT0gbnVsbCkgPyBjcmVhdGUoYmFzZSkgOiBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdChvKSwgZGVzY3JpcHRvcnMpO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IG1ldGhvZHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXZlbnQtZW1pdHRlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIGxvb3BBc3luYyA9IGV4cG9ydHMubG9vcEFzeW5jID0gZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBpc1N5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdm9pZCAwO1xuXG4gIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpc0RvbmUgPSB0cnVlO1xuXG4gICAgaWYgKGlzU3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gYXJncztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9O1xuXG4gIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSByZXR1cm47XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcblxuICAgIGlmIChpc1N5bmMpIHJldHVybjsgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cblxuICAgIGlzU3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsoY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgaXNTeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIF90b0NvbnN1bWFibGVBcnJheShkb25lQXJncykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VHVybiA+PSB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgbmV4dCgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ28gPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfQnJvd3NlclByb3RvY29sID0gcmVxdWlyZSgnLi9Ccm93c2VyUHJvdG9jb2wnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnZXRVc2VyQ29uZmlybWF0aW9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Jyb3dzZXJQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ28nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdvO1xuICB9XG59KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhhc2hQYXRoID0gZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG59O1xuXG52YXIgcHVzaEhhc2hQYXRoID0gZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn07XG5cbnZhciByZXBsYWNlSGFzaFBhdGggPSBmdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB2YXIgaSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBpID49IDAgPyBpIDogMCkgKyAnIycgKyBwYXRoKTtcbn07XG5cbnZhciBlbnN1cmVTbGFzaCA9IGZ1bmN0aW9uIGVuc3VyZVNsYXNoKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG5cbiAgaWYgKCgwLCBfUGF0aFV0aWxzLmlzQWJzb2x1dGVQYXRoKShwYXRoKSkgcmV0dXJuIHRydWU7XG5cbiAgcmVwbGFjZUhhc2hQYXRoKCcvJyArIHBhdGgpO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbihxdWVyeUtleSkge1xuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBrZXkgPSAoMCwgX1BhdGhVdGlscy5nZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgpKHBhdGgsIHF1ZXJ5S2V5KTtcblxuICB2YXIgc3RhdGUgPSB2b2lkIDA7XG4gIGlmIChrZXkpIHtcbiAgICBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgpKHBhdGgsIHF1ZXJ5S2V5KTtcbiAgICBzdGF0ZSA9ICgwLCBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZSkoa2V5KTtcbiAgfVxuXG4gIHZhciBpbml0ID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcbiAgaW5pdC5zdGF0ZSA9IHN0YXRlO1xuXG4gIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGluaXQsIHVuZGVmaW5lZCwga2V5KTtcbn07XG5cbnZhciBwcmV2TG9jYXRpb24gPSB2b2lkIDA7XG5cbnZhciBzdGFydExpc3RlbmVyID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZnVuY3Rpb24gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgcXVlcnlLZXkpIHtcbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGlmICghZW5zdXJlU2xhc2goKSkgcmV0dXJuOyAvLyBIYXNoIHBhdGggbXVzdCBhbHdheXMgYmVnaW4gd2l0aCBhIC9cblxuICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24ocXVlcnlLZXkpO1xuXG4gICAgaWYgKHByZXZMb2NhdGlvbiAmJiBjdXJyZW50TG9jYXRpb24ua2V5ICYmIHByZXZMb2NhdGlvbi5rZXkgPT09IGN1cnJlbnRMb2NhdGlvbi5rZXkpIHJldHVybjsgLy8gSWdub3JlIGV4dHJhbmVvdXMgaGFzaGNoYW5nZSBldmVudHNcblxuICAgIHByZXZMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgIGxpc3RlbmVyKGN1cnJlbnRMb2NhdGlvbik7XG4gIH07XG5cbiAgZW5zdXJlU2xhc2goKTtcbiAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gIH07XG59O1xuXG52YXIgdXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgcXVlcnlLZXksIHVwZGF0ZUhhc2gpIHtcbiAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgdmFyIHBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG5cbiAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXRoID0gKDAsIF9QYXRoVXRpbHMuYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCkocGF0aCwgcXVlcnlLZXksIGtleSk7XG4gICAgKDAsIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKShrZXksIHN0YXRlKTtcbiAgfVxuXG4gIHByZXZMb2NhdGlvbiA9IGxvY2F0aW9uO1xuXG4gIHVwZGF0ZUhhc2gocGF0aCk7XG59O1xuXG52YXIgcHVzaExvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24sIHF1ZXJ5S2V5KSB7XG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgcXVlcnlLZXksIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKGdldEhhc2hQYXRoKCkgIT09IHBhdGgpIHtcbiAgICAgIHB1c2hIYXNoUGF0aChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdZb3UgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aCB1c2luZyBoYXNoIGhpc3RvcnknKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uLCBxdWVyeUtleSkge1xuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHF1ZXJ5S2V5LCBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChnZXRIYXNoUGF0aCgpICE9PSBwYXRoKSByZXBsYWNlSGFzaFBhdGgocGF0aCk7XG4gIH0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvSGFzaFByb3RvY29sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dldFVzZXJDb25maXJtYXRpb24nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ287XG4gIH1cbn0pO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHdpbmRvdy5sb2NhdGlvbik7XG59O1xuXG52YXIgcHVzaExvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24pIHtcbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgdXBkYXRlIGxvY2F0aW9uXG59O1xuXG52YXIgcmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbiAgcmV0dXJuIGZhbHNlOyAvLyBEb24ndCB1cGRhdGUgbG9jYXRpb25cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL1JlZnJlc2hQcm90b2NvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xuXG52YXIgQnJvd3NlclByb3RvY29sID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0Jyb3dzZXJQcm90b2NvbCk7XG5cbnZhciBfUmVmcmVzaFByb3RvY29sID0gcmVxdWlyZSgnLi9SZWZyZXNoUHJvdG9jb2wnKTtcblxudmFyIFJlZnJlc2hQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9SZWZyZXNoUHJvdG9jb2wpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgSFRNTDUncyBoaXN0b3J5IEFQSVxuICogKHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50KSB0byBtYW5hZ2UgaGlzdG9yeS5cbiAqIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZCBvZiBtYW5hZ2luZyBoaXN0b3J5IGluIGJyb3dzZXJzIGJlY2F1c2VcbiAqIGl0IHByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICpcbiAqIE5vdGU6IEluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGZ1bGxcbiAqIHBhZ2UgcmVsb2FkcyB3aWxsIGJlIHVzZWQgdG8gcHJlc2VydmUgY2xlYW4gVVJMcy4gWW91IGNhbiBmb3JjZSB0aGlzXG4gKiBiZWhhdmlvciB1c2luZyB7IGZvcmNlUmVmcmVzaDogdHJ1ZSB9IGluIG9wdGlvbnMuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICB2YXIgdXNlUmVmcmVzaCA9IG9wdGlvbnMuZm9yY2VSZWZyZXNoIHx8ICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcbiAgdmFyIFByb3RvY29sID0gdXNlUmVmcmVzaCA/IFJlZnJlc2hQcm90b2NvbCA6IEJyb3dzZXJQcm90b2NvbDtcblxuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IFByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBQcm90b2NvbC5nZXRDdXJyZW50TG9jYXRpb247XG4gIHZhciBwdXNoTG9jYXRpb24gPSBQcm90b2NvbC5wdXNoTG9jYXRpb247XG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBQcm90b2NvbC5yZXBsYWNlTG9jYXRpb247XG4gIHZhciBnbyA9IFByb3RvY29sLmdvO1xuXG5cbiAgdmFyIGhpc3RvcnkgPSAoMCwgX2NyZWF0ZUhpc3RvcnkyLmRlZmF1bHQpKF9leHRlbmRzKHtcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBnZXRVc2VyQ29uZmlybWF0aW9uIH0sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBwdXNoTG9jYXRpb246IHB1c2hMb2NhdGlvbixcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcbiAgICBnbzogZ29cbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BMaXN0ZW5lciA9IHZvaWQgMDtcblxuICB2YXIgc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGJlZm9yZSkge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BMaXN0ZW5lciA9IEJyb3dzZXJQcm90b2NvbC5zdGFydExpc3RlbmVyKGhpc3RvcnkudHJhbnNpdGlvblRvKTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGJlZm9yZSA/IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKSA6IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgdHJ1ZSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0hhc2hQcm90b2NvbCA9IHJlcXVpcmUoJy4vSGFzaFByb3RvY29sJyk7XG5cbnZhciBIYXNoUHJvdG9jb2wgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfSGFzaFByb3RvY29sKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIERlZmF1bHRRdWVyeUtleSA9ICdfayc7XG5cbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICB2YXIgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuXG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkocXVlcnlLZXkgIT09IGZhbHNlLCAnVXNpbmcgeyBxdWVyeUtleTogZmFsc2UgfSBubyBsb25nZXIgd29ya3MuIEluc3RlYWQsIGp1c3QgZG9uXFwndCAnICsgJ3VzZSBsb2NhdGlvbiBzdGF0ZSBpZiB5b3UgZG9uXFwndCB3YW50IGEga2V5IGluIHlvdXIgVVJMIHF1ZXJ5IHN0cmluZycpIDogdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgcXVlcnlLZXkgIT09ICdzdHJpbmcnKSBxdWVyeUtleSA9IERlZmF1bHRRdWVyeUtleTtcblxuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IEhhc2hQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xuXG5cbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLmdldEN1cnJlbnRMb2NhdGlvbihxdWVyeUtleSk7XG4gIH07XG5cbiAgdmFyIHB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiBIYXNoUHJvdG9jb2wucHVzaExvY2F0aW9uKGxvY2F0aW9uLCBxdWVyeUtleSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiBIYXNoUHJvdG9jb2wucmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uLCBxdWVyeUtleSk7XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSAoMCwgX2NyZWF0ZUhpc3RvcnkyLmRlZmF1bHQpKF9leHRlbmRzKHtcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBnZXRVc2VyQ29uZmlybWF0aW9uIH0sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBwdXNoTG9jYXRpb246IHB1c2hMb2NhdGlvbixcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcbiAgICBnbzogSGFzaFByb3RvY29sLmdvXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wTGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgdmFyIHN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBiZWZvcmUpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wTGlzdGVuZXIgPSBIYXNoUHJvdG9jb2wuc3RhcnRMaXN0ZW5lcihoaXN0b3J5LnRyYW5zaXRpb25UbywgcXVlcnlLZXkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gYmVmb3JlID8gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpIDogaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BMaXN0ZW5lcigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCB0cnVlKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKSgpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpIDogdm9pZCAwO1xuXG4gICAgaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgIHJldHVybiAnIycgKyBoaXN0b3J5LmNyZWF0ZUhyZWYocGF0aCk7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgZ286IGdvLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWZcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIYXNoSGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVN0YXRlU3RvcmFnZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKSB7XG4gIHJldHVybiBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3RhdGU7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZW50cnkpIHtcbiAgICBtZW1vW2VudHJ5LmtleV0gPSBlbnRyeS5zdGF0ZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufTtcblxudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogb3B0aW9ucyB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IFtvcHRpb25zXSB9O1xuICB9XG5cbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2N1cnJlbnRdO1xuICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZW50cnkpO1xuXG4gICAgdmFyIGtleSA9IHZvaWQgMCxcbiAgICAgICAgc3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKGVudHJ5LmtleSkge1xuICAgICAga2V5ID0gZW50cnkua2V5O1xuICAgICAgc3RhdGUgPSByZWFkU3RhdGUoa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdCA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShfZXh0ZW5kcyh7fSwgaW5pdCwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIGluZGV4ID0gY3VycmVudCArIG47XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgaWYgKCFuKSByZXR1cm47XG5cbiAgICBpZiAoIWNhbkdvKG4pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0Nhbm5vdCBnbyglcykgdGhlcmUgaXMgbm90IGVub3VnaCBoaXN0b3J5JywgbikgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50ICs9IG47XG4gICAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuXG4gICAgLy8gQ2hhbmdlIGFjdGlvbiB0byBQT1BcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7IGFjdGlvbjogX0FjdGlvbnMuUE9QIH0pKTtcbiAgfTtcblxuICB2YXIgcHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgY3VycmVudCArPSAxO1xuXG4gICAgaWYgKGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgZW50cmllcy5zcGxpY2UoY3VycmVudCk7XG5cbiAgICBlbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuXG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICB9O1xuXG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICBlbnRyaWVzW2N1cnJlbnRdID0gbG9jYXRpb247XG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0gKDAsIF9jcmVhdGVIaXN0b3J5Mi5kZWZhdWx0KShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIHB1c2hMb2NhdGlvbjogcHVzaExvY2F0aW9uLFxuICAgIHJlcGxhY2VMb2NhdGlvbjogcmVwbGFjZUxvY2F0aW9uLFxuICAgIGdvOiBnb1xuICB9KSk7XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGVudHJpZXMgPSBfb3B0aW9ucy5lbnRyaWVzO1xuICB2YXIgY3VycmVudCA9IF9vcHRpb25zLmN1cnJlbnQ7XG5cblxuICBpZiAodHlwZW9mIGVudHJpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZW50cmllcyA9IFtlbnRyaWVzXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgIGVudHJpZXMgPSBbJy8nXTtcbiAgfVxuXG4gIGVudHJpZXMgPSBlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSk7XG4gIH0pO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICBjdXJyZW50ID0gZW50cmllcy5sZW5ndGggLSAxO1xuICB9IGVsc2Uge1xuICAgICEoY3VycmVudCA+PSAwICYmIGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnQ3VycmVudCBpbmRleCBtdXN0IGJlID49IDAgYW5kIDwgJXMsIHdhcyAlcycsIGVudHJpZXMubGVuZ3RoLCBjdXJyZW50KSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICB2YXIgc3RvcmFnZSA9IGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKTtcblxuICB2YXIgc2F2ZVN0YXRlID0gZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldID0gc3RhdGU7XG4gIH07XG5cbiAgdmFyIHJlYWRTdGF0ZSA9IGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldO1xuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlTWVtb3J5SGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLkFjdGlvbnMgPSBleHBvcnRzLnVzZVF1ZXJpZXMgPSBleHBvcnRzLnVzZUJlZm9yZVVubG9hZCA9IGV4cG9ydHMudXNlQmFzZW5hbWUgPSBleHBvcnRzLmNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBleHBvcnRzLmNyZWF0ZUhhc2hIaXN0b3J5ID0gZXhwb3J0cy5jcmVhdGVIaXN0b3J5ID0gdW5kZWZpbmVkO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdsb2NhdGlvbnNBcmVFcXVhbCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsO1xuICB9XG59KTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlQnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVCcm93c2VySGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gcmVxdWlyZSgnLi9jcmVhdGVIYXNoSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhhc2hIaXN0b3J5Mik7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSByZXF1aXJlKCcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkyKTtcblxudmFyIF91c2VCYXNlbmFtZTIgPSByZXF1aXJlKCcuL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUyKTtcblxudmFyIF91c2VCZWZvcmVVbmxvYWQyID0gcmVxdWlyZSgnLi91c2VCZWZvcmVVbmxvYWQnKTtcblxudmFyIF91c2VCZWZvcmVVbmxvYWQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmVmb3JlVW5sb2FkMik7XG5cbnZhciBfdXNlUXVlcmllczIgPSByZXF1aXJlKCcuL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMyKTtcblxudmFyIF9BY3Rpb25zMiA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX0FjdGlvbnMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWN0aW9uczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmNyZWF0ZUhpc3RvcnkgPSBfY3JlYXRlQnJvd3Nlckhpc3RvcnkyLmRlZmF1bHQ7XG5leHBvcnRzLmNyZWF0ZUhhc2hIaXN0b3J5ID0gX2NyZWF0ZUhhc2hIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZUJhc2VuYW1lID0gX3VzZUJhc2VuYW1lMy5kZWZhdWx0O1xuZXhwb3J0cy51c2VCZWZvcmVVbmxvYWQgPSBfdXNlQmVmb3JlVW5sb2FkMy5kZWZhdWx0O1xuZXhwb3J0cy51c2VRdWVyaWVzID0gX3VzZVF1ZXJpZXMzLmRlZmF1bHQ7XG5leHBvcnRzLkFjdGlvbnMgPSBfQWN0aW9uczMuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB1c2VCYXNlbmFtZSA9IGZ1bmN0aW9uIHVzZUJhc2VuYW1lKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuICAgIHZhciBiYXNlbmFtZSA9IG9wdGlvbnMuYmFzZW5hbWU7XG5cblxuICAgIHZhciBhZGRCYXNlbmFtZSA9IGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoIWxvY2F0aW9uKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIGlmIChiYXNlbmFtZSAmJiBsb2NhdGlvbi5iYXNlbmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2VuYW1lKSA9PT0gMCkge1xuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSBiYXNlbmFtZTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gJycpIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH07XG5cbiAgICB2YXIgcHJlcGVuZEJhc2VuYW1lID0gZnVuY3Rpb24gcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIHZhciBvYmplY3QgPSB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShsb2NhdGlvbikgOiBsb2NhdGlvbjtcbiAgICAgIHZhciBwbmFtZSA9IG9iamVjdC5wYXRobmFtZTtcbiAgICAgIHZhciBub3JtYWxpemVkQmFzZW5hbWUgPSBiYXNlbmFtZS5zbGljZSgtMSkgPT09ICcvJyA/IGJhc2VuYW1lIDogYmFzZW5hbWUgKyAnLyc7XG4gICAgICB2YXIgbm9ybWFsaXplZFBhdGhuYW1lID0gcG5hbWUuY2hhckF0KDApID09PSAnLycgPyBwbmFtZS5zbGljZSgxKSA6IHBuYW1lO1xuICAgICAgdmFyIHBhdGhuYW1lID0gbm9ybWFsaXplZEJhc2VuYW1lICsgbm9ybWFsaXplZFBhdGhuYW1lO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGFkZEJhc2VuYW1lKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3J1blRyYW5zaXRpb25Ib29rMi5kZWZhdWx0KShob29rLCBhZGRCYXNlbmFtZShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcihhZGRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5wdXNoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LnJlcGxhY2UocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkQmFzZW5hbWUoaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKV0uY29uY2F0KGFyZ3MpKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvblxuICAgIH0pO1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlQmFzZW5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIoZ2V0UHJvbXB0TWVzc2FnZSkge1xuICB2YXIgaGFuZGxlQmVmb3JlVW5sb2FkID0gZnVuY3Rpb24gaGFuZGxlQmVmb3JlVW5sb2FkKGV2ZW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBnZXRQcm9tcHRNZXNzYWdlKCk7XG5cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAoZXZlbnQgfHwgd2luZG93LmV2ZW50KS5yZXR1cm5WYWx1ZSA9IG1lc3NhZ2U7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCAnYmVmb3JldW5sb2FkJywgaGFuZGxlQmVmb3JlVW5sb2FkKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgJ2JlZm9yZXVubG9hZCcsIGhhbmRsZUJlZm9yZVVubG9hZCk7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBob3cgdG8gdXNlIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgaW4gd2ViXG4gKiBicm93c2VycyB0byBjYW5jZWwgbmF2aWdhdGlvbi5cbiAqL1xudmFyIHVzZUJlZm9yZVVubG9hZCA9IGZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjcmVhdGVIaXN0b3J5KSB7XG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ3VzZUJlZm9yZVVubG9hZCBvbmx5IHdvcmtzIGluIERPTSBlbnZpcm9ubWVudHMnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgIHZhciBzdG9wTGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgICB2YXIgZ2V0UHJvbXB0TWVzc2FnZSA9IGZ1bmN0aW9uIGdldFByb21wdE1lc3NhZ2UoKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBtZXNzYWdlID09IG51bGwgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBsaXN0ZW5lcnNbaV0uY2FsbCgpO1xuICAgICAgfXJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuQmVmb3JlVW5sb2FkID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlVW5sb2FkKGxpc3RlbmVyKSB7XG4gICAgICBpZiAobGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpID09PSAxKSBzdG9wTGlzdGVuZXIgPSBzdGFydExpc3RlbmVyKGdldFByb21wdE1lc3NhZ2UpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCAmJiBzdG9wTGlzdGVuZXIpIHtcbiAgICAgICAgICBzdG9wTGlzdGVuZXIoKTtcbiAgICAgICAgICBzdG9wTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZVVubG9hZDogbGlzdGVuQmVmb3JlVW5sb2FkXG4gICAgfSk7XG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VCZWZvcmVVbmxvYWQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL3VzZUJlZm9yZVVubG9hZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9xdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5LXN0cmluZycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRTdHJpbmdpZnlRdWVyeSA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdpZnlRdWVyeShxdWVyeSkge1xuICByZXR1cm4gKDAsIF9xdWVyeVN0cmluZy5zdHJpbmdpZnkpKHF1ZXJ5KS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG5cbnZhciBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5wYXJzZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNyZWF0ZUhpc3RvcnkgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjcmVhdGVcbiAqIGhpc3Rvcnkgb2JqZWN0cyB0aGF0IGtub3cgaG93IHRvIGhhbmRsZSBVUkwgcXVlcmllcy5cbiAqL1xudmFyIHVzZVF1ZXJpZXMgPSBmdW5jdGlvbiB1c2VRdWVyaWVzKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IG9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBvcHRpb25zLnBhcnNlUXVlcnlTdHJpbmc7XG5cblxuICAgIGlmICh0eXBlb2Ygc3RyaW5naWZ5UXVlcnkgIT09ICdmdW5jdGlvbicpIHN0cmluZ2lmeVF1ZXJ5ID0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJzZVF1ZXJ5U3RyaW5nICE9PSAnZnVuY3Rpb24nKSBwYXJzZVF1ZXJ5U3RyaW5nID0gZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmc7XG5cbiAgICB2YXIgZGVjb2RlUXVlcnkgPSBmdW5jdGlvbiBkZWNvZGVRdWVyeShsb2NhdGlvbikge1xuICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkgPT0gbnVsbCkgbG9jYXRpb24ucXVlcnkgPSBwYXJzZVF1ZXJ5U3RyaW5nKGxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfTtcblxuICAgIHZhciBlbmNvZGVRdWVyeSA9IGZ1bmN0aW9uIGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgdmFyIG9iamVjdCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKGxvY2F0aW9uKSA6IGxvY2F0aW9uO1xuICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gc3RyaW5naWZ5UXVlcnkocXVlcnkpO1xuICAgICAgdmFyIHNlYXJjaCA9IHF1ZXJ5U3RyaW5nID8gJz8nICsgcXVlcnlTdHJpbmcgOiAnJztcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvYmplY3QsIHtcbiAgICAgICAgc2VhcmNoOiBzZWFyY2hcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWNvZGVRdWVyeShoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKDAsIF9ydW5UcmFuc2l0aW9uSG9vazIuZGVmYXVsdCkoaG9vaywgZGVjb2RlUXVlcnkobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZGVjb2RlUXVlcnkobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucHVzaChlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5yZXBsYWNlKGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgoZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0xvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KV0uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5KSBuZXdMb2NhdGlvbi5xdWVyeSA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVRdWVyeSkobG9jYXRpb24ucXVlcnkpO1xuXG4gICAgICByZXR1cm4gZGVjb2RlUXVlcnkobmV3TG9jYXRpb24pO1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb25cbiAgICB9KTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVF1ZXJpZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjEuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FycmF5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBhZGRlZCBzdXBwb3J0IGZvciByZXN0cmljdGluZ1xuICogZmxhdHRlbmluZyBhbmQgc3BlY2lmeWluZyB0aGUgc3RhcnQgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYXJyYXlzLWxpa2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgKGlzU3RyaWN0IHx8IGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGlzRGVlcCwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9iYXNlZmxhdHRlbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gKiBvdmVyIGBvYmplY3RgIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvclxuICogZWFjaCBwcm9wZXJ0eS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9iYXNlZm9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4KTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBOYU5gIGlzIGZvdW5kIGluIGBhcnJheWAuXG4gKiBJZiBgZnJvbVJpZ2h0YCBpcyBwcm92aWRlZCBlbGVtZW50cyBvZiBgYXJyYXlgIGFyZSBpdGVyYXRlZCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgYE5hTmAsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDAgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9iYXNlaW5kZXhvZi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2VpbmRleG9mJyksXG4gICAgY2FjaGVJbmRleE9mID0gcmVxdWlyZSgnbG9kYXNoLl9jYWNoZWluZGV4b2YnKSxcbiAgICBjcmVhdGVDYWNoZSA9IHJlcXVpcmUoJ2xvZGFzaC5fY3JlYXRlY2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5kZXhPZiA9IGJhc2VJbmRleE9mLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgaXNMYXJnZSA9IGlzQ29tbW9uICYmIGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFLFxuICAgICAgc2VlbiA9IGlzTGFyZ2UgPyBjcmVhdGVDYWNoZSgpIDogbnVsbCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGlmIChzZWVuKSB7XG4gICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCAwKSA8IDApIHtcbiAgICAgIGlmIChpdGVyYXRlZSB8fCBpc0xhcmdlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuaXE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9iYXNldW5pcS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodGhpc0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbiAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kQ2FsbGJhY2s7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9iaW5kY2FsbGJhY2svaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjAuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG4gKiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuICAgICAgcmVzdWx0ID0gKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpID8gZGF0YS5zZXQuaGFzKHZhbHVlKSA6IGRhdGEuaGFzaFt2YWx1ZV07XG5cbiAgcmV0dXJuIHJlc3VsdCA/IDAgOiAtMTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUluZGV4T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9jYWNoZWluZGV4b2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjEuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fZ2V0bmF0aXZlJyk7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKGdsb2JhbCwgJ1NldCcpO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuZGF0YSA9IHsgJ2hhc2gnOiBuYXRpdmVDcmVhdGUobnVsbCksICdzZXQnOiBuZXcgU2V0IH07XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHRoaXMucHVzaCh2YWx1ZXNbbGVuZ3RoXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBwdXNoXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZGF0YS5zZXQuYWRkKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmhhc2hbdmFsdWVdID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgU2V0YCBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdCBpZiBgU2V0YCBpcyBzdXBwb3J0ZWQsIGVsc2UgYG51bGxgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSh2YWx1ZXMpIHtcbiAgcmV0dXJuIChuYXRpdmVDcmVhdGUgJiYgU2V0KSA/IG5ldyBTZXRDYWNoZSh2YWx1ZXMpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYFNldGAgY2FjaGUuXG5TZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IGNhY2hlUHVzaDtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDYWNoZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2NyZWF0ZWNhY2hlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4yLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIHJvb3QgPSByZXF1aXJlKCdsb2Rhc2guX3Jvb3QnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4xID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGRlXFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdWZlMjAtXFxcXHVmZTIzJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZjAnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9NYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSArICddJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWFwIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAnXFx4Y0MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAnXFx4ZUMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICdcXHhkZic6ICdzcydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICovXG5mdW5jdGlvbiBkZWJ1cnJMZXR0ZXIobGV0dGVyKSB7XG4gIHJldHVybiBkZWJ1cnJlZExldHRlcnNbbGV0dGVyXTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IFN5bWJvbCA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAqIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBTeW1ib2wgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmcgW2xhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIHRvIGJhc2ljIGxhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICogLy8gPT4gJ2RlamEgdnUnXG4gKi9cbmZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluMSwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidXJyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5kZWJ1cnIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjEuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZGVidXJyID0gcmVxdWlyZSgnbG9kYXNoLmRlYnVycicpLFxuICAgIHdvcmRzID0gcmVxdWlyZSgnbG9kYXNoLndvcmRzJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykpLCBjYWxsYmFjaywgJycpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAqIC8vID0+ICdmb28tYmFyJ1xuICpcbiAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAqIC8vID0+ICdmb28tYmFyJ1xuICpcbiAqIF8ua2ViYWJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKi9cbnZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtlYmFiQ2FzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gua2ViYWJjYXNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBnZXROYXRpdmUgPSByZXF1aXJlKCdsb2Rhc2guX2dldG5hdGl2ZScpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2tleXMnKTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSA/ICt2YWx1ZSA6IC0xO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgdmFyIHByb3BzID0ga2V5c0luKG9iamVjdCksXG4gICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGg7XG5cbiAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgaWYgKChhbGxvd0luZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpIHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG52YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QpIHx8XG4gICAgICAodHlwZW9mIG9iamVjdCAhPSAnZnVuY3Rpb24nICYmIGlzQXJyYXlMaWtlKG9iamVjdCkpKSB7XG4gICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBuYXRpdmVLZXlzKG9iamVjdCkgOiBbXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGlzUHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gua2V5cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuNi4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzIGFuIGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvcmVzdF9wYXJhbWV0ZXJzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBzYXkgPSBfLnJlc3RQYXJhbShmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAqIH0pO1xuICpcbiAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiByZXN0UGFyYW0oZnVuYywgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogKCtzdGFydCB8fCAwKSwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN0W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RhcnQpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCByZXN0KTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCByZXN0KTtcbiAgICB9XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgaW5kZXggPSAtMTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSByZXN0O1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzdFBhcmFtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5yZXN0cGFyYW0vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjEuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlZmxhdHRlbicpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNldW5pcScpLFxuICAgIHJlc3RQYXJhbSA9IHJlcXVpcmUoJ2xvZGFzaC5yZXN0cGFyYW0nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gKiBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaW9uKFsxLCAyXSwgWzQsIDJdLCBbMiwgMV0pO1xuICogLy8gPT4gWzEsIDIsIDRdXG4gKi9cbnZhciB1bmlvbiA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgZmFsc2UsIHRydWUpKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC51bmlvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMi4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciByb290ID0gcmVxdWlyZSgnbG9kYXNoLl9yb290Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1ZmUyMC1cXFxcdWZlMjMnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmMCcsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUXVvdGVSYW5nZSA9ICdcXFxcdTIwMThcXFxcdTIwMTlcXFxcdTIwMWNcXFxcdTIwMWQnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUXVvdGVSYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9NYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSArICddJyxcbiAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJzTG93ZXJNaXNjID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzVXBwZXJNaXNjID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxO1xuXG4vKiogVXNlZCB0byBtYXRjaCBub24tY29tcG91bmQgd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVCYXNpY1dvcmQgPSAvW2EtekEtWjAtOV0rL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVDb21wbGV4V29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyTWlzYyArICcrKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNMb3dlck1pc2MsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNMb3dlck1pc2MgKyAnKycsXG4gIHJzVXBwZXIgKyAnKycsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xudmFyIHJlSGFzQ29tcGxleFdvcmQgPSAvW2Etel1bQS1aXXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBTeW1ib2wgPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IG9uZS4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBmb3IgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gU3ltYm9sID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gKi9cbmZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcGF0dGVybiA9IHJlSGFzQ29tcGxleFdvcmQudGVzdChzdHJpbmcpID8gcmVDb21wbGV4V29yZCA6IHJlQmFzaWNXb3JkO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd29yZHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLndvcmRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG5mdW5jdGlvbiBlbmNvZGVyRm9yQXJyYXlGb3JtYXQob3B0cykge1xuXHRzd2l0Y2ggKG9wdHMuYXJyYXlGb3JtYXQpIHtcblx0XHRjYXNlICdpbmRleCc6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IFtcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcblx0XHRcdFx0XHQnWycsXG5cdFx0XHRcdFx0aW5kZXgsXG5cdFx0XHRcdFx0J10nXG5cdFx0XHRcdF0uam9pbignJykgOiBbXG5cdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG5cdFx0XHRcdFx0J1snLFxuXHRcdFx0XHRcdGVuY29kZShpbmRleCwgb3B0cyksXG5cdFx0XHRcdFx0J109Jyxcblx0XHRcdFx0XHRlbmNvZGUodmFsdWUsIG9wdHMpXG5cdFx0XHRcdF0uam9pbignJyk7XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnYnJhY2tldCc6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gZW5jb2RlKGtleSwgb3B0cykgOiBbXG5cdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG5cdFx0XHRcdFx0J1tdPScsXG5cdFx0XHRcdFx0ZW5jb2RlKHZhbHVlLCBvcHRzKVxuXHRcdFx0XHRdLmpvaW4oJycpO1xuXHRcdFx0fTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gZW5jb2RlKGtleSwgb3B0cykgOiBbXG5cdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG5cdFx0XHRcdFx0Jz0nLFxuXHRcdFx0XHRcdGVuY29kZSh2YWx1ZSwgb3B0cylcblx0XHRcdFx0XS5qb2luKCcnKTtcblx0XHRcdH07XG5cdH1cbn1cblxuZnVuY3Rpb24gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0cykge1xuXHR2YXIgcmVzdWx0O1xuXG5cdHN3aXRjaCAob3B0cy5hcnJheUZvcm1hdCkge1xuXHRcdGNhc2UgJ2luZGV4Jzpcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpIHtcblx0XHRcdFx0cmVzdWx0ID0gL1xcWyhcXGQqKV0kLy5leGVjKGtleSk7XG5cblx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1xcW1xcZCpdJC8sICcnKTtcblxuXHRcdFx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XVtyZXN1bHRbMV1dID0gdmFsdWU7XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnYnJhY2tldCc6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSB7XG5cdFx0XHRcdHJlc3VsdCA9IC8oXFxbXSkkLy5leGVjKGtleSk7XG5cblx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1xcW10kLywgJycpO1xuXG5cdFx0XHRcdGlmICghcmVzdWx0IHx8IGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW10uY29uY2F0KGFjY3VtdWxhdG9yW2tleV0sIHZhbHVlKTtcblx0XHRcdH07XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikge1xuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbXS5jb25jYXQoYWNjdW11bGF0b3Jba2V5XSwgdmFsdWUpO1xuXHRcdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIG9wdHMpIHtcblx0aWYgKG9wdHMuZW5jb2RlKSB7XG5cdFx0cmV0dXJuIG9wdHMuc3RyaWN0ID8gc3RyaWN0VXJpRW5jb2RlKHZhbHVlKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGtleXNTb3J0ZXIoaW5wdXQpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIGlucHV0LnNvcnQoKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGtleXNTb3J0ZXIoT2JqZWN0LmtleXMoaW5wdXQpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpO1xuXHRcdH0pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRyZXR1cm4gaW5wdXRba2V5XTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBpbnB1dDtcbn1cblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuXHRvcHRzID0gb2JqZWN0QXNzaWduKHthcnJheUZvcm1hdDogJ25vbmUnfSwgb3B0cyk7XG5cblx0dmFyIGZvcm1hdHRlciA9IHBhcnNlckZvckFycmF5Rm9ybWF0KG9wdHMpO1xuXG5cdC8vIENyZWF0ZSBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGVcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvaXNzdWVzLzQ3XG5cdHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0c3RyLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdC8vIEZpcmVmb3ggKHByZSA0MCkgZGVjb2RlcyBgJTNEYCB0byBgPWBcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWQ7XG5cblx0XHQvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdGZvcm1hdHRlcihkZWNvZGVVUklDb21wb25lbnQoa2V5KSwgdmFsLCByZXQpO1xuXHR9KTtcblxuXHRyZXR1cm4gT2JqZWN0LmtleXMocmV0KS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuXHRcdHZhciB2YWwgPSByZXRba2V5XTtcblx0XHRpZiAoQm9vbGVhbih2YWwpICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdC8vIFNvcnQgb2JqZWN0IGtleXMsIG5vdCB2YWx1ZXNcblx0XHRcdHJlc3VsdFtrZXldID0ga2V5c1NvcnRlcih2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0ZW5jb2RlOiB0cnVlLFxuXHRcdHN0cmljdDogdHJ1ZSxcblx0XHRhcnJheUZvcm1hdDogJ25vbmUnXG5cdH07XG5cblx0b3B0cyA9IG9iamVjdEFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG5cblx0dmFyIGZvcm1hdHRlciA9IGVuY29kZXJGb3JBcnJheUZvcm1hdChvcHRzKTtcblxuXHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdmFsID0gb2JqW2tleV07XG5cblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0cyk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0XHR2YWwuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQucHVzaChmb3JtYXR0ZXIoa2V5LCB2YWwyLCByZXN1bHQubGVuZ3RoKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdHMpICsgJz0nICsgZW5jb2RlKHZhbCwgb3B0cyk7XG5cdH0pLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4Lmxlbmd0aCA+IDA7XG5cdH0pLmpvaW4oJyYnKSA6ICcnO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9xdWVyeS1zdHJpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbGFzc05hbWVGcm9tVk5vZGU7XG5cbnZhciBfc2VsZWN0b3JQYXJzZXIyID0gcmVxdWlyZSgnLi9zZWxlY3RvclBhcnNlcicpO1xuXG52YXIgX3NlbGVjdG9yUGFyc2VyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdG9yUGFyc2VyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNsYXNzTmFtZUZyb21WTm9kZSh2Tm9kZSkge1xuICB2YXIgX3NlbGVjdG9yUGFyc2VyID0gKDAsIF9zZWxlY3RvclBhcnNlcjMuZGVmYXVsdCkodk5vZGUuc2VsKTtcblxuICB2YXIgY24gPSBfc2VsZWN0b3JQYXJzZXIuY2xhc3NOYW1lO1xuXG5cbiAgaWYgKCF2Tm9kZS5kYXRhKSB7XG4gICAgcmV0dXJuIGNuO1xuICB9XG5cbiAgdmFyIF92Tm9kZSRkYXRhID0gdk5vZGUuZGF0YTtcbiAgdmFyIGRhdGFDbGFzcyA9IF92Tm9kZSRkYXRhLmNsYXNzO1xuICB2YXIgcHJvcHMgPSBfdk5vZGUkZGF0YS5wcm9wcztcblxuXG4gIGlmIChkYXRhQ2xhc3MpIHtcbiAgICB2YXIgYyA9IE9iamVjdC5rZXlzKHZOb2RlLmRhdGEuY2xhc3MpLmZpbHRlcihmdW5jdGlvbiAoY2wpIHtcbiAgICAgIHJldHVybiB2Tm9kZS5kYXRhLmNsYXNzW2NsXTtcbiAgICB9KTtcbiAgICBjbiArPSAnICcgKyBjLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGlmIChwcm9wcyAmJiBwcm9wcy5jbGFzc05hbWUpIHtcbiAgICBjbiArPSAnICcgKyBwcm9wcy5jbGFzc05hbWU7XG4gIH1cblxuICByZXR1cm4gY24udHJpbSgpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS1zZWxlY3Rvci9saWIvY2xhc3NOYW1lRnJvbVZOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBBbGwgU1ZHIGNoaWxkcmVuIGVsZW1lbnRzLCBub3QgaW4gdGhpcyBsaXN0LCBzaG91bGQgc2VsZi1jbG9zZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ludHJvLmh0bWwjVGVybUNvbnRhaW5lckVsZW1lbnRcbiAgJ2EnOiB0cnVlLFxuICAnZGVmcyc6IHRydWUsXG4gICdnbHlwaCc6IHRydWUsXG4gICdnJzogdHJ1ZSxcbiAgJ21hcmtlcic6IHRydWUsXG4gICdtYXNrJzogdHJ1ZSxcbiAgJ21pc3NpbmctZ2x5cGgnOiB0cnVlLFxuICAncGF0dGVybic6IHRydWUsXG4gICdzdmcnOiB0cnVlLFxuICAnc3dpdGNoJzogdHJ1ZSxcbiAgJ3N5bWJvbCc6IHRydWUsXG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ludHJvLmh0bWwjVGVybURlc2NyaXB0aXZlRWxlbWVudFxuICAnZGVzYyc6IHRydWUsXG4gICdtZXRhZGF0YSc6IHRydWUsXG4gICd0aXRsZSc6IHRydWVcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL2NvbnRhaW5lci1lbGVtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIGluaXQgPSByZXF1aXJlKCcuL2luaXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KFtyZXF1aXJlKCcuL21vZHVsZXMvYXR0cmlidXRlcycpLCByZXF1aXJlKCcuL21vZHVsZXMvc3R5bGUnKV0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIHBhcnNlU2VsZWN0b3IgPSByZXF1aXJlKCcuL3BhcnNlLXNlbGVjdG9yJyk7XG52YXIgVk9JRF9FTEVNRU5UUyA9IHJlcXVpcmUoJy4vdm9pZC1lbGVtZW50cycpO1xudmFyIENPTlRBSU5FUl9FTEVNRU5UUyA9IHJlcXVpcmUoJy4vY29udGFpbmVyLWVsZW1lbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5pdChtb2R1bGVzKSB7XG4gIGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgIGFyci5wdXNoKGZuKGRhdGEpKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSwgW10pLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICE9PSAnJztcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiByZW5kZXJUb1N0cmluZyh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuc2VsICYmIHZub2RlLnRleHQpIHtcbiAgICAgIHJldHVybiB2bm9kZS50ZXh0O1xuICAgIH1cblxuICAgIHZub2RlLmRhdGEgPSB2bm9kZS5kYXRhIHx8IHt9O1xuXG4gICAgLy8gU3VwcG9ydCB0aHVua3NcbiAgICBpZiAodHlwZW9mIHZub2RlLnNlbCA9PT0gJ3N0cmluZycgJiYgdm5vZGUuc2VsLnNsaWNlKDAsIDUpID09PSAndGh1bmsnKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmRhdGEuZm4uYXBwbHkobnVsbCwgdm5vZGUuZGF0YS5hcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgdGFnTmFtZSA9IHBhcnNlU2VsZWN0b3Iodm5vZGUuc2VsKS50YWdOYW1lO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gcGFyc2Uodm5vZGUpO1xuICAgIHZhciBzdmcgPSB2bm9kZS5kYXRhLm5zID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIHZhciB0YWcgPSBbXTtcblxuICAgIC8vIE9wZW4gdGFnXG4gICAgdGFnLnB1c2goJzwnICsgdGFnTmFtZSk7XG4gICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICB0YWcucHVzaCgnICcgKyBhdHRyaWJ1dGVzLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIGlmIChzdmcgJiYgQ09OVEFJTkVSX0VMRU1FTlRTW3RhZ05hbWVdICE9PSB0cnVlKSB7XG4gICAgICB0YWcucHVzaCgnIC8nKTtcbiAgICB9XG4gICAgdGFnLnB1c2goJz4nKTtcblxuICAgIC8vIENsb3NlIHRhZywgaWYgbmVlZGVkXG4gICAgaWYgKFZPSURfRUxFTUVOVFNbdGFnTmFtZV0gIT09IHRydWUgJiYgIXN2ZyB8fCBzdmcgJiYgQ09OVEFJTkVSX0VMRU1FTlRTW3RhZ05hbWVdID09PSB0cnVlKSB7XG4gICAgICBpZiAodm5vZGUuZGF0YS5wcm9wcyAmJiB2bm9kZS5kYXRhLnByb3BzLmlubmVySFRNTCkge1xuICAgICAgICB0YWcucHVzaCh2bm9kZS5kYXRhLnByb3BzLmlubmVySFRNTCk7XG4gICAgICB9IGVsc2UgaWYgKHZub2RlLnRleHQpIHtcbiAgICAgICAgdGFnLnB1c2godm5vZGUudGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgdGFnLnB1c2gocmVuZGVyVG9TdHJpbmcoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0YWcucHVzaCgnPC8nICsgdGFnTmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZy5qb2luKCcnKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL2luaXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBmb3JPd24gPSByZXF1aXJlKCdsb2Rhc2guZm9yb3duJyk7XG52YXIgZXNjYXBlID0gcmVxdWlyZSgnbG9kYXNoLmVzY2FwZScpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgnbG9kYXNoLnVuaW9uJyk7XG5cbnZhciBwYXJzZVNlbGVjdG9yID0gcmVxdWlyZSgnLi4vcGFyc2Utc2VsZWN0b3InKTtcblxuLy8gZGF0YS5hdHRycywgZGF0YS5wcm9wcywgZGF0YS5jbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF0dHJpYnV0ZXModm5vZGUpIHtcbiAgdmFyIHNlbGVjdG9yID0gcGFyc2VTZWxlY3Rvcih2bm9kZS5zZWwpO1xuICB2YXIgcGFyc2VkQ2xhc3NlcyA9IHNlbGVjdG9yLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XG4gIHZhciBjbGFzc2VzID0gW107XG4gIHZhciB2YWx1ZXMgPSB7fTtcblxuICBpZiAoc2VsZWN0b3IuaWQpIHtcbiAgICB2YWx1ZXMuaWQgPSBzZWxlY3Rvci5pZDtcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZXModm5vZGUuZGF0YS5wcm9wcywgdmFsdWVzKTtcbiAgc2V0QXR0cmlidXRlcyh2bm9kZS5kYXRhLmF0dHJzLCB2YWx1ZXMpOyAvLyBgYXR0cnNgIG92ZXJyaWRlIGBwcm9wc2AsIG5vdCBzdXJlIGlmIHRoaXMgaXMgZ29vZCBzb1xuXG4gIGlmICh2bm9kZS5kYXRhLmNsYXNzKSB7XG4gICAgLy8gT21pdCBgY2xhc3NOYW1lYCBhdHRyaWJ1dGUgaWYgYGNsYXNzYCBpcyBzZXQgb24gdm5vZGVcbiAgICB2YWx1ZXMuY2xhc3MgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZm9yT3duKHZub2RlLmRhdGEuY2xhc3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICBjbGFzc2VzLnB1c2goa2V5KTtcbiAgICB9XG4gIH0pO1xuICBjbGFzc2VzID0gdW5pb24oY2xhc3NlcywgdmFsdWVzLmNsYXNzLCBwYXJzZWRDbGFzc2VzKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCAhPT0gJyc7XG4gIH0pO1xuXG4gIGlmIChjbGFzc2VzLmxlbmd0aCkge1xuICAgIHZhbHVlcy5jbGFzcyA9IGNsYXNzZXMuam9pbignICcpO1xuICB9XG5cbiAgZm9yT3duKHZhbHVlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBhdHRyaWJ1dGVzLnB1c2godmFsdWUgPT09IHRydWUgPyBrZXkgOiBrZXkgKyAnPVwiJyArIGVzY2FwZSh2YWx1ZSkgKyAnXCInKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXMubGVuZ3RoID8gYXR0cmlidXRlcy5qb2luKCcgJykgOiAnJztcbn07XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXModmFsdWVzLCB0YXJnZXQpIHtcbiAgZm9yT3duKHZhbHVlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnaHRtbEZvcicpIHtcbiAgICAgIHRhcmdldFsnZm9yJ10gPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ2NsYXNzTmFtZScpIHtcbiAgICAgIHRhcmdldFsnY2xhc3MnXSA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL2F0dHJpYnV0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgZm9yT3duID0gcmVxdWlyZSgnbG9kYXNoLmZvcm93bicpO1xudmFyIGVzY2FwZSA9IHJlcXVpcmUoJ2xvZGFzaC5lc2NhcGUnKTtcbnZhciBrZWJhYkNhc2UgPSByZXF1aXJlKCdsb2Rhc2gua2ViYWJjYXNlJyk7XG5cbi8vIGRhdGEuc3R5bGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHlsZSh2bm9kZSkge1xuICB2YXIgc3R5bGVzID0gW107XG4gIHZhciBzdHlsZSA9IHZub2RlLmRhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gbWVyZ2UgaW4gYGRlbGF5ZWRgIHByb3BlcnRpZXNcbiAgaWYgKHN0eWxlLmRlbGF5ZWQpIHtcbiAgICBfZXh0ZW5kcyhzdHlsZSwgc3R5bGUuZGVsYXllZCk7XG4gIH1cblxuICBmb3JPd24oc3R5bGUsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgLy8gb21pdCBob29rIG9iamVjdHNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgc3R5bGVzLnB1c2goa2ViYWJDYXNlKGtleSkgKyAnOiAnICsgZXNjYXBlKHZhbHVlKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3R5bGVzLmxlbmd0aCA/ICdzdHlsZT1cIicgKyBzdHlsZXMuam9pbignOyAnKSArICdcIicgOiAnJztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL21vZHVsZXMvc3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8vIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL3N5bnRheC5odG1sI3ZvaWQtZWxlbWVudHNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS10by1odG1sL2xpYi92b2lkLWVsZW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFZOb2RlID0gcmVxdWlyZSgnLi92bm9kZScpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xuXG5mdW5jdGlvbiBhZGROUyhkYXRhLCBjaGlsZHJlbikge1xuICBkYXRhLm5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICBhZGROUyhjaGlsZHJlbltpXS5kYXRhLCBjaGlsZHJlbltpXS5jaGlsZHJlbik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaChzZWwsIGIsIGMpIHtcbiAgdmFyIGRhdGEgPSB7fSwgY2hpbGRyZW4sIHRleHQsIGk7XG4gIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICBkYXRhID0gYjtcbiAgICBpZiAoaXMuYXJyYXkoYykpIHsgY2hpbGRyZW4gPSBjOyB9XG4gICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGMpKSB7IHRleHQgPSBjOyB9XG4gIH0gZWxzZSBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzLmFycmF5KGIpKSB7IGNoaWxkcmVuID0gYjsgfVxuICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShiKSkgeyB0ZXh0ID0gYjsgfVxuICAgIGVsc2UgeyBkYXRhID0gYjsgfVxuICB9XG4gIGlmIChpcy5hcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpcy5wcmltaXRpdmUoY2hpbGRyZW5baV0pKSBjaGlsZHJlbltpXSA9IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlbFswXSA9PT0gJ3MnICYmIHNlbFsxXSA9PT0gJ3YnICYmIHNlbFsyXSA9PT0gJ2cnKSB7XG4gICAgYWRkTlMoZGF0YSwgY2hpbGRyZW4pO1xuICB9XG4gIHJldHVybiBWTm9kZShzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCB1bmRlZmluZWQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9oLmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKXtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpe1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpe1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpe1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChub2RlLCBjaGlsZCl7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChub2RlLCBjaGlsZCl7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpe1xuICByZXR1cm4gbm9kZS5wYXJlbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyhub2RlKXtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUobm9kZSl7XG4gIHJldHVybiBub2RlLnRhZ05hbWU7XG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpe1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnRcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vaHRtbGRvbWFwaS5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBib29sZWFuQXR0cnMgPSBbXCJhbGxvd2Z1bGxzY3JlZW5cIiwgXCJhc3luY1wiLCBcImF1dG9mb2N1c1wiLCBcImF1dG9wbGF5XCIsIFwiY2hlY2tlZFwiLCBcImNvbXBhY3RcIiwgXCJjb250cm9sc1wiLCBcImRlY2xhcmVcIiwgXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIsIFwiZGVmYXVsdGNoZWNrZWRcIiwgXCJkZWZhdWx0bXV0ZWRcIiwgXCJkZWZhdWx0c2VsZWN0ZWRcIiwgXCJkZWZlclwiLCBcImRpc2FibGVkXCIsIFwiZHJhZ2dhYmxlXCIsIFxuICAgICAgICAgICAgICAgIFwiZW5hYmxlZFwiLCBcImZvcm1ub3ZhbGlkYXRlXCIsIFwiaGlkZGVuXCIsIFwiaW5kZXRlcm1pbmF0ZVwiLCBcImluZXJ0XCIsIFwiaXNtYXBcIiwgXCJpdGVtc2NvcGVcIiwgXCJsb29wXCIsIFwibXVsdGlwbGVcIiwgXG4gICAgICAgICAgICAgICAgXCJtdXRlZFwiLCBcIm5vaHJlZlwiLCBcIm5vcmVzaXplXCIsIFwibm9zaGFkZVwiLCBcIm5vdmFsaWRhdGVcIiwgXCJub3dyYXBcIiwgXCJvcGVuXCIsIFwicGF1c2VvbmV4aXRcIiwgXCJyZWFkb25seVwiLCBcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJzY29wZWRcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCIsIFwic29ydGFibGVcIiwgXCJzcGVsbGNoZWNrXCIsIFwidHJhbnNsYXRlXCIsIFxuICAgICAgICAgICAgICAgIFwidHJ1ZXNwZWVkXCIsIFwidHlwZW11c3RtYXRjaFwiLCBcInZpc2libGVcIl07XG4gICAgXG52YXIgYm9vbGVhbkF0dHJzRGljdCA9IHt9O1xuZm9yKHZhciBpPTAsIGxlbiA9IGJvb2xlYW5BdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBib29sZWFuQXR0cnNEaWN0W2Jvb2xlYW5BdHRyc1tpXV0gPSB0cnVlO1xufVxuICAgIFxuZnVuY3Rpb24gdXBkYXRlQXR0cnMob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBrZXksIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge30sIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgXG4gIC8vIHVwZGF0ZSBtb2RpZmllZCBhdHRyaWJ1dGVzLCBhZGQgbmV3IGF0dHJpYnV0ZXNcbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCB0byBuYW1lc3BhY2VkIGF0dHJpYnV0ZXMgKHNldEF0dHJpYnV0ZU5TKVxuICAgICAgaWYoIWN1ciAmJiBib29sZWFuQXR0cnNEaWN0W2tleV0pXG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGVsc2VcbiAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vcmVtb3ZlIHJlbW92ZWQgYXR0cmlidXRlc1xuICAvLyB1c2UgYGluYCBvcGVyYXRvciBzaW5jZSB0aGUgcHJldmlvdXMgYGZvcmAgaXRlcmF0aW9uIHVzZXMgaXQgKC5pLmUuIGFkZCBldmVuIGF0dHJpYnV0ZXMgd2l0aCB1bmRlZmluZWQgdmFsdWUpXG4gIC8vIHRoZSBvdGhlciBvcHRpb24gaXMgdG8gcmVtb3ZlIGFsbCBhdHRyaWJ1dGVzIHdpdGggdmFsdWUgPT0gdW5kZWZpbmVkXG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKCEoa2V5IGluIGF0dHJzKSkge1xuICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtjcmVhdGU6IHVwZGF0ZUF0dHJzLCB1cGRhdGU6IHVwZGF0ZUF0dHJzfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiB1cGRhdGVDbGFzcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGN1ciwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLFxuICAgICAgb2xkQ2xhc3MgPSBvbGRWbm9kZS5kYXRhLmNsYXNzIHx8IHt9LFxuICAgICAga2xhc3MgPSB2bm9kZS5kYXRhLmNsYXNzIHx8IHt9O1xuICBmb3IgKG5hbWUgaW4gb2xkQ2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzW25hbWVdKSB7XG4gICAgICBlbG0uY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIGtsYXNzKSB7XG4gICAgY3VyID0ga2xhc3NbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkQ2xhc3NbbmFtZV0pIHtcbiAgICAgIGVsbS5jbGFzc0xpc3RbY3VyID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlQ2xhc3MsIHVwZGF0ZTogdXBkYXRlQ2xhc3N9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL21vZHVsZXMvY2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG5mdW5jdGlvbiBhcnJJbnZva2VyKGFycikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSByZXR1cm47XG4gICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gbGVuZ3RoIGlzIHR3bywgZm9yIHBlcmZvcm1hbmNlXG4gICAgYXJyLmxlbmd0aCA9PT0gMiA/IGFyclswXShhcnJbMV0pIDogYXJyWzBdLmFwcGx5KHVuZGVmaW5lZCwgYXJyLnNsaWNlKDEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm5JbnZva2VyKG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2KSB7IFxuICAgIGlmIChvLmZuID09PSBudWxsKSByZXR1cm47XG4gICAgby5mbihldik7IFxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFdmVudExpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge30sIG9uID0gdm5vZGUuZGF0YS5vbjtcbiAgaWYgKCFvbikgcmV0dXJuO1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBpZiAob2xkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpcy5hcnJheShjdXIpKSB7XG4gICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGFyckludm9rZXIoY3VyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXIgPSB7Zm46IGN1cn07XG4gICAgICAgIG9uW25hbWVdID0gY3VyO1xuICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmbkludm9rZXIoY3VyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpcy5hcnJheShvbGQpKSB7XG4gICAgICAvLyBEZWxpYmVyYXRlbHkgbW9kaWZ5IG9sZCBhcnJheSBzaW5jZSBpdCdzIGNhcHR1cmVkIGluIGNsb3N1cmUgY3JlYXRlZCB3aXRoIGBhcnJJbnZva2VyYFxuICAgICAgb2xkLmxlbmd0aCA9IGN1ci5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkgb2xkW2ldID0gY3VyW2ldO1xuICAgICAgb25bbmFtZV0gID0gb2xkO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGQuZm4gPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgaWYgKG9sZE9uKSB7XG4gICAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgICBpZiAob25bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICAgIGlmIChpcy5hcnJheShvbGQpKSB7XG4gICAgICAgICAgb2xkLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb2xkLmZuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtjcmVhdGU6IHVwZGF0ZUV2ZW50TGlzdGVuZXJzLCB1cGRhdGU6IHVwZGF0ZUV2ZW50TGlzdGVuZXJzfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9tb2R1bGVzL2V2ZW50bGlzdGVuZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJhZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB8fCBzZXRUaW1lb3V0O1xudmFyIG5leHRGcmFtZSA9IGZ1bmN0aW9uKGZuKSB7IHJhZihmdW5jdGlvbigpIHsgcmFmKGZuKTsgfSk7IH07XG5cbmZ1bmN0aW9uIHNldE5leHRGcmFtZShvYmosIHByb3AsIHZhbCkge1xuICBuZXh0RnJhbWUoZnVuY3Rpb24oKSB7IG9ialtwcm9wXSA9IHZhbDsgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFRleHROb2RlUmVjdCh0ZXh0Tm9kZSkge1xuICB2YXIgcmVjdDtcbiAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGV4dE5vZGUpO1xuICAgIGlmIChyYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgcmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gY2FsY1RyYW5zZm9ybU9yaWdpbihpc1RleHROb2RlLCB0ZXh0UmVjdCwgYm91bmRpbmdSZWN0KSB7XG4gIGlmIChpc1RleHROb2RlKSB7XG4gICAgaWYgKHRleHRSZWN0KSB7XG4gICAgICAvL2NhbGN1bGF0ZSBwaXhlbHMgdG8gY2VudGVyIG9mIHRleHQgZnJvbSBsZWZ0IGVkZ2Ugb2YgYm91bmRpbmcgYm94XG4gICAgICB2YXIgcmVsYXRpdmVDZW50ZXJYID0gdGV4dFJlY3QubGVmdCArIHRleHRSZWN0LndpZHRoLzIgLSBib3VuZGluZ1JlY3QubGVmdDtcbiAgICAgIHZhciByZWxhdGl2ZUNlbnRlclkgPSB0ZXh0UmVjdC50b3AgKyB0ZXh0UmVjdC5oZWlnaHQvMiAtIGJvdW5kaW5nUmVjdC50b3A7XG4gICAgICByZXR1cm4gcmVsYXRpdmVDZW50ZXJYICsgJ3B4ICcgKyByZWxhdGl2ZUNlbnRlclkgKyAncHgnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzAgMCc7IC8vdG9wIGxlZnRcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dER4KG9sZFRleHRSZWN0LCBuZXdUZXh0UmVjdCkge1xuICBpZiAob2xkVGV4dFJlY3QgJiYgbmV3VGV4dFJlY3QpIHtcbiAgICByZXR1cm4gKChvbGRUZXh0UmVjdC5sZWZ0ICsgb2xkVGV4dFJlY3Qud2lkdGgvMikgLSAobmV3VGV4dFJlY3QubGVmdCArIG5ld1RleHRSZWN0LndpZHRoLzIpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGdldFRleHREeShvbGRUZXh0UmVjdCwgbmV3VGV4dFJlY3QpIHtcbiAgaWYgKG9sZFRleHRSZWN0ICYmIG5ld1RleHRSZWN0KSB7XG4gICAgcmV0dXJuICgob2xkVGV4dFJlY3QudG9wICsgb2xkVGV4dFJlY3QuaGVpZ2h0LzIpIC0gKG5ld1RleHRSZWN0LnRvcCArIG5ld1RleHRSZWN0LmhlaWdodC8yKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGlzVGV4dEVsZW1lbnQoZWxtKSB7XG4gIHJldHVybiBlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgZWxtLmNoaWxkTm9kZXNbMF0ubm9kZVR5cGUgPT09IDM7XG59XG5cbnZhciByZW1vdmVkLCBjcmVhdGVkO1xuXG5mdW5jdGlvbiBwcmUob2xkVm5vZGUsIHZub2RlKSB7XG4gIHJlbW92ZWQgPSB7fTtcbiAgY3JlYXRlZCA9IFtdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBoZXJvID0gdm5vZGUuZGF0YS5oZXJvO1xuICBpZiAoaGVybyAmJiBoZXJvLmlkKSB7XG4gICAgY3JlYXRlZC5wdXNoKGhlcm8uaWQpO1xuICAgIGNyZWF0ZWQucHVzaCh2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveSh2bm9kZSkge1xuICB2YXIgaGVybyA9IHZub2RlLmRhdGEuaGVybztcbiAgaWYgKGhlcm8gJiYgaGVyby5pZCkge1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdm5vZGUuaXNUZXh0Tm9kZSA9IGlzVGV4dEVsZW1lbnQoZWxtKTsgLy9pcyB0aGlzIGEgdGV4dCBub2RlP1xuICAgIHZub2RlLmJvdW5kaW5nUmVjdCA9IGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy9zYXZlIHRoZSBib3VuZGluZyByZWN0YW5nbGUgdG8gYSBuZXcgcHJvcGVydHkgb24gdGhlIHZub2RlXG4gICAgdm5vZGUudGV4dFJlY3QgPSB2bm9kZS5pc1RleHROb2RlID8gZ2V0VGV4dE5vZGVSZWN0KGVsbS5jaGlsZE5vZGVzWzBdKSA6IG51bGw7IC8vc2F2ZSBib3VuZGluZyByZWN0IG9mIGlubmVyIHRleHQgbm9kZVxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxtLCBudWxsKTsgLy9nZXQgY3VycmVudCBzdHlsZXMgKGluY2x1ZGVzIGluaGVyaXRlZCBwcm9wZXJ0aWVzKVxuICAgIHZub2RlLnNhdmVkU3R5bGUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbXB1dGVkU3R5bGUpKTsgLy9zYXZlIGEgY29weSBvZiBjb21wdXRlZCBzdHlsZSB2YWx1ZXNcbiAgICByZW1vdmVkW2hlcm8uaWRdID0gdm5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdCgpIHtcbiAgdmFyIGksIGlkLCBuZXdFbG0sIG9sZFZub2RlLCBvbGRFbG0sIGhSYXRpbywgd1JhdGlvLFxuICAgICAgb2xkUmVjdCwgbmV3UmVjdCwgZHgsIGR5LCBvcmlnVHJhbnNmb3JtLCBvcmlnVHJhbnNpdGlvbixcbiAgICAgIG5ld1N0eWxlLCBvbGRTdHlsZSwgbmV3Q29tcHV0ZWRTdHlsZSwgaXNUZXh0Tm9kZSxcbiAgICAgIG5ld1RleHRSZWN0LCBvbGRUZXh0UmVjdDtcbiAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZCA9IGNyZWF0ZWRbaV07XG4gICAgbmV3RWxtID0gY3JlYXRlZFtpKzFdLmVsbTtcbiAgICBvbGRWbm9kZSA9IHJlbW92ZWRbaWRdO1xuICAgIGlmIChvbGRWbm9kZSkge1xuICAgICAgaXNUZXh0Tm9kZSA9IG9sZFZub2RlLmlzVGV4dE5vZGUgJiYgaXNUZXh0RWxlbWVudChuZXdFbG0pOyAvL0FyZSBvbGQgJiBuZXcgYm90aCB0ZXh0P1xuICAgICAgbmV3U3R5bGUgPSBuZXdFbG0uc3R5bGU7XG4gICAgICBuZXdDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobmV3RWxtLCBudWxsKTsgLy9nZXQgZnVsbCBjb21wdXRlZCBzdHlsZSBmb3IgbmV3IGVsZW1lbnRcbiAgICAgIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIG9sZFN0eWxlID0gb2xkRWxtLnN0eWxlO1xuICAgICAgLy9PdmVyYWxsIGVsZW1lbnQgYm91bmRpbmcgYm94ZXNcbiAgICAgIG5ld1JlY3QgPSBuZXdFbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBvbGRSZWN0ID0gb2xkVm5vZGUuYm91bmRpbmdSZWN0OyAvL3ByZXZpb3VzbHkgc2F2ZWQgYm91bmRpbmcgcmVjdFxuICAgICAgLy9UZXh0IG5vZGUgYm91bmRpbmcgYm94ZXMgJiBkaXN0YW5jZXNcbiAgICAgIGlmIChpc1RleHROb2RlKSB7XG4gICAgICAgIG5ld1RleHRSZWN0ID0gZ2V0VGV4dE5vZGVSZWN0KG5ld0VsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgb2xkVGV4dFJlY3QgPSBvbGRWbm9kZS50ZXh0UmVjdDtcbiAgICAgICAgZHggPSBnZXRUZXh0RHgob2xkVGV4dFJlY3QsIG5ld1RleHRSZWN0KTtcbiAgICAgICAgZHkgPSBnZXRUZXh0RHkob2xkVGV4dFJlY3QsIG5ld1RleHRSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vQ2FsY3VsYXRlIGRpc3RhbmNlcyBiZXR3ZWVuIG9sZCAmIG5ldyBwb3NpdGlvbnNcbiAgICAgICAgZHggPSBvbGRSZWN0LmxlZnQgLSBuZXdSZWN0LmxlZnQ7XG4gICAgICAgIGR5ID0gb2xkUmVjdC50b3AgLSBuZXdSZWN0LnRvcDtcbiAgICAgIH1cbiAgICAgIGhSYXRpbyA9IG5ld1JlY3QuaGVpZ2h0IC8gKE1hdGgubWF4KG9sZFJlY3QuaGVpZ2h0LCAxKSk7XG4gICAgICB3UmF0aW8gPSBpc1RleHROb2RlID8gaFJhdGlvIDogbmV3UmVjdC53aWR0aCAvIChNYXRoLm1heChvbGRSZWN0LndpZHRoLCAxKSk7IC8vdGV4dCBzY2FsZXMgYmFzZWQgb24gaFJhdGlvXG4gICAgICAvLyBBbmltYXRlIG5ldyBlbGVtZW50XG4gICAgICBvcmlnVHJhbnNmb3JtID0gbmV3U3R5bGUudHJhbnNmb3JtO1xuICAgICAgb3JpZ1RyYW5zaXRpb24gPSBuZXdTdHlsZS50cmFuc2l0aW9uO1xuICAgICAgaWYgKG5ld0NvbXB1dGVkU3R5bGUuZGlzcGxheSA9PT0gJ2lubGluZScpIC8vaW5saW5lIGVsZW1lbnRzIGNhbm5vdCBiZSB0cmFuc2Zvcm1lZFxuICAgICAgICBuZXdTdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7ICAgICAgICAvL3RoaXMgZG9lcyBub3QgYXBwZWFyIHRvIGhhdmUgYW55IG5lZ2F0aXZlIHNpZGUgZWZmZWN0c1xuICAgICAgbmV3U3R5bGUudHJhbnNpdGlvbiA9IG9yaWdUcmFuc2l0aW9uICsgJ3RyYW5zZm9ybSAwcyc7XG4gICAgICBuZXdTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjVHJhbnNmb3JtT3JpZ2luKGlzVGV4dE5vZGUsIG5ld1RleHRSZWN0LCBuZXdSZWN0KTtcbiAgICAgIG5ld1N0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICBuZXdTdHlsZS50cmFuc2Zvcm0gPSBvcmlnVHJhbnNmb3JtICsgJ3RyYW5zbGF0ZSgnK2R4KydweCwgJytkeSsncHgpICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzY2FsZSgnKzEvd1JhdGlvKycsICcrMS9oUmF0aW8rJyknO1xuICAgICAgc2V0TmV4dEZyYW1lKG5ld1N0eWxlLCAndHJhbnNpdGlvbicsIG9yaWdUcmFuc2l0aW9uKTtcbiAgICAgIHNldE5leHRGcmFtZShuZXdTdHlsZSwgJ3RyYW5zZm9ybScsIG9yaWdUcmFuc2Zvcm0pO1xuICAgICAgc2V0TmV4dEZyYW1lKG5ld1N0eWxlLCAnb3BhY2l0eScsICcxJyk7XG4gICAgICAvLyBBbmltYXRlIG9sZCBlbGVtZW50XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2xkVm5vZGUuc2F2ZWRTdHlsZSkgeyAvL3JlLWFwcGx5IHNhdmVkIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChwYXJzZUludChrZXkpICE9IGtleSkge1xuICAgICAgICAgIHZhciBtcyA9IGtleS5zdWJzdHJpbmcoMCwyKSA9PT0gJ21zJztcbiAgICAgICAgICB2YXIgbW96ID0ga2V5LnN1YnN0cmluZygwLDMpID09PSAnbW96JztcbiAgICAgICAgICB2YXIgd2Via2l0ID0ga2V5LnN1YnN0cmluZygwLDYpID09PSAnd2Via2l0JztcbiAgICAgIFx0ICBpZiAoIW1zICYmICFtb3ogJiYgIXdlYmtpdCkgLy9pZ25vcmUgcHJlZml4ZWQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICBcdCAgb2xkU3R5bGVba2V5XSA9IG9sZFZub2RlLnNhdmVkU3R5bGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2xkU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgb2xkU3R5bGUudG9wID0gb2xkUmVjdC50b3AgKyAncHgnOyAvL3N0YXJ0IGF0IGV4aXN0aW5nIHBvc2l0aW9uXG4gICAgICBvbGRTdHlsZS5sZWZ0ID0gb2xkUmVjdC5sZWZ0ICsgJ3B4JztcbiAgICAgIG9sZFN0eWxlLndpZHRoID0gb2xkUmVjdC53aWR0aCArICdweCc7IC8vTmVlZGVkIGZvciBlbGVtZW50cyB3aG8gd2VyZSBzaXplZCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnRzXG4gICAgICBvbGRTdHlsZS5oZWlnaHQgPSBvbGRSZWN0LmhlaWdodCArICdweCc7IC8vTmVlZGVkIGZvciBlbGVtZW50cyB3aG8gd2VyZSBzaXplZCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnRzXG4gICAgICBvbGRTdHlsZS5tYXJnaW4gPSAwOyAvL01hcmdpbiBvbiBoZXJvIGVsZW1lbnQgbGVhZHMgdG8gaW5jb3JyZWN0IHBvc2l0aW9uaW5nXG4gICAgICBvbGRTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjVHJhbnNmb3JtT3JpZ2luKGlzVGV4dE5vZGUsIG9sZFRleHRSZWN0LCBvbGRSZWN0KTtcbiAgICAgIG9sZFN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgb2xkU3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob2xkRWxtKTtcbiAgICAgIHNldE5leHRGcmFtZShvbGRTdHlsZSwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJysgLWR4ICsncHgsICcrIC1keSArJ3B4KSBzY2FsZSgnK3dSYXRpbysnLCAnK2hSYXRpbysnKScpOyAvL3NjYWxlIG11c3QgYmUgb24gZmFyIHJpZ2h0IGZvciB0cmFuc2xhdGUgdG8gYmUgY29ycmVjdFxuICAgICAgc2V0TmV4dEZyYW1lKG9sZFN0eWxlLCAnb3BhY2l0eScsICcwJyk7XG4gICAgICBvbGRFbG0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChldi5wcm9wZXJ0eU5hbWUgPT09ICd0cmFuc2Zvcm0nKVxuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZXYudGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW1vdmVkID0gY3JlYXRlZCA9IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7cHJlOiBwcmUsIGNyZWF0ZTogY3JlYXRlLCBkZXN0cm95OiBkZXN0cm95LCBwb3N0OiBwb3N0fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9tb2R1bGVzL2hlcm8uanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiB1cGRhdGVQcm9wcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGtleSwgY3VyLCBvbGQsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5wcm9wcyB8fCB7fSwgcHJvcHMgPSB2bm9kZS5kYXRhLnByb3BzIHx8IHt9O1xuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmICghcHJvcHNba2V5XSkge1xuICAgICAgZGVsZXRlIGVsbVtrZXldO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgb2xkID0gb2xkUHJvcHNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIgJiYgKGtleSAhPT0gJ3ZhbHVlJyB8fCBlbG1ba2V5XSAhPT0gY3VyKSkge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlUHJvcHMsIHVwZGF0ZTogdXBkYXRlUHJvcHN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL21vZHVsZXMvcHJvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmFmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IHNldFRpbWVvdXQ7XG52YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24oZm4pIHsgcmFmKGZ1bmN0aW9uKCkgeyByYWYoZm4pOyB9KTsgfTtcblxuZnVuY3Rpb24gc2V0TmV4dEZyYW1lKG9iaiwgcHJvcCwgdmFsKSB7XG4gIG5leHRGcmFtZShmdW5jdGlvbigpIHsgb2JqW3Byb3BdID0gdmFsOyB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZFN0eWxlID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fSxcbiAgICAgIHN0eWxlID0gdm5vZGUuZGF0YS5zdHlsZSB8fCB7fSxcbiAgICAgIG9sZEhhc0RlbCA9ICdkZWxheWVkJyBpbiBvbGRTdHlsZTtcbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKCFzdHlsZVtuYW1lXSkge1xuICAgICAgZWxtLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgIGN1ciA9IHN0eWxlW25hbWVdO1xuICAgIGlmIChuYW1lID09PSAnZGVsYXllZCcpIHtcbiAgICAgIGZvciAobmFtZSBpbiBzdHlsZS5kZWxheWVkKSB7XG4gICAgICAgIGN1ciA9IHN0eWxlLmRlbGF5ZWRbbmFtZV07XG4gICAgICAgIGlmICghb2xkSGFzRGVsIHx8IGN1ciAhPT0gb2xkU3R5bGUuZGVsYXllZFtuYW1lXSkge1xuICAgICAgICAgIHNldE5leHRGcmFtZShlbG0uc3R5bGUsIG5hbWUsIGN1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgIT09ICdyZW1vdmUnICYmIGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIGVsbS5zdHlsZVtuYW1lXSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlEZXN0cm95U3R5bGUodm5vZGUpIHtcbiAgdmFyIHN0eWxlLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIHMgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICBpZiAoIXMgfHwgIShzdHlsZSA9IHMuZGVzdHJveSkpIHJldHVybjtcbiAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlSZW1vdmVTdHlsZSh2bm9kZSwgcm0pIHtcbiAgdmFyIHMgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICBpZiAoIXMgfHwgIXMucmVtb3ZlKSB7XG4gICAgcm0oKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgaWR4LCBpID0gMCwgbWF4RHVyID0gMCxcbiAgICAgIGNvbXBTdHlsZSwgc3R5bGUgPSBzLnJlbW92ZSwgYW1vdW50ID0gMCwgYXBwbGllZCA9IFtdO1xuICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICBhcHBsaWVkLnB1c2gobmFtZSk7XG4gICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gIH1cbiAgY29tcFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbG0pO1xuICB2YXIgcHJvcHMgPSBjb21wU3R5bGVbJ3RyYW5zaXRpb24tcHJvcGVydHknXS5zcGxpdCgnLCAnKTtcbiAgZm9yICg7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgIGlmKGFwcGxpZWQuaW5kZXhPZihwcm9wc1tpXSkgIT09IC0xKSBhbW91bnQrKztcbiAgfVxuICBlbG0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKGV2LnRhcmdldCA9PT0gZWxtKSAtLWFtb3VudDtcbiAgICBpZiAoYW1vdW50ID09PSAwKSBybSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVTdHlsZSwgdXBkYXRlOiB1cGRhdGVTdHlsZSwgZGVzdHJveTogYXBwbHlEZXN0cm95U3R5bGUsIHJlbW92ZTogYXBwbHlSZW1vdmVTdHlsZX07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vbW9kdWxlcy9zdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGpzaGludCBuZXdjYXA6IGZhbHNlXG4vKiBnbG9iYWwgcmVxdWlyZSwgbW9kdWxlLCBkb2N1bWVudCwgTm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVk5vZGUgPSByZXF1aXJlKCcuL3Zub2RlJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG52YXIgZG9tQXBpID0gcmVxdWlyZSgnLi9odG1sZG9tYXBpJyk7XG5cbmZ1bmN0aW9uIGlzVW5kZWYocykgeyByZXR1cm4gcyA9PT0gdW5kZWZpbmVkOyB9XG5mdW5jdGlvbiBpc0RlZihzKSB7IHJldHVybiBzICE9PSB1bmRlZmluZWQ7IH1cblxudmFyIGVtcHR5Tm9kZSA9IFZOb2RlKCcnLCB7fSwgW10sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gc2FtZVZub2RlKHZub2RlMSwgdm5vZGUyKSB7XG4gIHJldHVybiB2bm9kZTEua2V5ID09PSB2bm9kZTIua2V5ICYmIHZub2RlMS5zZWwgPT09IHZub2RlMi5zZWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4KGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBtYXAgPSB7fSwga2V5O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgbWFwW2tleV0gPSBpO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveScsICdwcmUnLCAncG9zdCddO1xuXG5mdW5jdGlvbiBpbml0KG1vZHVsZXMsIGFwaSkge1xuICB2YXIgaSwgaiwgY2JzID0ge307XG5cbiAgaWYgKGlzVW5kZWYoYXBpKSkgYXBpID0gZG9tQXBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKG1vZHVsZXNbal1baG9va3NbaV1dICE9PSB1bmRlZmluZWQpIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQoZWxtKSB7XG4gICAgcmV0dXJuIFZOb2RlKGFwaS50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS1saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGFwaS5wYXJlbnROb2RlKGNoaWxkRWxtKTtcbiAgICAgICAgYXBpLnJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIHZhciBpLCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlbG0sIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4sIHNlbCA9IHZub2RlLnNlbDtcbiAgICBpZiAoaXNEZWYoc2VsKSkge1xuICAgICAgLy8gUGFyc2Ugc2VsZWN0b3JcbiAgICAgIHZhciBoYXNoSWR4ID0gc2VsLmluZGV4T2YoJyMnKTtcbiAgICAgIHZhciBkb3RJZHggPSBzZWwuaW5kZXhPZignLicsIGhhc2hJZHgpO1xuICAgICAgdmFyIGhhc2ggPSBoYXNoSWR4ID4gMCA/IGhhc2hJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgdmFyIGRvdCA9IGRvdElkeCA+IDAgPyBkb3RJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgdmFyIHRhZyA9IGhhc2hJZHggIT09IC0xIHx8IGRvdElkeCAhPT0gLTEgPyBzZWwuc2xpY2UoMCwgTWF0aC5taW4oaGFzaCwgZG90KSkgOiBzZWw7XG4gICAgICBlbG0gPSB2bm9kZS5lbG0gPSBpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ucykgPyBhcGkuY3JlYXRlRWxlbWVudE5TKGksIHRhZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFwaS5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICBpZiAoaGFzaCA8IGRvdCkgZWxtLmlkID0gc2VsLnNsaWNlKGhhc2ggKyAxLCBkb3QpO1xuICAgICAgaWYgKGRvdElkeCA+IDApIGVsbS5jbGFzc05hbWUgPSBzZWwuc2xpY2UoZG90KzEpLnJlcGxhY2UoL1xcLi9nLCAnICcpO1xuICAgICAgaWYgKGlzLmFycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBhcGkuYXBwZW5kQ2hpbGQoZWxtLCBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzLnByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICBhcGkuYXBwZW5kQ2hpbGQoZWxtLCBhcGkuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgIGlmIChpLmNyZWF0ZSkgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgIGlmIChpLmluc2VydCkgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG0gPSB2bm9kZS5lbG0gPSBhcGkuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZS5lbG07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUpLCBiZWZvcmUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rKHZub2RlKSB7XG4gICAgdmFyIGksIGosIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSBpKHZub2RlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGksIGxpc3RlbmVycywgcm0sIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnNlbCkpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgICAgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgICAgIHJtID0gY3JlYXRlUm1DYihjaC5lbG0sIGxpc3RlbmVycyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIGNicy5yZW1vdmVbaV0oY2gsIHJtKTtcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGNoLmRhdGEpICYmIGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgICAgIGkoY2gsIHJtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIGFwaS5yZW1vdmVDaGlsZChwYXJlbnRFbG0sIGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMCwgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCBiZWZvcmU7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlkeEluT2xkID0gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSksIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIGJlZm9yZSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4KzFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHgrMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgYmVmb3JlLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIHZhciBpLCBob29rO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YSkgJiYgaXNEZWYoaG9vayA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG0sIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW4sIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkgcmV0dXJuO1xuICAgIGlmICghc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgIHZhciBwYXJlbnRFbG0gPSBhcGkucGFyZW50Tm9kZShvbGRWbm9kZS5lbG0pO1xuICAgICAgZWxtID0gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbSwgb2xkVm5vZGUuZWxtKTtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICBpID0gdm5vZGUuZGF0YS5ob29rO1xuICAgICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGhvb2spICYmIGlzRGVmKGkgPSBob29rLnBvc3RwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24ob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGksIGVsbSwgcGFyZW50O1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnByZS5sZW5ndGg7ICsraSkgY2JzLnByZVtpXSgpO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuc2VsKSkge1xuICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgcGFyZW50ID0gYXBpLnBhcmVudE5vZGUoZWxtKTtcblxuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50LCB2bm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhlbG0pKTtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudCwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGluc2VydGVkVm5vZGVRdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQoaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNicy5wb3N0Lmxlbmd0aDsgKytpKSBjYnMucG9zdFtpXSgpO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7aW5pdDogaW5pdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vc25hYmJkb20uanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaCA9IHJlcXVpcmUoJy4vaCcpO1xuXG5mdW5jdGlvbiBjb3B5VG9UaHVuayh2bm9kZSwgdGh1bmspIHtcbiAgdGh1bmsuZWxtID0gdm5vZGUuZWxtO1xuICB2bm9kZS5kYXRhLmZuID0gdGh1bmsuZGF0YS5mbjtcbiAgdm5vZGUuZGF0YS5hcmdzID0gdGh1bmsuZGF0YS5hcmdzO1xuICB0aHVuay5kYXRhID0gdm5vZGUuZGF0YTtcbiAgdGh1bmsuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgdGh1bmsudGV4dCA9IHZub2RlLnRleHQ7XG4gIHRodW5rLmVsbSA9IHZub2RlLmVsbTtcbn1cblxuZnVuY3Rpb24gaW5pdCh0aHVuaykge1xuICB2YXIgaSwgY3VyID0gdGh1bmsuZGF0YTtcbiAgdmFyIHZub2RlID0gY3VyLmZuLmFwcGx5KHVuZGVmaW5lZCwgY3VyLmFyZ3MpO1xuICBjb3B5VG9UaHVuayh2bm9kZSwgdGh1bmspO1xufVxuXG5mdW5jdGlvbiBwcmVwYXRjaChvbGRWbm9kZSwgdGh1bmspIHtcbiAgdmFyIGksIG9sZCA9IG9sZFZub2RlLmRhdGEsIGN1ciA9IHRodW5rLmRhdGEsIHZub2RlO1xuICB2YXIgb2xkQXJncyA9IG9sZC5hcmdzLCBhcmdzID0gY3VyLmFyZ3M7XG4gIGlmIChvbGQuZm4gIT09IGN1ci5mbiB8fCBvbGRBcmdzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICBjb3B5VG9UaHVuayhjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKSwgdGh1bmspO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG9sZEFyZ3NbaV0gIT09IGFyZ3NbaV0pIHtcbiAgICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVuayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvcHlUb1RodW5rKG9sZFZub2RlLCB0aHVuayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsLCBrZXksIGZuLCBhcmdzKSB7XG4gIGlmIChhcmdzID09PSB1bmRlZmluZWQpIHtcbiAgICBhcmdzID0gZm47XG4gICAgZm4gPSBrZXk7XG4gICAga2V5ID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBoKHNlbCwge1xuICAgIGtleToga2V5LFxuICAgIGhvb2s6IHtpbml0OiBpbml0LCBwcmVwYXRjaDogcHJlcGF0Y2h9LFxuICAgIGZuOiBmbixcbiAgICBhcmdzOiBhcmdzXG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS90aHVuay5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqXS9nLCBmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGlzUGF0dGVybiwgaXNSb3V0ZURlZmluaXRpb24sIHRyYXZlcnNlUm91dGVzLCBpc05vdE51bGwsIHNwbGl0UGF0aCwgaXNQYXJhbSwgZXh0cmFjdFBhcnRpYWwsIHVucHJlZml4ZWQsIH0gZnJvbSAnLi91dGlsJztcbmZ1bmN0aW9uIHN3aXRjaFBhdGhJbnB1dEd1YXJkKHBhdGgsIHJvdXRlcykge1xuICAgIGlmICghaXNQYXR0ZXJuKHBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IHBhcmFtZXRlciB0byBzd2l0Y2hQYXRoIG11c3QgYmUgYSByb3V0ZSBwYXRoLlwiKTtcbiAgICB9XG4gICAgaWYgKCFpc1JvdXRlRGVmaW5pdGlvbihyb3V0ZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBwYXJhbWV0ZXIgdG8gc3dpdGNoUGF0aCBtdXN0IGJlIGFuIG9iamVjdCBcIiArXG4gICAgICAgICAgICBcImNvbnRhaW5pbmcgcm91dGUgcGF0dGVybnMuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUGF0aChzb3VyY2VQYXRoLCBtYXRjaGVkUGF0aCkge1xuICAgIHZhciBzb3VyY2VQYXJ0cyA9IHNwbGl0UGF0aChzb3VyY2VQYXRoKTtcbiAgICB2YXIgbWF0Y2hlZFBhcnRzID0gc3BsaXRQYXRoKG1hdGNoZWRQYXRoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZWRQYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobWF0Y2hlZFBhcnRzW2ldICE9PSBzb3VyY2VQYXJ0c1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiL1wiICsgZXh0cmFjdFBhcnRpYWwoc291cmNlUGF0aCwgbWF0Y2hlZFBhdGgpO1xufVxuZnVuY3Rpb24gYmV0dGVyTWF0Y2goY2FuZGlkYXRlLCByZWZlcmVuY2UpIHtcbiAgICBpZiAoIWlzTm90TnVsbChjYW5kaWRhdGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc05vdE51bGwocmVmZXJlbmNlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVBhdGgoY2FuZGlkYXRlLCByZWZlcmVuY2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmRpZGF0ZS5sZW5ndGggPj0gcmVmZXJlbmNlLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNXaXRoUGFyYW1zKHNvdXJjZVBhdGgsIHBhdHRlcm4pIHtcbiAgICB2YXIgc291cmNlUGFydHMgPSBzcGxpdFBhdGgoc291cmNlUGF0aCk7XG4gICAgdmFyIHBhdHRlcm5QYXJ0cyA9IHNwbGl0UGF0aChwYXR0ZXJuKTtcbiAgICB2YXIgcGFyYW1zID0gcGF0dGVyblBhcnRzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQsIGkpIHsgcmV0dXJuIGlzUGFyYW0ocGFydCkgPyBzb3VyY2VQYXJ0c1tpXSA6IG51bGw7IH0pXG4gICAgICAgIC5maWx0ZXIoaXNOb3ROdWxsKTtcbiAgICB2YXIgbWF0Y2hlZCA9IHBhdHRlcm5QYXJ0c1xuICAgICAgICAuZXZlcnkoZnVuY3Rpb24gKHBhcnQsIGkpIHsgcmV0dXJuIGlzUGFyYW0ocGFydCkgfHwgcGFydCA9PT0gc291cmNlUGFydHNbaV07IH0pO1xuICAgIHJldHVybiBtYXRjaGVkID8gcGFyYW1zIDogW107XG59XG5mdW5jdGlvbiBnZXRQYXJhbUZuVmFsdWUocGFyYW1GbiwgcGFyYW1zKSB7XG4gICAgdmFyIF9wYXJhbUZuID0gaXNSb3V0ZURlZmluaXRpb24ocGFyYW1GbikgPyBwYXJhbUZuW1wiL1wiXSA6IHBhcmFtRm47XG4gICAgcmV0dXJuIHR5cGVvZiBfcGFyYW1GbiA9PT0gXCJmdW5jdGlvblwiID8gX3BhcmFtRm4uYXBwbHkodm9pZCAwLCBwYXJhbXMpIDogX3BhcmFtRm47XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShfYSkge1xuICAgIHZhciBzb3VyY2VQYXRoID0gX2Euc291cmNlUGF0aCwgbWF0Y2hlZFBhdGggPSBfYS5tYXRjaGVkUGF0aCwgbWF0Y2hlZFZhbHVlID0gX2EubWF0Y2hlZFZhbHVlLCByb3V0ZXMgPSBfYS5yb3V0ZXM7XG4gICAgdmFyIHBhdGggPSBtYXRjaGVkUGF0aCA/IHZhbGlkYXRlUGF0aChzb3VyY2VQYXRoLCBtYXRjaGVkUGF0aCkgOiBudWxsO1xuICAgIHZhciB2YWx1ZSA9IG1hdGNoZWRWYWx1ZTtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHJvdXRlc1tcIipcIl0gPyBzb3VyY2VQYXRoIDogbnVsbDtcbiAgICAgICAgdmFsdWUgPSBwYXRoID8gcm91dGVzW1wiKlwiXSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3dpdGNoUGF0aChzb3VyY2VQYXRoLCByb3V0ZXMpIHtcbiAgICBzd2l0Y2hQYXRoSW5wdXRHdWFyZChzb3VyY2VQYXRoLCByb3V0ZXMpO1xuICAgIHZhciBtYXRjaGVkUGF0aCA9IG51bGw7XG4gICAgdmFyIG1hdGNoZWRWYWx1ZSA9IG51bGw7XG4gICAgdHJhdmVyc2VSb3V0ZXMocm91dGVzLCBmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybikge1xuICAgICAgICBpZiAoc291cmNlUGF0aC5zZWFyY2gocGF0dGVybikgPT09IDAgJiYgYmV0dGVyTWF0Y2gocGF0dGVybiwgbWF0Y2hlZFBhdGgpKSB7XG4gICAgICAgICAgICBtYXRjaGVkUGF0aCA9IHBhdHRlcm47XG4gICAgICAgICAgICBtYXRjaGVkVmFsdWUgPSByb3V0ZXNbcGF0dGVybl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmFtcyA9IG1hdGNoZXNXaXRoUGFyYW1zKHNvdXJjZVBhdGgsIHBhdHRlcm4pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwICYmIGJldHRlck1hdGNoKHNvdXJjZVBhdGgsIG1hdGNoZWRQYXRoKSkge1xuICAgICAgICAgICAgbWF0Y2hlZFBhdGggPSBleHRyYWN0UGFydGlhbChzb3VyY2VQYXRoLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIG1hdGNoZWRWYWx1ZSA9IGdldFBhcmFtRm5WYWx1ZShyb3V0ZXNbcGF0dGVybl0sIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUm91dGVEZWZpbml0aW9uKHJvdXRlc1twYXR0ZXJuXSkgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVBhdGggIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc3dpdGNoUGF0aCh1bnByZWZpeGVkKHNvdXJjZVBhdGgsIHBhdHRlcm4pIHx8IFwiL1wiLCByb3V0ZXNbcGF0dGVybl0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRQYXRoID0gcGF0dGVybiArIGNoaWxkLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGggIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgYmV0dGVyTWF0Y2gobmVzdGVkUGF0aCwgbWF0Y2hlZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRQYXRoID0gbmVzdGVkUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZhbHVlID0gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHsgc291cmNlUGF0aDogc291cmNlUGF0aCwgbWF0Y2hlZFBhdGg6IG1hdGNoZWRQYXRoLCBtYXRjaGVkVmFsdWU6IG1hdGNoZWRWYWx1ZSwgcm91dGVzOiByb3V0ZXMgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3dpdGNoLXBhdGgvbGliL2VzMjAxNS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBmdW5jdGlvbiBpc1BhdHRlcm4oY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZS5jaGFyQXQoMCkgPT09IFwiL1wiIHx8IGNhbmRpZGF0ZSA9PT0gXCIqXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSb3V0ZURlZmluaXRpb24oY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuICFjYW5kaWRhdGUgfHwgdHlwZW9mIGNhbmRpZGF0ZSAhPT0gXCJvYmplY3RcIiA/XG4gICAgICAgIGZhbHNlIDogaXNQYXR0ZXJuKE9iamVjdC5rZXlzKGNhbmRpZGF0ZSlbMF0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlUm91dGVzKHJvdXRlcywgY2FsbGJhY2spIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09IFwiKlwiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhbGxiYWNrKHBhdHRlcm4pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc05vdE51bGwoY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICEhczsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQYXJhbShjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlLm1hdGNoKC86XFx3Ky8pICE9PSBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJ0aWFsKHNvdXJjZVBhdGgsIHBhdHRlcm4pIHtcbiAgICB2YXIgcGF0dGVyblBhcnRzID0gc3BsaXRQYXRoKHBhdHRlcm4pO1xuICAgIHZhciBzb3VyY2VQYXJ0cyA9IHNwbGl0UGF0aChzb3VyY2VQYXRoKTtcbiAgICB2YXIgbWF0Y2hlZFBhcnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuUGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbWF0Y2hlZFBhcnRzLnB1c2goc291cmNlUGFydHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlZFBhcnRzLmZpbHRlcihpc05vdE51bGwpLmpvaW4oXCIvXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVucHJlZml4ZWQoZnVsbFN0cmluZywgcHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bGxTdHJpbmcuc3BsaXQocHJlZml4KVsxXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N3aXRjaC1wYXRoL2xpYi9lczIwMTUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaW5kZXgnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3Q7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsO1xuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIF9TeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIF9TeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoX1N5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdF9TeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgVUkgZnJvbSBcIi4uL3VpXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbmltcG9ydCB7ZGl2LCBWTm9kZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBJbmRleCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlcykge1xuICAgIGNvbnN0IHZUcmVlJCA9IHhzLm9mKFxuICAgICAgZGl2KFwiLmNlbnRlcmVkXCIsIFtcbiAgICAgICAgVUkuQ29udGFpbmVyLnJlbmRlcihbXG4gICAgICAgICAgVUkuR3JpZC5yZW5kZXIoe2NlbnRlcmVkOiB0cnVlfSwgW1xuICAgICAgICAgICAgVUkuUm93LnJlbmRlcihbXG4gICAgICAgICAgICAgIFVJLkhlYWRlci5yZW5kZXIoe3NpemU6IFVJLlNpemUuSHVnZX0sIFwiV2VsY29tZS5cIiwge1xuICAgICAgICAgICAgICAgIHN1YnRleHQ6IFwiQXQgdGhlIG1vbWVudCB0aGUgZG9jcyBhcmUgYSBXSVAuIFBsYW5uZWQgcGFnZXMgYXJlIHNjYWZmb2xkZWQgaW4gdGhlIHNpZGVtZW51LlwiXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBET006IHZUcmVlJCxcbiAgICAgIHJvdXRlcjogeHMubmV2ZXIoKVxuICAgIH07XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL2luZGV4L2luZGV4LnRzIiwiLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuaW1wb3J0IHhzLCB7IFN0cmVhbSB9IGZyb20gXCJ4c3RyZWFtXCI7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG5pbXBvcnQgeyBkaXYsIFZOb2RlIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7IFNpZGViYXIgfSBmcm9tIFwiLi9zaWRlYmFyXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTGF5b3V0IHtcbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBhbnksIHBhZ2U6IGFueSkge1xuXG4gICAgLyoqKiBDcmVhdGUgY29tcG9uZW50cyAqKiovXG4gICAgbGV0IHNpZGViYXIgPSBTaWRlYmFyLnJ1bihzb3VyY2VzKTtcbiAgICAvKioqIENvbXBvc2UgdmlldyAqKiovXG4gICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzaWRlYmFyLkRPTSwgcGFnZS5ET00sKVxuICAgICAgLm1hcCgoW3NpZGViYXIsIHBhZ2VdKSA9PlxuICAgICAgICBkaXYoXCIuZnVsbC5oZWlnaHRcIiwgW1xuICAgICAgICAgIGRpdihcIi5jb250ZW50LnB1c2hlclwiLCBbXG4gICAgICAgICAgICBzaWRlYmFyLFxuICAgICAgICAgICAgcGFnZVxuICAgICAgICAgIF0pLFxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICByb3V0ZXI6IHBhZ2Uucm91dGVyXG4gICAgfTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvbGF5b3V0L2luZGV4LnRzIiwiaW1wb3J0ICogYXMgVUkgZnJvbSBcIi4uLy4uL3VpXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbmltcG9ydCB7IGRpdiwgVk5vZGUgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFNpZGViYXIge1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXMpIHtcbiAgICBsZXQgY3VycmVudFBhZ2UkID0gc291cmNlcy5yb3V0ZXIuaGlzdG9yeSQubWFwKHggPT4geC5wYXRobmFtZSkgYXMgU3RyZWFtPHN0cmluZz47XG4gICAgY29uc3QgdlRyZWUkID0gY3VycmVudFBhZ2UkLm1hcChwYWdlID0+XG4gICAgICBkaXYoXCIubGVmdC5tZW51XCIsIFtcbiAgICAgICAgZGl2KFwiLmZpeGVkXCIsIFtcbiAgICAgICAgICBVSS5NZW51LnJlbmRlcih7XG4gICAgICAgICAgICB2ZXJ0aWNhbDogdHJ1ZSwgaW52ZXJ0ZWQ6IHRydWUsXG4gICAgICAgICAgICBhdHRhY2htZW50OiBVSS5BdHRhY2htZW50Lk5vbmUsIHNpemU6IFVJLlNpemUuRmx1aWRcbiAgICAgICAgICB9LCBbe1xuICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogW1wiSW50cm9kdWN0aW9uXCIsIFVJLk1lbnUucmVuZGVyKFxuICAgICAgICAgICAgICB7IHN1Ym1lbnU6IHRydWUsIH0sIFt7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogXCIvXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvXCIgfHwgcGFnZSA9PT0gXCIvaG9tZVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiQWJvdXRcIlxuICAgICAgICAgICAgICB9XSldXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBbXCJFbGVtZW50c1wiLCBVSS5NZW51LnJlbmRlcihcbiAgICAgICAgICAgICAgeyBzdWJtZW51OiB0cnVlLCB9LCBbe1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2J1dHRvblwiLCBhY3RpdmU6IHBhZ2UgPT09IFwiL2VsZW1lbnRzL2J1dHRvblwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiQnV0dG9uXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2NvbnRhaW5lclwiLCBhY3RpdmU6IHBhZ2UgPT09IFwiL2VsZW1lbnRzL2NvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiQ29udGFpbmVyXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2RpdmlkZXJcIiwgYWN0aXZlOiBwYWdlID09PSBcIi9lbGVtZW50cy9kaXZpZGVyXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJEaXZpZGVyXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2hlYWRlclwiLCBhY3RpdmU6IHBhZ2UgPT09IFwiL2VsZW1lbnRzL2hlYWRlclwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiSGVhZGVyXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2ljb25cIiwgYWN0aXZlOiBwYWdlID09PSBcIi9lbGVtZW50cy9pY29uXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJJY29uXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2ltYWdlXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvZWxlbWVudHMvaW1hZ2VcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkltYWdlXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2xhYmVsXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvZWxlbWVudHMvbGFiZWxcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkxhYmVsXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2xpc3RcIiwgYWN0aXZlOiBwYWdlID09PSBcIi9lbGVtZW50cy9saXN0XCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJMaXN0XCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL2xvYWRlclwiLCBhY3RpdmU6IHBhZ2UgPT09IFwiL2VsZW1lbnRzL2xvYWRlclwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiTG9hZGVyXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL3NlZ21lbnRcIiwgYWN0aXZlOiBwYWdlID09PSBcIi9lbGVtZW50cy9zZWdtZW50XCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJTZWdtZW50XCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL3N0ZXBcIiwgYWN0aXZlOiBwYWdlID09PSBcIi9lbGVtZW50cy9zdGVwXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJTdGVwXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL2VsZW1lbnRzL3RleHRib3hcIiwgYWN0aXZlOiBwYWdlID09PSBcIi9lbGVtZW50cy90ZXh0Ym94XCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJUZXh0Ym94XCJcbiAgICAgICAgICAgICAgfV0pXVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogW1wiQ29sbGVjdGlvbnNcIiwgVUkuTWVudS5yZW5kZXIoXG4gICAgICAgICAgICAgIHsgc3VibWVudTogdHJ1ZSwgfSwgW3tcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9jb2xsZWN0aW9ucy9icmVhZGNydW1iXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvY29sbGVjdGlvbnMvYnJlYWRjcnVtYlwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiQnJlYWRjcnVtYlwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9jb2xsZWN0aW9ucy9mb3JtXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvY29sbGVjdGlvbnMvZm9ybVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiRm9ybVwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9jb2xsZWN0aW9ucy9ncmlkXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvY29sbGVjdGlvbnMvZ3JpZFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiR3JpZFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9jb2xsZWN0aW9ucy9tZW51XCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvY29sbGVjdGlvbnMvbWVudVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiTWVudVwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9jb2xsZWN0aW9ucy9tZXNzYWdlXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvY29sbGVjdGlvbnMvbWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiTWVzc2FnZVwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9jb2xsZWN0aW9ucy90YWJsZVwiLCBhY3RpdmU6IHBhZ2UgPT09IFwiL2NvbGxlY3Rpb25zL3RhYmxlXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJUYWJsZVwiXG4gICAgICAgICAgICAgIH1dKV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IFtcIk1vZHVsZXNcIiwgVUkuTWVudS5yZW5kZXIoXG4gICAgICAgICAgICAgIHsgc3VibWVudTogdHJ1ZSwgfSwgW3tcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9tb2R1bGVzL2NoZWNrYm94XCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvbW9kdWxlcy9jaGVja2JveFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiQ2hlY2tib3hcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogXCIvbW9kdWxlcy9kaW1tZXJcIiwgYWN0aXZlOiBwYWdlID09PSBcIi9tb2R1bGVzL2RpbW1lclwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiRGltbWVyXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL21vZHVsZXMvZHJvcGRvd25cIiwgYWN0aXZlOiBwYWdlID09PSBcIi9tb2R1bGVzL2Ryb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJEcm9wZG93blwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9tb2R1bGVzL21vZGFsXCIsIGFjdGl2ZTogcGFnZSA9PT0gXCIvbW9kdWxlcy9tb2RhbFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiTW9kYWxcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogXCIvbW9kdWxlcy9wb3B1cFwiLCBhY3RpdmU6IHBhZ2UgPT09IFwiL21vZHVsZXMvcG9wdXBcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlBvcHVwXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL21vZHVsZXMvcHJvZ3Jlc3NcIiwgYWN0aXZlOiBwYWdlID09PSBcIi9tb2R1bGVzL3Byb2dyZXNzXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJQcm9ncmVzc1wiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBcIi9tb2R1bGVzL3RyYW5zaXRpb25cIiwgYWN0aXZlOiBwYWdlID09PSBcIi9tb2R1bGVzL3RyYW5zaXRpb25cIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICB9XSldXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBbXCJWaWV3c1wiLCBVSS5NZW51LnJlbmRlcihcbiAgICAgICAgICAgICAgeyBzdWJtZW51OiB0cnVlLCB9LCBbe1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IFwiL3ZpZXdzL3N0YXRpc3RpY1wiLCBhY3RpdmU6IHBhZ2UgPT09IFwiL3ZpZXdzL3N0YXRpc3RpY1wiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiU3RhdGlzdGljXCJcbiAgICAgICAgICAgICAgfV0pXVxuICAgICAgICAgIH1dKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBET006IHZUcmVlJCxcbiAgICAgIHJvdXRlcjogeHMubmV2ZXIoKVxuICAgIH07XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL2xheW91dC9zaWRlYmFyL2luZGV4LnRzIiwiaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeHMsIHtTdHJlYW19IGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQge0RPTVNvdXJjZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuaW50ZXJmYWNlIENvbXBvbmVudFJvdXRlclNvdXJjZXMge1xuICByb3V0ZXM6IGFueTtcbiAgcm91dGVyOiBhbnk7XG4gIERPTTogRE9NU291cmNlO1xufVxuXG5jb25zdCBjYWxsUGFnZSA9IGZ1bmN0aW9uIChzb3VyY2VzOiBDb21wb25lbnRSb3V0ZXJTb3VyY2VzKSB7XG4gIHJldHVybiAoe3BhdGgsIHZhbHVlfSkgPT4ge1xuICAgIGNvbnN0IHBTb3VyY2VzID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlcywge3JvdXRlcjogc291cmNlcy5yb3V0ZXIucGF0aChwYXRoKX0pO1xuICAgIGNvbnN0IGlzb2xhdGVkUGFnZSA9IGlzb2xhdGUodmFsdWUpKHBTb3VyY2VzKSBhcyBhbnk7XG4gICAgcmV0dXJuIGlzb2xhdGVkUGFnZTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHByb3BPck5ldmVyKGtleTogc3RyaW5nLCB4OiBPYmplY3QpIHtcbiAgaWYgKHguaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgcmV0dXJuIHhba2V5XTtcbiAgfVxuICByZXR1cm4geHMubmV2ZXIoKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkJ5S2V5KGtleTogc3RyaW5nLCBzdHJlYW06IFN0cmVhbTxhbnk+KSB7XG4gICAgcmV0dXJuIHN0cmVhbS5tYXAoeCA9PiBwcm9wT3JOZXZlcihrZXksIHgpKS5mbGF0dGVuKCk7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudFJvdXRlciAoc291cmNlczogQ29tcG9uZW50Um91dGVyU291cmNlcykge1xuICBjb25zdCBjb21wb25lbnQkID0gc291cmNlcy5yb3V0ZXIuZGVmaW5lKHNvdXJjZXMucm91dGVzKVxuICAgIC5tYXAocm91dGUgPT4gY2FsbFBhZ2Uoc291cmNlcykocm91dGUpKVxuICAgIC5yZW1lbWJlcigpXG4gICAgLmRlYnVnKCgpID0+IHt9KTsgLy9TdGF0ZSQgZG9lcyBub3Qgd29yayB3aXRob3V0IHRoaXMgbGluZS4gVW5hYmxlIHRvIHJlcHJvZHVjZSBpbiB3ZWJwYWNrYmluLlxuICBjb25zdCBwbHVjayA9IGtleSA9PiBmbGF0dGVuQnlLZXkoa2V5LCBjb21wb25lbnQkKTtcbiAgY29uc3Qgc2lua3MgPSB7XG4gICAgcGx1Y2s6IHBsdWNrLFxuICAgIERPTTogcGx1Y2soXCJET01cIiksXG4gICAgcm91dGVyOiBwbHVjayhcInJvdXRlclwiKSxcbiAgfTtcbiAgcmV0dXJuIHNpbmtzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzb3VyY2VzID0+IGlzb2xhdGUoQ29tcG9uZW50Um91dGVyKShzb3VyY2VzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL3JvdXRlci50cyIsIi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbmltcG9ydCB7Vk5vZGV9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQge1N0cmVhbX0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCB7IEluZGV4fSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiL1wiOiBJbmRleC5ydW5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy9yb3V0ZXMudHMiLCJpbXBvcnQgeyBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rc30gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7ZGl2LCBhLCBzcGFuLCBpLCBWTm9kZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQnJlYWRjcnVtYiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGFycm93PzogYm9vbGVhbjtcbiAgICBjaGV2cm9uPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgdHlwZSBDb250ZW50ID0gQXJyYXk8QnJlYWRDcnVtYkl0ZW0+O1xuICBleHBvcnQgaW50ZXJmYWNlIEJyZWFkQ3J1bWJJdGVte1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG4gICAgdGV4dD86IHN0cmluZztcbiAgICBocmVmPzogc3RyaW5nO1xuICB9XG4gIC8qKlxuICAgKiBBbiBpbnRlcmFjdGl2ZSBCcmVhZGNydW1iIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBhIGhpc3Rvcnkgb2YgbGlua3MuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogIGFycm93PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnJlYWRjcnVtYiB0byB1c2UgYXJyb3cgaWNvbnMuXG4gICAqICBjaGVjdnJvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJyZWFkY3J1bWIgdG8gdXNlIGNoZXZyb24gaWNvbnMuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEFycmF5IG9mIHt9XG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIEhpZ2hsaWdodHMgdGhlIHNlY3Rpb24gYXMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqICAgdGV4dD86IHN0cmluZyAtIFRoZSB0ZXh0IGZvciB0aGUgc2VjdGlvbi5cbiAgICogICBocmVmPzogc3RyaW5nIC0gVGhlIGxvY2F0aW9uIGZvciB0aGUgc2VjdGlvbiB0byBwb2ludCB0b3dhcmRzLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50PikgOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoW10pO1xuICAgICAgY29uc3QgYnJlYWRjcnVtYiQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiBicmVhZGNydW1iJCxcbiAgICAgICAgRXZlbnRzOiB0eXBlID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5icmVhZGNydW1iXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0YXRpYyBCcmVhZGNydW1iIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBhIGhpc3Rvcnkgb2YgbGlua3MuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzXG4gICAqICBhcnJvdz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJyZWFkY3J1bWIgdG8gdXNlIGFycm93IGljb25zLlxuICAgKiAgY2hlY3Zyb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBicmVhZGNydW1iIHRvIHVzZSBjaGV2cm9uIGljb25zLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiAgIGFjdGl2ZT86IGJvb2xlYW4gLSBIaWdobGlnaHRzIHRoZSBzZWN0aW9uIGFzIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKiAgIHRleHQ/OiBzdHJpbmcgLSBUaGUgdGV4dCBmb3IgdGhlIHNlY3Rpb24uXG4gICAqICAgaHJlZj86IHN0cmluZyAtIFRoZSBsb2NhdGlvbiBmb3IgdGhlIHNlY3Rpb24gdG8gcG9pbnQgdG93YXJkcy5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHN8Q29udGVudCA9IHt9LCBjOiBDb250ZW50ID0gW10pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNDb250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNDb250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgbGV0IGNoaWxkcmVuID0gY29udGVudC5tYXAoYyA9PiBbXG4gICAgICBzZWN0aW9uKGMpLCBkaXZpZGVyKHByb3BzKVxuICAgIF0pLnJlZHVjZSgoYSwgbikgPT4gYS5jb25jYXQobikpO1xuICAgIGNoaWxkcmVuLnNwbGljZSgtMSwgMSk7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ1aSBicmVhZGNydW1iXCJ9fSwgY2hpbGRyZW4pO1xuICB9XG4gIGZ1bmN0aW9uIHNlY3Rpb24oc2VjdGlvbjogQnJlYWRDcnVtYkl0ZW0pIDogVk5vZGUge1xuICAgIHJldHVybiBzZWN0aW9uLmFjdGl2ZVxuICAgICAgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiYWN0aXZlIHNlY3Rpb25cIn19LCBzZWN0aW9uLnRleHQpXG4gICAgICA6IGEoeyBwcm9wczogeyBjbGFzc05hbWU6IFwic2VjdGlvblwiLCBocmVmOiBzZWN0aW9uLmhyZWZ9fSwgc2VjdGlvbi50ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBkaXZpZGVyKHByb3BzOiBQcm9wcykgOiBWTm9kZSB7XG4gICAgcmV0dXJuIHNwYW4oeyBwcm9wczogeyBjbGFzc05hbWU6IFwiZGl2aWRlclwifX0sIGRpdmlkZXJJY29uKHByb3BzKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGl2aWRlckljb24ocHJvcHM6IFByb3BzKSA6IFZOb2RlIHtcbiAgICBpZiAocHJvcHMuYXJyb3cpIHtcbiAgICAgIHJldHVybiBpKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInJpZ2h0IGFycm93IGljb24gZGl2aWRlclwifX0pO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2hldnJvbikge1xuICAgICAgcmV0dXJuIGkoeyBwcm9wczogeyBjbGFzc05hbWU6IFwicmlnaHQgY2hldnJvbiBpY29uIGRpdmlkZXJcIn19KTtcbiAgICB9XG4gICAgcmV0dXJuIChcIiAvIFwiKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gaXNDb250ZW50KHByb3BzT3JDb250ZW50OiBQcm9wcyB8IENvbnRlbnQpOiBwcm9wc09yQ29udGVudCBpcyBDb250ZW50IHtcbiAgICByZXR1cm4gcHJvcHNPckNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiAoPENvbnRlbnQ+cHJvcHNPckNvbnRlbnQpLnB1c2ggIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2JyZWFkY3J1bWIvaW5kZXgudHMiLCJpbXBvcnQge1xuICBET01Db250ZW50LCBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCJ1dGlsc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiwgbGFiZWwsIFZOb2RlIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBGaWVsZCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGlubGluZT86IGJvb2xlYW47XG4gICAgY2VudGVyZWQ/OiBib29sZWFuO1xuICAgIHJlcXVpcmVkPzogYm9vbGVhbjtcbiAgfVxuICAvKipcbiAgICogV3JhcHMgY29udGVudCBpbiBhIEZpZWxkIHN1aXRhYmxlIGZvciB0aGUgRm9ybSBjb21wb25lbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICB3aWR0aD86IG51bWJlciAtIFRoZSB3aWR0aCBvZiB0aGUgZmllbGQgaW4gZ3JpZCBjb2x1bW5zLlxuICAgKiAgIGlubGluZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIG5leHQgdG8gdGhlIGZpZWxkIGluc3RlYWQgb2YgYWJvdmUgaXQuXG4gICAqICAgY2VudGVyZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjb250ZW50IG9mIHRoZSBmaWVsZCB0byBiZSBjZW50ZXJlZC5cbiAgICogICByZXF1aXJlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZpZWxkIHRvIHNob3cgaXQgaXMgbWFuZGF0b3J5LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiB7fSBvZlxuICAgKiAgIGxhYmVsPzogRE9NQ29udGVudCAtIFRoZSBsYWJlbCBmb3IgdGhlIGZpZWxkLlxuICAgKiAgIGJvZHk6IERPTUNvbnRlbnQgLSBUaGUgZmllbGQgaW5wdXQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcbiAgICAgIHNvdXJjZXMuZXh0cmFzJCA9IHNvdXJjZXMuZXh0cmFzJCA/IHNvdXJjZXMuZXh0cmFzJCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkLCBzb3VyY2VzLmV4dHJhcyQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudCwgZXh0cmFdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQsIGV4dHJhKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuZmllbGRcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGNvbnRlbnQgaW4gYSBGaWVsZCBzdWl0YWJsZSBmb3IgdGhlIEZvcm0gY29tcG9uZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICB3aWR0aD86IG51bWJlciAtIFRoZSB3aWR0aCBvZiB0aGUgZmllbGQgaW4gZ3JpZCBjb2x1bW5zLlxuICAgKiAgIGlubGluZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIG5leHQgdG8gdGhlIGZpZWxkIGluc3RlYWQgb2YgYWJvdmUgaXQuXG4gICAqICAgY2VudGVyZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjb250ZW50IG9mIHRoZSBmaWVsZCB0byBiZSBjZW50ZXJlZC5cbiAgICogICByZXF1aXJlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZpZWxkIHRvIHNob3cgaXQgaXMgbWFuZGF0b3J5LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiB7fSBvZlxuICAgKiAgIGxhYmVsPzogRE9NQ29udGVudCAtIFRoZSBsYWJlbCBmb3IgdGhlIGZpZWxkLlxuICAgKiAgIGJvZHk6IERPTUNvbnRlbnQgLSBUaGUgZmllbGQgaW5wdXQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIiwgZTogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgbGV0IGV4dHJhID0gaXNET01Db250ZW50KHBPckMpID8gKGMgPT09IFwiXCIpID8gZSA6IGMgOiBlO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXS5jb25jYXQoZXh0cmEgPyBsYWJlbChleHRyYSkgOiBcIlwiLCBjb250ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMud2lkdGgpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQocHJvcHMud2lkdGgpICsgXCIgd2lkZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW5saW5lKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW5saW5lXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jZW50ZXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNlbnRlcmVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yZXF1aXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBmaWVsZFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9mb3JtL2ZpZWxkLnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCJ1dGlsc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiwgbGFiZWwgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEZpZWxkcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGxhYmVsPzogRE9NQ29udGVudDtcbiAgICBlcXVhbFdpZHRoPzogYm9vbGVhbjtcbiAgICBncm91cGVkPzogYm9vbGVhbjtcbiAgICBpbmxpbmU/OiBib29sZWFuO1xuICAgIHJlcXVpcmVkPzogYm9vbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBtdWx0aXBsZSByZWxhdGVkIEZpZWxkIGNvbXBvbmVudHMgdG9nZXRoZXIuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBsYWJlbD86IERPTUNvbnRlbnQgLSBBIGxhYmVsIGZvciB0aGUgZmllbGRzLlxuICAgKiAgIGVxdWFsV2lkdGg/OiBib29sZWFuIC0gRGl2aWRlcyBmaWVsZHMgaW4gZXF1YWwgd2lkdGguXG4gICAqICAgZ3JvdXBlZD86IGJvb2xlYW4gLSBHcm91cHMgZmllbGRzIHRvZ2V0aGVyIGZvciByZWxhdGVkIGNob2ljZXMuXG4gICAqICAgaW5saW5lPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWxzIHRvIGJlIG5leHQgdG8gdGhlIGZpZWxkcyBpbnN0ZWFkIG9mIGFib3ZlIHRoZW0uXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmZpZWxkc1wiKS5ldmVudHModHlwZSksXG4gICAgICAgIHZhbHVlJDogeHMubmV2ZXIoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIG11bHRpcGxlIHJlbGF0ZWQgRmllbGQgY29tcG9uZW50cyB0b2dldGhlci5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgbGFiZWw/OiBET01Db250ZW50IC0gQSBsYWJlbCBmb3IgdGhlIGZpZWxkcy5cbiAgICogICBlcXVhbFdpZHRoPzogYm9vbGVhbiAtIERpdmlkZXMgZmllbGRzIGluIGVxdWFsIHdpZHRoLlxuICAgKiAgIGdyb3VwZWQ/OiBib29sZWFuIC0gR3JvdXBzIGZpZWxkcyB0b2dldGhlciBmb3IgcmVsYXRlZCBjaG9pY2VzLlxuICAgKiAgIGlubGluZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVscyB0byBiZSBuZXh0IHRvIHRoZSBmaWVsZHMgaW5zdGVhZCBvZiBhYm92ZSB0aGVtLlxuICAgKiAgIHJlcXVpcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGhlIGZpZWxkcyB0byBtYWtlIHRoZW0gYXBwZWFyIG1hbmRldG9yeS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgbGV0IGxibCA9IHByb3BzLmxhYmVsID8gbGFiZWwocHJvcHMubGFiZWwpIDogXCJcIjtcbiAgICBsZXQgY2hpbGRyZW4gPSAoPEFycmF5PGFueT4+Y29udGVudCkubGVuZ3RoID8gW2xibF0uY29uY2F0KGNvbnRlbnQpIDogW2xibCwgY29udGVudF07XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzLCBjb250ZW50KSB9IH0sIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMsIGNvbnRlbnQpIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5lcXVhbFdpZHRoICYmIGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KGNvbnRlbnQubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlubGluZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGlubGluZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZ3JvdXBlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGdyb3VwZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJlcXVpcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmVxdWlyZWRcIjtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGZpZWxkc1wiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9mb3JtL2ZpZWxkcy50cyIsImltcG9ydCB7XG4gIERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLFxuICBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50XG59IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBGb3JtIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgZXF1YWxXaWR0aD86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZm9ybSBjb21wb25lbnQgZm9yIGNhcHR1cmluZyBncm91cHMgb2YgdXNlciBpbnB1dC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGxvYWRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmb3JtIHdpdGggYSBsb2FkZXIuXG4gICAqICAgZXF1YWxXaWR0aD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZvcm0gY29udGVudCB0byBoYXZlIGVxdWFsIHdpZHRocyBwZXIgcm93LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZm9ybSBmb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBmb3JtJ3MgY29udGVudC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JClcbiAgICAgICAgLm1hcCgoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5mb3JtXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZm9ybSBjb21wb25lbnQgZm9yIGNhcHR1cmluZyBncm91cHMgb2YgdXNlciBpbnB1dC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZvcm0gd2l0aCBhIGxvYWRlci5cbiAgICogICBlcXVhbFdpZHRoPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZm9ybSBjb250ZW50IHRvIGhhdmUgZXF1YWwgd2lkdGhzIHBlciByb3cuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmb3JtIGZvciBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGZvcm0ncyBjb250ZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgY29udGVudCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcykge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lcXVhbFdpZHRoKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZXF1YWwgd2lkdGhcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgZm9ybVwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9mb3JtL2Zvcm0udHMiLCJleHBvcnQgKiBmcm9tIFwiLi9mb3JtXCJcbmV4cG9ydCAqIGZyb20gXCIuL2ZpZWxkXCJcbmV4cG9ydCAqIGZyb20gXCIuL2ZpZWxkc1wiXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9pbmRleC50cyIsImltcG9ydCB7XG4gIERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLFxuICBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50XG59IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBWZXJ0aWNhbEFsaWdubWVudCwgVGV4dEFsaWdubWVudCwgU2l6ZSwgRmxvYXQgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCJ1dGlsc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29sdW1uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgbW9iaWxlPzogbnVtYmVyO1xuICAgIHRhYmxldD86IG51bWJlcjtcbiAgICBjb21wdXRlcj86IG51bWJlcjtcbiAgICBsYXJnZXNjcmVlbj86IG51bWJlcjtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudDtcbiAgICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudDtcbiAgICBmbG9hdD86IEZsb2F0O1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBjb250ZW50IGluIGEgY29sdW1uIHN1aXRhYmxlIGZvciB0aGUgR3JpZCBjb21wb25lbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2V0aGVyIHRoZSBjb2x1bW4gc2hvdWxkIGJlIGxlZnQgb3IgcmlnaHQgZmxvYXRlZC5cbiAgICogICB3aWR0aD86IGludCAtIFRoZSBkZWZhdWx0IHdpZHRoIG9mIHRoZSBjb2x1bW4uXG4gICAqICAgbW9iaWxlPzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gbW9iaWxlIGRldmljZXMuXG4gICAqICAgdGFibGV0PzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gdGFibGV0IGRldmljZXMuXG4gICAqICAgY29tcHV0ZXI/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiBjb21wdXRlciBkZXZpY2VzLlxuICAgKiAgIGxhcmdlc2NyZWVuPzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gbGFyZ2Ugc2NyZWVuIGRldmljZXMuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgY29sdW1uLlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGhlIHRleHQgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gQ29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmNvbHVtblwiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29udGVudCBpbiBhIGNvbHVtbiBzdWl0YWJsZSBmb3IgdGhlIEdyaWQgY29tcG9uZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2V0aGVyIHRoZSBjb2x1bW4gc2hvdWxkIGJlIGxlZnQgb3IgcmlnaHQgZmxvYXRlZC5cbiAgICogICB3aWR0aD86IGludCAtIFRoZSBkZWZhdWx0IHdpZHRoIG9mIHRoZSBjb2x1bW4uXG4gICAqICAgbW9iaWxlPzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gbW9iaWxlIGRldmljZXMuXG4gICAqICAgdGFibGV0PzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gdGFibGV0IGRldmljZXMuXG4gICAqICAgY29tcHV0ZXI/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiBjb21wdXRlciBkZXZpY2VzLlxuICAgKiAgIGxhcmdlc2NyZWVuPzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gbGFyZ2Ugc2NyZWVuIGRldmljZXMuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgY29sdW1uLlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGhlIHRleHQgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBjb250ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5mbG9hdCAmJiBwcm9wcy5mbG9hdCA9PT0gRmxvYXQuUmlnaHQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodCBmbG9hdGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbG9hdCAmJiBwcm9wcy5mbG9hdCA9PT0gRmxvYXQuTGVmdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxlZnQgZmxvYXRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubW9iaWxlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KHByb3BzLm1vYmlsZSkgKyBcIiB3aWRlIG1vYmlsZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGFibGV0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KHByb3BzLnRhYmxldCkgKyBcIiB3aWRlIHRhYmxldFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcHV0ZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQocHJvcHMuY29tcHV0ZXIpICsgXCIgd2lkZSBjb21wdXRlclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubGFyZ2VzY3JlZW4pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQocHJvcHMubGFyZ2VzY3JlZW4pICsgXCIgd2lkZSBsYXJnZXNjcmVlblwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBWZXJ0aWNhbEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hbGlnbm1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy50ZXh0QWxpZ25tZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFRleHRBbGlnbm1lbnQuVG9DbGFzc25hbWUocHJvcHMudGV4dEFsaWdubWVudCk7XG4gICAgfVxuICAgIGlmIChwcm9wcy53aWR0aCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChwcm9wcy53aWR0aCkgKyBcIiB3aWRlXCI7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBjb2x1bW5cIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9jb2x1bW4udHMiLCJpbXBvcnQge1xuICBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcyxcbiAgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudFxufSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgVmVydGljYWxBbGlnbm1lbnQsIFRleHRBbGlnbm1lbnQgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCJ1dGlsc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgR3JpZCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGVxdWFsbHlEaXZpZGVkPzogYm9vbGVhbjtcbiAgICBkaXZpZGVkPzogYm9vbGVhbjtcbiAgICBjb250YWluZXI/OiBib29sZWFuO1xuICAgIGNlbGxlZD86IGJvb2xlYW47XG4gICAgaW50Q2VsbGVkPzogYm9vbGVhbjtcbiAgICBwYWRkZWQ/OiBib29sZWFuO1xuICAgIHJlbGF4ZWQ/OiBib29sZWFuO1xuICAgIGNlbnRlcmVkPzogYm9vbGVhbjtcbiAgICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudDtcbiAgICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBjb250ZW50IGluIGEgY29sdW1uIHN1aXRhYmxlIGZvciB0aGUgR3JpZCBjb21wb25lbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBlcXVhbGx5RGl2aWRlZD86IGJvb2xlYW4gLSBTdHlsZXMgZ3JpZCBjb250ZW50IHRvIHRha2UgdXAgZXF1YWwgYW1vdW50cyBvZiBzcGFjZS5cbiAgICogICBkaXZpZGVkPzogYm9vbGVhbiAtIFVzZSBkaXZpZGVycyB0byBzZXBlcmF0ZSBjb250ZW50IGluIHRoZSBHcmlkLlxuICAgKiAgIGNvbnRhaW5lcj8gOiBib29sZWFuIC0gV3JhcHMgdGhlIGdyaWQgaW4gYSBjb250YWluZXIuXG4gICAqICAgY2VsbGVkPzogYm9vbGVhbiAtIERpdmlkZXMgdGhlIGdyaWQgaW50byBjZWxscy5cbiAgICogICBpbnRDZWxsZWQ/OiBib29sZWFuIC0gRGl2aWRlcyB0aGUgZ3JpZCBpbnRvIGNlbGxzIHdpdGggb25seSBpbnRlcm5hbCBkaXZpZGVycy5cbiAgICogICBwYWRkZWQ/OiBib29sZWFuIC0gQWRkcyB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBndXR0ZXJzIHRvIHRoZSBncmlkLlxuICAgKiAgIHJlbGF4ZWQ/OiBib29sZWFuIC0gSW5jcmVhc2VzIHRoZSBhbW91bnQgb2YgbmVnYXRpdmUgc3BhY2UuXG4gICAqICAgY2VudGVyZWQ/OiBib29sZWFuIC0gQ2VudGVycyB0aGUgY29udGVudCBvZiB0aGUgR3JpZC5cbiAgICogICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudDogRGV0ZXJtaW5lcyB0aGUgYWxpZ25tZW50IG9mIGNvbnRlbnQgaW4gdGhlIEdyaWQuXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQ6IERldGVybWluZXMgdGhlIHRleHQgYWxpZ25tZW50IG9mIGNvbnRlbnQgaW4gdGhlIEdyaWQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpXG4gICAgICAgIC5tYXAoKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuZ3JpZFwiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29udGVudCBpbiBhIGNvbHVtbiBzdWl0YWJsZSBmb3IgdGhlIEdyaWQgY29tcG9uZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBlcXVhbGx5RGl2aWRlZD86IGJvb2xlYW4gLSBTdHlsZXMgZ3JpZCBjb250ZW50IHRvIHRha2UgdXAgZXF1YWwgYW1vdW50cyBvZiBzcGFjZS5cbiAgICogICBkaXZpZGVkPzogYm9vbGVhbiAtIFVzZSBkaXZpZGVycyB0byBzZXBlcmF0ZSBjb250ZW50IGluIHRoZSBHcmlkLlxuICAgKiAgIGNvbnRhaW5lcj8gOiBib29sZWFuIC0gV3JhcHMgdGhlIGdyaWQgaW4gYSBjb250YWluZXIuXG4gICAqICAgY2VsbGVkPzogYm9vbGVhbiAtIERpdmlkZXMgdGhlIGdyaWQgaW50byBjZWxscy5cbiAgICogICBpbnRDZWxsZWQ/OiBib29sZWFuIC0gRGl2aWRlcyB0aGUgZ3JpZCBpbnRvIGNlbGxzIHdpdGggb25seSBpbnRlcm5hbCBkaXZpZGVycy5cbiAgICogICBwYWRkZWQ/OiBib29sZWFuIC0gQWRkcyB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBndXR0ZXJzIHRvIHRoZSBncmlkLlxuICAgKiAgIHJlbGF4ZWQ/OiBib29sZWFuIC0gSW5jcmVhc2VzIHRoZSBhbW91bnQgb2YgbmVnYXRpdmUgc3BhY2UuXG4gICAqICAgY2VudGVyZWQ/OiBib29sZWFuIC0gQ2VudGVycyB0aGUgY29udGVudCBvZiB0aGUgR3JpZC5cbiAgICogICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudDogRGV0ZXJtaW5lcyB0aGUgYWxpZ25tZW50IG9mIGNvbnRlbnQgaW4gdGhlIEdyaWQuXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQ6IERldGVybWluZXMgdGhlIHRleHQgYWxpZ25tZW50IG9mIGNvbnRlbnQgaW4gdGhlIEdyaWQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcywgY29udGVudCkgfSB9LCBjb250ZW50KTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcywgY29udGVudCk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuZXF1YWxseURpdmlkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQoY29udGVudC5sZW5ndGggPyBjb250ZW50Lmxlbmd0aCA6IDEpICsgXCIgY29sdW1uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXZpZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGl2aWRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29udGFpbmVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29udGFpbmVyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jZWxsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjZWxsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludENlbGxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludGVybmFsbHkgY2VsbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wYWRkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwYWRkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJlbGF4ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByZWxheGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jZW50ZXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNlbnRlcmVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBWZXJ0aWNhbEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hbGlnbm1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy50ZXh0QWxpZ25tZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFRleHRBbGlnbm1lbnQuVG9DbGFzc25hbWUocHJvcHMudGV4dEFsaWdubWVudCk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBncmlkXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2dyaWQvZ3JpZC50cyIsImV4cG9ydCAqIGZyb20gXCIuL2dyaWRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Jvd1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29sdW1uXCI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9pbmRleC50cyIsImltcG9ydCB7XG4gIERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLFxuICBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50XG59IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBudW1Ub1RleHQgfSBmcm9tIFwidXRpbHNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFJvdyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHN0cmV0Y2hlZD86IGJvb2xlYW47XG4gICAgbW9iaWxlPzogYm9vbGVhbjtcbiAgICB0YWJsZXQ/OiBib29sZWFuO1xuICAgIGNvbXB1dGVyPzogYm9vbGVhbjtcbiAgICBsYXJnZXNjcmVlbj86IGJvb2xlYW47XG4gICAgZXF1YWxseURpdmlkZWQ/OiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSb3cgY29tcG9uZW50IHRoYXQgd3JhcHMgQ29sdW1uIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBzdHJldGNoZWQ/OiBib29sZWFuIC0gRW5zdXJlcyB0aGUgY29sdW1ucyBhcmUgc3RyZXRjaGVkIHRvIGVxdWFsIGhlaWdodC5cbiAgICogICBtb2JpbGU/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gbW9iaWxlIGRldmljZXMuXG4gICAqICAgdGFibGV0PzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIHRhYmxldCBkZXZpY2VzLlxuICAgKiAgIGNvbXB1dGVyPzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIGNvbXB1dGVyIGRldmljZXMuXG4gICAqICAgbGFyZ2VzY3JlZW4/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gbGFyZ2VzY3JlZW4gZGV2aWNlcy5cbiAgICogICBlcXVhbGx5RGl2aWRlZD86IGJvb2xlYW4gLSBNYWtlcyBlYWNoIGNvbHVtbiBvZiB0aGUgcm93IGVxdWFsIGluIHdpZHRoLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5yb3dcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSb3cgY29tcG9uZW50IHRoYXQgd3JhcHMgQ29sdW1uIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIHN0cmV0Y2hlZD86IGJvb2xlYW4gLSBFbnN1cmVzIHRoZSBjb2x1bW5zIGFyZSBzdHJldGNoZWQgdG8gZXF1YWwgaGVpZ2h0LlxuICAgKiAgIG1vYmlsZT86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogICB0YWJsZXQ/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gdGFibGV0IGRldmljZXMuXG4gICAqICAgY29tcHV0ZXI/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gY29tcHV0ZXIgZGV2aWNlcy5cbiAgICogICBsYXJnZXNjcmVlbj86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiBsYXJnZXNjcmVlbiBkZXZpY2VzLlxuICAgKiAgIGVxdWFsbHlEaXZpZGVkPzogYm9vbGVhbiAtIE1ha2VzIGVhY2ggY29sdW1uIG9mIHRoZSByb3cgZXF1YWwgaW4gd2lkdGguXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHN8RE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMsIGNvbnRlbnQpIH0gfSwgY29udGVudCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcywgY29udGVudCk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuc3RyZXRjaGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3RyZXRjaGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5tb2JpbGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBtb2JpbGUgb25seVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGFibGV0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdGFibGV0IG9ubHlcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXB1dGVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcHV0ZXIgb25seVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubGFyZ2VzY3JlZW4pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsYXJnZXNjcmVlbiBvbmx5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lcXVhbGx5RGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQubGVuZ3RoIDogMSkgKyBcIiBjb2x1bW5cIjtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIHJvd1wiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9ncmlkL3Jvdy50cyIsImV4cG9ydCAqIGZyb20gXCIuL2JyZWFkY3J1bWJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Zvcm1cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2dyaWRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21lbnVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21lc3NhZ2VcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RhYmxlXCI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnQgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgSWNvblR5cGUsIFNpemUsIENvbG9yLCBBbmltYXRpb24sIERpcmVjdGlvbiB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzLCB7IFN0cmVhbSB9IGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSBcImVsZW1lbnRzL2ljb25cIjtcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwibW9kdWxlcy90cmFuc2l0aW9uXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIG9uJD86IFN0cmVhbTxib29sZWFuPjtcbiAgICBjbG9zZWFibGU/OiBib29sZWFuO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGZsb2F0aW5nPzogYm9vbGVhbjtcbiAgICBjb21wYWN0PzogYm9vbGVhbjtcbiAgICBhdHRhY2hlZD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENvbnRlbnQge1xuICAgIGljb24/OiBJY29uVHlwZTtcbiAgICBoZWFkZXI/OiBET01Db250ZW50O1xuICAgIGJvZHk/OiBET01Db250ZW50O1xuICB9XG4gIC8qKlxuICAgKiBBIG1lc3NhZ2UgY29tcG9uZW50IHRvIHByZXNlbnQgbWVzc2FnZXMgdG8gdXNlcnMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBvbiQ/OiBTdHJlYW08Ym9vbGVhbj4gLSBXaGVuIHRvIHNob3cvaGlkZSB0aGUgbWVzc2FnZS5cbiAgICogICBjbG9zZWFibGU/OiBib29sZWFuIC0gUHJvdmlkZXMgYSBjbG9zZSBpY29uIGZvciB0aGUgbWVzc2FnZSBmb3IgZGlzbWlzc2FsLlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVzc2FnZSB0byBzdXBwb3J0IGFuIGljb24uXG4gICAqICAgZmxvYXRpbmc/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVzc2FnZSB0byBmbG9hdCBhYm92ZSByZWxhdGVkIGNvbnRlbnQuXG4gICAqICAgY29tcGFjdD86IGJvb2xlYW4gLSBGb3JtYXRzIGEgbWVzc2FnZSB0byBvbmx5IG9jY3VweSB3aWR0aCBuZWVkZWQgYnkgaXRzIGNvbnRlbnQuXG4gICAqICAgYXR0YWNoZWQ/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVzc2FnZSB0byBhcHBlYXIgYXR0YWNoZWQgdG8gb3RoZXIgY29udGVudC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBtZXNzYWdlLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IHt9XG4gICAqICAgaWNvbj86IFN0cmluZ3xWTm9kZSAtIEEgbWVzc2FnZSBjYW4gaGF2ZSBhbiBpY29uIHNpZ25pZnlpbmcgdGhlIHR5cGUgb2YgbWVzc2FnZS5cbiAgICogICBoZWFkZXI/OiBTdHJpbmd8Vk5vZGUgLSBBIG1lc3NhZ2UgY2FuIGhhdmUgYSBoZWFkZXIgdGV4dC5cbiAgICogICBib2R5PzogU3RyaW5nfFZOb2RlIC0gQSBtZXNzYWdlIGNhbiBoYXZlIGFkZGl0aW9uYWx5IGJvZHkgY29udGVudC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IGljb24gPSBJY29uLnJ1bih7IERPTTogc291cmNlcy5ET00sIHByb3BzJDogeHMub2YoeyB0eXBlOiBcImNsb3NlXCIgfSkgfSk7XG4gICAgICBjb25zdCBjbG9zZSQgPSBpY29uLkV2ZW50cyhcImNsaWNrXCIpLm1hcFRvKGZhbHNlKTtcbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQsIGljb24uRE9NKVxuICAgICAgICAubWFwKChbcHJvcHMsIGNvbnRlbnQsIGNsb3NlSWNvbl0pID0+XG4gICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgICAgICAgY29udGVudC5pY29uLFxuICAgICAgICAgICAgcHJvcHMuY2xvc2VhYmxlID8gY2xvc2VJY29uIDogXCJcIixcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBbXS5jb25jYXQoXG4gICAgICAgICAgICAgIGNvbnRlbnQuaGVhZGVyID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImhlYWRlclwiIH0gfSwgY29udGVudC5oZWFkZXIpIDogXCJcIixcbiAgICAgICAgICAgICAgY29udGVudC5ib2R5XG4gICAgICAgICAgICApKVxuICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgICBjb25zdCBvbiQgPSBzb3VyY2VzLnByb3BzJC5tYXAocHJvcHMgPT4gcHJvcHMub24kID8gcHJvcHMub24kIDogeHMub2YodHJ1ZSkpLmZsYXR0ZW4oKTtcbiAgICAgIGNvbnN0IGFjdGl2ZSQgPSB4cy5tZXJnZShvbiQsIGNsb3NlJCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uJCA9IGFjdGl2ZSQuZm9sZCgocHJldkFuaW0sIGFjdGl2ZSkgPT4gcHJldkFuaW0uZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTm9uZVxuICAgICAgICA/IHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBhY3RpdmUgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0IH1cbiAgICAgICAgOiB7IGFuaW1hdGlvbjogQW5pbWF0aW9uLkZhZGUsIGRpcmVjdGlvbjogYWN0aXZlID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dCB9XG4gICAgICAgICwgeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IERpcmVjdGlvbi5Ob25lIH0pO1xuICAgICAgY29uc3QgYW5pbWF0ZWRWVHJlZSQgPSBUcmFuc2l0aW9uLnJ1bih7IERPTTogc291cmNlcy5ET00sIHRhcmdldCQ6IHZUcmVlJCwgYXJncyQ6IHRyYW5zaXRpb24kIH0pLkRPTTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogYW5pbWF0ZWRWVHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5tZXNzYWdlXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBjb21wb25lbnQgdG8gcHJlc2VudCBtZXNzYWdlcyB0byB1c2Vycy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgb24kPzogU3RyZWFtPGJvb2xlYW4+IC0gV2hlbiB0byBzaG93L2hpZGUgdGhlIG1lc3NhZ2UuXG4gICAqICAgY2xvc2VhYmxlPzogYm9vbGVhbiAtIFByb3ZpZGVzIGEgY2xvc2UgaWNvbiBmb3IgdGhlIG1lc3NhZ2UgZm9yIGRpc21pc3NhbC5cbiAgICogICBpY29uPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIG1lc3NhZ2UgdG8gc3VwcG9ydCBhbiBpY29uLlxuICAgKiAgIGZsb2F0aW5nPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIG1lc3NhZ2UgdG8gZmxvYXQgYWJvdmUgcmVsYXRlZCBjb250ZW50LlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gRm9ybWF0cyBhIG1lc3NhZ2UgdG8gb25seSBvY2N1cHkgd2lkdGggbmVlZGVkIGJ5IGl0cyBjb250ZW50LlxuICAgKiAgIGF0dGFjaGVkPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIG1lc3NhZ2UgdG8gYXBwZWFyIGF0dGFjaGVkIHRvIG90aGVyIGNvbnRlbnQuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgbWVzc2FnZS5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiB7fVxuICAgKiAgIGljb24/OiBTdHJpbmd8Vk5vZGUgLSBBIG1lc3NhZ2UgY2FuIGhhdmUgYW4gaWNvbiBzaWduaWZ5aW5nIHRoZSB0eXBlIG9mIG1lc3NhZ2UuXG4gICAqICAgaGVhZGVyPzogU3RyaW5nfFZOb2RlIC0gQSBtZXNzYWdlIGNhbiBoYXZlIGEgaGVhZGVyIHRleHQuXG4gICAqICAgYm9keT86IFN0cmluZ3xWTm9kZSAtIEEgbWVzc2FnZSBjYW4gaGF2ZSBhZGRpdGlvbmFseSBib2R5IGNvbnRlbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgQ29udGVudCA9IHt9LCBjOiBDb250ZW50ID0ge30pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNDb250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNDb250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgY29uc3QgY2xvc2VJY29uID0gSWNvbi5yZW5kZXIoe30sIEljb25UeXBlLkNsb3NlKTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgY29udGVudC5pY29uID8gSWNvbi5yZW5kZXIoY29udGVudC5pY29uKSA6IFwiXCIsXG4gICAgICBwcm9wcy5jbG9zZWFibGUgPyBjbG9zZUljb24gOiBcIlwiLFxuICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImNvbnRlbnRcIiB9IH0sIFtdLmNvbmNhdChcbiAgICAgICAgY29udGVudC5oZWFkZXIgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiaGVhZGVyXCIgfSB9LCBjb250ZW50LmhlYWRlcikgOiBcIlwiLFxuICAgICAgICBjb250ZW50LmJvZHlcbiAgICAgICkpXG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5pY29uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaWNvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmxvYXRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbG9hdGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcGFjdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXBhY3RcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmF0dGFjaGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYXR0YWNoZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBtZXNzYWdlXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29udGVudChjb250ZW50KTogY29udGVudCBpcyBDb250ZW50IHtcbiAgICByZXR1cm4gY29udGVudCAhPT0gdW5kZWZpbmVkICYmIChpc0RPTUNvbnRlbnQoY29udGVudC5pY29uKSB8fCBpc0RPTUNvbnRlbnQoY29udGVudC5oZWFkZXIpIHx8IGlzRE9NQ29udGVudChjb250ZW50LmJvZHkpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL21lc3NhZ2UvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplLCBDb2xvciB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IHRhYmxlLCB0ciwgdGgsIHRkLCB0aGVhZCwgdGJvZHksIHRmb290IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBUYWJsZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHNpbmdsZWxpbmU/OiBib29sZWFuO1xuICAgIGZpeGVkPzogYm9vbGVhbjtcbiAgICBzZWxlY3RhYmxlPzogYm9vbGVhbjtcbiAgICBzdHJpcGVkPzogYm9vbGVhbjtcbiAgICBjZWxsZWQ/OiBib29sZWFuO1xuICAgIGJhc2ljPzogYm9vbGVhbjtcbiAgICB2ZXJ5YmFzaWM/OiBib29sZWFuO1xuICAgIGNvbGxhcHNpbmc/OiBib29sZWFuO1xuICAgIHBhZGRlZD86IGJvb2xlYW47XG4gICAgdmVyeXBhZGRlZD86IGJvb2xlYW47XG4gICAgY29tcGFjdD86IGJvb2xlYW47XG4gICAgdmVyeWNvbXBhY3Q/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDb250ZW50IHtcbiAgICBoZWFkZXI/OiBBcnJheTxET01Db250ZW50PjtcbiAgICBib2R5OiBBcnJheTxBcnJheTxET01Db250ZW50Pj47XG4gICAgZm9vdGVyPzogQXJyYXk8RE9NQ29udGVudD4gfCBET01Db250ZW50O1xuICB9XG5cblxuICAvKipcbiAgICogQSB0YWJsZSBjb21wb25lbnQgdG8gc2hvdyBjb250ZW50IGluIGEgdGFibGUuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBzaW5nbGVsaW5lPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRhYmxlIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lLlxuICAgKiAgIGZpeGVkPzogYm9vbGVhbiAtIFN0b3BzIHJlc2l6aW5nIG9mIHRhYmxlIGNlbGxzIGJhc2VkIG9uIGNvbnRlbnQuXG4gICAqICAgc2VsZWN0YWJsZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHJvd3Mgb2YgdGhlIHRhYmxlIHRvIGJlIHNlbGVjdGFibGUuXG4gICAqICAgc3RyaXBlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHJvd3Mgb2YgdGhlIHRhYmxlIHRvIGFsdGVybmF0ZSBjb2xvcnMuXG4gICAqICAgY2VsbGVkPzogYm9vbGVhbiAtIERpdmlkZXMgZWFjaCByb3cgaW50byBzZXBlcmF0ZSBjZWxscy5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBSZWR1Y2VzIHRoZSBjb21wbGV4aXR5IG9mIHRoZSB0YWJsZS5cbiAgICogICB2ZXJ5YmFzaWM/OiBib29sZWFuIC0gUmVkdWNlcyB0aGUgY29tcGxleGl0eSBvZiB0aGUgdGFibGUgYnkgYSBsb3QuXG4gICAqICAgY29sbGFwc2luZz86IGJvb2xlYW4gLSBNYWtlcyB0aGUgdGFibGUgb25seSB0YWtlIHVwIGFzIG11Y2ggc3BhY2UgYXMgbmVlZGVkLlxuICAgKiAgIHBhZGRlZD86IGJvb2xlYW4gLSBBZGRzIGV4dHJhIHBhZGRpbmcgdG8gdGhlIHRhYmxlIGNvbnRlbnQuXG4gICAqICAgdmVyeXBhZGRlZD86IGJvb2xlYW4gLSBBZGRzIGEgbG90IG9mIGV4dHJhIHBhZGRpbmcgdG8gdGhlIHRhYmxlIGNvbnRlbnQuXG4gICAqICAgY29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRhYmxlIGNvbnRlbnQgdG8gYmUgbW9yZSBjb21wYWN0LCB0byBhbGxvdyBmb3IgbW9yZSByb3dzLlxuICAgKiAgIHZlcnljb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGFibGUgY29udGVudCB0byBiZSBncmVhdGx5IGNvbXBhY3RlZC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0YWJsZSBjb250ZW50LlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3VyIG9mIHRoZSB0YWJsZS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge30gb2ZcbiAgICogXHRoZWFkZXJzOiBbRE9NQ29udGVudF1cbiAgICogXHRib2R5OiBbW0RvbUNvbnRlbnRdXVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZih7IGJvZHk6IFtdIH0pO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi50YWJsZVwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHRhYmxlIGNvbXBvbmVudCB0byBzaG93IGNvbnRlbnQgaW4gYSB0YWJsZS5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIHNpbmdsZWxpbmU/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgY29udGVudCBvZiB0aGUgdGFibGUgdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUuXG4gICAqICAgZml4ZWQ/OiBib29sZWFuIC0gU3RvcHMgcmVzaXppbmcgb2YgdGFibGUgY2VsbHMgYmFzZWQgb24gY29udGVudC5cbiAgICogICBzZWxlY3RhYmxlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcm93cyBvZiB0aGUgdGFibGUgdG8gYmUgc2VsZWN0YWJsZS5cbiAgICogICBzdHJpcGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcm93cyBvZiB0aGUgdGFibGUgdG8gYWx0ZXJuYXRlIGNvbG9ycy5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gRGl2aWRlcyBlYWNoIHJvdyBpbnRvIHNlcGVyYXRlIGNlbGxzLlxuICAgKiAgIGJhc2ljPzogYm9vbGVhbiAtIFJlZHVjZXMgdGhlIGNvbXBsZXhpdHkgb2YgdGhlIHRhYmxlLlxuICAgKiAgIHZlcnliYXNpYz86IGJvb2xlYW4gLSBSZWR1Y2VzIHRoZSBjb21wbGV4aXR5IG9mIHRoZSB0YWJsZSBieSBhIGxvdC5cbiAgICogICBjb2xsYXBzaW5nPzogYm9vbGVhbiAtIE1ha2VzIHRoZSB0YWJsZSBvbmx5IHRha2UgdXAgYXMgbXVjaCBzcGFjZSBhcyBuZWVkZWQuXG4gICAqICAgcGFkZGVkPzogYm9vbGVhbiAtIEFkZHMgZXh0cmEgcGFkZGluZyB0byB0aGUgdGFibGUgY29udGVudC5cbiAgICogICB2ZXJ5cGFkZGVkPzogYm9vbGVhbiAtIEFkZHMgYSBsb3Qgb2YgZXh0cmEgcGFkZGluZyB0byB0aGUgdGFibGUgY29udGVudC5cbiAgICogICBjb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGFibGUgY29udGVudCB0byBiZSBtb3JlIGNvbXBhY3QsIHRvIGFsbG93IGZvciBtb3JlIHJvd3MuXG4gICAqICAgdmVyeWNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0YWJsZSBjb250ZW50IHRvIGJlIGdyZWF0bHkgY29tcGFjdGVkLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHRhYmxlIGNvbnRlbnQuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvdXIgb2YgdGhlIHRhYmxlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiB7fSBvZlxuICAgKiBcdGhlYWRlcnM6IFtET01Db250ZW50XVxuICAgKiBcdGJvZHk6IFtbRG9tQ29udGVudF1dXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgQ29udGVudCA9IHt9LCBjOiBDb250ZW50ID0geyBib2R5OiBbXSB9KTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuXG4gICAgbGV0IGhlYWRlciA9IGNvbnRlbnQuaGVhZGVyID8gdGhlYWQoW3RyKGNvbnRlbnQuaGVhZGVyLm1hcChoID0+IHRoKGgpKSldKSA6IFwiXCI7XG4gICAgbGV0IGZvb3RlcjtcbiAgICBpZiAoaXNET01Db250ZW50KGNvbnRlbnQuZm9vdGVyKSkge1xuICAgICAgZm9vdGVyID0gdGZvb3QoY29udGVudC5mb290ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvb3RlciA9IGNvbnRlbnQuZm9vdGVyID8gdGZvb3QoW3RyKGNvbnRlbnQuZm9vdGVyLm1hcChmID0+IHRoKGYpKSldKSA6IFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgaGVhZGVyLFxuICAgICAgdGJvZHkoY29udGVudC5ib2R5Lm1hcChyID0+IHRyKHIubWFwKGMgPT4gdGQoYykpKSkpLFxuICAgICAgZm9vdGVyXG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuc2luZ2xlbGluZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNpbmdsZSBsaW5lXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5maXhlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZpeGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zZWxlY3RhYmxlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VsZWN0YWJsZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc3RyaXBlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHN0cmlwZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbGxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNlbGxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYmFzaWMpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBiYXNpY1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmVyeWJhc2ljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVyeSBiYXNpY1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29sbGFwc2luZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbGxhcHNpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBhZGRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHBhZGRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmVyeXBhZGRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnkgcGFkZGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wYWN0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGFjdFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmVyeWNvbXBhY3QpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ5IGNvbXBhY3RcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiB0YWJsZVwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbnRlbnQoY29udGVudCk6IGNvbnRlbnQgaXMgQ29udGVudCB7XG4gICAgcmV0dXJuIGNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAoPENvbnRlbnQ+Y29udGVudCkuYm9keSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoKDxDb250ZW50PmNvbnRlbnQpLmhlYWRlciAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICg8Q29udGVudD5jb250ZW50KS5mb290ZXIgIT09IHVuZGVmaW5lZCkpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvdGFibGUvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzLCBpc0RPTUNvbnRlbnQgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgQ29sb3IsIFNpemUsIEF0dGFjaG1lbnQsIEZsb2F0IH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2LCBhIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBCdXR0b24ge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBhbmltYXRlZD86IGJvb2xlYW47XG4gICAgdmVydGljYWxBbmltYXRlZD86IGJvb2xlYW47XG4gICAgbGFiZWxlZD86IGJvb2xlYW47XG4gICAgcmlnaHRsYWJlbGVkPzogYm9vbGVhbjtcbiAgICBpY29uPzogYm9vbGVhbjtcbiAgICBiYXNpYz86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGxvYWRpbmc/OiBib29sZWFuO1xuICAgIGNvbXBhY3Q/OiBib29sZWFuO1xuICAgIGNpcmN1bGFyPzogYm9vbGVhbjtcbiAgICBmbHVpZD86IGJvb2xlYW47XG4gICAgaHJlZj86IHN0cmluZztcbiAgICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBmbG9hdD86IEZsb2F0O1xuICAgIGNvbG9yPzogQ29sb3I7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGludGVyYWN0aXZlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHVzZXIgaW50ZXJhY3Rpb24gdGhyb3VnaCBjbGlja2luZy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgYW5pbWF0ZWQ/IDogYm9vbGVhbiAtIEFsbG93cyBmb3IgYW4gYW5pbWF0aW9uIGluIHRoZSBidXR0b24gdG8gc2hvdyBoaWRkZW4gY29udGVudC5cbiAgICogICB2ZXJ0aWNhbEFuaW1hdGVkPzogYm9vbGVhbiAtIFNlZSBhbmltYXRlZC4gVGhpcyBhbmltYXRpb24gaXMgdmVydGljYWwuXG4gICAqICAgbGFiZWxlZD86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGxhYmVsZWQgYnV0dG9ucy5cbiAgICogICBpY29uPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgYnV0dG9ucyB3aXRoIGFuIGljb24uXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIHNpbXBsZXIuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIG9uIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIFNldHMgdGhlIGJ1dHRvbiB0byB0aGUgYWN0aXZlIHN0YXRlLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBsb2FkaW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHNob3cgdGhhdCBpdCBpcyBsb2FkaW5nIC8gd29ya2luZy5cbiAgICogICBjb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIGZvciBhIHRpZ2h0IGZpdC5cbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgY2lyY3VsYXIuXG4gICAqICAgZmx1aWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYmUgYXMgd2lkZSBhcyBwb3NzaWJsZS5cbiAgICogICBocmVmPzogc3RyaW5nIC0gT3V0cHV0cyB0aGUgYnV0dG9uIGFzIGEgbGluayB0byB0byB0aGUgaHJlZi5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFdoZXJlIHRoZSBidXR0b24gc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGJ1dHRvbi5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gVGhlIGxlZnQgb3IgcmlnaHQgZmxvYXQgb2YgdGhlIGJ1dHRvbi5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBidXR0b24uXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IHt9IG9mXG4gICAqICAgYm9keT86IERPTUNvbnRlbnQgLSBUaGUgYm9keSBjb250ZW50IHRvIGRpc3BsYXkgb24gdGhlIGJ1dHRvbi5cbiAgICogICBoaWRkZW4/OiBET01Db250ZW50IC0gVGhlIGhpZGRlbiBjb250ZW50IHRvIGRpc3BsYXkgZm9yIGFuaW1hdGVkIGJ1dHRvbnMuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuICAgICAgc291cmNlcy5leHRyYXMkID0gc291cmNlcy5leHRyYXMkID8gc291cmNlcy5leHRyYXMkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZ0cmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQsIHNvdXJjZXMuZXh0cmFzJCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50LCBleHRyYXNdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQsIGV4dHJhcylcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZ0cmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnVpLmJ1dHRvblwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0YXRpYyBidXR0b24gY29tcG9uZW50IGZvciB1c2VyIGludGVyYWN0aW9uIHRocm91Z2ggY2xpY2tpbmcuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIHByb3BlcnRpZXM6XG4gICAqICAgYW5pbWF0ZWQ/IDogYm9vbGVhbiAtIEFsbG93cyBmb3IgYW4gYW5pbWF0aW9uIGluIHRoZSBidXR0b24gdG8gc2hvdyBoaWRkZW4gY29udGVudC5cbiAgICogICB2ZXJ0aWNhbEFuaW1hdGVkPzogYm9vbGVhbiAtIFNlZSBhbmltYXRlZC4gVGhpcyBhbmltYXRpb24gaXMgdmVydGljYWwuXG4gICAqICAgbGFiZWxlZD86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGxhYmVsZWQgYnV0dG9ucy5cbiAgICogICBpY29uPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgYnV0dG9ucyB3aXRoIGFuIGljb24uXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIHNpbXBsZXIuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIG9uIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIFNldHMgdGhlIGJ1dHRvbiB0byB0aGUgYWN0aXZlIHN0YXRlLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBsb2FkaW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHNob3cgdGhhdCBpdCBpcyBsb2FkaW5nIC8gd29ya2luZy5cbiAgICogICBjb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIGZvciBhIHRpZ2h0IGZpdC5cbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgY2lyY3VsYXIuXG4gICAqICAgZmx1aWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYmUgYXMgd2lkZSBhcyBwb3NzaWJsZS5cbiAgICogICBocmVmPzogc3RyaW5nIC0gT3V0cHV0cyB0aGUgYnV0dG9uIGFzIGEgbGluayB0byB0byB0aGUgaHJlZi5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFdoZXJlIHRoZSBidXR0b24gc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGJ1dHRvbi5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gVGhlIGxlZnQgb3IgcmlnaHQgZmxvYXQgb2YgdGhlIGJ1dHRvbi5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBidXR0b24uXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IHt9IG9mXG4gICAqICAgYm9keT86IERPTUNvbnRlbnQgLSBUaGUgYm9keSBjb250ZW50IHRvIGRpc3BsYXkgb24gdGhlIGJ1dHRvbi5cbiAgICogICBoaWRkZW4/OiBET01Db250ZW50IC0gVGhlIGhpZGRlbiBjb250ZW50IHRvIGRpc3BsYXkgZm9yIGFuaW1hdGVkIGJ1dHRvbnMuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIiwgZTogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgbGV0IGV4dHJhID0gaXNET01Db250ZW50KHBPckMpID8gKGMgIT09IFwiXCIpID8gYyA6IGUgOiBlO1xuICAgIGxldCBjaGlsZHJlbiA9IGV4dHJhXG4gICAgICA/IFtkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidmlzaWJsZSBjb250ZW50XCIgfSB9LCBjb250ZW50KSxcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJoaWRkZW4gY29udGVudFwiIH0gfSwgZXh0cmEpXVxuICAgICAgOiBjb250ZW50O1xuICAgIHJldHVybiBwcm9wcy5ocmVmXG4gICAgICA/IGEoeyBwcm9wczogeyBocmVmOiBwcm9wcy5ocmVmLCBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBjaGlsZHJlbilcbiAgICAgIDogZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuYW5pbWF0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhbmltYXRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmVydGljYWxBbmltYXRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnRpY2FsLmFuaW1hdGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sYWJlbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGFiZWxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmlnaHRsYWJlbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmlnaHQgbGFiZWxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmJhc2ljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYmFzaWNcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmFjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubG9hZGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxvYWRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXBhY3QpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb21wYWN0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaXJjdWxhcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNpcmN1bGFyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbHVpZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsdWlkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmF0dGFjaG1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQXR0YWNobWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hdHRhY2htZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGJ1dHRvblwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9idXR0b24vaW5kZXgudHMiLCJpbXBvcnQge0RPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50fSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7ZGl2fSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbnRhaW5lciB7XG4gIC8qKlxuICAqIEEgcmVzcG9uc2l2ZSBjb250YWluZXIgY29tcG9uZW50IHRvIGhvc3Qgb3RoZXIgY29udGVudC5cbiAgKiBEb2VzIG5vdCBhY2NlcHQgYW55IHByb3BlcnRpZXMgaW4gcHJvcHMkLlxuICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPGFueSwgRE9NQ29udGVudD4pIDogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxhbnksIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0gc291cmNlcy5jb250ZW50JC5tYXAoY29udGVudCA9PiByZW5kZXIoY29udGVudCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5jb250YWluZXJcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgKiBBIHJlc3BvbnNpdmUgY29udGFpbmVyIGNvbXBvbmVudCB0byBob3N0IG90aGVyIGNvbnRlbnQuXG4gICogRG9lcyBub3QgYWNjZXB0IGFueSBwcm9wZXJ0aWVzLlxuICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBPYmplY3R8RE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIikgOiBWTm9kZSB7XG4gICAgLy8gbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQzogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInVpIGNvbnRhaW5lclwifX0sIGNvbnRlbnQpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvY29udGFpbmVyL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQge2Rpdn0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBEaXZpZGVyIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgaG9yaXpvbnRhbD86IGJvb2xlYW47XG4gICAgdmVydGljYWw/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBmaXR0ZWQ/OiBib29sZWFuO1xuICAgIGhpZGRlbj86IGJvb2xlYW47XG4gICAgc2VjdGlvbj86IGJvb2xlYW47XG4gICAgY2xlYXJpbmc/OiBib29sZWFuO1xuICAgIGhlYWRlcj86IGJvb2xlYW47XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkaXZpZGVyIGVsZW1lbnQgdG8gc2VwZXJhdGUgY29udGVudCBvbiBwYWdlLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqIFx0Y29udGVudD86IFZOb2RlIC0gVGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSBkaXZpZGVyLlxuICAgKiBcdGhvcml6b250YWw/OiBib29sZWFuIC0gTmVlZGVkIHRvIHJlbmRlciB0ZXh0IGhvcml6b250YWxseSBpbiB0aGUgZGl2aWRlci5cbiAgICogXHR2ZXJ0aWNhbD86IGJvb2xlYW4gLSBEZXRlcm1pbmVzIHZlcnRpY2FsL2hvcml6b250YWwgb3JpZW50YXRpb24gb2YgdGhlIGRpdmlkZXIuXG4gICAqIFx0aW52ZXJ0ZWQ/OiBib29sZWFuIC0gRm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqIFx0Zml0dGVkPzogYm9vbGVhbiAtIE1pbmltaXplcyB0aGUgc3BhY2UgYmV0d2VlbiBkaXZpZGVkIGNvbnRlbnQuXG4gICAqIFx0aGlkZGVuPzogYm9vbGVhbiAtIENyZWF0ZXMgYW4gaW52aXNpYmxlIGRpdmlkZXIgdGhhdCBkaXZpZGVzIHRoZSBjb250ZW50LlxuICAgKiBcdHNlY3Rpb24/OiBib29sZWFuIC0gUHJvdmlkZXMgZ3JlYXRlciBtYXJnaW5zIGZvciBiZXR3ZWVuIGRpdmlkZWQgY29udGVudC5cbiAgICogXHRjbGVhcmluZz86IGJvb2xlYW4gLSBDbGVhcnMgZmxvYXRlZCBjb250ZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSA6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQ6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5kaXZpZGVyXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkaXZpZGVyIGVsZW1lbnQgdG8gc2VwZXJhdGUgY29udGVudCBvbiBwYWdlLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogXHRjb250ZW50PzogVk5vZGUgLSBUaGUgY29udGVudCB0byBhZGQgdG8gdGhlIGRpdmlkZXIuXG4gICAqIFx0aG9yaXpvbnRhbD86IGJvb2xlYW4gLSBOZWVkZWQgdG8gcmVuZGVyIHRleHQgaG9yaXpvbnRhbGx5IGluIHRoZSBkaXZpZGVyLlxuICAgKiBcdHZlcnRpY2FsPzogYm9vbGVhbiAtIERldGVybWluZXMgdmVydGljYWwvaG9yaXpvbnRhbCBvcmllbnRhdGlvbiBvZiB0aGUgZGl2aWRlci5cbiAgICogXHRpbnZlcnRlZD86IGJvb2xlYW4gLSBGb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogXHRmaXR0ZWQ/OiBib29sZWFuIC0gTWluaW1pemVzIHRoZSBzcGFjZSBiZXR3ZWVuIGRpdmlkZWQgY29udGVudC5cbiAgICogXHRoaWRkZW4/OiBib29sZWFuIC0gQ3JlYXRlcyBhbiBpbnZpc2libGUgZGl2aWRlciB0aGF0IGRpdmlkZXMgdGhlIGNvbnRlbnQuXG4gICAqIFx0c2VjdGlvbj86IGJvb2xlYW4gLSBQcm92aWRlcyBncmVhdGVyIG1hcmdpbnMgZm9yIGJldHdlZW4gZGl2aWRlZCBjb250ZW50LlxuICAgKiBcdGNsZWFyaW5nPzogYm9vbGVhbiAtIENsZWFycyBmbG9hdGVkIGNvbnRlbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHN8RE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHtjbGFzc05hbWU6IGdldENsYXNzTmFtZShwcm9wcywgY29udGVudCkgfX0sIGNvbnRlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wczogUHJvcHMsIGNvbnRlbnQ/KSA6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMudmVydGljYWwpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ0aWNhbFwiO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGhvcml6b250YWxcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZpdHRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZpdHRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaGlkZGVuKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaGlkZGVuXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zZWN0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VjdGlvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2xlYXJpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjbGVhcmluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaGVhZGVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaGVhZGVyXCI7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBkaXZpZGVyXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2RpdmlkZXIvaW5kZXgudHMiLCJpbXBvcnQge0RPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXMsSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIEF0dGFjaG1lbnQsIEZsb2F0LCBUZXh0QWxpZ25tZW50LCBDb2xvciB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgSGVhZGVyIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgaWNvbj86IGJvb2xlYW47XG4gICAgZGl2aWRlcj86IGJvb2xlYW47XG4gICAgYmxvY2s/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudDtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBjb2xvcj86IENvbG9yO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgRXh0cmFzIHtcbiAgICBzdWJ0ZXh0PzogRE9NQ29udGVudDtcbiAgICBpY29uPzogRE9NQ29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgaGVhZGVyIGZvciBpbXBvcnRhbnQgdGV4dC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBpY29uIGhlYWRlcnMuXG4gICAqICAgZGl2aWRlcj86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGhlYWRlcnMgdG8gc2VwZXJhdGUgY29udGVudC5cbiAgICogICBibG9jaz86IGJvb2xlYW4gLSBXcmFwcyBoZWFkZXIgaW4gYSBibG9jay5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBkaXNhYmxlZCBjb250ZW50LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBTdHlsaW5nIGZvciBoZWFkZXJzIGF0dGFjaGVkIHRvIG90aGVyIGNvbnRlbnQuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIEZsb2F0cyB0aGUgaGVhZGVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGV4dCBhbGlnbm1lbnQgb2YgdGhlIGhlYWRlciB0ZXh0LlxuICAgKiAgIHNpemU/OiBTaXplIC0gRGV0ZXJtaW5lcyB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGhlYWRlci5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge30gb2ZcbiAgICogICB0ZXh0OiBET01Db250ZW50IC0gVGhlIGhlYWRlciB0ZXh0LlxuICAgKiAgIHN1YnRleHQ/OiBET01Db250ZW50LSBBbiBvcHRpb25hbCBzdWItaGVhZGVyIHRvIGFjY29tcGFueSB0aGUgaGVhZGVyLlxuICAgKiAgIGljb24/OiBET01Db250ZW50IC0gT3B0aW9uYWwgaW1hZ2UvaWNvbiBjb250ZW50IGZvciB0aGUgaGVhZGVyLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIEV4dHJhcz4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIEV4dHJhcz4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuICAgICAgc291cmNlcy5leHRyYXMkID0gc291cmNlcy5leHRyYXMkID8gc291cmNlcy5leHRyYXMkIDogeHMub2Yoe30pO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkLCBzb3VyY2VzLmV4dHJhcyQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudCwgZXh0cmFzXSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50LCBleHRyYXMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5oZWFkZXJcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoZWFkZXIgZm9yIGltcG9ydGFudCB0ZXh0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBpY29uPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgaWNvbiBoZWFkZXJzLlxuICAgKiAgIGRpdmlkZXI/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBoZWFkZXJzIHRvIHNlcGVyYXRlIGNvbnRlbnQuXG4gICAqICAgYmxvY2s/OiBib29sZWFuIC0gV3JhcHMgaGVhZGVyIGluIGEgYmxvY2suXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGluZyBmb3IgZGlzYWJsZWQgY29udGVudC5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gU3R5bGluZyBmb3IgaGVhZGVycyBhdHRhY2hlZCB0byBvdGhlciBjb250ZW50LlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBGbG9hdHMgdGhlIGhlYWRlciB0byB0aGUgbGVmdCBvciByaWdodC5cbiAgICogICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudCAtIFRleHQgYWxpZ25tZW50IG9mIHRoZSBoZWFkZXIgdGV4dC5cbiAgICogICBzaXplPzogU2l6ZSAtIERldGVybWluZXMgdGhlIHNpemUgb2YgdGhlIGhlYWRlci5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBoZWFkZXIuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IHt9IG9mXG4gICAqICAgdGV4dDogRE9NQ29udGVudCAtIFRoZSBoZWFkZXIgdGV4dC5cbiAgICogICBzdWJ0ZXh0PzogRE9NQ29udGVudC0gQW4gb3B0aW9uYWwgc3ViLWhlYWRlciB0byBhY2NvbXBhbnkgdGhlIGhlYWRlci5cbiAgICogICBpY29uPzogRE9NQ29udGVudCAtIE9wdGlvbmFsIGltYWdlL2ljb24gY29udGVudCBmb3IgdGhlIGhlYWRlci5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQ29yRTogUHJvcHMgfCBET01Db250ZW50IHwgRXh0cmFzID0ge30sIGNPckU6IERPTUNvbnRlbnQgfCBFeHRyYXMgPSB7fSwgZTogRXh0cmFzID0ge30pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckNvckUpID8ge30gOiBpc0V4dHJhcyhwT3JDb3JFKSA/IHt9IDogcE9yQ29yRTtcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDb3JFKSA/IHBPckNvckUgOiBpc0RPTUNvbnRlbnQoY09yRSkgPyBjT3JFIDogXCJcIjtcbiAgICBsZXQgZXh0cmFzID0gaXNFeHRyYXMocE9yQ29yRSkgPyBwT3JDb3JFIDogaXNFeHRyYXMoY09yRSkgPyBjT3JFIDogZTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgZXh0cmFzLmljb24gPyBleHRyYXMuaWNvbiA6IFwiXCIsXG4gICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY29udGVudFwiIH0gfSwgW10uY29uY2F0KFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBleHRyYXMuc3VidGV4dCA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJzdWIgaGVhZGVyXCIgfSB9LCBleHRyYXMuc3VidGV4dCkgOiBcIlwiXG4gICAgICApKVxuICAgIF0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmljb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpY29uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXZpZGVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGl2aWRlclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYmxvY2spIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBibG9ja1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmF0dGFjaG1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQXR0YWNobWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hdHRhY2htZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuZmxvYXQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gRmxvYXQuVG9DbGFzc25hbWUocHJvcHMuZmxvYXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy50ZXh0QWxpZ25tZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFRleHRBbGlnbm1lbnQuVG9DbGFzc25hbWUocHJvcHMudGV4dEFsaWdubWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGhlYWRlclwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V4dHJhcyhleHRyYSk6IGV4dHJhIGlzIEV4dHJhcyB7XG4gICAgcmV0dXJuIGV4dHJhICE9PSB1bmRlZmluZWQgJiYgKCg8RXh0cmFzPmV4dHJhKS5zdWJ0ZXh0ICE9PSB1bmRlZmluZWRcbiAgICAgIHx8ICgoPEV4dHJhcz5leHRyYSkuaWNvbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAoKDxFeHRyYXM+ZXh0cmEpLmljb24pICE9PSBcImJvb2xlYW5cIikpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvaGVhZGVyL2luZGV4LnRzIiwiaW1wb3J0IHsgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIFZlcnRpY2FsQWxpZ25tZW50LCBGbG9hdCB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBhLCBpbWcgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgSW1hZ2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBocmVmPzogc3RyaW5nO1xuICAgIGhpZGRlbj86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGF2YXRhcj86IGJvb2xlYW47XG4gICAgYm9yZGVyZWQ/OiBib29sZWFuO1xuICAgIHNwYWNlZD86IGJvb2xlYW47XG4gICAgY2lyY3VsYXI/OiBib29sZWFuO1xuICAgIHJvdW5kZWQ/OiBib29sZWFuO1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gICAgc2l6ZT86IFNpemU7XG4gICAgdmVydGljYWxBbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbWFnZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgaW1hZ2VzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgaHJlZj86IHN0cmluZyAtIFN0eWxlcyB0aGUgaW1hZ2UgYXMgYSBsaW5rIHRvd2FyZHMgdGhlIGxvY2F0aW9uLlxuICAgKiAgIGhpZGRlbj86IGJvb2xlYW4gLSBIaWRlcyB0aGUgaW1hZ2UuXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqICAgYXZhdGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2UgZm9yIHVzYWdlIGFzIGFuIGF2YXRhci5cbiAgICogICBib3JkZXJlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHdpdGggYSBib3JkZXIuXG4gICAqICAgc3BhY2VkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2Ugd2l0aCBleHRyYSBzcGFjaW5nIHRvIHNlcGVyYXRlIGl0IGZyb20gbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgY2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB0byBiZSBjaXJjdWxhci5cbiAgICogICByb3VuZGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2UgdG8gaGF2ZSByb3VuZGVkIGVkZ2VzLlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBUaGUgZmxvYXQgb3JpZW50YXRpb24gb2YgdGhlIGltYWdlLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGltYWdlLlxuICAgKiAgIHZlcnRpY2FsQWxpZ25tZW50PzogVmVydGljYWxBbGlnbm1lbnQgLSBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRleHQgbmVhcmJ5IHRoZSBpbWFnZS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogc3RyaW5nIC0gVGhlIHNyYyB1cmwuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIHN0cmluZz4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBzdHJpbmc+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuaW1hZ2VcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltYWdlIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBpbWFnZXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGxpbms/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSBhcyBhIGxpbmsuXG4gICAqICAgaGlkZGVuPzogYm9vbGVhbiAtIEhpZGVzIHRoZSBpbWFnZS5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBhdmF0YXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSBmb3IgdXNhZ2UgYXMgYW4gYXZhdGFyLlxuICAgKiAgIGJvcmRlcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2Ugd2l0aCBhIGJvcmRlci5cbiAgICogICBzcGFjZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB3aXRoIGV4dHJhIHNwYWNpbmcgdG8gc2VwZXJhdGUgaXQgZnJvbSBuZWFyYnkgY29udGVudC5cbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIHJvdW5kZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB0byBoYXZlIHJvdW5kZWQgZWRnZXMuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFRoZSBmbG9hdCBvcmllbnRhdGlvbiBvZiB0aGUgaW1hZ2UuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgaW1hZ2UuXG4gICAqICAgdmVydGljYWxBbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudCAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGV4dCBuZWFyYnkgdGhlIGltYWdlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBzdHJpbmcgLSBUaGUgc3JjIHVybC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBzdHJpbmcgPSB7fSwgYzogc3RyaW5nID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSB0eXBlb2YgKHBPckMpID09PSBcInN0cmluZ1wiID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gdHlwZW9mIChwT3JDKSA9PT0gXCJzdHJpbmdcIiA/IHBPckMgOiBjO1xuICAgIGxldCBpbWFnZSA9IGltZyh7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSwgc3JjOiBjb250ZW50IH0gfSk7XG4gICAgcmV0dXJuIHByb3BzLmhyZWYgPyBhKHsgcHJvcHM6IHsgaHJlZjogcHJvcHMuaHJlZiB9IH0sIGltYWdlKSA6IGltYWdlO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmhyZWYpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsaW5rXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5oaWRkZW4pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBoaWRkZW5cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmF2YXRhcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGF2YXRhclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYm9yZGVyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBib3JkZXJlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc3BhY2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3BhY2VkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaXJjdWxhcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNpcmN1bGFyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yb3VuZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcm91bmRlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMudmVydGljYWxBbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVmVydGljYWxBbGlnbm1lbnQuVG9DbGFzc25hbWUocHJvcHMudmVydGljYWxBbGlnbm1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lICsgXCIgaW1hZ2VcIjtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2ltYWdlL2luZGV4LnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vYnV0dG9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb250YWluZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RpdmlkZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2hlYWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaWNvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW1hZ2VcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xhYmVsXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saXN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9sb2FkZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NlZ21lbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N0ZXBcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RleHRib3hcIjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50IH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIEF0dGFjaG1lbnQsIENvbG9yIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBMYWJlbCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGNpcmN1bGFyPzogYm9vbGVhbjtcbiAgICBlbXB0eT86IGJvb2xlYW47XG4gICAgcG9pbnRpbmc/OiBib29sZWFuO1xuICAgIGJhc2ljPzogYm9vbGVhbjtcbiAgICBsZWZ0Q29ybmVyPzogYm9vbGVhbjtcbiAgICByaWdodENvcm5lcj86IGJvb2xlYW47XG4gICAgdGFnPzogYm9vbGVhbjtcbiAgICByaWJib24/OiBib29sZWFuO1xuICAgIGludlJpYmJvbj86IGJvb2xlYW47XG4gICAgaG9yaXpvbnRhbD86IGJvb2xlYW47XG4gICAgZmxvYXRpbmc/OiBib29sZWFuO1xuICAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50O1xuICAgIHNpemU/OiBTaXplO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIExhYmVsIGNvbXBvbmVudCB0byBhZGQgaW5mb3JtYXRpb24gdG8gY2VydGFpbiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgY2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBjaXJjdWxhci5cbiAgICogICBlbXB0eT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIGZvciBlbXB0eSBjb250ZW50LlxuICAgKiAgIHBvaW50aW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgcG9pbnRpbmcgdG93YXJkcyBuZWFyYnkgY29udGVudC5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIG1pbmltYWxpc3RpYy5cbiAgICogICBsZWZ0Q29ybmVyPzogYm9vbGVhbiAtIEF0dGFjaGVzIHRoZSBsYWJlbCB0byB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIG5lYXJieSBjb250ZW50LlxuICAgKiAgIHJpZ2h0Q29ybmVyPzogYm9vbGVhbiAtIEF0dGFjaGVzIHRoZSBsYWJlbCB0byB0aGUgdG9wLXJpZ2h0IGNvcm5lciBvZiBuZWFyYnkgY29udGVudC5cbiAgICogICB0YWc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBsb29rIGxpa2UgYSB0YWcuXG4gICAqICAgcmliYm9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gbG9vayBsaWtlIGEgcmliYm9uIG92ZXIgdGhlIGxlZnQgc2lkZSBvZiBjb250ZW50LlxuICAgKiAgIGludlJpYmJvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGxvb2sgbGlrZSBhIHJpYmJvbiBvdmVyIHRoZSByaWdodCBzaWRlIG9mIGNvbnRlbnQuXG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIGZvciBob3Jpem9udGFsIGNvbnRlbnQuXG4gICAqICAgZmxvYXRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBmbG9hdGluZyBvdmVyIG5lYXJieSBjb250ZW50LlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gV2hlcmUgdGhlIGxhYmVsIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsYWJlbC5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBsYWJlbC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBhbmQgZXh0cmFzOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG4gICAgICBzb3VyY2VzLmV4dHJhcyQgPSBzb3VyY2VzLmV4dHJhcyQgPyBzb3VyY2VzLmV4dHJhcyQgOiB4cy5vZihbXSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQsIHNvdXJjZXMuZXh0cmFzJCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50LCBleHRyYXNdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQsIGV4dHJhcylcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmxhYmVsXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMYWJlbCBjb21wb25lbnQgdG8gYWRkIGluZm9ybWF0aW9uIHRvIGNlcnRhaW4gY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgY2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBjaXJjdWxhci5cbiAgICogICBlbXB0eT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIGZvciBlbXB0eSBjb250ZW50LlxuICAgKiAgIHBvaW50aW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgcG9pbnRpbmcgdG93YXJkcyBuZWFyYnkgY29udGVudC5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIG1pbmltYWxpc3RpYy5cbiAgICogICBsZWZ0Q29ybmVyPzogYm9vbGVhbiAtIEF0dGFjaGVzIHRoZSBsYWJlbCB0byB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIG5lYXJieSBjb250ZW50LlxuICAgKiAgIHJpZ2h0Q29ybmVyPzogYm9vbGVhbiAtIEF0dGFjaGVzIHRoZSBsYWJlbCB0byB0aGUgdG9wLXJpZ2h0IGNvcm5lciBvZiBuZWFyYnkgY29udGVudC5cbiAgICogICB0YWc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBsb29rIGxpa2UgYSB0YWcuXG4gICAqICAgcmliYm9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gbG9vayBsaWtlIGEgcmliYm9uIG92ZXIgdGhlIGxlZnQgc2lkZSBvZiBjb250ZW50LlxuICAgKiAgIGludlJpYmJvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGxvb2sgbGlrZSBhIHJpYmJvbiBvdmVyIHRoZSByaWdodCBzaWRlIG9mIGNvbnRlbnQuXG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIGZvciBob3Jpem9udGFsIGNvbnRlbnQuXG4gICAqICAgZmxvYXRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBmbG9hdGluZyBvdmVyIG5lYXJieSBjb250ZW50LlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gV2hlcmUgdGhlIGxhYmVsIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsYWJlbC5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBsYWJlbC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBhbmQgZXh0cmFzOiBET01Db250ZW50XG4gICAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIsIGU6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIGxldCBkZXRhaWwgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBjIDogZTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgY29udGVudCxcbiAgICAgIGRldGFpbCA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkZXRhaWxcIiB9IH0sIGRldGFpbCkgOiBcIlwiXG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5jaXJjdWxhcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNpcmN1bGFyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lbXB0eSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGVtcHR5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wb2ludGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHBvaW50aW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5iYXNpYykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJhc2ljXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sZWZ0Q29ybmVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGVmdCBjb3JuZXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJpZ2h0Q29ybmVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmlnaHQgY29ybmVyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB0YWdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJpYmJvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJpYmJvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52UmliYm9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmlnaHQgcmliYm9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmxvYXRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbG9hdGluZyBcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGxhYmVsXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2xhYmVsL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIFZlcnRpY2FsQWxpZ25tZW50LCBGbG9hdCB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGEsIGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTGlzdCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGJ1bGxldGVkPzogYm9vbGVhbjtcbiAgICBvcmRlcmVkPzogYm9vbGVhbjtcbiAgICBob3Jpem9udGFsPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgc2VsZWN0aW9uPzogYm9vbGVhbjtcbiAgICBhbmltYXRlZD86IGJvb2xlYW47XG4gICAgcmVsYXhlZD86IGJvb2xlYW47XG4gICAgZGl2aWRlZD86IGJvb2xlYW47XG4gICAgY2VsbGVkPzogYm9vbGVhbjtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudDtcbiAgICBmbG9hdD86IEZsb2F0O1xuICB9XG4gIGV4cG9ydCB0eXBlIENvbnRlbnQgPSBBcnJheTxMaXN0SXRlbT47XG4gIGV4cG9ydCBpbnRlcmZhY2UgTGlzdEl0ZW0ge1xuICAgIGxlZnQ/OiBET01Db250ZW50O1xuICAgIGNvbnRlbnQ/OiBET01Db250ZW50O1xuICAgIGljb24/OiBET01Db250ZW50O1xuICAgIHJpZ2h0PzogRE9NQ29udGVudDtcbiAgICBoZWFkZXI/OiBET01Db250ZW50O1xuICAgIGRlc2NyaXB0aW9uPzogRE9NQ29udGVudDtcbiAgICBocmVmPzogc3RyaW5nO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTGlzdCBjb21wb25lbnQgZm9yIHNob3dpbmcgbGlzdHMgb2YgY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGJ1bGxldGVkPzogYm9vbGVhbiAtIERpc3BsYXlzIGxpc3QgYXMgYSBidWxsZXRlZCBsaXN0LlxuICAgKiAgIG9yZGVyZWQ/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBhcyBhbiBvcmRlcmVkIGxpc3QuXG4gICAqICAgbGluaz86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyB3aXRoIGxpbmtzLlxuICAgKiAgIGhvcml6b250YWw/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBob3Jpem9udGFsbHkuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGluZyBmb3IgbGlzdHMgb24gZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBzZWxlY3Rpb24/OiBib29sZWFuIC0gU3R5bGluZyBmb3IgbGlzdHMgbWVhbnQgdG8gZGlzcGxheSBhIHNlbGVjdGlvbi5cbiAgICogICBhbmltYXRlZD86IGJvb2xlYW4gLSBBZGRzIGFuIGFuaW1hdGlvbiB0byBkaXNwbGF5IGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLlxuICAgKiAgIHJlbGF4ZWQ/OiBib29sZWFuIC0gQWRkcyBtb3JlIG5lZ2F0aXZlIHNwYWNlIGFycm91bmQgdGhlIGxpc3QuXG4gICAqICAgZGl2aWRlZD86IGJvb2xlYW4gLSBBZGRzIGhvcml6b250YWwgZGl2aWRlcnMgYmV0d2VlbiBjb250ZW50IG9mIGxpc3QuXG4gICAqICAgY2VsbGVkPzogYm9vbGVhbiAtIFdyYXBzIGNvbnRlbnQgb2YgbGlzdCBpbiBjZWxscy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsaXN0IGFuZCBpdHMgY29udGVudC5cbiAgICogICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudCAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgbGlzdCdzIGNvbnRlbnQuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFdldGhlciB0aGUgbGlzdCBzaG91bGQgYmUgbGVmdCBvciByaWdodCBmbG9hdGluZy5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogQXJyYXkgb2Yge31cbiAgICogICBsZWZ0PzogRE9NQ29udGVudCAtIExlZnQgZmxvYXRlZCBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICBib2R5PzogRE9NQ29udGVudCAtIEJvZHkgY29udGVudCBmb3IgdGhlIGl0ZW0uXG4gICAqICAgcmlnaHQ/OiBET01Db250ZW50IC0gUmlnaHQgZmxvYXRlZCBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICBoZWFkZXI/OiBET01Db250ZW50IC0gTmFtZSBvZiB0aGUgbGlzdCBpdGVtXG4gICAqICAgZGVzY3JpcHRpb24/OiBET01Db250ZW50IC0gRGVzY3JpcHRpb24gb2YgdGhlIGxpc3QgaXRlbS5cbiAgICogICBocmVmPzogc3RyaW5nIC0gTGluayBmb3IgbGluayBsaXN0c1xuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmxpc3RcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgICB2YWx1ZSQ6IHhzLm5ldmVyKClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTGlzdCBjb21wb25lbnQgZm9yIHNob3dpbmcgbGlzdHMgb2YgY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGJ1bGxldGVkPzogYm9vbGVhbiAtIERpc3BsYXlzIGxpc3QgYXMgYSBidWxsZXRlZCBsaXN0LlxuICAgKiAgIG9yZGVyZWQ/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBhcyBhbiBvcmRlcmVkIGxpc3QuXG4gICAqICAgbGluaz86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyB3aXRoIGxpbmtzLlxuICAgKiAgIGhvcml6b250YWw/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBob3Jpem9udGFsbHkuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGluZyBmb3IgbGlzdHMgb24gZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBzZWxlY3Rpb24/OiBib29sZWFuIC0gU3R5bGluZyBmb3IgbGlzdHMgbWVhbnQgdG8gZGlzcGxheSBhIHNlbGVjdGlvbi5cbiAgICogICBhbmltYXRlZD86IGJvb2xlYW4gLSBBZGRzIGFuIGFuaW1hdGlvbiB0byBkaXNwbGF5IGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLlxuICAgKiAgIHJlbGF4ZWQ/OiBib29sZWFuIC0gQWRkcyBtb3JlIG5lZ2F0aXZlIHNwYWNlIGFycm91bmQgdGhlIGxpc3QuXG4gICAqICAgZGl2aWRlZD86IGJvb2xlYW4gLSBBZGRzIGhvcml6b250YWwgZGl2aWRlcnMgYmV0d2VlbiBjb250ZW50IG9mIGxpc3QuXG4gICAqICAgY2VsbGVkPzogYm9vbGVhbiAtIFdyYXBzIGNvbnRlbnQgb2YgbGlzdCBpbiBjZWxscy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsaXN0IGFuZCBpdHMgY29udGVudC5cbiAgICogICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudCAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgbGlzdCdzIGNvbnRlbnQuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFdldGhlciB0aGUgbGlzdCBzaG91bGQgYmUgbGVmdCBvciByaWdodCBmbG9hdGluZy5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogQXJyYXkgb2Yge31cbiAgICogICBsZWZ0PzogRE9NQ29udGVudCAtIExlZnQgZmxvYXRlZCBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICBib2R5PzogRE9NQ29udGVudCAtIEJvZHkgY29udGVudCBmb3IgdGhlIGl0ZW0uXG4gICAqICAgcmlnaHQ/OiBET01Db250ZW50IC0gUmlnaHQgZmxvYXRlZCBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICBoZWFkZXI/OiBET01Db250ZW50IC0gTmFtZSBvZiB0aGUgbGlzdCBpdGVtXG4gICAqICAgZGVzY3JpcHRpb24/OiBET01Db250ZW50IC0gRGVzY3JpcHRpb24gb2YgdGhlIGxpc3QgaXRlbS5cbiAgICogICBocmVmPzogc3RyaW5nIC0gTGluayBmb3IgbGluayBsaXN0c1xuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IENvbnRlbnQgPSB7fSwgYzogQ29udGVudCA9IFtdKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IChwT3JDIGluc3RhbmNlb2YgQXJyYXkpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gKHBPckMgaW5zdGFuY2VvZiBBcnJheSkgPyBwT3JDIDogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSxcbiAgICAgIGNvbnRlbnQubWFwKCh7aGVhZGVyLCBpY29uLCBjb250ZW50LCBkZXNjcmlwdGlvbiwgaHJlZiwgbGVmdCwgcmlnaHR9KSA9PiB7XG4gICAgICAgIGxldCBsID0gbGVmdCA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJsZWZ0IGZsb2F0ZWQgY29udGVudFwiIH0gfSwgbGVmdCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByID0gcmlnaHQgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwicmlnaHQgZmxvYXRlZCBjb250ZW50XCIgfSB9LCByaWdodCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBoID0gaGVhZGVyID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImhlYWRlclwiIH0gfSwgaGVhZGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGQgPSBkZXNjcmlwdGlvbiA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkZXNjcmlwdGlvblwiIH0gfSwgZGVzY3JpcHRpb24pIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgaSA9IGljb24gPyBpY29uIDogXCJcIjtcbiAgICAgICAgbGV0IGMgPSBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY29udGVudFwiIH0gfSxcbiAgICAgICAgICBbXS5jb25jYXQoaCwgZCwgY29udGVudClcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10uY29uY2F0KGwsIGksIGMsIHIpO1xuICAgICAgICByZXR1cm4gaHJlZlxuICAgICAgICAgID8gYSh7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJpdGVtXCIgfSB9LCB7IHByb3BzOiB7IGhyZWY6IGhyZWYgfSB9LCBjaGlsZHJlbilcbiAgICAgICAgICA6IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJpdGVtXCIgfSB9LCBjaGlsZHJlbik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5idWxsZXRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJ1bGxldGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5vcmRlcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgb3JkZXJlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGhvcml6b250YWxcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNlbGVjdGlvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNlbGVjdGlvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYW5pbWF0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhbmltYXRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmVsYXhlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJlbGF4ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpdmlkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXZpZGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jZWxsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjZWxsZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVmVydGljYWxBbGlnbm1lbnQuVG9DbGFzc25hbWUocHJvcHMuYWxpZ25tZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuZmxvYXQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gRmxvYXQuVG9DbGFzc25hbWUocHJvcHMuZmxvYXQpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgbGlzdFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9saXN0L2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnQgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzLCB7IFN0cmVhbSB9IGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeyBEaW1tZXIgfSBmcm9tIFwibW9kdWxlcy9kaW1tZXJcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBMb2FkZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICB0eXBlOiBMb2FkZXJUeXBlO1xuICAgIGVsZW1lbnQ/OiBTdHJlYW08Vk5vZGU+O1xuICAgIG9uJD86IFN0cmVhbTxib29sZWFuPjtcbiAgICBjZW50ZXJlZD86IGJvb2xlYW47XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgaW5kZXRlcm1pbmF0ZT86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIHRleHQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICB9XG4gIC8qKlxuICAgKiBBIGxvYWRlciBjb21wb25lbnQgdG8gc2hvdyB0aGF0IGNlcnRhaW4gY29udGVudCBvciBhIHBhZ2UgaXMgbG9hZGluZy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIHR5cGU6IExvYWRlclR5cGUgLSBUaGUgdHlwZSBvZiBsb2FkZXIgdG8gdXNlLiBTZWUgZXhwb3J0ZWQgZW51bS5cbiAgICogICBlbGVtZW50PzogU3RyZWFtPFZOb2RlPiAtIFRoZSBlbGVtZW50IHRvIG1hcmsgYXMgbG9hZGVkLiAoT25seSB1c2VkIGZvciB0eXBlLkNvbnRlbnQpXG4gICAqICAgb24kOiBTdHJlYW08Ym9vbGVhbj4gLSBXaGVuIHRvIHNob3cvaGlkZSB0aGUgbG9hZGVyLiAoTm90IHVzZWQgZm9yIGlubGluZSwgYWRkIGRpc2FibGVkIHByb3BlcnR5IGluc3RlYWQuKVxuICAgKiAgIGNlbnRlcmVkPzogYm9vbGVhbiAtIENlbnRlcnMgdGhlIGxvYWRlciBzcGlubmVyIGluIGl0cyBwYXJlbnQgY29tcG9uZW50LlxuICAgKiAgIGFjdGl2ZT86IGJvb2xlYW4gLSBBbHdheXMgc2hvd3MgdGhlIGxvYWRlci5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBBbHdheXMgaGlkZXMgdGhlIGxvYWRlci5cbiAgICogICBpbmRldGVybWluYXRlPzogYm9vbGVhbiAtIE1ha2VzIHRoZSBsb2FkZXIgc3BpbiBpbmRpY2F0ZSBpdHMgdW5zdXJlIG9mIGhvdyBsb25nIGEgdGFzayB3aWxsIHRha2UuXG4gICAqICAgdGV4dD86IGJvb2xlYW4gLSBQb3NpdGlvbnMgdGhlIGxvYWRlciB0byBsZWF2ZSBzcGFjZSBmb3IgdGV4dC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsb2FkZXIuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQgb2Y6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2YoeyB0eXBlOiBMb2FkZXJUeXBlLklubGluZSB9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCBwcm9wcyQgPSBzb3VyY2VzLnByb3BzJC5yZW1lbWJlcigpO1xuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShwcm9wcyQsIHNvdXJjZXMuY29udGVudCQpXG4gICAgICAgIC5tYXAoKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICAgKTtcbiAgICAgIGNvbnN0IG9uJCA9IHByb3BzJC5tYXAocHJvcHMgPT4gcHJvcHMub24kKS5mbGF0dGVuKCk7XG4gICAgICBjb25zdCB0YXJnZXQkID0gcHJvcHMkLm1hcChwcm9wcyA9PiBwcm9wcy50eXBlID09PSBMb2FkZXJUeXBlLlBhZ2UgPyB4cy5vZihcInBhZ2VcIikgOiBwcm9wcy5lbGVtZW50KS5mbGF0dGVuKCk7XG4gICAgICBjb25zdCBkaW1tZXIgPSBEaW1tZXIucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgYXJncyQ6IG9uJCwgdGFyZ2V0JCwgY29udGVudCQ6IHZUcmVlJCB9LCBwcm9wcyQubWFwKHByb3BzID0+IHByb3BzLmludmVydGVkKSk7XG4gICAgICBjb25zdCByZXN1bHQkID0gcHJvcHMkLm1hcChcbiAgICAgICAgcHJvcHMgPT4gcHJvcHMudHlwZSA9PT0gTG9hZGVyVHlwZS5JbmxpbmUgPyB2VHJlZSQgOiBkaW1tZXIuRE9NXG4gICAgICApLmZsYXR0ZW4oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogcmVzdWx0JCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmxvYWRlclwiKS5ldmVudHModHlwZSksXG4gICAgICAgIHZhbHVlJDogeHMubmV2ZXIoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbG9hZGVyIGNvbXBvbmVudCB0byBzaG93IHRoYXQgY2VydGFpbiBjb250ZW50IG9yIGEgcGFnZSBpcyBsb2FkaW5nLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICB0eXBlOiBMb2FkZXJUeXBlIC0gVGhlIHR5cGUgb2YgbG9hZGVyIHRvIHVzZS4gU2VlIGV4cG9ydGVkIGVudW0uXG4gICAqICAgZWxlbWVudD86IFN0cmVhbTxWTm9kZT4gLSBUaGUgZWxlbWVudCB0byBtYXJrIGFzIGxvYWRlZC4gKE9ubHkgdXNlZCBmb3IgdHlwZS5Db250ZW50KVxuICAgKiAgIG9uJDogU3RyZWFtPGJvb2xlYW4+IC0gV2hlbiB0byBzaG93L2hpZGUgdGhlIGxvYWRlci4gKE5vdCB1c2VkIGZvciBpbmxpbmUsIGFkZCBkaXNhYmxlZCBwcm9wZXJ0eSBpbnN0ZWFkLilcbiAgICogICBjZW50ZXJlZD86IGJvb2xlYW4gLSBDZW50ZXJzIHRoZSBsb2FkZXIgc3Bpbm5lciBpbiBpdHMgcGFyZW50IGNvbXBvbmVudC5cbiAgICogICBhY3RpdmU/OiBib29sZWFuIC0gQWx3YXlzIHNob3dzIHRoZSBsb2FkZXIuXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gQWx3YXlzIGhpZGVzIHRoZSBsb2FkZXIuXG4gICAqICAgaW5kZXRlcm1pbmF0ZT86IGJvb2xlYW4gLSBNYWtlcyB0aGUgbG9hZGVyIHNwaW4gaW5kaWNhdGUgaXRzIHVuc3VyZSBvZiBob3cgbG9uZyBhIHRhc2sgd2lsbCB0YWtlLlxuICAgKiAgIHRleHQ/OiBib29sZWFuIC0gUG9zaXRpb25zIHRoZSBsb2FkZXIgdG8gbGVhdmUgc3BhY2UgZm9yIHRleHQuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgbG9hZGVyLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt0eXBlOiBMb2FkZXJUeXBlLlBhZ2V9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlW10ge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHsgdHlwZTogTG9hZGVyVHlwZS5QYWdlIH0gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIFtkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBjb250ZW50KV07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuYWN0aXZlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYWN0aXZlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jZW50ZXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNlbnRlcmVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbmRldGVybWluYXRlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW5kZXRlcm1pbmF0ZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGV4dCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRleHRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gTG9hZGVyVHlwZS5Ub0NsYXNzbmFtZShwcm9wcy50eXBlKTtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG4gIGV4cG9ydCBlbnVtIExvYWRlclR5cGUge1xuICAgIElubGluZSwgUGFnZSwgQ29udGVudFxuICB9XG4gIGV4cG9ydCBuYW1lc3BhY2UgTG9hZGVyVHlwZSB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKHR5cGU6IExvYWRlclR5cGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIExvYWRlclR5cGUuSW5saW5lOiByZXR1cm4gXCIgaW5saW5lIGxvYWRlclwiO1xuICAgICAgICBjYXNlIExvYWRlclR5cGUuUGFnZTogcmV0dXJuIFwiIGxvYWRlclwiO1xuICAgICAgICBjYXNlIExvYWRlclR5cGUuQ29udGVudDogcmV0dXJuIFwiIGxvYWRlclwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2xvYWRlci9pbmRleC50cyIsImltcG9ydCB7XG4gIERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLFxuICBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50XG59IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgQXR0YWNobWVudCwgRmxvYXQsIFRleHRBbGlnbm1lbnQgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFNlZ21lbnQge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICByYWlzZWQ/OiBib29sZWFuO1xuICAgIHN0YWNrZWQ/OiBib29sZWFuO1xuICAgIHRhbGxTdGFja2VkPzogYm9vbGVhbjtcbiAgICBwaWxlZD86IGJvb2xlYW47XG4gICAgdmVydGljYWw/OiBib29sZWFuO1xuICAgIGxvYWRpbmc/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBwYWRkZWQ/OiBib29sZWFuO1xuICAgIHZlcnlQYWRkZWQ/OiBib29sZWFuO1xuICAgIGNvbXBhY3Q/OiBib29sZWFuO1xuICAgIGNpcmN1bGFyPzogYm9vbGVhbjtcbiAgICBjbGVhcmluZz86IGJvb2xlYW47XG4gICAgYmFzaWM/OiBib29sZWFuO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNlZ21lbnQgY29tcG9uZW50IHRvIGRpdmlkZSB1cCBwYWdlIGNvbnRlbnQgaW50byBzZWdtZW50cy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIHJhaXNlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGFwcGVhciBmbG9hdGluZyBhYm92ZSBuZWFyYnkgY29udGVudC5cbiAgICogICBzdGFja2VkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGxpa2UgYSBzdGFjayBvZiBwYXBlcnMuXG4gICAqICAgdGFsbFN0YWNrZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgbGlrZSBhIHRhbGwgc3RhY2sgb2YgcGFwZXJzLlxuICAgKiAgIHBpbGVkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGxpa2UgYSBwaWxlIG9mIHBhcGVycy5cbiAgICogICB2ZXJ0aWNhbD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IGNvbnRlbnQgdG8gYmUgYWxpZ25lZCBhcyBwYXJ0IG9mIGEgdmVydGljYWwgZ3JvdXAuXG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHdpdGggYSBsb2FkaW5nIGljb24uXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCBmb3IgZGFyayBjb250ZW50LlxuICAgKiAgIHBhZGRlZD86IGJvb2xlYW4/IC0gSW5jcmVhc2VzIHRoZSBwYWRkaW5nIG9uIHRoZSBzZWdtZW50LlxuICAgKiAgIHZlcnlQYWRkZWQ/OiBib29sZWFuIC0gSW5jcmVhc2VzIHRoZSBwYWRkaW5nIG9uIHRoZSBzZWdtZW50IGJ5IGEgbG90LlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gTWFrZXMgdGhlIHNlZ21lbnQgdGFrZSB1cCBvbmx5IHRoZSBzcGFjZSBuZWVkZWQgYnkgaXRzIGNvbnRlbnQuXG4gICAqICAgY2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIGNsZWFyaW5nPzogYm9vbGVhbiAtIENsZWFycyBmbG9hdGVkIGNvbnRlbnQuXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gUmVtb3ZlcyBhbnkgc3BlY2lhbCBzdHlsaW5nLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHNlZ21lbnQuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBUaGUgYXR0YWNobWVudCBvZiB0aGUgc2VnbWVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2hlcmUgdGhlIHNlZ21lbnQgc2hvdWxkIGZsb2F0LlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGhlIHRleHQgYWxpZ25tZW50IG9mIHRoZSBzZWdtZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5zZWdtZW50XCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2VnbWVudCBjb21wb25lbnQgdG8gZGl2aWRlIHVwIHBhZ2UgY29udGVudCBpbnRvIHNlZ21lbnRzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICByYWlzZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgZmxvYXRpbmcgYWJvdmUgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgc3RhY2tlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGFwcGVhciBsaWtlIGEgc3RhY2sgb2YgcGFwZXJzLlxuICAgKiAgIHRhbGxTdGFja2VkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGxpa2UgYSB0YWxsIHN0YWNrIG9mIHBhcGVycy5cbiAgICogICBwaWxlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGFwcGVhciBsaWtlIGEgcGlsZSBvZiBwYXBlcnMuXG4gICAqICAgdmVydGljYWw/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCBjb250ZW50IHRvIGJlIGFsaWduZWQgYXMgcGFydCBvZiBhIHZlcnRpY2FsIGdyb3VwLlxuICAgKiAgIGxvYWRpbmc/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB3aXRoIGEgbG9hZGluZyBpY29uLlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgZm9yIGRhcmsgY29udGVudC5cbiAgICogICBwYWRkZWQ/OiBib29sZWFuPyAtIEluY3JlYXNlcyB0aGUgcGFkZGluZyBvbiB0aGUgc2VnbWVudC5cbiAgICogICB2ZXJ5UGFkZGVkPzogYm9vbGVhbiAtIEluY3JlYXNlcyB0aGUgcGFkZGluZyBvbiB0aGUgc2VnbWVudCBieSBhIGxvdC5cbiAgICogICBjb21wYWN0PzogYm9vbGVhbiAtIE1ha2VzIHRoZSBzZWdtZW50IHRha2UgdXAgb25seSB0aGUgc3BhY2UgbmVlZGVkIGJ5IGl0cyBjb250ZW50LlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBiZSBjaXJjdWxhci5cbiAgICogICBjbGVhcmluZz86IGJvb2xlYW4gLSBDbGVhcnMgZmxvYXRlZCBjb250ZW50LlxuICAgKiAgIGJhc2ljPzogYm9vbGVhbiAtIFJlbW92ZXMgYW55IHNwZWNpYWwgc3R5bGluZy5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBzZWdtZW50LlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gVGhlIGF0dGFjaG1lbnQgb2YgdGhlIHNlZ21lbnQuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFdoZXJlIHRoZSBzZWdtZW50IHNob3VsZCBmbG9hdC5cbiAgICogICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudCAtIFRoZSB0ZXh0IGFsaWdubWVudCBvZiB0aGUgc2VnbWVudC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCA6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBjb250ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnJhaXNlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJhaXNlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc3RhY2tlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHN0YWNrZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRhbGxTdGFja2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdGFsbCBzdGFja2VkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5waWxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHBpbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ0aWNhbCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnRpY2FsXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sb2FkaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbG9hZGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucGFkZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcGFkZGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ5UGFkZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVyeSBwYWRkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXBhY3QpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb21wYWN0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaXJjdWxhcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNpcmN1bGFyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jbGVhcmluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNsZWFyaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5iYXNpYykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJhc2ljXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnRleHRBbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVGV4dEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy50ZXh0QWxpZ25tZW50KTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIHNlZ21lbnRcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvc2VnbWVudC9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplLCBBdHRhY2htZW50IH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeyBudW1Ub1RleHQgfSBmcm9tIFwidXRpbHNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYsIGEgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFN0ZXBzIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgbGluaz86IGJvb2xlYW47XG4gICAgdmVydGljYWw/OiBib29sZWFuO1xuICAgIHN0YWNrYWJsZT86IGJvb2xlYW47XG4gICAgZXZlbmx5RGl2aWRlZD86IGJvb2xlYW47XG4gICAgZmx1aWQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50O1xuICB9XG4gIGV4cG9ydCB0eXBlIENvbnRlbnQgPSBBcnJheTxTdGVwSXRlbT47XG4gIGV4cG9ydCBpbnRlcmZhY2UgU3RlcEl0ZW0ge1xuICAgIGljb24/OiBET01Db250ZW50O1xuICAgIGhlYWRlcj86IERPTUNvbnRlbnQ7XG4gICAgZGVzY3JpcHRpb24/OiBET01Db250ZW50O1xuICAgIGlzQ29tcGxldGVkPzogYm9vbGVhbjtcbiAgICBpc0FjdGl2ZT86IGJvb2xlYW47XG4gICAgaXNEaXNhYmxlZD86IGJvb2xlYW47XG4gICAgbGluaz86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQSBzdGVwcyBjb21wb25lbnQgdG8gc2hvdyB0aGUgY29tcGxldGlvbiBzdGF0dXMgb2YgYSBzZXJpZXMgb2YgYWN0aXZpdGllcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgbGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdG8gc3RlcHMgdG8gZGlzcGxheSBhcyBhIGxpbmsuXG4gICAqIFx0dmVydGljYWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGVwcyB0byBhbGlnbiB2ZXJ0aWNhbGx5LlxuICAgKiBcdHN0YWNrYWJsZT86IGJvb2xlYW4gLSBMZXRzIHRoZSBzdGVwcyByZWFsaWduIHZlcnRpY2FsbHkgb24gc21hbGxlciBzY3JlZW5zLlxuICAgKiBcdGV2ZW5seURpdmlkZWQ/OiBib29sZWFuIC0gQXJyYW5nZXMgdGhlIHN0ZXBzIHRvIHRha2UgdXAgZXF1YWwgYW1vdW50IG9mIHdpZHRoIG9mIHRoZWlyIHBhcmVudC5cbiAgICogXHRmbHVpZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0ZXBzIHRvIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgdGhlaXIgcGFyZW50LlxuICAgKiBcdHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHN0ZXBzLlxuICAgKiBcdGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gU3R5bGVzIHRoZSBzdGVwcyB0byBhcHBlYXIgYXR0YWNoZWQgdG8gbmVhcmJ5IGNvbnRlbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IEFycmF5IG9mIHt9XG4gICAqIFx0aWNvbj86IERPTUNvbnRlbnQgVGhlIGljb24gdG8gdXNlIGZvciB0aGUgc3RlcC5cbiAgICogXHRoZWFkZXI/OiBET01Db250ZW50IC0gVGhlIHRpdGxlIGZvciB0aGUgc3RlcC5cbiAgICogXHRkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQgLSBUaGUgZGVzY3JpcHRpb24gZm9yIHRoZSBzdGVwLlxuICAgKiBcdGlzQ29tcGxldGVkPzogYm9vbGVhbiAtIE1hcmtzIHRoZSBzdGVwIGFzIGNvbXBsZXRlZC5cbiAgICogXHRpc0FjdGl2ZT86IGJvb2xlYW4gLSBNYXJrcyB0aGUgc3RlcCBhcyB0aGUgY3VycmVudCBzdGVwLlxuICAgKiBcdGlzRGlzYWJsZWQ/OiBib29sZWFuIC0gTWFya3MgdGhlIHN0ZXAgYXMgZGlzYWJsZWQuXG4gICAqICBsaW5rPzogYm9vbGVhbiAtIFN0eWxlIHRoZSBzdGVwIHRvIGJlIGNsaWNrYWJsZS5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoW10pO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnN0ZXBcIikuZXZlbnRzKHR5cGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogZXZ0LFxuICAgICAgICB2YWx1ZSQ6IHhzLm5ldmVyKClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0ZXBzIGNvbXBvbmVudCB0byBzaG93IHRoZSBjb21wbGV0aW9uIHN0YXR1cyBvZiBhIHNlcmllcyBvZiBhY3Rpdml0aWVzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogIGxpbms/OiBib29sZWFuIC0gU3R5bGVzIHRvIHN0ZXBzIHRvIGRpc3BsYXkgYXMgYSBsaW5rLlxuICAgKiBcdHZlcnRpY2FsPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc3RlcHMgdG8gYWxpZ24gdmVydGljYWxseS5cbiAgICogXHRzdGFja2FibGU/OiBib29sZWFuIC0gTGV0cyB0aGUgc3RlcHMgcmVhbGlnbiB2ZXJ0aWNhbGx5IG9uIHNtYWxsZXIgc2NyZWVucy5cbiAgICogXHRldmVubHlEaXZpZGVkPzogYm9vbGVhbiAtIEFycmFuZ2VzIHRoZSBzdGVwcyB0byB0YWtlIHVwIGVxdWFsIGFtb3VudCBvZiB3aWR0aCBvZiB0aGVpciBwYXJlbnQuXG4gICAqIFx0Zmx1aWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGVwcyB0byB0YWtlIHVwIHRoZSBmdWxsIHdpZHRoIG9mIHRoZWlyIHBhcmVudC5cbiAgICogXHRzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBzdGVwcy5cbiAgICogXHRhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFN0eWxlcyB0aGUgc3RlcHMgdG8gYXBwZWFyIGF0dGFjaGVkIHRvIG5lYXJieSBjb250ZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiBcdGljb24/OiBET01Db250ZW50IFRoZSBpY29uIHRvIHVzZSBmb3IgdGhlIHN0ZXAuXG4gICAqIFx0aGVhZGVyPzogRE9NQ29udGVudCAtIFRoZSB0aXRsZSBmb3IgdGhlIHN0ZXAuXG4gICAqIFx0ZGVzY3JpcHRpb24/OiBET01Db250ZW50IC0gVGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgc3RlcC5cbiAgICogXHRpc0NvbXBsZXRlZD86IGJvb2xlYW4gLSBNYXJrcyB0aGUgc3RlcCBhcyBjb21wbGV0ZWQuXG4gICAqIFx0aXNBY3RpdmU/OiBib29sZWFuIC0gTWFya3MgdGhlIHN0ZXAgYXMgdGhlIGN1cnJlbnQgc3RlcC5cbiAgICogXHRpc0Rpc2FibGVkPzogYm9vbGVhbiAtIE1hcmtzIHRoZSBzdGVwIGFzIGRpc2FibGVkLlxuICAgKiAgbGluaz86IGJvb2xlYW4gLSBTdHlsZSB0aGUgc3RlcCB0byBiZSBjbGlja2FibGUuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgQ29udGVudCA9IHt9LCBjOiBDb250ZW50ID0gW10pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gcE9yQyBpbnN0YW5jZW9mIEFycmF5ID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gcE9yQyBpbnN0YW5jZW9mIEFycmF5ID8gcE9yQyA6IGM7XG4gICAgbGV0IGNoaWxkcmVuID0gY29udGVudC5tYXAoKHtpY29uLCBoZWFkZXIsIGRlc2NyaXB0aW9uLCBpc0NvbXBsZXRlZCwgaXNBY3RpdmUsIGlzRGlzYWJsZWQsIGxpbmt9LCBpKSA9PlxuICAgICAgcHJvcHMubGlua1xuICAgICAgICA/IGEoeyBwcm9wczogeyBpZDogaSwgY2xhc3NOYW1lOiBnZXRTdGVwQ2xhc3NuYW1lKGlzQ29tcGxldGVkLCBpc0FjdGl2ZSwgaXNEaXNhYmxlZCwgbGluaykgfSB9LCBbXG4gICAgICAgICAgaWNvbixcbiAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY29udGVudFwiIH0gfSwgW1xuICAgICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInRpdGxlXCIgfSB9LCBoZWFkZXIpLFxuICAgICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImRlc2NyaXB0aW9uXCIgfSB9LCBkZXNjcmlwdGlvbilcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgICA6IGRpdih7IHByb3BzOiB7IGlkOiBpLCBjbGFzc05hbWU6IGdldFN0ZXBDbGFzc25hbWUoaXNDb21wbGV0ZWQsIGlzQWN0aXZlLCBpc0Rpc2FibGVkLCBsaW5rKSB9IH0sIFtcbiAgICAgICAgICBpY29uLFxuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBbXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidGl0bGVcIiB9IH0sIGhlYWRlciksXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiZGVzY3JpcHRpb25cIiB9IH0sIGRlc2NyaXB0aW9uKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgKTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMsIGNvbnRlbnQubGVuZ3RoKSB9IH0sIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0ZXBDbGFzc25hbWUoaXNDb21wbGV0ZWQ/OiBib29sZWFuLCBpc0FjdGl2ZT86IGJvb2xlYW4sIGlzRGlzYWJsZWQ/OiBib29sZWFuLCBsaW5rPzogYm9vbGVhbikge1xuICAgIGxldCBjbGFzc05hbWUgPSBcIlwiO1xuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiYWN0aXZlXCI7XG4gICAgfVxuICAgIGlmIChpc0NvbXBsZXRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXBsZXRlZFwiO1xuICAgIH1cbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChsaW5rKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGlua1wiO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgc3RlcFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcywgbGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnN0YWNrYWJsZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHN0YWNrYWJsZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmx1aWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbHVpZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZXZlbmx5RGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChsZW5ndGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmF0dGFjaG1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQXR0YWNobWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hdHRhY2htZW50KTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIHN0ZXBzXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL3N0ZXAvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSVZhbHVlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgU2l6ZSB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiwgaW5wdXQsIHRleHRhcmVhIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBUZXh0Ym94IHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgaW5pdGlhbD86IHN0cmluZztcbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICBpY29uPzogYm9vbGVhbjtcbiAgICBsYWJlbGVkPzogYm9vbGVhbjtcbiAgICBhY3Rpb24/OiBib29sZWFuO1xuICAgIGxlZnRDb250ZW50PzogYm9vbGVhbjtcbiAgICByaWdodENvbnRlbnQ/OiBib29sZWFuO1xuICAgIHRyYW5zcGFyZW50PzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgZm9jdXM/OiBib29sZWFuO1xuICAgIGxvYWRpbmc/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBsYXJnZT86IGJvb2xlYW47XG4gICAgdHlwZT86IHN0cmluZztcbiAgICBjb2xvcj86IENvbG9yO1xuICAgIHNpemU/OiBTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdGV4dGJveCBjb21wb25lbnQgZm9yIGNhcHR1cmluZyB1c2VyIGlucHV0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgaW5pdGlhbD86IHN0cmluZyAtIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIHBsYWNlaG9sZGVyPzogc3RyaW5nIC0gVGhlIHBsYWNlaG9sZGVyIHRleHQgb2YgdGhlIHRleHRib3guXG4gICAqICAgaWNvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggZm9yIGRpc3BsYXlpbmcgYW4gaWNvbiBpbiB0aGUgdGV4dGJveC5cbiAgICogICBsYWJlbGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGlzcGxheWluZyBhIGxhYmVsIGluIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGFjdGlvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggZm9yIGRpc3BsYXlpbmcgYW4gYWN0aW9uIGNvbXBvbmVudCBpbiB0aGUgdGV4dGJveC5cbiAgICogICBsZWZ0Q29udGVudD86IGJvb2xlYW4gLSBBZGRzIGNvbnRlbnQgdG8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dGJveC5cbiAgICogICByaWdodENvbnRlbnQ/OiBib29sZWFuIC0gQWRkcyBjb250ZW50IHRvIHRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIHRyYW5zcGFyZW50PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCB0byBhcHBlYXIgdHJhbnNwYXJlbnQuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkYXJrZXIgYmFja2dyb3VuZHMuXG4gICAqICAgZm9jdXM/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IHRvIHNob3cgaXQgaGFzIGZvY3VzLlxuICAgKiAgIGxvYWRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IHdpdGggYSBsb2FkaW5nIGljb24uXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHRleHRib3guXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJVmFsdWVDb21wb25lbnRTaW5rczxzdHJpbmc+IHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgZXZ0ID0gKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5pbnB1dFwiKS5ldmVudHModHlwZSk7XG4gICAgICBjb25zdCBwcm9wcyQgPSBzb3VyY2VzLnByb3BzJC5yZW1lbWJlcigpO1xuICAgICAgLy8gY29uc3QgaW5pdGlhbFZhbHVlJCA9IHByb3BzJC5tYXAocHJvcHMgPT4gcHJvcHMuaW5pdGlhbCk7XG4gICAgICBjb25zdCBuZXdWYWx1ZSQgPSBldnQoXCJpbnB1dFwiKS5tYXAoZXYgPT4gKGV2LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSkucmVtZW1iZXIoKTtcbiAgICAgIC8vIGNvbnN0IHZhbHVlJCA9IHhzLm1lcmdlKGluaXRpYWxWYWx1ZSQsIG5ld1ZhbHVlJCk7XG4gICAgICBjb25zdCB2dHJlZSQgPSB4cy5jb21iaW5lKHByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2dHJlZSQsXG4gICAgICAgIEV2ZW50czogZXZ0LFxuICAgICAgICB2YWx1ZSQ6IG5ld1ZhbHVlJFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdGV4dGJveCBjb21wb25lbnQgZm9yIGNhcHR1cmluZyB1c2VyIGlucHV0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBpbml0aWFsPzogc3RyaW5nIC0gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHRleHRib3guXG4gICAqICAgcGxhY2Vob2xkZXI/OiBzdHJpbmcgLSBUaGUgcGxhY2Vob2xkZXIgdGV4dCBvZiB0aGUgdGV4dGJveC5cbiAgICogICBpY29uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGlzcGxheWluZyBhbiBpY29uIGluIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGxhYmVsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkaXNwbGF5aW5nIGEgbGFiZWwgaW4gdGhlIHRleHRib3guXG4gICAqICAgYWN0aW9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGlzcGxheWluZyBhbiBhY3Rpb24gY29tcG9uZW50IGluIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGxlZnRDb250ZW50PzogYm9vbGVhbiAtIEFkZHMgY29udGVudCB0byB0aGUgbGVmdCBzaWRlIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIHJpZ2h0Q29udGVudD86IGJvb2xlYW4gLSBBZGRzIGNvbnRlbnQgdG8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRleHRib3guXG4gICAqICAgdHJhbnNwYXJlbnQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IHRvIGFwcGVhciB0cmFuc3BhcmVudC5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggZm9yIGRhcmtlciBiYWNrZ3JvdW5kcy5cbiAgICogICBmb2N1cz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gc2hvdyBpdCBoYXMgZm9jdXMuXG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggd2l0aCBhIGxvYWRpbmcgaWNvbi5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHRleHRib3guXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGV4dGJveC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgbGV0IHRleHRib3ggPSBwcm9wcy5sYXJnZVxuICAgICAgPyB0ZXh0YXJlYSh7IHByb3BzOiB7IHZhbHVlOiBwcm9wcy5pbml0aWFsLCBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXIgfSB9KVxuICAgICAgOiBpbnB1dCh7IHByb3BzOiB7IHR5cGU6IHByb3BzLnR5cGUgPyBwcm9wcy50eXBlIDogXCJ0ZXh0XCIsIHZhbHVlOiBwcm9wcy5pbml0aWFsLCBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXIgfSB9KTtcbiAgICByZXR1cm4gcHJvcHMucmlnaHRDb250ZW50XG4gICAgICA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIFtcbiAgICAgICAgdGV4dGJveCxcbiAgICAgICAgY29udGVudFxuICAgICAgXSlcbiAgICAgIDogZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgICBjb250ZW50LFxuICAgICAgICB0ZXh0Ym94XG4gICAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmxlZnRDb250ZW50KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGVmdFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmlnaHRDb250ZW50KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmlnaHRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmljb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpY29uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sYWJlbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGFiZWxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYWN0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYWN0aW9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50cmFuc3BhcmVudCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRyYW5zcGFyZW50XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mb2N1cykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZvY3VzXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sb2FkaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbG9hZGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGlucHV0XCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL3RleHRib3gvaW5kZXgudHMiLCJleHBvcnQgbmFtZXNwYWNlIEljb25UeXBlIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKHR5cGU6IEljb25UeXBlKSB7XG4gICAgaWYgKHR5cGUgPCAwKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgdmFyIG5hbWUgPSBJY29uVHlwZVt0eXBlXTtcbiAgICByZXR1cm4gXCIgXCIgKyBuYW1lLm1hdGNoKC9bQS1aXVthLXpdKy9nKS5qb2luKFwiIFwiKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBHZXROYW1lcygpIHtcbiAgICB2YXIgbmFtZXM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yKHZhciBuIGluIEljb25UeXBlKSB7XG4gICAgICBpZih0eXBlb2YgSWNvblR5cGVbbl0gPT09ICdudW1iZXInKSBuYW1lcy5wdXNoKG4pO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXM7XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gSWNvblR5cGUge1xuICBTZWFyY2gsXG4gIE1haWxPdXRsaW5lLFxuICBFeHRlcm5hbCxcbiAgU2lnbmFsLFxuICBTZXR0aW5nLFxuICBIb21lLFxuICBJbmJveCxcbiAgQnJvd3NlcixcbiAgVGFnLFxuICBUYWdzLFxuICBDYWxlbmRhcixcbiAgQ29tbWVudCxcbiAgQ29tbWVudHMsXG4gIFNob3AsXG4gIFByaXZhY3ksXG4gIFNldHRpbmdzLFxuICBUcm9waHksXG4gIFBheW1lbnQsXG4gIEZlZWQsXG4gIEFsYXJtT3V0bGluZSxcbiAgVGFza3MsXG4gIENsb3VkLFxuICBMYWIsXG4gIE1haWwsXG4gIElkZWEsXG4gIERhc2hib2FyZCxcbiAgU2l0ZW1hcCxcbiAgQWxhcm0sXG4gIFRlcm1pbmFsLFxuICBDb2RlLFxuICBQcm90ZWN0LFxuICBDYWxlbmRhck91dGxpbmUsXG4gIFRpY2tldCxcbiAgRXh0ZXJuYWxTcXVhcmUsXG4gIE1hcCxcbiAgQnVnLFxuICBNYWlsU3F1YXJlLFxuICBIaXN0b3J5LFxuICBPcHRpb25zLFxuICBDb21tZW50T3V0bGluZSxcbiAgQ29tbWVudHNPdXRsaW5lLFxuICBUZXh0VGVsZXBob25lLFxuICBGaW5kLFxuICBXaWZpLFxuICBBbGFybVNsYXNoLFxuICBBbGFybVNsYXNoT3V0bGluZSxcbiAgQ29weXJpZ2h0LFxuICBBdCxcbiAgRXllZHJvcHBlcixcbiAgUGFpbnRCcnVzaCxcbiAgSGVhcnRiZWF0LFxuICBEb3dubG9hZCxcbiAgUmVwZWF0LFxuICBSZWZyZXNoLFxuICBMb2NrLFxuICBCb29rbWFyayxcbiAgUHJpbnQsXG4gIFdyaXRlLFxuICBUaGVtZSxcbiAgQWRqdXN0LFxuICBFZGl0LFxuICBFeHRlcm5hbFNoYXJlLFxuICBCYW4sXG4gIE1haWxGb3J3YXJkLFxuICBTaGFyZSxcbiAgRXhwYW5kLFxuICBDb21wcmVzcyxcbiAgVW5oaWRlLFxuICBIaWRlLFxuICBSYW5kb20sXG4gIFJldHdlZXQsXG4gIFNpZ25PdXQsXG4gIFBpbixcbiAgU2lnbkluLFxuICBVcGxvYWQsXG4gIENhbGwsXG4gIENhbGxTcXVhcmUsXG4gIFJlbW92ZUJvb2ttYXJrLFxuICBVbmxvY2ssXG4gIENvbmZpZ3VyZSxcbiAgRmlsdGVyLFxuICBXaXphcmQsXG4gIFVuZG8sXG4gIEV4Y2hhbmdlLFxuICBDbG91ZERvd25sb2FkLFxuICBDbG91ZFVwbG9hZCxcbiAgUmVwbHksXG4gIFJlcGx5QWxsLFxuICBFcmFzZSxcbiAgVW5sb2NrQWx0ZXJuYXRlLFxuICBBcmNoaXZlLFxuICBUcmFuc2xhdGUsXG4gIFJlY3ljbGUsXG4gIFNlbmQsXG4gIFNlbmRPdXRsaW5lLFxuICBTaGFyZUFsdGVybmF0ZSxcbiAgU2hhcmVBbHRlcm5hdGVTcXVhcmUsXG4gIFdhaXQsXG4gIFdyaXRlU3F1YXJlLFxuICBTaGFyZVNxdWFyZSxcbiAgQWRkVG9DYXJ0LFxuICBJbkNhcnQsXG4gIEFkZFVzZXIsXG4gIFJlbW92ZVVzZXIsXG4gIEhlbHBDaXJjbGUsXG4gIEluZm9DaXJjbGUsXG4gIFdhcm5pbmcsXG4gIFdhcm5pbmdDaXJjbGUsXG4gIFdhcm5pbmdTaWduLFxuICBIZWxwLFxuICBJbmZvLFxuICBBbm5vdW5jZW1lbnQsXG4gIEJpcnRoZGF5LFxuICBVc2VycyxcbiAgRG9jdG9yLFxuICBDaGlsZCxcbiAgVXNlcixcbiAgSGFuZGljYXAsXG4gIFN0dWRlbnQsXG4gIFNweSxcbiAgR3JpZExheW91dCxcbiAgTGlzdExheW91dCxcbiAgQmxvY2tMYXlvdXQsXG4gIFpvb20sXG4gIFpvb21PdXQsXG4gIFJlc2l6ZVZlcnRpY2FsLFxuICBSZXNpemVIb3Jpem9udGFsLFxuICBNYXhpbWl6ZSxcbiAgQ3JvcCxcbiAgRmVtYWxlLFxuICBNYWxlLFxuICBXb21hbixcbiAgTWFuLFxuICBOb25CaW5hcnlUcmFuc2dlbmRlcixcbiAgSW50ZXJnZW5kZXIsXG4gIFRyYW5zZ2VuZGVyLFxuICBMZXNiaWFuLFxuICBHYXksXG4gIEhldGVyb3NleHVhbCxcbiAgT3RoZXJHZW5kZXIsXG4gIE90aGVyR2VuZGVyVmVydGljYWwsXG4gIE90aGVyR2VuZGVySG9yaXpvbnRhbCxcbiAgTmV1dGVyLFxuICBDb2NrdGFpbCxcbiAgUm9hZCxcbiAgRmxhZyxcbiAgQm9vayxcbiAgR2lmdCxcbiAgTGVhZixcbiAgRmlyZSxcbiAgUGxhbmUsXG4gIE1hZ25ldCxcbiAgTGVnYWwsXG4gIExlbW9uLFxuICBXb3JsZCxcbiAgVHJhdmVsLFxuICBTaGlwcGluZyxcbiAgTW9uZXksXG4gIExpZ2h0bmluZyxcbiAgUmFpbixcbiAgVHJlYXRtZW50LFxuICBTdWl0Y2FzZSxcbiAgQmFyLFxuICBGbGFnT3V0bGluZSxcbiAgRmxhZ0NoZWNrZXJlZCxcbiAgUHV6emxlLFxuICBGaXJlRXh0aW5ndWlzaGVyLFxuICBSb2NrZXQsXG4gIEFuY2hvcixcbiAgQnVsbHNleWUsXG4gIFN1bixcbiAgTW9vbixcbiAgRmF4LFxuICBMaWZlUmluZyxcbiAgQm9tYixcbiAgU29jY2VyLFxuICBDYWxjdWxhdG9yLFxuICBEaWFtb25kLFxuICBDcm9zc2hhaXJzLFxuICBBc3RlcmlzayxcbiAgQ2VydGlmaWNhdGUsXG4gIENpcmNsZSxcbiAgUXVvdGVMZWZ0LFxuICBRdW90ZVJpZ2h0LFxuICBFbGxpcHNpc0hvcml6b250YWwsXG4gIEVsbGlwc2lzVmVydGljYWwsXG4gIEN1YmUsXG4gIEN1YmVzLFxuICBDaXJjbGVOb3RjaGVkLFxuICBDaXJjbGVUaGluLFxuICBTcXVhcmVPdXRsaW5lLFxuICBTcXVhcmUsXG4gIENoZWNrbWFyayxcbiAgUmVtb3ZlLFxuICBDaGVja21hcmtCb3gsXG4gIE1vdmUsXG4gIEFkZENpcmNsZSxcbiAgTWludXNDaXJjbGUsXG4gIFJlbW92ZUNpcmNsZSxcbiAgQ2hlY2tDaXJjbGUsXG4gIFJlbW92ZUNpcmNsZU91dGxpbmUsXG4gIENoZWNrQ2lyY2xlT3V0bGluZSxcbiAgUGx1cyxcbiAgTWludXMsXG4gIEFkZFNxdWFyZSxcbiAgUmFkaW8sXG4gIFNlbGVjdGVkUmFkaW8sXG4gIE1pbnVzU3F1YXJlLFxuICBNaW51c1NxdWFyZU91dGxpbmUsXG4gIENoZWNrU3F1YXJlLFxuICBQbHVzU3F1YXJlT3V0bGluZSxcbiAgVG9nZ2xlT2ZmLFxuICBUb2dnbGVPbixcbiAgRmlsbSxcbiAgU291bmQsXG4gIFBob3RvLFxuICBCYXJDaGFydCxcbiAgQ2FtZXJhUmV0cm8sXG4gIE5ld3NwYXBlcixcbiAgQXJlYUNoYXJ0LFxuICBQaWVDaGFydCxcbiAgTGluZUNoYXJ0LFxuICBBcnJvd0NpcmNsZU91dGxpbmVEb3duLFxuICBBcnJvd0NpcmNsZU91dGxpbmVVcCxcbiAgQ2hldnJvbkxlZnQsXG4gIENoZXZyb25SaWdodCxcbiAgQXJyb3dMZWZ0LFxuICBBcnJvd1JpZ2h0LFxuICBBcnJvd1VwLFxuICBBcnJvd0Rvd24sXG4gIENoZXZyb25VcCxcbiAgQ2hldnJvbkRvd24sXG4gIFBvaW50aW5nUmlnaHQsXG4gIFBvaW50aW5nTGVmdCxcbiAgUG9pbnRpbmdVcCxcbiAgUG9pbnRpbmdEb3duLFxuICBBcnJvd0NpcmNsZUxlZnQsXG4gIEFycm93Q2lyY2xlUmlnaHQsXG4gIEFycm93Q2lyY2xlVXAsXG4gIEFycm93Q2lyY2xlRG93bixcbiAgQ2FyZXREb3duLFxuICBDYXJldFVwLFxuICBDYXJldExlZnQsXG4gIENhcmV0UmlnaHQsXG4gIEFuZ2xlRG91YmxlTGVmdCxcbiAgQW5nbGVEb3VibGVSaWdodCxcbiAgQW5nbGVEb3VibGVVcCxcbiAgQW5nbGVEb3VibGVEb3duLFxuICBBbmdsZUxlZnQsXG4gIEFuZ2xlUmlnaHQsXG4gIEFuZ2xlVXAsXG4gIEFuZ2xlRG93bixcbiAgQ2hldnJvbkNpcmNsZUxlZnQsXG4gIENoZXZyb25DaXJjbGVSaWdodCxcbiAgQ2hldnJvbkNpcmNsZVVwLFxuICBDaGV2cm9uQ2lyY2xlRG93bixcbiAgVG9nZ2xlRG93bixcbiAgVG9nZ2xlVXAsXG4gIFRvZ2dsZVJpZ2h0LFxuICBMb25nQXJyb3dEb3duLFxuICBMb25nQXJyb3dVcCxcbiAgTG9uZ0Fycm93TGVmdCxcbiAgTG9uZ0Fycm93UmlnaHQsXG4gIEFycm93Q2lyY2xlT3V0bGluZVJpZ2h0LFxuICBBcnJvd0NpcmNsZU91dGxpbmVMZWZ0LFxuICBUb2dnbGVMZWZ0LFxuICBQb3dlcixcbiAgVHJhc2gsXG4gIFRyYXNoT3V0bGluZSxcbiAgRGlza091dGxpbmUsXG4gIERlc2t0b3AsXG4gIExhcHRvcCxcbiAgVGFibGV0LFxuICBNb2JpbGUsXG4gIEdhbWUsXG4gIEtleWJvYXJkLFxuICBQbHVnLFxuICBGb2xkZXIsXG4gIEZvbGRlck9wZW4sXG4gIExldmVsVXAsXG4gIExldmVsRG93bixcbiAgRmlsZSxcbiAgRmlsZU91dGxpbmUsXG4gIEZpbGVUZXh0LFxuICBGaWxlVGV4dE91dGxpbmUsXG4gIEZvbGRlck91dGxpbmUsXG4gIEZvbGRlck9wZW5PdXRsaW5lLFxuICBGaWxlUGRmT3V0bGluZSxcbiAgRmlsZVdvcmRPdXRsaW5lLFxuICBGaWxlRXhjZWxPdXRsaW5lLFxuICBGaWxlUG93ZXJwb2ludE91dGxpbmUsXG4gIEZpbGVJbWFnZU91dGxpbmUsXG4gIEZpbGVBcmNoaXZlT3V0bGluZSxcbiAgRmlsZUF1ZGlvT3V0bGluZSxcbiAgRmlsZVZpZGVvT3V0bGluZSxcbiAgRmlsZUNvZGVPdXRsaW5lLFxuICBCYXJjb2RlLFxuICBRcmNvZGUsXG4gIEZvcmssXG4gIEh0bWw1LFxuICBDc3MzLFxuICBSc3MsXG4gIFJzc1NxdWFyZSxcbiAgT3BlbmlkLFxuICBEYXRhYmFzZSxcbiAgU2VydmVyLFxuICBIZWFydCxcbiAgU3RhcixcbiAgRW1wdHlTdGFyLFxuICBUaHVtYnNPdXRsaW5lVXAsXG4gIFRodW1ic091dGxpbmVEb3duLFxuICBTdGFySGFsZixcbiAgRW1wdHlIZWFydCxcbiAgU21pbGUsXG4gIEZyb3duLFxuICBNZWgsXG4gIFN0YXJIYWxmRW1wdHksXG4gIFRodW1ic1VwLFxuICBUaHVtYnNEb3duLFxuICBNdXNpYyxcbiAgVmlkZW9QbGF5T3V0bGluZSxcbiAgVm9sdW1lT2ZmLFxuICBWb2x1bWVEb3duLFxuICBWb2x1bWVVcCxcbiAgUmVjb3JkLFxuICBTdGVwQmFja3dhcmQsXG4gIEZhc3RCYWNrd2FyZCxcbiAgQmFja3dhcmQsXG4gIFBsYXksXG4gIFBhdXNlLFxuICBTdG9wLFxuICBGb3J3YXJkLFxuICBGYXN0Rm9yd2FyZCxcbiAgU3RlcEZvcndhcmQsXG4gIEVqZWN0LFxuICBVbm11dGUsXG4gIE11dGUsXG4gIFZpZGVvUGxheSxcbiAgQ2xvc2VkQ2FwdGlvbmluZyxcbiAgTWFya2VyLFxuICBDb2ZmZWUsXG4gIEZvb2QsXG4gIEJ1aWxkaW5nT3V0bGluZSxcbiAgSG9zcGl0YWwsXG4gIEVtZXJnZW5jeSxcbiAgRmlyc3RBaWQsXG4gIE1pbGl0YXJ5LFxuICBILFxuICBMb2NhdGlvbkFycm93LFxuICBTcGFjZVNodXR0bGUsXG4gIFVuaXZlcnNpdHksXG4gIEJ1aWxkaW5nLFxuICBQYXcsXG4gIFNwb29uLFxuICBDYXIsXG4gIFRheGksXG4gIFRyZWUsXG4gIEJpY3ljbGUsXG4gIEJ1cyxcbiAgU2hpcCxcbiAgTW90b3JjeWNsZSxcbiAgU3RyZWV0VmlldyxcbiAgSG90ZWwsXG4gIFRyYWluLFxuICBTdWJ3YXksXG4gIFRhYmxlLFxuICBDb2x1bW5zLFxuICBTb3J0LFxuICBTb3J0QXNjZW5kaW5nLFxuICBTb3J0RGVzY2VuZGluZyxcbiAgU29ydEFscGhhYmV0QXNjZW5kaW5nLFxuICBTb3J0QWxwaGFiZXREZXNjZW5kaW5nLFxuICBTb3J0Q29udGVudEFzY2VuZGluZyxcbiAgU29ydENvbnRlbnREZXNjZW5kaW5nLFxuICBTb3J0TnVtZXJpY0FzY2VuZGluZyxcbiAgU29ydE51bWVyaWNEZXNjZW5kaW5nLFxuICBGb250LFxuICBCb2xkLFxuICBJdGFsaWMsXG4gIFRleHRIZWlnaHQsXG4gIFRleHRXaWR0aCxcbiAgQWxpZ25MZWZ0LFxuICBBbGlnbkNlbnRlcixcbiAgQWxpZ25SaWdodCxcbiAgQWxpZ25KdXN0aWZ5LFxuICBMaXN0LFxuICBPdXRkZW50LFxuICBJbmRlbnQsXG4gIExpbmtpZnksXG4gIEN1dCxcbiAgQ29weSxcbiAgQXR0YWNoLFxuICBTYXZlLFxuICBDb250ZW50LFxuICBVbm9yZGVyZWRMaXN0LFxuICBPcmRlcmVkTGlzdCxcbiAgU3RyaWtldGhyb3VnaCxcbiAgVW5kZXJsaW5lLFxuICBQYXN0ZSxcbiAgVW5saW5rLFxuICBTdXBlcnNjcmlwdCxcbiAgU3Vic2NyaXB0LFxuICBIZWFkZXIsXG4gIFBhcmFncmFwaCxcbiAgRXVybyxcbiAgUG91bmQsXG4gIERvbGxhcixcbiAgUnVwZWUsXG4gIFllbixcbiAgUnVibGUsXG4gIFdvbixcbiAgTGlyYSxcbiAgU2hla2VsLFxuICBQYXlwYWwsXG4gIFBheXBhbENhcmQsXG4gIEdvb2dsZVdhbGxldCxcbiAgVmlzYSxcbiAgTWFzdGVyY2FyZCxcbiAgRGlzY292ZXIsXG4gIEFtZXJpY2FuRXhwcmVzcyxcbiAgU3RyaXBlLFxuICBUd2l0dGVyU3F1YXJlLFxuICBGYWNlYm9va1NxdWFyZSxcbiAgTGlua2VkaW5TcXVhcmUsXG4gIEdpdGh1YlNxdWFyZSxcbiAgVHdpdHRlcixcbiAgRmFjZWJvb2ssXG4gIEdpdGh1YixcbiAgUGludGVyZXN0LFxuICBQaW50ZXJlc3RTcXVhcmUsXG4gIEdvb2dsZVBsdXNTcXVhcmUsXG4gIEdvb2dsZVBsdXMsXG4gIExpbmtlZGluLFxuICBHaXRodWJBbHRlcm5hdGUsXG4gIE1heGNkbixcbiAgQml0Y29pbixcbiAgWW91dHViZVNxdWFyZSxcbiAgWW91dHViZSxcbiAgWGluZyxcbiAgWGluZ1NxdWFyZSxcbiAgWW91dHViZVBsYXksXG4gIERyb3Bib3gsXG4gIFN0YWNrT3ZlcmZsb3csXG4gIEluc3RhZ3JhbSxcbiAgRmxpY2tyLFxuICBBZG4sXG4gIEJpdGJ1Y2tldCxcbiAgQml0YnVja2V0U3F1YXJlLFxuICBUdW1ibHIsXG4gIFR1bWJsclNxdWFyZSxcbiAgQXBwbGUsXG4gIFdpbmRvd3MsXG4gIEFuZHJvaWQsXG4gIExpbnV4LFxuICBEcmliYmJsZSxcbiAgU2t5cGUsXG4gIEZvdXJzcXVhcmUsXG4gIFRyZWxsbyxcbiAgR2l0dGlwLFxuICBWayxcbiAgV2VpYm8sXG4gIFJlbnJlbixcbiAgUGFnZWxpbmVzLFxuICBTdGFja0V4Y2hhbmdlLFxuICBWaW1lbyxcbiAgU2xhY2ssXG4gIFdvcmRwcmVzcyxcbiAgWWFob28sXG4gIEdvb2dsZSxcbiAgUmVkZGl0LFxuICBSZWRkaXRTcXVhcmUsXG4gIFN0dW1ibGV1cG9uQ2lyY2xlLFxuICBTdHVtYmxldXBvbixcbiAgRGVsaWNpb3VzLFxuICBEaWdnLFxuICBQaWVkUGlwZXIsXG4gIFBpZWRQaXBlckFsdGVybmF0ZSxcbiAgRHJ1cGFsLFxuICBKb29tbGEsXG4gIEJlaGFuY2UsXG4gIEJlaGFuY2VTcXVhcmUsXG4gIFN0ZWFtLFxuICBTdGVhbVNxdWFyZSxcbiAgU3BvdGlmeSxcbiAgRGV2aWFudGFydCxcbiAgU291bmRjbG91ZCxcbiAgVmluZSxcbiAgQ29kZXBlbixcbiAgSnNmaWRkbGUsXG4gIFJlYmVsLFxuICBFbXBpcmUsXG4gIEdpdFNxdWFyZSxcbiAgR2l0LFxuICBIYWNrZXJOZXdzLFxuICBUZW5jZW50V2VpYm8sXG4gIFFxLFxuICBXZWNoYXQsXG4gIFNsaWRlc2hhcmUsXG4gIFR3aXRjaCxcbiAgWWVscCxcbiAgTGFzdGZtLFxuICBMYXN0Zm1TcXVhcmUsXG4gIElveGhvc3QsXG4gIEFuZ2VsbGlzdCxcbiAgTWVhbnBhdGgsXG4gIEJ1eXNlbGxhZHMsXG4gIENvbm5lY3RkZXZlbG9wLFxuICBEYXNoY3ViZSxcbiAgRm9ydW1iZWUsXG4gIExlYW5wdWIsXG4gIFNlbGxzeSxcbiAgU2hpcnRzaW5idWxrLFxuICBTaW1wbHlidWlsdCxcbiAgU2t5YXRsYXMsXG4gIFdoYXRzYXBwLFxuICBWaWFjb2luLFxuICBNZWRpdW0sXG4gIExpa2UsXG4gIEZhdm9yaXRlLFxuICBWaWRlbyxcbiAgQ2hlY2ssXG4gIENsb3NlLFxuICBDYW5jZWwsXG4gIERlbGV0ZSxcbiAgWCxcbiAgVXNlclRpbWVzLFxuICBVc2VyQ2xvc2UsXG4gIFVzZXJDYW5jZWwsXG4gIFVzZXJEZWxldGUsXG4gIFVzZXJYLFxuICBab29tSW4sXG4gIE1hZ25pZnksXG4gIFNodXRkb3duLFxuICBDbG9jayxcbiAgVGltZSxcbiAgUGxheUNpcmNsZU91dGxpbmUsXG4gIEhlYWRwaG9uZSxcbiAgQ2FtZXJhLFxuICBWaWRlb0NhbWVyYSxcbiAgUGljdHVyZSxcbiAgUGVuY2lsLFxuICBDb21wb3NlLFxuICBQb2ludCxcbiAgVGludCxcbiAgU2lnbnVwLFxuICBQbHVzQ2lyY2xlLFxuICBEb250LFxuICBNaW5pbWl6ZSxcbiAgQWRkLFxuICBFeWUsXG4gIEF0dGVudGlvbixcbiAgQ2FydCxcbiAgU2h1ZmZsZSxcbiAgVGFsayxcbiAgQ2hhdCxcbiAgU2hvcHBpbmdDYXJ0LFxuICBCYXJHcmFwaCxcbiAgQXJlYUdyYXBoLFxuICBQaWVHcmFwaCxcbiAgTGluZUdyYXBoLFxuICBLZXksXG4gIENvZ3MsXG4gIERpc2N1c3Npb25zLFxuICBMaWtlT3V0bGluZSxcbiAgRGlzbGlrZU91dGxpbmUsXG4gIEhlYXJ0T3V0bGluZSxcbiAgTG9nT3V0LFxuICBUaHVtYlRhY2ssXG4gIFdpbm5lcixcbiAgQm9va21hcmtPdXRsaW5lLFxuICBQaG9uZSxcbiAgUGhvbmVTcXVhcmUsXG4gIENyZWRpdENhcmQsXG4gIEhkZE91dGxpbmUsXG4gIEJ1bGxob3JuLFxuICBCZWxsLFxuICBCZWxsT3V0bGluZSxcbiAgQmVsbFNsYXNoLFxuICBCZWxsU2xhc2hPdXRsaW5lLFxuICBIYW5kT3V0bGluZVJpZ2h0LFxuICBIYW5kT3V0bGluZUxlZnQsXG4gIEhhbmRPdXRsaW5lVXAsXG4gIEhhbmRPdXRsaW5lRG93bixcbiAgR2xvYmUsXG4gIFdyZW5jaCxcbiAgQnJpZWZjYXNlLFxuICBHcm91cCxcbiAgRmxhc2ssXG4gIFNpZGViYXIsXG4gIEJhcnMsXG4gIExpc3RVbCxcbiAgTGlzdE9sLFxuICBOdW1iZXJlZExpc3QsXG4gIE1hZ2ljLFxuICBUcnVjayxcbiAgQ3VycmVuY3ksXG4gIFRyaWFuZ2xlRG93bixcbiAgRHJvcGRvd24sXG4gIFRyaWFuZ2xlVXAsXG4gIFRyaWFuZ2xlTGVmdCxcbiAgVHJpYW5nbGVSaWdodCxcbiAgRW52ZWxvcGUsXG4gIENvbnZlcnNhdGlvbixcbiAgVW1icmVsbGEsXG4gIENsaXBib2FyZCxcbiAgTGlnaHRidWxiLFxuICBBbWJ1bGFuY2UsXG4gIE1lZGtpdCxcbiAgRmlnaHRlckpldCxcbiAgQmVlcixcbiAgUGx1c1NxdWFyZSxcbiAgQ29tcHV0ZXIsXG4gIENpcmNsZU91dGxpbmUsXG4gIEludGVyc2V4LFxuICBBc2V4dWFsLFxuICBTcGlubmVyLFxuICBHYW1lcGFkLFxuICBTdGFySGFsZkZ1bGwsXG4gIFF1ZXN0aW9uLFxuICBFcmFzZXIsXG4gIE1pY3JvcGhvbmUsXG4gIE1pY3JvcGhvbmVTbGFzaCxcbiAgU2hpZWxkLFxuICBUYXJnZXQsXG4gIFBsYXlDaXJjbGUsXG4gIFBlbmNpbFNxdWFyZSxcbiAgQ29tcGFzcyxcbiAgQW1leCxcbiAgRXVyLFxuICBHYnAsXG4gIFVzZCxcbiAgSW5yLFxuICBDbnksXG4gIFJtYixcbiAgSnB5LFxuICBSb3VibGUsXG4gIFJ1YixcbiAgS3J3LFxuICBCdGMsXG4gIFNoZXFlbCxcbiAgSWxzLFxuICBUcnksXG4gIFppcCxcbiAgRG90Q2lyY2xlT3V0bGluZSxcbiAgU2xpZGVycyxcbiAgV2ksXG4gIEdyYWR1YXRpb24sXG4gIFdlaXhpbixcbiAgQmlub2N1bGFycyxcbiAgR3JhdGlwYXksXG4gIEdlbmRlcmxlc3MsXG4gIFRlbGV0eXBlLFxuICBQb3dlckNvcmQsXG4gIFR0eSxcbiAgQ2MsXG4gIFBsdXNDYXJ0LFxuICBBcnJvd0Rvd25DYXJ0LFxuICBEZXRlY3RpdmUsXG4gIFZlbnVzLFxuICBNYXJzLFxuICBNZXJjdXJ5LFxuICBWZW51c0RvdWJsZSxcbiAgRmVtYWxlSG9tb3NleHVhbCxcbiAgTWFyc0RvdWJsZSxcbiAgTWFsZUhvbW9zZXh1YWwsXG4gIFZlbnVzTWFycyxcbiAgTWFyc1N0cm9rZSxcbiAgTWFyc0FsdGVybmF0ZSxcbiAgTWFyc1ZlcnRpY2FsLFxuICBNYXJzSG9yaXpvbnRhbCxcbiAgTWFyc1N0cm9rZVZlcnRpY2FsLFxuICBNYXJzU3Ryb2tlSG9yaXpvbnRhbCxcbiAgRmFjZWJvb2tPZmZpY2lhbCxcbiAgUGludGVyZXN0T2ZmaWNpYWwsXG4gIEJlZFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VudW1zL2ljb25UeXBlLnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vY29sbGVjdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2VsZW1lbnRzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tb2R1bGVzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi92aWV3c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW50ZXJmYWNlc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZW51bXNcIjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIGlzRE9NQ29udGVudH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQge2lucHV0LCBsYWJlbCwgZGl2LCBWTm9kZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBDaGVja2JveCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5PzogYm9vbGVhbjtcbiAgICBjaGVja2VkPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgZml0dGVkPzogYm9vbGVhbjtcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIHJhZGlvPzogYm9vbGVhbjtcbiAgICB0b2dnbGU/OiBib29sZWFuO1xuICB9XG4gIC8qKlxuICAqIENyZWF0ZXMgYSBjaGVja2JveCBlbGVtZW50IG9uIHRoZSBwYWdlLlxuICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgKiAgIHJlYWRvbmx5PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIHJlYWQtb25seS5cbiAgKiAgIGNoZWNrZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgY2hlY2tlZC5cbiAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGRpc2FibGVkLlxuICAqICAgZml0dGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggZm9yIHRpZ2h0IGZpdHMgd2l0aCBuZWFyYnkgY29udGVudC5cbiAgKiAgIHJhZGlvPzogc3RyaW5nIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgbGlrZSBhIHJhZGlvIGJ1dHRvbiBiZWxvbmdpbmcgdG8gdGhlIGdyb3VwLlxuICAqICAgdG9nZ2xlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGxpa2UgYSB0b2dnbGUuXG4gICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAqIEBwYXJhbSB7Q29tcG9uZW50U291cmNlc30gc291cmNlcyBUaGUgZGVmYXVsdCBjb21wb25lbnQgc291cmNlcy5cbiAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiaW5wdXRcIikuZXZlbnRzKHR5cGUpO1xuICAgICAgY29uc3QgY2xpY2tlZCQgPSBldnQoXCJjbGlja1wiKTtcbiAgICAgIGNvbnN0IHByb3BzJCA9IHNvdXJjZXMucHJvcHMkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCBjaGVja2VkJCA9IHByb3BzJC5tYXAocHJvcHMgPT5cbiAgICAgICAgY2xpY2tlZCQuZm9sZCgoYWNjLCBldnQpID0+IChldnQuc3JjRWxlbWVudCBhcyBhbnkpLmNoZWNrZWQsIHByb3BzLmNoZWNrZWQgPyB0cnVlIDogZmFsc2UpXG4gICAgICApLmZsYXR0ZW4oKS5yZW1lbWJlcigpO1xuICAgICAgLy8gY29uc3QgcmVuZGVyUHJvcHMkID0gIHhzLmNvbWJpbmUocHJvcHMkLCBjaGVja2VkJCkubWFwKFxuICAgICAgLy8gICAoW3Byb3BzLCBjaGVja2VkXSkgPT4gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtjaGVja2VkfSlcbiAgICAgIC8vICk7XG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogZXZ0LFxuICAgICAgICB2YWx1ZSQ6IGNoZWNrZWQkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgKiBDcmVhdGVzIGEgY2hlY2tib3ggZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICogICByZWFkb25seT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNoZWNrYm94IHRvIGFwcGVhciByZWFkLW9ubHkuXG4gICogICBjaGVja2VkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGNoZWNrZWQuXG4gICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNoZWNrYm94IHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgKiAgIGZpdHRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNoZWNrYm94IGZvciB0aWdodCBmaXRzIHdpdGggbmVhcmJ5IGNvbnRlbnQuXG4gICogICByYWRpbz86IHN0cmluZyAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGxpa2UgYSByYWRpbyBidXR0b24gYmVsb25naW5nIHRvIHRoZSBncm91cC5cbiAgKiAgIHRvZ2dsZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNoZWNrYm94IHRvIGFwcGVhciBsaWtlIGEgdG9nZ2xlLlxuICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgKiBAcGFyYW0ge0NvbXBvbmVudFNvdXJjZXN9IHNvdXJjZXMgVGhlIGRlZmF1bHQgY29tcG9uZW50IHNvdXJjZXMuXG4gICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHN8RE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIikge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczoge2NsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKHByb3BzKSB9fSwgW1xuICAgICAgaW5wdXQoe3Byb3BzOiB7XG4gICAgICAgIHR5cGU6IHByb3BzLnJhZGlvID8gXCJyYWRpb1wiIDogXCJjaGVja2JveFwiLFxuICAgICAgICBuYW1lOnByb3BzLm5hbWUsIFxuICAgICAgICBjaGVja2VkOnByb3BzLmNoZWNrZWQsIFxuICAgICAgICBkaXNhYmxlZDpwcm9wcy5yZWFkb25seXx8cHJvcHMuZGlzYWJsZWRcbiAgICAgIH19KSxcbiAgICAgIGxhYmVsKHtwcm9wczoge2Zvcjpwcm9wcy5uYW1lfX0sIHByb3BzLmZpdHRlZCA/IFwiXCIgOiBjb250ZW50KVxuICAgIF0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wczogUHJvcHMpIDogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5yZWFkb25seSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJlYWQtb25seVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2hlY2tlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNoZWNrZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZpdHRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZpdHRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmFkaW8pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByYWRpb1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudG9nZ2xlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdG9nZ2xlXCI7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWUgKyBcIiBjaGVja2JveFwiO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kdWxlcy9jaGVja2JveC9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJVmFsdWVDb21wb25lbnRTaW5rcyB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBJY29uVHlwZSwgQ29sb3IsIFNpemUsIEFuaW1hdGlvbiwgRGlyZWN0aW9uIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBkcm9wUmVwZWF0cyBmcm9tIFwieHN0cmVhbS9leHRyYS9kcm9wUmVwZWF0c1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCJ4c3RyZWFtL2V4dHJhL2RlYm91bmNlXCI7XG5pbXBvcnQgY29uY2F0IGZyb20gXCJ4c3RyZWFtL2V4dHJhL2NvbmNhdFwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgZGVsYXkgZnJvbSBcInhzdHJlYW0vZXh0cmEvZGVsYXlcIjtcbmltcG9ydCB7IGRpdiwgaW5wdXQgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5pbXBvcnQgeyBNZW51IH0gZnJvbSBcImNvbGxlY3Rpb25zL21lbnVcIjtcbmltcG9ydCB7IEljb24gfSBmcm9tIFwiZWxlbWVudHMvaWNvblwiO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCJtb2R1bGVzL3RyYW5zaXRpb25cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBEcm9wZG93biB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHN0YXRpYz86IHN0cmluZztcbiAgICByaWdodEFsaWduZWQ/OiBib29sZWFuO1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG4gICAgaW5pdGlhbD86IGFueTtcbiAgICBkZWZhdWx0Pzogc3RyaW5nO1xuICAgIHNlbGVjdGlvbj86IGJvb2xlYW47XG4gICAgaW5saW5lPzogYm9vbGVhbjtcbiAgICBmbG9hdGluZz86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIHNjcm9sbGluZz86IGJvb2xlYW47XG4gICAgY29tcGFjdD86IGJvb2xlYW47XG4gICAgc2VhcmNoPzogYm9vbGVhbjtcbiAgICBwb2ludGluZz86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgfVxuICBleHBvcnQgdHlwZSBDb250ZW50PFY+ID0gQXJyYXk8RHJvcGRvd25JdGVtPFY+PjtcbiAgZXhwb3J0IGludGVyZmFjZSBEcm9wZG93bkl0ZW08Vj4ge1xuICAgIGJvZHk6IERPTUNvbnRlbnQ7XG4gICAgdmFsdWU6IFY7XG4gICAgaGVhZGVyPzogYm9vbGVhbjtcbiAgICBmaXR0ZWQ/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBhY3RpdmU/OiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZHJvcGRvd24gY29tcG9uZW50IGZvciBjYXB0dXJpbmcgdXNlciBpbnB1dC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgYWN0aXZlPzogYm9vbGVhbixcbiAgICogIGluaXRpYWw/OiBhbnlcbiAgICogIGRlZmF1bHQ/OiBzdHJpbmdcbiAgICogIHNlbGVjdGlvbj86IGJvb2xlYW5cbiAgICogIGlubGluZT86IGJvb2xlYW5cbiAgICogIGZsb2F0aW5nPzogYm9vbGVhblxuICAgKiAgbG9hZGluZz86IGJvb2xlYW5cbiAgICogIGRpc2FibGVkPzogYm9vbGVhblxuICAgKiAgc2Nyb2xsaW5nPzogYm9vbGVhblxuICAgKiAgc2VhcmNoPzogYm9vbGVhblxuICAgKiAgY29tcGFjdD86IGJvb2xlYW5cbiAgICogIHNpemU/OiBTaXplXG4gICAqICBjb2xvcj86IENvbG9yXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IEFycmF5IG9mIHtcbiAgICogIGJvZHk6IERPTUNvbnRlbnQsXG4gICAqICB2YWx1ZTogYW55LFxuICAgKiAgaGVhZGVyPzogYm9vbGVhbixcbiAgICogIGZpdHRlZD86IGJvb2xlYW4sXG4gICAqICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gICAqICBhY3RpdmU/OiBib29sZWFuXG4gICAqIH1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW48Vj4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudDxWPj4pOiBJVmFsdWVDb21wb25lbnRTaW5rczxWPiB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50PFY+Pikge1xuICAgICAgY29uc3QgZXZ0ID0gKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5kcm9wZG93blwiKS5ldmVudHModHlwZSk7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG5cbiAgICAgIGNvbnN0IHByb3BzJCA9IHNvdXJjZXMucHJvcHMkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCBpdGVtQ2xpY2skcHJveHkgPSB4cy5jcmVhdGUoKTtcbiAgICAgIGNvbnN0IHZhbHVlJHByb3h5ID0geHMuY3JlYXRlKCk7XG5cbiAgICAgIGNvbnN0IGRyb3Bkb3duQ2xpY2skID0gZXZ0KFwiY2xpY2tcIilcbiAgICAgICAgLmZpbHRlcihldnQgPT4gIShldnQuc3JjRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRlbVwiKSlcbiAgICAgICAgLm1hcFRvKERpcmVjdGlvbi5Jbik7XG4gICAgICBjb25zdCBtb3VzZWxlYXZlJCA9IHhzLm1lcmdlKGV2dChcIm1vdXNlbGVhdmVcIikuZmlsdGVyKFxuICAgICAgICBldnQgPT4gZXZ0LnNyY0VsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoXCJpY29uXCIpID09PSAtMVxuICAgICAgKSwgZXZ0KFwibW91c2VlbnRlclwiKSlcbiAgICAgICAgLm1hcChldnQgPT4gKGV2dCBhcyBNb3VzZUV2ZW50KS50eXBlID09PSBcIm1vdXNlZW50ZXJcIiA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXQpXG4gICAgICAgIC5jb21wb3NlKGRlYm91bmNlKDI1MCkpXG4gICAgICAgIC5maWx0ZXIoZGlyID0+IGRpciA9PT0gRGlyZWN0aW9uLk91dCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uJCA9IHhzLm1lcmdlKGRyb3Bkb3duQ2xpY2skLCBpdGVtQ2xpY2skcHJveHksIG1vdXNlbGVhdmUkKVxuICAgICAgICAuc3RhcnRXaXRoKERpcmVjdGlvbi5PdXQpXG4gICAgICAgIC5tYXAoZGlyID0+ICh7XG4gICAgICAgICAgYW5pbWF0aW9uOiBBbmltYXRpb24uRmFkZSxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpclxuICAgICAgICB9KSlcbiAgICAgICAgLmNvbXBvc2UoZHJvcFJlcGVhdHMoXG4gICAgICAgICAgKGEsIGIpID0+IChhIGFzIGFueSkuZGlyZWN0aW9uID09PSAoYiBhcyBhbnkpLmRpcmVjdGlvblxuICAgICAgICAgICAgJiYgKGEgYXMgYW55KS5hbmltYXRpb24gPT09IChiIGFzIGFueSkuYW5pbWF0aW9uXG4gICAgICAgICkpXG4gICAgICAgIC5kcm9wKDEpXG4gICAgICAgIC5zdGFydFdpdGgoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IERpcmVjdGlvbi5PdXQgfSk7XG5cbiAgICAgIGNvbnN0IGZpbHRlciQgPSBzb3VyY2VzLkRPTS5zZWxlY3QoXCJpbnB1dFwiKS5ldmVudHMoXCJrZXl1cFwiKVxuICAgICAgICAubWFwKGV2ID0+IChldi50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUpXG4gICAgICAgIC5zdGFydFdpdGgoXCJcIikgYXMgU3RyZWFtPHN0cmluZz47XG4gICAgICBjb25zdCBmaWx0ZXJlZENvbnRlbnQkID0geHMuY29tYmluZShzb3VyY2VzLmNvbnRlbnQkLCBmaWx0ZXIkKS5tYXAoXG4gICAgICAgIChbY29udGVudCwgZmlsdGVyXSkgPT4gY29udGVudC5maWx0ZXIoYyA9PiBmaWx0ZXJDb250ZW50KGMsIGZpbHRlcikpXG4gICAgICApLnJlbWVtYmVyKCk7XG5cbiAgICAgIGNvbnN0IGNvbnRlbnQkID0geHMuY29tYmluZShmaWx0ZXJlZENvbnRlbnQkLCB2YWx1ZSRwcm94eSkubWFwKFxuICAgICAgICAoW2NvbnRlbnQsIHZhbHVlXSkgPT4gY29udGVudC5tYXAoXG4gICAgICAgICAgaXRlbSA9PiBpdGVtLnZhbHVlID09PSB2YWx1ZSA/IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHsgYWN0aXZlOiB0cnVlIH0pIDogaXRlbVxuICAgICAgICApXG4gICAgICApLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCBtZW51ID0gTWVudS5ydW4oeyBET006IHNvdXJjZXMuRE9NLCBjb250ZW50JCB9KTtcblxuICAgICAgY29uc3QgdHJhbnNpdGlvbmVkTWVudSA9IFRyYW5zaXRpb24ucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgdGFyZ2V0JDogbWVudS5ET00sIGFyZ3MkOiB0cmFuc2l0aW9uJCBhcyBhbnkgfSk7XG5cbiAgICAgIGxldCBpdGVtQ2xpY2skID0gZXZ0KFwiY2xpY2tcIikuZmlsdGVyKHggPT4geC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRlbVwiKSkucmVtZW1iZXIoKTtcbiAgICAgIGl0ZW1DbGljayRwcm94eS5pbWl0YXRlKGl0ZW1DbGljayQubWFwVG8oRGlyZWN0aW9uLk91dCkgYXMgYW55KTtcblxuICAgICAgY29uc3QgY2xpY2tlZElkJCA9IGl0ZW1DbGljayRcbiAgICAgICAgLm1hcChldiA9PiBwYXJzZUludCgoZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5pZCkpXG4gICAgICAgIC5maWx0ZXIobiA9PiAhaXNOYU4obikgJiYgdHlwZW9mIChuKSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgICBjb25zdCBlbWl0dGVkVmFsdWUkID0gY2xpY2tlZElkJC5tYXAoaWQgPT4gZmlsdGVyZWRDb250ZW50JC5tYXAoaXRlbXMgPT4gaXRlbXNbaWRdLnZhbHVlKS50YWtlKDEpKS5mbGF0dGVuKCkucmVtZW1iZXIoKSBhcyBhbnk7XG4gICAgICBjb25zdCBpbml0aWFsVmFsdWUkID0gcHJvcHMkLm1hcChwcm9wcyA9PiBwcm9wcy5pbml0aWFsKS5yZW1lbWJlcigpO1xuICAgICAgdmFsdWUkcHJveHkuaW1pdGF0ZSh4cy5tZXJnZShpbml0aWFsVmFsdWUkIGFzIGFueSwgZW1pdHRlZFZhbHVlJCkpO1xuXG4gICAgICBjb25zdCBpY29uID0gSWNvbi5yZW5kZXIoe30sIEljb25UeXBlLkRyb3Bkb3duKTtcbiAgICAgIGNvbnN0IGFjdGl2ZSQgPSB4cy5tZXJnZShcbiAgICAgICAgdHJhbnNpdGlvbiQuZmlsdGVyKHggPT4geC5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5JbikubWFwVG8odHJ1ZSksXG4gICAgICAgIHRyYW5zaXRpb24kLmZpbHRlcih4ID0+IHguZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uT3V0KS5jb21wb3NlKGRlbGF5KDI1MCkpLm1hcFRvKGZhbHNlKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0cmVhbXMgPSB4cy5jb21iaW5lKFxuICAgICAgICBwcm9wcyQsXG4gICAgICAgIGFjdGl2ZSQsXG4gICAgICAgIHRyYW5zaXRpb25lZE1lbnUuRE9NLFxuICAgICAgICBjb250ZW50JC5tYXAoY29udGVudCA9PiBjb250ZW50LmZpbHRlcihpdGVtID0+IGl0ZW0uYWN0aXZlKVswXSlcbiAgICAgICk7XG4gICAgICBjb25zdCB2dHJlZSQgPSBzdHJlYW1zLm1hcChcbiAgICAgICAgKFtwcm9wcywgYWN0aXZlLCBtZW51LCBpdGVtXSkgPT5cbiAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzTmFtZShwcm9wcywgYWN0aXZlKSB9IH0sIFtcbiAgICAgICAgICAgIGdldFRleHQoaXRlbSwgcHJvcHMpLFxuICAgICAgICAgICAgcHJvcHMuc2VhcmNoID8gaW5wdXQoeyBwcm9wczogeyBjbGFzc05hbWU6IFwic2VhcmNoXCIgfSB9KSA6IFwiXCIsXG4gICAgICAgICAgICBpY29uLCBtZW51XG4gICAgICAgICAgXSlcbiAgICAgICkucmVtZW1iZXIoKTtcblxuICAgICAgLy9Ub2RvIGZpbmQgY2xlYW5lciB3YXkgdG8gY2xlYXIgaW5wdXQgdXNpbmcgc25hYmJkb20gaG9va3M/XG4gICAgICBlbWl0dGVkVmFsdWUkLm1hcChfID0+IHZ0cmVlJC50YWtlKDEpKS5mbGF0dGVuKCkuYWRkTGlzdGVuZXIobmV3IEV4ZWN1dGVMaXN0ZW5lcihmdW5jdGlvbiAodm5vZGU6IFZOb2RlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgKHZub2RlLmVsbSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBlbG0gPSAodm5vZGUuZWxtIGFzIEVsZW1lbnQpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIik7XG4gICAgICAgICAgICBpZiAoZWxtWzBdICYmIGVsbVswXS52YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZW5kaW5nIG5leHRcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxtWzBdLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgZmlsdGVyJC5zaGFtZWZ1bGx5U2VuZE5leHQoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2xlYXIsIDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdnRyZWUkLFxuICAgICAgICBFdmVudHM6IGV2dCxcbiAgICAgICAgdmFsdWUkOiBjb25jYXQoaW5pdGlhbFZhbHVlJCwgZW1pdHRlZFZhbHVlJClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGRyb3Bkb3duIGNvbXBvbmVudCBmb3IgY2FwdHVyaW5nIHVzZXIgaW5wdXQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgYWN0aXZlPzogYm9vbGVhbixcbiAgICogIGluaXRpYWw/OiBhbnlcbiAgICogIGRlZmF1bHQ/OiBzdHJpbmdcbiAgICogIHNlbGVjdGlvbj86IGJvb2xlYW5cbiAgICogIGlubGluZT86IGJvb2xlYW5cbiAgICogIGZsb2F0aW5nPzogYm9vbGVhblxuICAgKiAgbG9hZGluZz86IGJvb2xlYW5cbiAgICogIGRpc2FibGVkPzogYm9vbGVhblxuICAgKiAgc2Nyb2xsaW5nPzogYm9vbGVhblxuICAgKiAgc2VhcmNoPzogYm9vbGVhblxuICAgKiAgY29tcGFjdD86IGJvb2xlYW5cbiAgICogIHNpemU/OiBTaXplXG4gICAqICBjb2xvcj86IENvbG9yXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEFycmF5IG9mIHtcbiAgICogIGJvZHk6IERPTUNvbnRlbnQsXG4gICAqICB2YWx1ZTogYW55LFxuICAgKiAgaGVhZGVyPzogYm9vbGVhbixcbiAgICogIGZpdHRlZD86IGJvb2xlYW4sXG4gICAqICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gICAqICBhY3RpdmU/OiBib29sZWFuXG4gICAqIH1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBDb250ZW50PGFueT4gPSB7fSwgYzogQ29udGVudDxhbnk+ID0gW10pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gKHBPckMgaW5zdGFuY2VvZiBBcnJheSkgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSAocE9yQyBpbnN0YW5jZW9mIEFycmF5KSA/IHBPckMgOiBjO1xuICAgIGNvbnN0IGljb24gPSBJY29uLnJlbmRlcih7fSwgSWNvblR5cGUuRHJvcGRvd24pO1xuICAgIGNvbnN0IG1lbnUgPSBNZW51LnJlbmRlcih7fSwgY29udGVudCk7XG4gICAgY29uc3QgaXRlbSA9IGNvbnRlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5hY3RpdmUpWzBdO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzTmFtZShwcm9wcykgfSB9LCBbXG4gICAgICBnZXRUZXh0KGl0ZW0sIHByb3BzKSxcbiAgICAgIHByb3BzLnNlYXJjaCA/IGlucHV0KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInNlYXJjaFwiIH0gfSkgOiBcIlwiLFxuICAgICAgaWNvbiwgbWVudVxuICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BzOiBQcm9wcywgYWN0aXZlPykge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnJpZ2h0QWxpZ25lZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJpZ2h0XCI7XG5cbiAgICB9XG4gICAgaWYgKHByb3BzLnNlbGVjdGlvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNlbGVjdGlvblwiO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5pbmxpbmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbmxpbmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZsb2F0aW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZmxvYXRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zY3JvbGxpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzY3JvbGxpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNlYXJjaCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNlYXJjaFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcGFjdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXBhY3RcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBvaW50aW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcG9pbnRpbmdcIjtcbiAgICB9XG4gICAgaWYgKGFjdGl2ZSB8fCBwcm9wcy5hY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWUgKyBcIiBkcm9wZG93blwiO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRleHQ8Vj4oaXRlbTogRHJvcGRvd25JdGVtPFY+LCBwcm9wczogUHJvcHMpOiBWTm9kZSB7XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc3RhdGljKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ0ZXh0XCIgfSB9LCBwcm9wcy5zdGF0aWMpO1xuICAgIH1cbiAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkZWZhdWx0IHRleHRcIiB9IH0sIHByb3BzLmRlZmF1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInRleHRcIiB9IH0sIGl0ZW0uYm9keSk7XG4gIH1cbiAgZnVuY3Rpb24gZmlsdGVyQ29udGVudDxWPihpdGVtOiBEcm9wZG93bkl0ZW08Vj4sIGZpbHRlcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgZnVuY3Rpb24gZihub2RlOiBWTm9kZSkge1xuICAgICAgaWYgKG5vZGUudGV4dCkge1xuICAgICAgICByZXR1cm4gbm9kZS50ZXh0LmluZGV4T2YoZmlsdGVyKSAhPT0gLTEgfHwgIWZpbHRlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBjIGluIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoZihjKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoaXRlbS5ib2R5ID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgcmV0dXJuIChpdGVtLmJvZHkgYXMgc3RyaW5nKS5pbmRleE9mKGZpbHRlcikgIT09IC0xIHx8ICFmaWx0ZXI7XG4gICAgfVxuICAgIGlmICghKGl0ZW0uYm9keSBhcyBhbnkpLnB1c2gpIHtcbiAgICAgIHJldHVybiBmKGl0ZW0uYm9keSBhcyBWTm9kZSk7XG4gICAgfVxuICAgIGZvciAobGV0IGMgaW4gKGl0ZW0uYm9keSBhcyBWTm9kZSkuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChmKGMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2xhc3MgRXhlY3V0ZUxpc3RlbmVyIHtcbiAgICBmOiBGdW5jdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihmOiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5mID0gZjtcbiAgICB9XG4gICAgbmV4dChpKSB7IHRoaXMuZihpKTsgfVxuICAgIGVycm9yKGkpIHsgfVxuICAgIGNvbXBsZXRlKCkgeyB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2Ryb3Bkb3duL2luZGV4LnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vY2hlY2tib3hcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RpbW1lclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZHJvcGRvd25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL21vZGFsXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wb3B1cFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHJvZ3Jlc3NcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RyYW5zaXRpb25cIjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kdWxlcy9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBET01Tb3VyY2UgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzLCB7IFN0cmVhbSwgTWVtb3J5U3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcblxuaW1wb3J0IHsgSWNvblR5cGUsIERpcmVjdGlvbiwgQW5pbWF0aW9ufSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB7IERpbW1lcn0gZnJvbSBcIm1vZHVsZXMvZGltbWVyXCI7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSBcImVsZW1lbnRzL2ljb25cIjtcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwibW9kdWxlcy90cmFuc2l0aW9uXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTW9kYWwge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBoZWFkZXI/OiBzdHJpbmc7XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTW9kYWxTb3VyY2VzIHtcbiAgICBET006IERPTVNvdXJjZTtcbiAgICBvbiQ6IFN0cmVhbTxib29sZWFuPjtcbiAgICBwcm9wcyQ/OiBTdHJlYW08UHJvcHM+O1xuICAgIGNvbnRlbnQkPzogU3RyZWFtPERPTUNvbnRlbnQ+O1xuICAgIGFjdGlvbnMkPzogU3RyZWFtPERPTUNvbnRlbnQ+O1xuICAgIHRhcmdldCQ/OiBTdHJlYW08Vk5vZGU+O1xuICB9XG4gIC8qKlxuICAgKiBBIG1vZGFsIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBjb250ZW50IGluIGEgbW9kYWwuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGhlYWRlcjogU3RyaW5nIC0gVGhlIGhlYWRlciB0ZXh0IGZvciB0aGUgY29tcG9uZW50LlxuICAgKiAgIG9uJDogU3RyZWFtPEJvb2xlYW4+IC0gV2hlbiB0byBkaXNwbGF5IHRoZSBtb2RhbC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBNb2RhbFNvdXJjZXMpIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IE1vZGFsU291cmNlcykge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2YoeyBvbiQ6IHhzLm9mKGZhbHNlKSB9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuICAgICAgc291cmNlcy5hY3Rpb25zJCA9IHNvdXJjZXMuYWN0aW9ucyQgPyBzb3VyY2VzLmFjdGlvbnMkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLnRhcmdldCQgPSBzb3VyY2VzLnRhcmdldCQgPyBzb3VyY2VzLnRhcmdldCQgOiB4cy5vZihcInBhZ2VcIik7XG5cbiAgICAgIGNvbnN0IGNsb3NlSWNvbiA9IEljb24ucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgcHJvcHMkOiB4cy5vZih7IGxpbms6IHRydWUgfSksIGNvbnRlbnQkOiB4cy5vZihJY29uVHlwZS5DbG9zZSkgfSk7XG4gICAgICBjb25zdCBjbG9zZSQgPSBjbG9zZUljb24uRXZlbnRzKFwiY2xpY2tcIikubWFwVG8oZmFsc2UpO1xuXG4gICAgICAvKioqIFJlbmRlciBtb2RhbCAqKiovXG4gICAgICBsZXQgZGltbWVyY2xpY2skcHJveHkgPSB4cy5jcmVhdGUoKSBhcyBTdHJlYW08Ym9vbGVhbj47XG4gICAgICBjb25zdCBvbiQgPSB4cy5tZXJnZShzb3VyY2VzLm9uJCwgZGltbWVyY2xpY2skcHJveHksIGNsb3NlJCkucmVtZW1iZXIoKSBhcyBNZW1vcnlTdHJlYW08Ym9vbGVhbj47XG4gICAgICBjb25zdCBjb250ZW50JCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQsIHNvdXJjZXMuYWN0aW9ucyQsIGNsb3NlSWNvbi5ET00pLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudCwgYWN0aW9ucywgaWNvbl0pID0+XG4gICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInVpIHNjcm9sbGluZyBhY3RpdmUgbW9kYWxcIiB9IH0sIFtcbiAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiaGVhZGVyXCIgfSB9LCBwcm9wcy5oZWFkZXIpLFxuICAgICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImNvbnRlbnRcIiB9IH0sIGNvbnRlbnQpLFxuICAgICAgICAgICAgYWN0aW9ucyA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJhY3Rpb25zXCIgfSB9LCBhY3Rpb25zKSA6IFwiXCJcbiAgICAgICAgICBdKVxuICAgICAgKS5yZW1lbWJlcigpO1xuXG4gICAgICAvKioqIEFuaW1hdGlvbiAqKiovXG4gICAgICBjb25zdCB0cmFuc2l0aW9uJCA9IG9uJFxuICAgICAgICAuZm9sZCgocHJldkFuaW0sIGFjdGl2ZSkgPT4gcHJldkFuaW0uZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTm9uZVxuICAgICAgICAgID8gKHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBhY3RpdmUgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0IH0pXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICBhbmltYXRpb246IEFuaW1hdGlvbi5GYWRlLCBkaXJlY3Rpb246IGFjdGl2ZSA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXRcbiAgICAgICAgICB9XG4gICAgICAgICwgKHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uTm9uZSB9KSk7XG4gICAgICBjb25zdCBhbmltYXRlZENvbnRlbnQgPSBUcmFuc2l0aW9uLnJ1bih7IERPTTogc291cmNlcy5ET00sIHRhcmdldCQ6IGNvbnRlbnQkLCBhcmdzJDogdHJhbnNpdGlvbiQgfSk7XG5cbiAgICAgIC8qKiogQWN0aXZhdGUgZGltbWVyICoqKi9cbiAgICAgIGxldCBkaW1tZXJDb250ZW50JCA9IGFuaW1hdGVkQ29udGVudC5ET00ubWFwKHggPT4gW3hdKTtcbiAgICAgIGNvbnN0IGRpbW1lciA9IERpbW1lci5ydW4oeyBET006IHNvdXJjZXMuRE9NLCB0YXJnZXQkOiBzb3VyY2VzLnRhcmdldCQsIGFyZ3MkOiBvbiQsIGNvbnRlbnQkOiBkaW1tZXJDb250ZW50JCB9LCBzb3VyY2VzLnByb3BzJC5tYXAoeCA9PiB4LmludmVydGVkKSk7XG4gICAgICBjb25zdCBkaW1tZXJjbGljayQgPSBkaW1tZXIuRXZlbnRzKFwibW91c2Vkb3duXCIpXG4gICAgICAgIC5maWx0ZXIoZXZ0ID0+IGV2dC5zcmNFbGVtZW50ID09PSAoZXZ0IGFzIE1vdXNlRXZlbnQpLmN1cnJlbnRUYXJnZXQpXG4gICAgICAgIC5tYXBUbyhmYWxzZSk7XG4gICAgICBkaW1tZXJjbGljayRwcm94eS5pbWl0YXRlKGRpbW1lcmNsaWNrJCk7XG5cbiAgICAgIGNvbnN0IGZhZGVPdXRFbmQkID0gb24kLm1hcChhY3RpdmUgPT4gIWFjdGl2ZSA/IGRpbW1lci5FdmVudHMoXCJhbmltYXRpb25lbmRcIikgOiB4cy5uZXZlcigpKS5mbGF0dGVuKCkubWFwVG8oZmFsc2UpO1xuICAgICAgLy8gY29uc3QgYWN0aXZlJCA9IHhzLm1lcmdlKHNvdXJjZXMub24kLCBmYWRlT3V0RW5kJCkucmVtZW1iZXIoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZSQ6IHhzLm1lcmdlKHNvdXJjZXMub24kLCBmYWRlT3V0RW5kJCksXG4gICAgICAgIERPTTogZGltbWVyLkRPTSxcbiAgICAgICAgRXZlbnRzOiBhbmltYXRlZENvbnRlbnQuRXZlbnRzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL21vZGFsL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgQW5pbWF0aW9uLCBEaXJlY3Rpb24gfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tIFwibW9kdWxlcy90cmFuc2l0aW9uXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzLCB7IFN0cmVhbSB9IGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwieHN0cmVhbS9leHRyYS9kZWJvdW5jZVwiO1xuaW1wb3J0IGRyb3BSZXBlYXRzIGZyb20gXCJ4c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzXCI7XG5pbXBvcnQgZGVsYXkgZnJvbSBcInhzdHJlYW0vZXh0cmEvZGVsYXlcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBQb3B1cCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQXJncyB7XG4gICAgYWN0aXZlOiBib29sZWFuO1xuICAgIGF0dGFjaG1lbnQ6IFBvcHVwQXR0YWNobWVudDtcbiAgICBoZWFkZXI/OiBzdHJpbmc7XG4gICAgd2lkZT86IGJvb2xlYW47XG4gICAgdmVyeVdpZGU/OiBib29sZWFuO1xuICAgIGZsb3dpbmc/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBzaXplPzogU2l6ZTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgSVRldGhlcmVkSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyBleHRlbmRzIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICB0ZXRoZXI6IGFueTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFZOb2RlLCBBcmdzLCBET01Db250ZW50Pik6IElUZXRoZXJlZEludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFZOb2RlLCBBcmdzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5hcmdzJCA9IHNvdXJjZXMuYXJncyQgPyBzb3VyY2VzLmFyZ3MkIDogeHMub2YoeyBhY3RpdmU6IGZhbHNlLCBhdHRhY2htZW50OiBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTGVmdCB9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCBhcmdzJCA9IHNvdXJjZXMuYXJncyQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoYXJncyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFthcmdzLCBjb250ZW50XSkgPT4gcmVuZGVyKGFyZ3MsIGNvbnRlbnQpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtb3VzZWxlYXZlJHByb3h5ID0geHMuY3JlYXRlKCk7XG4gICAgICBjb25zdCBtb3VzZWVudGVyJHByb3h5ID0geHMuY3JlYXRlKCk7XG4gICAgICBjb25zdCBhY3RpdmUkID0gYXJncyQubWFwKGFyZyA9PiBhcmcuYWN0aXZlID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dCkuZHJvcCgxKTtcbiAgICAgIGNvbnN0IHRpbWVyJCA9IGFjdGl2ZSQubWFwKGRpciA9PiBkaXIgPT09IERpcmVjdGlvbi5PdXQgPyB4cy5vZihEaXJlY3Rpb24uT3V0KVxuICAgICAgICA6IHhzLm9mKERpcmVjdGlvbi5PdXQpLmNvbXBvc2UoZGVsYXkoMTAwMCkpLmVuZFdoZW4obW91c2VlbnRlciRwcm94eSlcbiAgICAgICkuZmxhdHRlbigpO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiQgPSB4cy5tZXJnZShhY3RpdmUkLCBtb3VzZWxlYXZlJHByb3h5LCB0aW1lciQpXG4gICAgICAgIC5tYXAoZGlyID0+ICh7XG4gICAgICAgICAgYW5pbWF0aW9uOiBBbmltYXRpb24uRmFkZSxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpclxuICAgICAgICB9KSlcbiAgICAgICAgLmNvbXBvc2UoZHJvcFJlcGVhdHMoXG4gICAgICAgICAgKGEsIGIpID0+IChhIGFzIGFueSkuZGlyZWN0aW9uID09PSAoYiBhcyBhbnkpLmRpcmVjdGlvblxuICAgICAgICAgICAgJiYgKGEgYXMgYW55KS5hbmltYXRpb24gPT09IChiIGFzIGFueSkuYW5pbWF0aW9uXG4gICAgICAgICkpXG4gICAgICAgIC5zdGFydFdpdGgoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IERpcmVjdGlvbi5PdXQgfSkgYXMgU3RyZWFtPGFueT47XG4gICAgICBjb25zdCBhbmltYXRlZFBvcHVwID0gVHJhbnNpdGlvbi5ydW4oeyBET006IHNvdXJjZXMuRE9NLCB0YXJnZXQkOiB2VHJlZSQsIGFyZ3MkOiB0cmFuc2l0aW9uJCB9KTtcbiAgICAgIGNvbnN0IG1vdXNlZW50ZXIkID0gYW5pbWF0ZWRQb3B1cC5FdmVudHMoXCJtb3VzZWVudGVyXCIpO1xuICAgICAgY29uc3QgbW91c2VsZWF2ZSQgPSB4cy5tZXJnZShhbmltYXRlZFBvcHVwLkV2ZW50cyhcIm1vdXNlbGVhdmVcIiksIG1vdXNlZW50ZXIkKVxuICAgICAgICAubWFwKGV2dCA9PiBldnQudHlwZSA9PT0gXCJtb3VzZWVudGVyXCIgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0KVxuICAgICAgICAuY29tcG9zZShkZWJvdW5jZSgyMDApKVxuICAgICAgICAuZmlsdGVyKGRpciA9PiBkaXIgPT09IERpcmVjdGlvbi5PdXQpO1xuICAgICAgbW91c2VsZWF2ZSRwcm94eS5pbWl0YXRlKG1vdXNlbGVhdmUkKTtcbiAgICAgIG1vdXNlZW50ZXIkcHJveHkuaW1pdGF0ZShtb3VzZWVudGVyJCk7XG5cbiAgICAgIGNvbnN0IHBvcHVwJCA9IGFuaW1hdGVkUG9wdXAuRE9NLnJlbWVtYmVyKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHBvcHVwJCxcbiAgICAgICAgRXZlbnRzOiBhbmltYXRlZFBvcHVwLkV2ZW50cyxcbiAgICAgICAgdGV0aGVyOiB4cy5jb21iaW5lKHBvcHVwJCwgc291cmNlcy50YXJnZXQkLCBhcmdzJClcbiAgICAgICAgICAubWFwKChbZWxlbWVudCwgdGFyZ2V0LCBhcmdzXSkgPT4gKHsgZWxlbWVudCwgdGFyZ2V0LCBhcmdzIH0pKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihhcmdzOiBBcmdzID0geyBhY3RpdmU6IHRydWUsIGF0dGFjaG1lbnQ6IFBvcHVwQXR0YWNobWVudC5Cb3R0b21MZWZ0IH0sIGNvbnRlbnQ6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShhcmdzKSB9IH0sIFtcbiAgICAgIGFyZ3MuaGVhZGVyID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImhlYWRlclwiIH0gfSwgYXJncy5oZWFkZXIpIDogXCJcIixcbiAgICAgIGNvbnRlbnRcbiAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogQXJncyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMud2lkZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHdpZGVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnlXaWRlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVyeSB3aWRlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbG93aW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZmxvd2luZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBQb3B1cEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCkgKyBcIiBwb3B1cFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbiAgZXhwb3J0IGVudW0gUG9wdXBBdHRhY2htZW50IHtcbiAgICBUb3BMZWZ0LCBUb3BNaWRkbGUsIFRvcFJpZ2h0LCBMZWZ0Q2VudGVyLCBSaWdodENlbnRlcixcbiAgICBCb3R0b21MZWZ0LCBCb3R0b21NaWRkbGUsIEJvdHRvbVJpZ2h0LFxuICAgIENlbnRlclxuICB9XG4gIGV4cG9ydCBuYW1lc3BhY2UgUG9wdXBBdHRhY2htZW50IHtcbiAgICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUoYXR0YWNobWVudDogUG9wdXBBdHRhY2htZW50KSB7XG4gICAgICBzd2l0Y2ggKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wTGVmdDogcmV0dXJuIFwiIHRvcCBsZWZ0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcE1pZGRsZTogcmV0dXJuIFwiIHRvcCBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wUmlnaHQ6IHJldHVybiBcIiB0b3AgcmlnaHRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuTGVmdENlbnRlcjogcmV0dXJuIFwiIGxlZnQgY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlJpZ2h0Q2VudGVyOiByZXR1cm4gXCIgcmlnaHQgY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbUxlZnQ6IHJldHVybiBcIiBib3R0b20gbGVmdFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21NaWRkbGU6IHJldHVybiBcIiBib3R0b20gY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbVJpZ2h0OiByZXR1cm4gXCIgYm90dG9tIHJpZ2h0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkNlbnRlcjogcmV0dXJuIFwiIGNlbnRlclwiO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gXCIgYm90dG9tIGxlZnRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0IGZ1bmN0aW9uIFRvVGV0aGVyKGF0dGFjaG1lbnQ6IFBvcHVwQXR0YWNobWVudCkge1xuICAgICAgc3dpdGNoIChhdHRhY2htZW50KSB7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcExlZnQ6IHJldHVybiBcInRvcCBsZWZ0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcE1pZGRsZTogcmV0dXJuIFwidG9wIGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BSaWdodDogcmV0dXJuIFwidG9wIHJpZ2h0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkxlZnRDZW50ZXI6IHJldHVybiBcImxlZnQgbWlkZGxlXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlJpZ2h0Q2VudGVyOiByZXR1cm4gXCJyaWdodCBtaWRkbGVcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTGVmdDogcmV0dXJuIFwiYm90dG9tIGxlZnRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTWlkZGxlOiByZXR1cm4gXCJib3R0b20gY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbVJpZ2h0OiByZXR1cm4gXCJib3R0b20gcmlnaHRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQ2VudGVyOiByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIFwiYm90dG9tIGxlZnRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0IGZ1bmN0aW9uIFRvT3Bwb3NpdGVUZXRoZXIoYXR0YWNobWVudDogUG9wdXBBdHRhY2htZW50KSB7XG4gICAgICBzd2l0Y2ggKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wTGVmdDogcmV0dXJuIFwiYm90dG9tIHJpZ2h0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcE1pZGRsZTogcmV0dXJuIFwiYm90dG9tIGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BSaWdodDogcmV0dXJuIFwiYm90dG9tIGxlZnRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuTGVmdENlbnRlcjogcmV0dXJuIFwicmlnaHQgbWlkZGxlXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlJpZ2h0Q2VudGVyOiByZXR1cm4gXCJsZWZ0IG1pZGRsZVwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21MZWZ0OiByZXR1cm4gXCJ0b3AgcmlnaHRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTWlkZGxlOiByZXR1cm4gXCJ0b3AgY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbVJpZ2h0OiByZXR1cm4gXCJ0b3AgbGVmdFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5DZW50ZXI6IHJldHVybiBcImNlbnRlclwiO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gXCJib3R0b20gbGVmdFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvcG9wdXAvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplLCBBdHRhY2htZW50LCBDb2xvciB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUHJvZ3Jlc3NCYXIge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBwcm9ncmVzczogbnVtYmVyO1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBjb2xvcj86IENvbG9yO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTGFiZWwgY29tcG9uZW50IHRvIGFkZCBpbmZvcm1hdGlvbiB0byBjZXJ0YWluIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBwcm9ncmVzczogbnVtYmVyIC0gVGhlICUgb2YgcHJvZ3Jlc3MgdGhlIHByb2dyZXNzIGJhciBzaG91bGQgcmVmbGVjdC5cbiAgICogICBhY3RpdmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBwcm9ncmVzcyBiYXIgdG8gcmVmbGVjdCBhY3Rpdml0aXkuXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBwcm9ncmVzcyBiYXIgdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcHJvZ3Jlc3MgYmFyIGZvciBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gV2hlcmUgdGhlIHByb2dyZXNzIGJhciBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7IHByb2dyZXNzOiAwIH0pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoW10pO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5wcm9ncmVzc1wiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTGFiZWwgY29tcG9uZW50IHRvIGFkZCBpbmZvcm1hdGlvbiB0byBjZXJ0YWluIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVhOlxuICAgKiAgIHByb2dyZXNzOiBudW1iZXIgLSBUaGUgJSBvZiBwcm9ncmVzcyB0aGUgcHJvZ3Jlc3MgYmFyIHNob3VsZCByZWZsZWN0LlxuICAgKiAgIGFjdGl2ZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHByb2dyZXNzIGJhciB0byByZWZsZWN0IGFjdGl2aXRpeS5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHByb2dyZXNzIGJhciB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBwcm9ncmVzcyBiYXIgZm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBXaGVyZSB0aGUgcHJvZ3Jlc3MgYmFyIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHtwcm9ncmVzczogMH0sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHsgcHJvZ3Jlc3M6IDAgfSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImJhclwiIH0gfSwgeyBzdHlsZTogeyB3aWR0aDogcHJvcHMucHJvZ3Jlc3MgKyBcIiVcIiB9IH0sIFtcbiAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInByb2dyZXNzXCIgfSB9LCBbcHJvcHMucHJvZ3Jlc3MgKyBcIiVcIl0pXG4gICAgICBdKSxcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJsYWJlbFwiIH0gfSwgY29udGVudClcbiAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmFjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hdHRhY2htZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgcHJvZ3Jlc3NcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kdWxlcy9wcm9ncmVzcy9pbmRleC50cyIsImV4cG9ydCAqIGZyb20gXCIuL3N0YXRpc3RpY1wiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZpZXdzL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IENvbG9yLCBGbG9hdCwgU2l6ZX0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHtkaXZ9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cblxuZXhwb3J0IG5hbWVzcGFjZSBTdGF0aXN0aWMge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICB0ZXh0PzogYm9vbGVhbjtcbiAgICBob3Jpem9udGFsPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBmbG9hdD86IEZsb2F0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3RhdGlzdGljIGNvbXBvbmVudCB0byBzaG93IHN0YXRpc3RpY3MuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBob3Jpem9udGFsPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc3RhdGlzdGljIHRvIGRpc3BsYXkgaG9yaXpvbnRhbGx5LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc3RhdGlzdGljIGZvciBhIGRhcmsgYmFja2dyb3VuZC5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgc3RhdGlzdGljLlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBXaGVyZSB0byBmbG9hdCB0aGUgc3RhdGlzdGljLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiB7fSBvZlxuICAgKiAgIHZhbHVlOiBTdHJpbmd8Vk5vZGUgLSBUaGUgdmFsdWUgZm9yIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgbGFiZWw6IFN0cmluZ3xWTm9kZSAtIFRoZSBsYWJlbCBmb3IgdGhlIHN0YXRpc3RpYy5cbiAgICogICBpc1RleHQ/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgc3RhdGlzdGljIHZhbHVlIGZvciB0ZXh0IGJhc2VkIHZhbHVlcy5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50PikgOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcbiAgICAgIHNvdXJjZXMuZXh0cmFzJCA9IHNvdXJjZXMuZXh0cmFzJCA/IHNvdXJjZXMuZXh0cmFzJCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnN0YXRpc3RpY1wiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0YXRpc3RpYyBjb21wb25lbnQgdG8gc2hvdyBzdGF0aXN0aWNzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBob3Jpem9udGFsPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc3RhdGlzdGljIHRvIGRpc3BsYXkgaG9yaXpvbnRhbGx5LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc3RhdGlzdGljIGZvciBhIGRhcmsgYmFja2dyb3VuZC5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgc3RhdGlzdGljLlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBXaGVyZSB0byBmbG9hdCB0aGUgc3RhdGlzdGljLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiB7fSBvZlxuICAgKiAgIHZhbHVlOiBTdHJpbmd8Vk5vZGUgLSBUaGUgdmFsdWUgZm9yIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgbGFiZWw6IFN0cmluZ3xWTm9kZSAtIFRoZSBsYWJlbCBmb3IgdGhlIHN0YXRpc3RpYy5cbiAgICogICBpc1RleHQ/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgc3RhdGlzdGljIHZhbHVlIGZvciB0ZXh0IGJhc2VkIHZhbHVlcy5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHN8RE9NQ29udGVudCA9IHt9LCBjOkRPTUNvbnRlbnQgPSBcIlwiLCBlOkRPTUNvbnRlbnQgPSBcIlwiKSA6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6cE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIGxldCBsYWJlbCA9IGlzRE9NQ29udGVudChwT3JDKSA/IGMgOiBlO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfX0sIFtcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogcHJvcHMudGV4dCA/IFwidGV4dCB2YWx1ZVwiIDogXCJ2YWx1ZVwifX0sIGNvbnRlbnQpLFxuICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImxhYmVsXCIgfX0sIGxhYmVsKVxuICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcykgOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpIFwiO1xuICAgIGlmIChwcm9wcy5ob3Jpem9udGFsKSB7IFxuICAgICAgIGNsYXNzTmFtZSArPSBcIiBob3Jpem9udGFsXCI7XG59XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7IFxuICAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xufVxuICAgIGlmICh0eXBlb2YocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7IFxuICAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG59XG4gICAgaWYgKHR5cGVvZihwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikgeyBcbiAgICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbn1cbiAgICBpZiAodHlwZW9mKHByb3BzLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikgeyBcbiAgICAgICBjbGFzc05hbWUgKz0gRmxvYXQuVG9DbGFzc25hbWUocHJvcHMuZmxvYXQpO1xufVxuICAgIGNsYXNzTmFtZSArPSBcIiBzdGF0aXN0aWNcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdmlld3Mvc3RhdGlzdGljL2luZGV4LnRzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcbnZhciBDb25jYXRQcm9kdWNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY2F0UHJvZHVjZXIoc3RyZWFtcykge1xuICAgICAgICB0aGlzLnN0cmVhbXMgPSBzdHJlYW1zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29uY2F0JztcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgIH1cbiAgICBDb25jYXRQcm9kdWNlci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5zdHJlYW1zW3RoaXMuaV0uX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIENvbmNhdFByb2R1Y2VyLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmVhbXMgPSB0aGlzLnN0cmVhbXM7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtc1t0aGlzLmldLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgIH07XG4gICAgQ29uY2F0UHJvZHVjZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9uKHQpO1xuICAgIH07XG4gICAgQ29uY2F0UHJvZHVjZXIucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIENvbmNhdFByb2R1Y2VyLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc3RyZWFtcyA9IHRoaXMuc3RyZWFtcztcbiAgICAgICAgc3RyZWFtc1t0aGlzLmldLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICgrK3RoaXMuaSA8IHN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJlYW1zW3RoaXMuaV0uX2FkZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHUuX2MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbmNhdFByb2R1Y2VyO1xufSgpKTtcbi8qKlxuICogUHV0cyBvbmUgc3RyZWFtIGFmdGVyIHRoZSBvdGhlci4gKmNvbmNhdCogaXMgYSBmYWN0b3J5IHRoYXQgdGFrZXMgbXVsdGlwbGVcbiAqIHN0cmVhbXMgYXMgYXJndW1lbnRzLCBhbmQgc3RhcnRzIHRoZSBgbisxYC10aCBzdHJlYW0gb25seSB3aGVuIHRoZSBgbmAtdGhcbiAqIHN0cmVhbSBoYXMgY29tcGxldGVkLiBJdCBjb25jYXRlbmF0ZXMgdGhvc2Ugc3RyZWFtcyB0b2dldGhlci5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLTItLS0zLS0tNC18XG4gKiAuLi4uLi4uLi4uLi4uLi4tLWEtYi1jLS1kLXxcbiAqICAgICAgICAgICBjb25jYXRcbiAqIC0tMS0tMi0tLTMtLS00LS0tYS1iLWMtLWQtfFxuICogYGBgXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IGNvbmNhdCBmcm9tICd4c3RyZWFtL2V4dHJhL2NvbmNhdCdcbiAqXG4gKiBjb25zdCBzdHJlYW1BID0geHMub2YoJ2EnLCAnYicsICdjJylcbiAqIGNvbnN0IHN0cmVhbUIgPSB4cy5vZigxMCwgMjAsIDMwKVxuICogY29uc3Qgc3RyZWFtQyA9IHhzLm9mKCdYJywgJ1knLCAnWicpXG4gKlxuICogY29uc3Qgb3V0cHV0U3RyZWFtID0gY29uY2F0KHN0cmVhbUEsIHN0cmVhbUIsIHN0cmVhbUMpXG4gKlxuICogb3V0cHV0U3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogKHgpID0+IGNvbnNvbGUubG9nKHgpLFxuICogICBlcnJvcjogKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIpLFxuICogICBjb21wbGV0ZTogKCkgPT4gY29uc29sZS5sb2coJ2NvbmNhdCBjb21wbGV0ZWQnKSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZmFjdG9yeSB0cnVlXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMSBBIHN0cmVhbSB0byBjb25jYXRlbmF0ZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMiBBIHN0cmVhbSB0byBjb25jYXRlbmF0ZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuIFR3b1xuICogb3IgbW9yZSBzdHJlYW1zIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgc3RyZWFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBpbmRleF8xLlN0cmVhbShuZXcgQ29uY2F0UHJvZHVjZXIoc3RyZWFtcykpO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29uY2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2V4dHJhL2NvbmNhdC5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG52YXIgRkNJTCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRkNJTChvdXQsIG9wKSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIEZDSUwucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5vdXQuX24odCk7XG4gICAgfTtcbiAgICBGQ0lMLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5vdXQuX2UoZXJyKTtcbiAgICB9O1xuICAgIEZDSUwucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wLmxlc3MoKTtcbiAgICB9O1xuICAgIHJldHVybiBGQ0lMO1xufSgpKTtcbnZhciBGbGF0dGVuQ29uY09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGbGF0dGVuQ29uY09wZXJhdG9yKGlucykge1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZsYXR0ZW5Db25jdXJyZW50bHknO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDE7IC8vIG51bWJlciBvZiBvdXRlcnMgYW5kIGlubmVycyB0aGF0IGhhdmUgbm90IHlldCBlbmRlZFxuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgfVxuICAgIEZsYXR0ZW5Db25jT3BlcmF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBGbGF0dGVuQ29uY09wZXJhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAxO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgfTtcbiAgICBGbGF0dGVuQ29uY09wZXJhdG9yLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgICAgIGlmICghdSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZsYXR0ZW5Db25jT3BlcmF0b3IucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICBzLl9hZGQobmV3IEZDSUwodSwgdGhpcykpO1xuICAgIH07XG4gICAgRmxhdHRlbkNvbmNPcGVyYXRvci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRmxhdHRlbkNvbmNPcGVyYXRvci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGVzcygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZsYXR0ZW5Db25jT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5GbGF0dGVuQ29uY09wZXJhdG9yID0gRmxhdHRlbkNvbmNPcGVyYXRvcjtcbi8qKlxuICogRmxhdHRlbnMgYSBcInN0cmVhbSBvZiBzdHJlYW1zXCIsIGhhbmRsaW5nIG11bHRpcGxlIGNvbmN1cnJlbnQgbmVzdGVkIHN0cmVhbXNcbiAqIHNpbXVsdGFuZW91c2x5LlxuICpcbiAqIElmIHRoZSBpbnB1dCBzdHJlYW0gaXMgYSBzdHJlYW0gdGhhdCBlbWl0cyBzdHJlYW1zLCB0aGVuIHRoaXMgb3BlcmF0b3Igd2lsbFxuICogcmV0dXJuIGFuIG91dHB1dCBzdHJlYW0gd2hpY2ggaXMgYSBmbGF0IHN0cmVhbTogZW1pdHMgcmVndWxhciBldmVudHMuIFRoZVxuICogZmxhdHRlbmluZyBoYXBwZW5zIGNvbmN1cnJlbnRseS4gSXQgd29ya3MgbGlrZSB0aGlzOiB3aGVuIHRoZSBpbnB1dCBzdHJlYW1cbiAqIGVtaXRzIGEgbmVzdGVkIHN0cmVhbSwgKmZsYXR0ZW5Db25jdXJyZW50bHkqIHdpbGwgc3RhcnQgaW1pdGF0aW5nIHRoYXRcbiAqIG5lc3RlZCBvbmUuIFdoZW4gdGhlIG5leHQgbmVzdGVkIHN0cmVhbSBpcyBlbWl0dGVkIG9uIHRoZSBpbnB1dCBzdHJlYW0sXG4gKiAqZmxhdHRlbkNvbmN1cnJlbnRseSogd2lsbCBhbHNvIGltaXRhdGUgdGhhdCBuZXcgb25lLCBidXQgd2lsbCBjb250aW51ZSB0b1xuICogaW1pdGF0ZSB0aGUgcHJldmlvdXMgbmVzdGVkIHN0cmVhbXMgYXMgd2VsbC5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLSstLS0tLS0tLSstLS0tLS0tLS0tLS0tLS1cbiAqICAgXFwgICAgICAgIFxcXG4gKiAgICBcXCAgICAgICAtLS0tMS0tLS0yLS0tMy0tXG4gKiAgICAtLWEtLWItLS0tYy0tLS1kLS0tLS0tLS1cbiAqICAgICBmbGF0dGVuQ29uY3VycmVudGx5XG4gKiAtLS0tLWEtLWItLS0tYy0xLS1kLTItLS0zLS1cbiAqIGBgYFxuICpcbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNvbmN1cnJlbnRseShpbnMpIHtcbiAgICByZXR1cm4gbmV3IGluZGV4XzEuU3RyZWFtKG5ldyBGbGF0dGVuQ29uY09wZXJhdG9yKGlucykpO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmxhdHRlbkNvbmN1cnJlbnRseTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsYXR0ZW5Db25jdXJyZW50bHkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3hzdHJlYW0vZXh0cmEvZmxhdHRlbkNvbmN1cnJlbnRseS5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=