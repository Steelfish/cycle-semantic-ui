/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 215);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var symbol_observable_1 = __webpack_require__(171);
var NO = {};
exports.NO = NO;
function noop() { }
function cp(a) {
    var l = a.length;
    var b = Array(l);
    for (var i = 0; i < l; ++i)
        b[i] = a[i];
    return b;
}
function and(f1, f2) {
    return function andFn(t) {
        return f1(t) && f2(t);
    };
}
function _try(c, t, u) {
    try {
        return c.f(t);
    }
    catch (e) {
        u._e(e);
        return NO;
    }
}
var NO_IL = {
    _n: noop,
    _e: noop,
    _c: noop,
};
exports.NO_IL = NO_IL;
// mutates the input
function internalizeProducer(producer) {
    producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
    };
    producer._stop = producer.stop;
}
var StreamSub = (function () {
    function StreamSub(_stream, _listener) {
        this._stream = _stream;
        this._listener = _listener;
    }
    StreamSub.prototype.unsubscribe = function () {
        this._stream.removeListener(this._listener);
    };
    return StreamSub;
}());
var Observer = (function () {
    function Observer(_listener) {
        this._listener = _listener;
    }
    Observer.prototype.next = function (value) {
        this._listener._n(value);
    };
    Observer.prototype.error = function (err) {
        this._listener._e(err);
    };
    Observer.prototype.complete = function () {
        this._listener._c();
    };
    return Observer;
}());
var FromObservable = (function () {
    function FromObservable(observable) {
        this.type = 'fromObservable';
        this.ins = observable;
        this.active = false;
    }
    FromObservable.prototype._start = function (out) {
        this.out = out;
        this.active = true;
        this._sub = this.ins.subscribe(new Observer(out));
        if (!this.active)
            this._sub.unsubscribe();
    };
    FromObservable.prototype._stop = function () {
        if (this._sub)
            this._sub.unsubscribe();
        this.active = false;
    };
    return FromObservable;
}());
var Merge = (function () {
    function Merge(insArr) {
        this.type = 'merge';
        this.insArr = insArr;
        this.out = NO;
        this.ac = 0;
    }
    Merge.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var L = s.length;
        this.ac = L;
        for (var i = 0; i < L; i++)
            s[i]._add(this);
    };
    Merge.prototype._stop = function () {
        var s = this.insArr;
        var L = s.length;
        for (var i = 0; i < L; i++)
            s[i]._remove(this);
        this.out = NO;
    };
    Merge.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    Merge.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Merge.prototype._c = function () {
        if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
                return;
            u._c();
        }
    };
    return Merge;
}());
var CombineListener = (function () {
    function CombineListener(i, out, p) {
        this.i = i;
        this.out = out;
        this.p = p;
        p.ils.push(this);
    }
    CombineListener.prototype._n = function (t) {
        var p = this.p, out = this.out;
        if (out === NO)
            return;
        if (p.up(t, this.i))
            out._n(p.vals);
    };
    CombineListener.prototype._e = function (err) {
        var out = this.out;
        if (out === NO)
            return;
        out._e(err);
    };
    CombineListener.prototype._c = function () {
        var p = this.p;
        if (p.out === NO)
            return;
        if (--p.Nc === 0)
            p.out._c();
    };
    return CombineListener;
}());
var Combine = (function () {
    function Combine(insArr) {
        this.type = 'combine';
        this.insArr = insArr;
        this.out = NO;
        this.ils = [];
        this.Nc = this.Nn = 0;
        this.vals = [];
    }
    Combine.prototype.up = function (t, i) {
        var v = this.vals[i];
        var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
        this.vals[i] = t;
        return Nn === 0;
    };
    Combine.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var n = this.Nc = this.Nn = s.length;
        var vals = this.vals = new Array(n);
        if (n === 0) {
            out._n([]);
            out._c();
        }
        else {
            for (var i = 0; i < n; i++) {
                vals[i] = NO;
                s[i]._add(new CombineListener(i, out, this));
            }
        }
    };
    Combine.prototype._stop = function () {
        var s = this.insArr;
        var n = s.length;
        var ils = this.ils;
        for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
        this.out = NO;
        this.ils = [];
        this.vals = [];
    };
    return Combine;
}());
var FromArray = (function () {
    function FromArray(a) {
        this.type = 'fromArray';
        this.a = a;
    }
    FromArray.prototype._start = function (out) {
        var a = this.a;
        for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
        out._c();
    };
    FromArray.prototype._stop = function () {
    };
    return FromArray;
}());
var FromPromise = (function () {
    function FromPromise(p) {
        this.type = 'fromPromise';
        this.on = false;
        this.p = p;
    }
    FromPromise.prototype._start = function (out) {
        var prod = this;
        this.on = true;
        this.p.then(function (v) {
            if (prod.on) {
                out._n(v);
                out._c();
            }
        }, function (e) {
            out._e(e);
        }).then(noop, function (err) {
            setTimeout(function () { throw err; });
        });
    };
    FromPromise.prototype._stop = function () {
        this.on = false;
    };
    return FromPromise;
}());
var Periodic = (function () {
    function Periodic(period) {
        this.type = 'periodic';
        this.period = period;
        this.intervalID = -1;
        this.i = 0;
    }
    Periodic.prototype._start = function (out) {
        var self = this;
        function intervalHandler() { out._n(self.i++); }
        this.intervalID = setInterval(intervalHandler, this.period);
    };
    Periodic.prototype._stop = function () {
        if (this.intervalID !== -1)
            clearInterval(this.intervalID);
        this.intervalID = -1;
        this.i = 0;
    };
    return Periodic;
}());
var Debug = (function () {
    function Debug(ins, arg) {
        this.type = 'debug';
        this.ins = ins;
        this.out = NO;
        this.s = noop;
        this.l = '';
        if (typeof arg === 'string')
            this.l = arg;
        else if (typeof arg === 'function')
            this.s = arg;
    }
    Debug.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Debug.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Debug.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var s = this.s, l = this.l;
        if (s !== noop) {
            try {
                s(t);
            }
            catch (e) {
                u._e(e);
            }
        }
        else if (l)
            console.log(l + ':', t);
        else
            console.log(t);
        u._n(t);
    };
    Debug.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Debug.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Debug;
}());
var Drop = (function () {
    function Drop(max, ins) {
        this.type = 'drop';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.dropped = 0;
    }
    Drop.prototype._start = function (out) {
        this.out = out;
        this.dropped = 0;
        this.ins._add(this);
    };
    Drop.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Drop.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        if (this.dropped++ >= this.max)
            u._n(t);
    };
    Drop.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Drop.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Drop;
}());
var EndWhenListener = (function () {
    function EndWhenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    EndWhenListener.prototype._n = function () {
        this.op.end();
    };
    EndWhenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    EndWhenListener.prototype._c = function () {
        this.op.end();
    };
    return EndWhenListener;
}());
var EndWhen = (function () {
    function EndWhen(o, ins) {
        this.type = 'endWhen';
        this.ins = ins;
        this.out = NO;
        this.o = o;
        this.oil = NO_IL;
    }
    EndWhen.prototype._start = function (out) {
        this.out = out;
        this.o._add(this.oil = new EndWhenListener(out, this));
        this.ins._add(this);
    };
    EndWhen.prototype._stop = function () {
        this.ins._remove(this);
        this.o._remove(this.oil);
        this.out = NO;
        this.oil = NO_IL;
    };
    EndWhen.prototype.end = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    EndWhen.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    EndWhen.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    EndWhen.prototype._c = function () {
        this.end();
    };
    return EndWhen;
}());
var Filter = (function () {
    function Filter(passes, ins) {
        this.type = 'filter';
        this.ins = ins;
        this.out = NO;
        this.f = passes;
    }
    Filter.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Filter.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Filter.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO || !r)
            return;
        u._n(t);
    };
    Filter.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Filter.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Filter;
}());
var FlattenListener = (function () {
    function FlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    FlattenListener.prototype._n = function (t) {
        this.out._n(t);
    };
    FlattenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    FlattenListener.prototype._c = function () {
        this.op.inner = NO;
        this.op.less();
    };
    return FlattenListener;
}());
var Flatten = (function () {
    function Flatten(ins) {
        this.type = 'flatten';
        this.ins = ins;
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    }
    Flatten.prototype._start = function (out) {
        this.out = out;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
        this.ins._add(this);
    };
    Flatten.prototype._stop = function () {
        this.ins._remove(this);
        if (this.inner !== NO)
            this.inner._remove(this.il);
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    };
    Flatten.prototype.less = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (!this.open && this.inner === NO)
            u._c();
    };
    Flatten.prototype._n = function (s) {
        var u = this.out;
        if (u === NO)
            return;
        var _a = this, inner = _a.inner, il = _a.il;
        if (inner !== NO && il !== NO_IL)
            inner._remove(il);
        (this.inner = s)._add(this.il = new FlattenListener(u, this));
    };
    Flatten.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Flatten.prototype._c = function () {
        this.open = false;
        this.less();
    };
    return Flatten;
}());
var Fold = (function () {
    function Fold(f, seed, ins) {
        var _this = this;
        this.type = 'fold';
        this.ins = ins;
        this.out = NO;
        this.f = function (t) { return f(_this.acc, t); };
        this.acc = this.seed = seed;
    }
    Fold.prototype._start = function (out) {
        this.out = out;
        this.acc = this.seed;
        out._n(this.acc);
        this.ins._add(this);
    };
    Fold.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.acc = this.seed;
    };
    Fold.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(this.acc = r);
    };
    Fold.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Fold.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Fold;
}());
var Last = (function () {
    function Last(ins) {
        this.type = 'last';
        this.ins = ins;
        this.out = NO;
        this.has = false;
        this.val = NO;
    }
    Last.prototype._start = function (out) {
        this.out = out;
        this.has = false;
        this.ins._add(this);
    };
    Last.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.val = NO;
    };
    Last.prototype._n = function (t) {
        this.has = true;
        this.val = t;
    };
    Last.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Last.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (this.has) {
            u._n(this.val);
            u._c();
        }
        else
            u._e(new Error('last() failed because input stream completed'));
    };
    return Last;
}());
var MapFlattenListener = (function () {
    function MapFlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    MapFlattenListener.prototype._n = function (r) {
        this.out._n(r);
    };
    MapFlattenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    MapFlattenListener.prototype._c = function () {
        this.op.inner = NO;
        this.op.less();
    };
    return MapFlattenListener;
}());
var MapFlatten = (function () {
    function MapFlatten(mapOp) {
        this.type = mapOp.type + "+flatten";
        this.ins = mapOp.ins;
        this.out = NO;
        this.mapOp = mapOp;
        this.inner = NO;
        this.il = NO_IL;
        this.open = true;
    }
    MapFlatten.prototype._start = function (out) {
        this.out = out;
        this.inner = NO;
        this.il = NO_IL;
        this.open = true;
        this.mapOp.ins._add(this);
    };
    MapFlatten.prototype._stop = function () {
        this.mapOp.ins._remove(this);
        if (this.inner !== NO)
            this.inner._remove(this.il);
        this.out = NO;
        this.inner = NO;
        this.il = NO_IL;
    };
    MapFlatten.prototype.less = function () {
        if (!this.open && this.inner === NO) {
            var u = this.out;
            if (u === NO)
                return;
            u._c();
        }
    };
    MapFlatten.prototype._n = function (v) {
        var u = this.out;
        if (u === NO)
            return;
        var _a = this, inner = _a.inner, il = _a.il;
        var s = _try(this.mapOp, v, u);
        if (s === NO)
            return;
        if (inner !== NO && il !== NO_IL)
            inner._remove(il);
        (this.inner = s)._add(this.il = new MapFlattenListener(u, this));
    };
    MapFlatten.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    MapFlatten.prototype._c = function () {
        this.open = false;
        this.less();
    };
    return MapFlatten;
}());
var MapOp = (function () {
    function MapOp(project, ins) {
        this.type = 'map';
        this.ins = ins;
        this.out = NO;
        this.f = project;
    }
    MapOp.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    MapOp.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    MapOp.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(r);
    };
    MapOp.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    MapOp.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return MapOp;
}());
var FilterMapFusion = (function (_super) {
    __extends(FilterMapFusion, _super);
    function FilterMapFusion(passes, project, ins) {
        var _this = _super.call(this, project, ins) || this;
        _this.type = 'filter+map';
        _this.passes = passes;
        return _this;
    }
    FilterMapFusion.prototype._n = function (t) {
        if (!this.passes(t))
            return;
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(r);
    };
    return FilterMapFusion;
}(MapOp));
var Remember = (function () {
    function Remember(ins) {
        this.type = 'remember';
        this.ins = ins;
        this.out = NO;
    }
    Remember.prototype._start = function (out) {
        this.out = out;
        this.ins._add(out);
    };
    Remember.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return Remember;
}());
var ReplaceError = (function () {
    function ReplaceError(replacer, ins) {
        this.type = 'replaceError';
        this.ins = ins;
        this.out = NO;
        this.f = replacer;
    }
    ReplaceError.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    ReplaceError.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    ReplaceError.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    ReplaceError.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
        }
        catch (e) {
            u._e(e);
        }
    };
    ReplaceError.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return ReplaceError;
}());
var StartWith = (function () {
    function StartWith(ins, val) {
        this.type = 'startWith';
        this.ins = ins;
        this.out = NO;
        this.val = val;
    }
    StartWith.prototype._start = function (out) {
        this.out = out;
        this.out._n(this.val);
        this.ins._add(out);
    };
    StartWith.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return StartWith;
}());
var Take = (function () {
    function Take(max, ins) {
        this.type = 'take';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.taken = 0;
    }
    Take.prototype._start = function (out) {
        this.out = out;
        this.taken = 0;
        if (this.max <= 0)
            out._c();
        else
            this.ins._add(this);
    };
    Take.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Take.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var m = ++this.taken;
        if (m < this.max)
            u._n(t);
        else if (m === this.max) {
            u._n(t);
            u._c();
        }
    };
    Take.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Take.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Take;
}());
var Stream = (function () {
    function Stream(producer) {
        this._prod = producer || NO;
        this._ils = [];
        this._stopID = NO;
        this._dl = NO;
        this._d = false;
        this._target = NO;
        this._err = NO;
    }
    Stream.prototype._n = function (t) {
        var a = this._ils;
        var L = a.length;
        if (this._d)
            this._dl._n(t);
        if (L == 1)
            a[0]._n(t);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._n(t);
        }
    };
    Stream.prototype._e = function (err) {
        if (this._err !== NO)
            return;
        this._err = err;
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._e(err);
        if (L == 1)
            a[0]._e(err);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._e(err);
        }
        if (!this._d && L == 0)
            throw this._err;
    };
    Stream.prototype._c = function () {
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._c();
        if (L == 1)
            a[0]._c();
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._c();
        }
    };
    Stream.prototype._x = function () {
        if (this._ils.length === 0)
            return;
        if (this._prod !== NO)
            this._prod._stop();
        this._err = NO;
        this._ils = [];
    };
    Stream.prototype._stopNow = function () {
        // WARNING: code that calls this method should
        // first check if this._prod is valid (not `NO`)
        this._prod._stop();
        this._err = NO;
        this._stopID = NO;
    };
    Stream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1)
            return;
        if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    Stream.prototype._remove = function (il) {
        var _this = this;
        var ta = this._target;
        if (ta !== NO)
            return ta._remove(il);
        var a = this._ils;
        var i = a.indexOf(il);
        if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
                this._err = NO;
                this._stopID = setTimeout(function () { return _this._stopNow(); });
            }
            else if (a.length === 1) {
                this._pruneCycles();
            }
        }
    };
    // If all paths stemming from `this` stream eventually end at `this`
    // stream, then we remove the single listener of `this` stream, to
    // force it to end its execution and dispose resources. This method
    // assumes as a precondition that this._ils has just one listener.
    Stream.prototype._pruneCycles = function () {
        if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
    };
    // Checks whether *there is no* path starting from `x` that leads to an end
    // listener (sink) in the stream graph, following edges A->B where B is a
    // listener of A. This means these paths constitute a cycle somehow. Is given
    // a trace of all visited nodes so far.
    Stream.prototype._hasNoSinks = function (x, trace) {
        if (trace.indexOf(x) !== -1)
            return true;
        else if (x.out === this)
            return true;
        else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
        else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
                if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                    return false;
            return true;
        }
        else
            return false;
    };
    Stream.prototype.ctor = function () {
        return this instanceof MemoryStream ? MemoryStream : Stream;
    };
    /**
     * Adds a Listener to the Stream.
     *
     * @param {Listener} listener
     */
    Stream.prototype.addListener = function (listener) {
        listener._n = listener.next || noop;
        listener._e = listener.error || noop;
        listener._c = listener.complete || noop;
        this._add(listener);
    };
    /**
     * Removes a Listener from the Stream, assuming the Listener was added to it.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.removeListener = function (listener) {
        this._remove(listener);
    };
    /**
     * Adds a Listener to the Stream returning a Subscription to remove that
     * listener.
     *
     * @param {Listener} listener
     * @returns {Subscription}
     */
    Stream.prototype.subscribe = function (listener) {
        this.addListener(listener);
        return new StreamSub(this, listener);
    };
    /**
     * Add interop between most.js and RxJS 5
     *
     * @returns {Stream}
     */
    Stream.prototype[symbol_observable_1.default] = function () {
        return this;
    };
    /**
     * Creates a new Stream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {Stream}
     */
    Stream.create = function (producer) {
        if (producer) {
            if (typeof producer.start !== 'function'
                || typeof producer.stop !== 'function')
                throw new Error('producer requires both start and stop functions');
            internalizeProducer(producer); // mutates the input
        }
        return new Stream(producer);
    };
    /**
     * Creates a new MemoryStream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {MemoryStream}
     */
    Stream.createWithMemory = function (producer) {
        if (producer)
            internalizeProducer(producer); // mutates the input
        return new MemoryStream(producer);
    };
    /**
     * Creates a Stream that does nothing when started. It never emits any event.
     *
     * Marble diagram:
     *
     * ```text
     *          never
     * -----------------------
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.never = function () {
        return new Stream({ _start: noop, _stop: noop });
    };
    /**
     * Creates a Stream that immediately emits the "complete" notification when
     * started, and that's it.
     *
     * Marble diagram:
     *
     * ```text
     * empty
     * -|
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.empty = function () {
        return new Stream({
            _start: function (il) { il._c(); },
            _stop: noop,
        });
    };
    /**
     * Creates a Stream that immediately emits an "error" notification with the
     * value you passed as the `error` argument when the stream starts, and that's
     * it.
     *
     * Marble diagram:
     *
     * ```text
     * throw(X)
     * -X
     * ```
     *
     * @factory true
     * @param error The error event to emit on the created stream.
     * @return {Stream}
     */
    Stream.throw = function (error) {
        return new Stream({
            _start: function (il) { il._e(error); },
            _stop: noop,
        });
    };
    /**
     * Creates a stream from an Array, Promise, or an Observable.
     *
     * @factory true
     * @param {Array|Promise|Observable} input The input to make a stream from.
     * @return {Stream}
     */
    Stream.from = function (input) {
        if (typeof input[symbol_observable_1.default] === 'function')
            return Stream.fromObservable(input);
        else if (typeof input.then === 'function')
            return Stream.fromPromise(input);
        else if (Array.isArray(input))
            return Stream.fromArray(input);
        throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    };
    /**
     * Creates a Stream that immediately emits the arguments that you give to
     * *of*, then completes.
     *
     * Marble diagram:
     *
     * ```text
     * of(1,2,3)
     * 123|
     * ```
     *
     * @factory true
     * @param a The first value you want to emit as an event on the stream.
     * @param b The second value you want to emit as an event on the stream. One
     * or more of these values may be given as arguments.
     * @return {Stream}
     */
    Stream.of = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        return Stream.fromArray(items);
    };
    /**
     * Converts an array to a stream. The returned stream will emit synchronously
     * all the items in the array, and then complete.
     *
     * Marble diagram:
     *
     * ```text
     * fromArray([1,2,3])
     * 123|
     * ```
     *
     * @factory true
     * @param {Array} array The array to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromArray = function (array) {
        return new Stream(new FromArray(array));
    };
    /**
     * Converts a promise to a stream. The returned stream will emit the resolved
     * value of the promise, and then complete. However, if the promise is
     * rejected, the stream will emit the corresponding error.
     *
     * Marble diagram:
     *
     * ```text
     * fromPromise( ----42 )
     * -----------------42|
     * ```
     *
     * @factory true
     * @param {Promise} promise The promise to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromPromise = function (promise) {
        return new Stream(new FromPromise(promise));
    };
    /**
     * Converts an Observable into a Stream.
     *
     * @factory true
     * @param {any} observable The observable to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromObservable = function (obs) {
        if (obs.endWhen)
            return obs;
        return new Stream(new FromObservable(obs));
    };
    /**
     * Creates a stream that periodically emits incremental numbers, every
     * `period` milliseconds.
     *
     * Marble diagram:
     *
     * ```text
     *     periodic(1000)
     * ---0---1---2---3---4---...
     * ```
     *
     * @factory true
     * @param {number} period The interval in milliseconds to use as a rate of
     * emission.
     * @return {Stream}
     */
    Stream.periodic = function (period) {
        return new Stream(new Periodic(period));
    };
    Stream.prototype._map = function (project) {
        var p = this._prod;
        var ctor = this.ctor();
        if (p instanceof Filter)
            return new ctor(new FilterMapFusion(p.f, project, p.ins));
        return new ctor(new MapOp(project, this));
    };
    /**
     * Transforms each event from the input Stream through a `project` function,
     * to get a Stream that emits those transformed events.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7------
     *    map(i => i * 10)
     * --10--30-50----70-----
     * ```
     *
     * @param {Function} project A function of type `(t: T) => U` that takes event
     * `t` of type `T` from the input Stream and produces an event of type `U`, to
     * be emitted on the output Stream.
     * @return {Stream}
     */
    Stream.prototype.map = function (project) {
        return this._map(project);
    };
    /**
     * It's like `map`, but transforms each input event to always the same
     * constant value on the output Stream.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7-----
     *       mapTo(10)
     * --10--10-10----10----
     * ```
     *
     * @param projectedValue A value to emit on the output Stream whenever the
     * input Stream emits any value.
     * @return {Stream}
     */
    Stream.prototype.mapTo = function (projectedValue) {
        var s = this.map(function () { return projectedValue; });
        var op = s._prod;
        op.type = op.type.replace('map', 'mapTo');
        return s;
    };
    /**
     * Only allows events that pass the test given by the `passes` argument.
     *
     * Each event from the input stream is given to the `passes` function. If the
     * function returns `true`, the event is forwarded to the output stream,
     * otherwise it is ignored and not forwarded.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2--3-----4-----5---6--7-8--
     *     filter(i => i % 2 === 0)
     * ------2--------4---------6----8--
     * ```
     *
     * @param {Function} passes A function of type `(t: T) +> boolean` that takes
     * an event from the input stream and checks if it passes, by returning a
     * boolean.
     * @return {Stream}
     */
    Stream.prototype.filter = function (passes) {
        var p = this._prod;
        if (p instanceof Filter)
            return new Stream(new Filter(and(p.f, passes), p.ins));
        return new Stream(new Filter(passes, this));
    };
    /**
     * Lets the first `amount` many events from the input stream pass to the
     * output stream, then makes the output stream complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *    take(3)
     * --a---b--c|
     * ```
     *
     * @param {number} amount How many events to allow from the input stream
     * before completing the output stream.
     * @return {Stream}
     */
    Stream.prototype.take = function (amount) {
        return new (this.ctor())(new Take(amount, this));
    };
    /**
     * Ignores the first `amount` many events from the input stream, and then
     * after that starts forwarding events from the input stream to the output
     * stream.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *       drop(3)
     * --------------d---e--
     * ```
     *
     * @param {number} amount How many events to ignore from the input stream
     * before forwarding all events from the input stream to the output stream.
     * @return {Stream}
     */
    Stream.prototype.drop = function (amount) {
        return new Stream(new Drop(amount, this));
    };
    /**
     * When the input stream completes, the output stream will emit the last event
     * emitted by the input stream, and then will also complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c--d----|
     *       last()
     * -----------------d|
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.last = function () {
        return new Stream(new Last(this));
    };
    /**
     * Prepends the given `initial` value to the sequence of events emitted by the
     * input stream. The returned stream is a MemoryStream, which means it is
     * already `remember()`'d.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3---
     *   startWith(0)
     * 0--1---2-----3---
     * ```
     *
     * @param initial The value or event to prepend.
     * @return {MemoryStream}
     */
    Stream.prototype.startWith = function (initial) {
        return new MemoryStream(new StartWith(this, initial));
    };
    /**
     * Uses another stream to determine when to complete the current stream.
     *
     * When the given `other` stream emits an event or completes, the output
     * stream will complete. Before that happens, the output stream will behaves
     * like the input stream.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3--4----5----6---
     *   endWhen( --------a--b--| )
     * ---1---2-----3--4--|
     * ```
     *
     * @param other Some other stream that is used to know when should the output
     * stream of this operator complete.
     * @return {Stream}
     */
    Stream.prototype.endWhen = function (other) {
        return new (this.ctor())(new EndWhen(other, this));
    };
    /**
     * "Folds" the stream onto itself.
     *
     * Combines events from the past throughout
     * the entire execution of the input stream, allowing you to accumulate them
     * together. It's essentially like `Array.prototype.reduce`. The returned
     * stream is a MemoryStream, which means it is already `remember()`'d.
     *
     * The output stream starts by emitting the `seed` which you give as argument.
     * Then, when an event happens on the input stream, it is combined with that
     * seed value through the `accumulate` function, and the output value is
     * emitted on the output stream. `fold` remembers that output value as `acc`
     * ("accumulator"), and then when a new input event `t` happens, `acc` will be
     * combined with that to produce the new `acc` and so forth.
     *
     * Marble diagram:
     *
     * ```text
     * ------1-----1--2----1----1------
     *   fold((acc, x) => acc + x, 3)
     * 3-----4-----5--7----8----9------
     * ```
     *
     * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that
     * takes the previous accumulated value `acc` and the incoming event from the
     * input stream and produces the new accumulated value.
     * @param seed The initial accumulated value, of type `R`.
     * @return {MemoryStream}
     */
    Stream.prototype.fold = function (accumulate, seed) {
        return new MemoryStream(new Fold(accumulate, seed, this));
    };
    /**
     * Replaces an error with another stream.
     *
     * When (and if) an error happens on the input stream, instead of forwarding
     * that error to the output stream, *replaceError* will call the `replace`
     * function which returns the stream that the output stream will replicate.
     * And, in case that new stream also emits an error, `replace` will be called
     * again to get another stream to start replicating.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2-----3--4-----X
     *   replaceError( () => --10--| )
     * --1---2-----3--4--------10--|
     * ```
     *
     * @param {Function} replace A function of type `(err) => Stream` that takes
     * the error that occurred on the input stream or on the previous replacement
     * stream and returns a new stream. The output stream will behave like the
     * stream that this function returns.
     * @return {Stream}
     */
    Stream.prototype.replaceError = function (replace) {
        return new (this.ctor())(new ReplaceError(replace, this));
    };
    /**
     * Flattens a "stream of streams", handling only one nested stream at a time
     * (no concurrency).
     *
     * If the input stream is a stream that emits streams, then this operator will
     * return an output stream which is a flat stream: emits regular events. The
     * flattening happens without concurrency. It works like this: when the input
     * stream emits a nested stream, *flatten* will start imitating that nested
     * one. However, as soon as the next nested stream is emitted on the input
     * stream, *flatten* will forget the previous nested one it was imitating, and
     * will start imitating the new nested one.
     *
     * Marble diagram:
     *
     * ```text
     * --+--------+---------------
     *   \        \
     *    \       ----1----2---3--
     *    --a--b----c----d--------
     *           flatten
     * -----a--b------1----2---3--
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.flatten = function () {
        var p = this._prod;
        return new Stream(p instanceof MapOp && !(p instanceof FilterMapFusion) ?
            new MapFlatten(p) :
            new Flatten(this));
    };
    /**
     * Passes the input stream to a custom operator, to produce an output stream.
     *
     * *compose* is a handy way of using an existing function in a chained style.
     * Instead of writing `outStream = f(inStream)` you can write
     * `outStream = inStream.compose(f)`.
     *
     * @param {function} operator A function that takes a stream as input and
     * returns a stream as well.
     * @return {Stream}
     */
    Stream.prototype.compose = function (operator) {
        return operator(this);
    };
    /**
     * Returns an output stream that behaves like the input stream, but also
     * remembers the most recent event that happens on the input stream, so that a
     * newly added listener will immediately receive that memorised event.
     *
     * @return {MemoryStream}
     */
    Stream.prototype.remember = function () {
        return new MemoryStream(new Remember(this));
    };
    /**
     * Returns an output stream that identically behaves like the input stream,
     * but also runs a `spy` function fo each event, to help you debug your app.
     *
     * *debug* takes a `spy` function as argument, and runs that for each event
     * happening on the input stream. If you don't provide the `spy` argument,
     * then *debug* will just `console.log` each event. This helps you to
     * understand the flow of events through some operator chain.
     *
     * Please note that if the output stream has no listeners, then it will not
     * start, which means `spy` will never run because no actual event happens in
     * that case.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3-----4--
     *         debug
     * --1----2-----3-----4--
     * ```
     *
     * @param {function} labelOrSpy A string to use as the label when printing
     * debug information on the console, or a 'spy' function that takes an event
     * as argument, and does not need to return anything.
     * @return {Stream}
     */
    Stream.prototype.debug = function (labelOrSpy) {
        return new (this.ctor())(new Debug(this, labelOrSpy));
    };
    /**
     * *imitate* changes this current Stream to emit the same events that the
     * `other` given Stream does. This method returns nothing.
     *
     * This method exists to allow one thing: **circular dependency of streams**.
     * For instance, let's imagine that for some reason you need to create a
     * circular dependency where stream `first$` depends on stream `second$`
     * which in turn depends on `first$`:
     *
     * <!-- skip-example -->
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var first$ = second$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * ```
     *
     * However, that is invalid JavaScript, because `second$` is undefined
     * on the first line. This is how *imitate* can help solve it:
     *
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var secondProxy$ = xs.create();
     * var first$ = secondProxy$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * secondProxy$.imitate(second$);
     * ```
     *
     * We create `secondProxy$` before the others, so it can be used in the
     * declaration of `first$`. Then, after both `first$` and `second$` are
     * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell
     * that they are "the same". `imitate` will not trigger the start of any
     * stream, it just binds `secondProxy$` and `second$` together.
     *
     * The following is an example where `imitate()` is important in Cycle.js
     * applications. A parent component contains some child components. A child
     * has an action stream which is given to the parent to define its state:
     *
     * <!-- skip-example -->
     * ```js
     * const childActionProxy$ = xs.create();
     * const parent = Parent({...sources, childAction$: childActionProxy$});
     * const childAction$ = parent.state$.map(s => s.child.action$).flatten();
     * childActionProxy$.imitate(childAction$);
     * ```
     *
     * Note, though, that **`imitate()` does not support MemoryStreams**. If we
     * would attempt to imitate a MemoryStream in a circular dependency, we would
     * either get a race condition (where the symptom would be "nothing happens")
     * or an infinite cyclic emission of values. It's useful to think about
     * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to
     * define a spreadsheet cell `A1` with a formula that depends on `B1` and
     * cell `B1` defined with a formula that depends on `A1`.
     *
     * If you find yourself wanting to use `imitate()` with a
     * MemoryStream, you should rework your code around `imitate()` to use a
     * Stream instead. Look for the stream in the circular dependency that
     * represents an event stream, and that would be a candidate for creating a
     * proxy Stream which then imitates the target Stream.
     *
     * @param {Stream} target The other stream to imitate on the current one. Must
     * not be a MemoryStream.
     */
    Stream.prototype.imitate = function (target) {
        if (target instanceof MemoryStream)
            throw new Error('A MemoryStream was given to imitate(), but it only ' +
                'supports a Stream. Read more about this restriction here: ' +
                'https://github.com/staltz/xstream#faq');
        this._target = target;
        for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
        this._ils = [];
    };
    /**
     * Forces the Stream to emit the given value to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param value The "next" value you want to broadcast to all listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendNext = function (value) {
        this._n(value);
    };
    /**
     * Forces the Stream to emit the given error to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param {any} error The error you want to broadcast to all the listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendError = function (error) {
        this._e(error);
    };
    /**
     * Forces the Stream to emit the "completed" event to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     */
    Stream.prototype.shamefullySendComplete = function () {
        this._c();
    };
    /**
     * Adds a "debug" listener to the stream. There can only be one debug
     * listener, that's why this is 'setDebugListener'. To remove the debug
     * listener, just call setDebugListener(null).
     *
     * A debug listener is like any other listener. The only difference is that a
     * debug listener is "stealthy": its presence/absence does not trigger the
     * start/stop of the stream (or the producer inside the stream). This is
     * useful so you can inspect what is going on without changing the behavior
     * of the program. If you have an idle stream and you add a normal listener to
     * it, the stream will start executing. But if you set a debug listener on an
     * idle stream, it won't start executing (not until the first normal listener
     * is added).
     *
     * As the name indicates, we don't recommend using this method to build app
     * logic. In fact, in most cases the debug operator works just fine. Only use
     * this one if you know what you're doing.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.setDebugListener = function (listener) {
        if (!listener) {
            this._d = false;
            this._dl = NO;
        }
        else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
        }
    };
    return Stream;
}());
/**
 * Blends multiple streams together, emitting events from all of them
 * concurrently.
 *
 * *merge* takes multiple streams as arguments, and creates a stream that
 * behaves like each of the argument streams, in parallel.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2-----3--------4---
 * ----a-----b----c---d------
 *            merge
 * --1-a--2--b--3-c---d--4---
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to merge together with other streams.
 * @param {Stream} stream2 A stream to merge together with other streams. Two
 * or more streams may be given as arguments.
 * @return {Stream}
 */
Stream.merge = function merge() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new Stream(new Merge(streams));
};
/**
 * Combines multiple input streams together to return a stream whose events
 * are arrays that collect the latest events from each input stream.
 *
 * *combine* internally remembers the most recent event from each of the input
 * streams. When any of the input streams emits an event, that event together
 * with all the other saved events are combined into an array. That array will
 * be emitted on the output stream. It's essentially a way of joining together
 * the events from multiple streams.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2-----3--------4---
 * ----a-----b-----c--d------
 *          combine
 * ----1a-2a-2b-3b-3c-3d-4d--
 * ```
 *
 * Note: to minimize garbage collection, *combine* uses the same array
 * instance for each emission.  If you need to compare emissions over time,
 * cache the values with `map` first:
 *
 * ```js
 * import pairwise from 'xstream/extra/pairwise'
 *
 * const stream1 = xs.of(1);
 * const stream2 = xs.of(2);
 *
 * xs.combine(stream1, stream2).map(
 *   combinedEmissions => ([ ...combinedEmissions ])
 * ).compose(pairwise)
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to combine together with other streams.
 * @param {Stream} stream2 A stream to combine together with other streams.
 * Multiple streams, not just two, may be given as arguments.
 * @return {Stream}
 */
Stream.combine = function combine() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new Stream(new Combine(streams));
};
exports.Stream = Stream;
var MemoryStream = (function (_super) {
    __extends(MemoryStream, _super);
    function MemoryStream(producer) {
        var _this = _super.call(this, producer) || this;
        _this._has = false;
        return _this;
    }
    MemoryStream.prototype._n = function (x) {
        this._v = x;
        this._has = true;
        _super.prototype._n.call(this, x);
    };
    MemoryStream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1) {
            if (this._has)
                il._n(this._v);
            return;
        }
        if (this._stopID !== NO) {
            if (this._has)
                il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else if (this._has)
            il._n(this._v);
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    MemoryStream.prototype._stopNow = function () {
        this._has = false;
        _super.prototype._stopNow.call(this);
    };
    MemoryStream.prototype._x = function () {
        this._has = false;
        _super.prototype._x.call(this);
    };
    MemoryStream.prototype.map = function (project) {
        return this._map(project);
    };
    MemoryStream.prototype.mapTo = function (projectedValue) {
        return _super.prototype.mapTo.call(this, projectedValue);
    };
    MemoryStream.prototype.take = function (amount) {
        return _super.prototype.take.call(this, amount);
    };
    MemoryStream.prototype.endWhen = function (other) {
        return _super.prototype.endWhen.call(this, other);
    };
    MemoryStream.prototype.replaceError = function (replace) {
        return _super.prototype.replaceError.call(this, replace);
    };
    MemoryStream.prototype.remember = function () {
        return this;
    };
    MemoryStream.prototype.debug = function (labelOrSpy) {
        return _super.prototype.debug.call(this, labelOrSpy);
    };
    return MemoryStream;
}(Stream));
exports.MemoryStream = MemoryStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Stream;
//# sourceMappingURL=index.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var thunk = __webpack_require__(167);
exports.thunk = thunk;
/**
 * A factory for the DOM driver function.
 *
 * Takes a `container` to define the target on the existing DOM which this
 * driver will operate on, and an `options` object as the second argument. The
 * input to this driver is a stream of virtual DOM objects, or in other words,
 * Snabbdom "VNode" objects. The output of this driver is a "DOMSource": a
 * collection of Observables queried with the methods `select()` and `events()`.
 *
 * `DOMSource.select(selector)` returns a new DOMSource with scope restricted to
 * the element(s) that matches the CSS `selector` given.
 *
 * `DOMSource.events(eventType, options)` returns a stream of events of
 * `eventType` happening on the elements that match the current DOMSource. The
 * event object contains the `ownerTarget` property that behaves exactly like
 * `currentTarget`. The reason for this is that some browsers doesn't allow
 * `currentTarget` property to be mutated, hence a new property is created. The
 * returned stream is an *xstream* Stream if you use `@cycle/xstream-run` to run
 * your app with this driver, or it is an RxJS Observable if you use
 * `@cycle/rxjs-run`, and so forth. The `options` parameter can have the
 * property `useCapture`, which is by default `false`, except it is `true` for
 * event types that do not bubble. Read more here
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * about the `useCapture` and its purpose.
 *
 * `DOMSource.elements()` returns a stream of the DOM element(s) matched by the
 * selectors in the DOMSource. Also, `DOMSource.select(':root').elements()`
 * returns a stream of DOM element corresponding to the root (or container) of
 * the app on the DOM.
 *
 * @param {(String|HTMLElement)} container the DOM selector for the element
 * (or the element itself) to contain the rendering of the VTrees.
 * @param {DOMDriverOptions} options an object with two optional properties:
 *
 *   - `modules: array` overrides `@cycle/dom`'s default Snabbdom modules as
 *     as defined in [`src/modules.ts`](./src/modules.ts).
 *   - `transposition: boolean` enables/disables transposition of inner streams
 *     in the virtual DOM tree.
 * @return {Function} the DOM driver function. The function expects a stream of
 * VNode as input, and outputs the DOMSource object.
 * @function makeDOMDriver
 */
var makeDOMDriver_1 = __webpack_require__(76);
exports.makeDOMDriver = makeDOMDriver_1.makeDOMDriver;
/**
 * A factory for the HTML driver function.
 *
 * Takes an `effect` callback function and an `options` object as arguments. The
 * input to this driver is a stream of virtual DOM objects, or in other words,
 * Snabbdom "VNode" objects. The output of this driver is a "DOMSource": a
 * collection of Observables queried with the methods `select()` and `events()`.
 *
 * The HTML Driver is supplementary to the DOM Driver. Instead of producing
 * elements on the DOM, it generates HTML as strings and does a side effect on
 * those HTML strings. That side effect is described by the `effect` callback
 * function. So, if you want to use the HTML Driver on the server-side to render
 * your application as HTML and send as a response (which is the typical use
 * case for the HTML Driver), you need to pass something like the
 * `html => response.send(html)` function as the `effect` argument. This way,
 * the driver knows what side effect to cause based on the HTML string it just
 * rendered.
 *
 * The HTML driver is useful only for that side effect in the `effect` callback.
 * It can be considered a sink-only driver. However, in order to serve as a
 * transparent replacement to the DOM Driver when rendering from the server, the
 * HTML driver returns a source object that behaves just like the DOMSource.
 * This helps reuse the same application that is written for the DOM Driver.
 * This fake DOMSource returns empty streams when you query it, because there
 * are no user events on the server.
 *
 * `DOMSource.select(selector)` returns a new DOMSource with scope restricted to
 * the element(s) that matches the CSS `selector` given.
 *
 * `DOMSource.events(eventType, options)` returns an empty stream. The returned
 * stream is an *xstream* Stream if you use `@cycle/xstream-run` to run your app
 * with this driver, or it is an RxJS Observable if you use `@cycle/rxjs-run`,
 * and so forth.
 *
 * `DOMSource.elements()` returns the stream of HTML string rendered from your
 * sink virtual DOM stream.
 *
 * @param {Function} effect a callback function that takes a string of rendered
 * HTML as input and should run a side effect, returning nothing.
 * @param {HTMLDriverOptions} options an object with one optional property:
 * `transposition: boolean` enables/disables transposition of inner streams in
 * the virtual DOM tree.
 * @return {Function} the HTML driver function. The function expects a stream of
 * VNode as input, and outputs the DOMSource object.
 * @function makeHTMLDriver
 */
var makeHTMLDriver_1 = __webpack_require__(77);
exports.makeHTMLDriver = makeHTMLDriver_1.makeHTMLDriver;
/**
 * A factory function to create mocked DOMSource objects, for testing purposes.
 *
 * Takes a `streamAdapter` and a `mockConfig` object as arguments, and returns
 * a DOMSource that can be given to any Cycle.js app that expects a DOMSource in
 * the sources, for testing.
 *
 * The `streamAdapter` parameter is a package such as `@cycle/xstream-adapter`,
 * `@cycle/rxjs-adapter`, etc. Import it as `import a from '@cycle/rx-adapter`,
 * then provide it to `mockDOMSource. This is important so the DOMSource created
 * knows which stream library should it use to export its streams when you call
 * `DOMSource.events()` for instance.
 *
 * The `mockConfig` parameter is an object specifying selectors, eventTypes and
 * their streams. Example:
 *
 * ```js
 * const domSource = mockDOMSource(RxAdapter, {
 *   '.foo': {
 *     'click': Rx.Observable.of({target: {}}),
 *     'mouseover': Rx.Observable.of({target: {}}),
 *   },
 *   '.bar': {
 *     'scroll': Rx.Observable.of({target: {}}),
 *     elements: Rx.Observable.of({tagName: 'div'}),
 *   }
 * });
 *
 * // Usage
 * const click$ = domSource.select('.foo').events('click');
 * const element$ = domSource.select('.bar').elements();
 * ```
 *
 * The mocked DOM Source supports isolation. It has the functions `isolateSink`
 * and `isolateSource` attached to it, and performs simple isolation using
 * classNames. *isolateSink* with scope `foo` will append the class `___foo` to
 * the stream of virtual DOM nodes, and *isolateSource* with scope `foo` will
 * perform a conventional `mockedDOMSource.select('.__foo')` call.
 *
 * @param {Object} mockConfig an object where keys are selector strings
 * and values are objects. Those nested objects have `eventType` strings as keys
 * and values are streams you created.
 * @return {Object} fake DOM source object, with an API containing `select()`
 * and `events()` and `elements()` which can be used just like the DOM Driver's
 * DOMSource.
 *
 * @function mockDOMSource
 */
var mockDOMSource_1 = __webpack_require__(78);
exports.mockDOMSource = mockDOMSource_1.mockDOMSource;
/**
 * The hyperscript function `h()` is a function to create virtual DOM objects,
 * also known as VNodes. Call
 *
 * ```js
 * h('div.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * to create a VNode that represents a `DIV` element with className `myClass`,
 * styled with red color, and no children because the `[]` array was passed. The
 * API is `h(tagOrSelector, optionalData, optionalChildrenOrText)`.
 *
 * However, usually you should use "hyperscript helpers", which are shortcut
 * functions based on hyperscript. There is one hyperscript helper function for
 * each DOM tagName, such as `h1()`, `h2()`, `div()`, `span()`, `label()`,
 * `input()`. For instance, the previous example could have been written
 * as:
 *
 * ```js
 * div('.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * There are also SVG helper functions, which apply the appropriate SVG
 * namespace to the resulting elements. `svg()` function creates the top-most
 * SVG element, and `svg.g`, `svg.polygon`, `svg.circle`, `svg.path` are for
 * SVG-specific child elements. Example:
 *
 * ```js
 * svg({width: 150, height: 150}, [
 *   svg.polygon({
 *     attrs: {
 *       class: 'triangle',
 *       points: '20 0 20 150 150 20'
 *     }
 *   })
 * ])
 * ```
 *
 * @function h
 */
var hyperscript_1 = __webpack_require__(24);
exports.h = hyperscript_1.h;
var hyperscript_helpers_1 = __webpack_require__(73);
exports.svg = hyperscript_helpers_1.default.svg;
exports.a = hyperscript_helpers_1.default.a;
exports.abbr = hyperscript_helpers_1.default.abbr;
exports.address = hyperscript_helpers_1.default.address;
exports.area = hyperscript_helpers_1.default.area;
exports.article = hyperscript_helpers_1.default.article;
exports.aside = hyperscript_helpers_1.default.aside;
exports.audio = hyperscript_helpers_1.default.audio;
exports.b = hyperscript_helpers_1.default.b;
exports.base = hyperscript_helpers_1.default.base;
exports.bdi = hyperscript_helpers_1.default.bdi;
exports.bdo = hyperscript_helpers_1.default.bdo;
exports.blockquote = hyperscript_helpers_1.default.blockquote;
exports.body = hyperscript_helpers_1.default.body;
exports.br = hyperscript_helpers_1.default.br;
exports.button = hyperscript_helpers_1.default.button;
exports.canvas = hyperscript_helpers_1.default.canvas;
exports.caption = hyperscript_helpers_1.default.caption;
exports.cite = hyperscript_helpers_1.default.cite;
exports.code = hyperscript_helpers_1.default.code;
exports.col = hyperscript_helpers_1.default.col;
exports.colgroup = hyperscript_helpers_1.default.colgroup;
exports.dd = hyperscript_helpers_1.default.dd;
exports.del = hyperscript_helpers_1.default.del;
exports.dfn = hyperscript_helpers_1.default.dfn;
exports.dir = hyperscript_helpers_1.default.dir;
exports.div = hyperscript_helpers_1.default.div;
exports.dl = hyperscript_helpers_1.default.dl;
exports.dt = hyperscript_helpers_1.default.dt;
exports.em = hyperscript_helpers_1.default.em;
exports.embed = hyperscript_helpers_1.default.embed;
exports.fieldset = hyperscript_helpers_1.default.fieldset;
exports.figcaption = hyperscript_helpers_1.default.figcaption;
exports.figure = hyperscript_helpers_1.default.figure;
exports.footer = hyperscript_helpers_1.default.footer;
exports.form = hyperscript_helpers_1.default.form;
exports.h1 = hyperscript_helpers_1.default.h1;
exports.h2 = hyperscript_helpers_1.default.h2;
exports.h3 = hyperscript_helpers_1.default.h3;
exports.h4 = hyperscript_helpers_1.default.h4;
exports.h5 = hyperscript_helpers_1.default.h5;
exports.h6 = hyperscript_helpers_1.default.h6;
exports.head = hyperscript_helpers_1.default.head;
exports.header = hyperscript_helpers_1.default.header;
exports.hgroup = hyperscript_helpers_1.default.hgroup;
exports.hr = hyperscript_helpers_1.default.hr;
exports.html = hyperscript_helpers_1.default.html;
exports.i = hyperscript_helpers_1.default.i;
exports.iframe = hyperscript_helpers_1.default.iframe;
exports.img = hyperscript_helpers_1.default.img;
exports.input = hyperscript_helpers_1.default.input;
exports.ins = hyperscript_helpers_1.default.ins;
exports.kbd = hyperscript_helpers_1.default.kbd;
exports.keygen = hyperscript_helpers_1.default.keygen;
exports.label = hyperscript_helpers_1.default.label;
exports.legend = hyperscript_helpers_1.default.legend;
exports.li = hyperscript_helpers_1.default.li;
exports.link = hyperscript_helpers_1.default.link;
exports.main = hyperscript_helpers_1.default.main;
exports.map = hyperscript_helpers_1.default.map;
exports.mark = hyperscript_helpers_1.default.mark;
exports.menu = hyperscript_helpers_1.default.menu;
exports.meta = hyperscript_helpers_1.default.meta;
exports.nav = hyperscript_helpers_1.default.nav;
exports.noscript = hyperscript_helpers_1.default.noscript;
exports.object = hyperscript_helpers_1.default.object;
exports.ol = hyperscript_helpers_1.default.ol;
exports.optgroup = hyperscript_helpers_1.default.optgroup;
exports.option = hyperscript_helpers_1.default.option;
exports.p = hyperscript_helpers_1.default.p;
exports.param = hyperscript_helpers_1.default.param;
exports.pre = hyperscript_helpers_1.default.pre;
exports.progress = hyperscript_helpers_1.default.progress;
exports.q = hyperscript_helpers_1.default.q;
exports.rp = hyperscript_helpers_1.default.rp;
exports.rt = hyperscript_helpers_1.default.rt;
exports.ruby = hyperscript_helpers_1.default.ruby;
exports.s = hyperscript_helpers_1.default.s;
exports.samp = hyperscript_helpers_1.default.samp;
exports.script = hyperscript_helpers_1.default.script;
exports.section = hyperscript_helpers_1.default.section;
exports.select = hyperscript_helpers_1.default.select;
exports.small = hyperscript_helpers_1.default.small;
exports.source = hyperscript_helpers_1.default.source;
exports.span = hyperscript_helpers_1.default.span;
exports.strong = hyperscript_helpers_1.default.strong;
exports.style = hyperscript_helpers_1.default.style;
exports.sub = hyperscript_helpers_1.default.sub;
exports.sup = hyperscript_helpers_1.default.sup;
exports.table = hyperscript_helpers_1.default.table;
exports.tbody = hyperscript_helpers_1.default.tbody;
exports.td = hyperscript_helpers_1.default.td;
exports.textarea = hyperscript_helpers_1.default.textarea;
exports.tfoot = hyperscript_helpers_1.default.tfoot;
exports.th = hyperscript_helpers_1.default.th;
exports.thead = hyperscript_helpers_1.default.thead;
exports.title = hyperscript_helpers_1.default.title;
exports.tr = hyperscript_helpers_1.default.tr;
exports.u = hyperscript_helpers_1.default.u;
exports.ul = hyperscript_helpers_1.default.ul;
exports.video = hyperscript_helpers_1.default.video;
//# sourceMappingURL=index.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var counter = 0;
function newScope() {
    return "cycle" + ++counter;
}
function checkIsolateArgs(dataflowComponent, scope) {
    if (typeof dataflowComponent !== "function") {
        throw new Error("First argument given to isolate() must be a " +
            "'dataflowComponent' function");
    }
    if (scope === null) {
        throw new Error("Second argument given to isolate() must not be null");
    }
}
function isolateAllSources(sources, scope) {
    var scopedSources = {};
    for (var key in sources) {
        if (sources.hasOwnProperty(key) && sources[key]
            && typeof sources[key].isolateSource === "function") {
            scopedSources[key] = sources[key].isolateSource(sources[key], scope);
        }
        else if (sources.hasOwnProperty(key)) {
            scopedSources[key] = sources[key];
        }
    }
    return scopedSources;
}
function isolateAllSinks(sources, sinks, scope) {
    var scopedSinks = {};
    for (var key in sinks) {
        if (sinks.hasOwnProperty(key)
            && sources[key]
            && typeof sources[key].isolateSink === "function") {
            scopedSinks[key] = sources[key].isolateSink(sinks[key], scope);
        }
        else if (sinks.hasOwnProperty(key)) {
            scopedSinks[key] = sinks[key];
        }
    }
    return scopedSinks;
}
/**
 * Takes a `dataflowComponent` function and an optional `scope` string, and
 * returns a scoped version of the `dataflowComponent` function.
 *
 * When the scoped dataflow component is invoked, each source provided to the
 * scoped dataflowComponent is isolated to the scope using
 * `source.isolateSource(source, scope)`, if possible. Likewise, the sinks
 * returned from the scoped dataflow component are isolate to the scope using
 * `source.isolateSink(sink, scope)`.
 *
 * If the `scope` is not provided, a new scope will be automatically created.
 * This means that while **`isolate(dataflowComponent, scope)` is pure**
 * (referentially transparent), **`isolate(dataflowComponent)` is impure**
 * (not referentially transparent). Two calls to `isolate(Foo, bar)` will
 * generate two indistinct dataflow components. But, two calls to `isolate(Foo)`
 * will generate two distinct dataflow components.
 *
 * Note that both `isolateSource()` and `isolateSink()` are static members of
 * `source`. The reason for this is that drivers produce `source` while the
 * application produces `sink`, and it's the driver's responsibility to
 * implement `isolateSource()` and `isolateSink()`.
 *
 * @param {Function} dataflowComponent a function that takes `sources` as input
 * and outputs a collection of `sinks`.
 * @param {String} scope an optional string that is used to isolate each
 * `sources` and `sinks` when the returned scoped dataflow component is invoked.
 * @return {Function} the scoped dataflow component function that, as the
 * original `dataflowComponent` function, takes `sources` and returns `sinks`.
 * @function isolate
 */
function isolate(component, scope) {
    if (scope === void 0) { scope = newScope(); }
    checkIsolateArgs(component, scope);
    var convertedScope = typeof scope === 'string' ? scope : scope.toString();
    return function scopedComponent(sources) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var scopedSources = isolateAllSources(sources, convertedScope);
        var sinks = component.apply(void 0, [scopedSources].concat(rest));
        var scopedSinks = isolateAllSinks(sources, sinks, convertedScope);
        return scopedSinks;
    };
}
isolate.reset = function () { return counter = 0; };
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = isolate;
//# sourceMappingURL=index.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(203));
var Size;
(function (Size) {
    Size[Size["Mini"] = 0] = "Mini";
    Size[Size["Tiny"] = 1] = "Tiny";
    Size[Size["Small"] = 2] = "Small";
    Size[Size["Medium"] = 3] = "Medium";
    Size[Size["Large"] = 4] = "Large";
    Size[Size["Big"] = 5] = "Big";
    Size[Size["Huge"] = 6] = "Huge";
    Size[Size["Massive"] = 7] = "Massive";
    Size[Size["Fluid"] = 8] = "Fluid";
})(Size = exports.Size || (exports.Size = {}));
(function (Size) {
    function ToClassname(size) {
        switch (size) {
            case Size.Mini: return " mini";
            case Size.Tiny: return " tiny";
            case Size.Small: return " small";
            case Size.Medium: return " medium";
            case Size.Large: return " large";
            case Size.Big: return " big";
            case Size.Huge: return " huge";
            case Size.Massive: return " massive";
            case Size.Fluid: return " fluid";
            default: return "";
        }
    }
    Size.ToClassname = ToClassname;
})(Size = exports.Size || (exports.Size = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = 0] = "Top";
    VerticalAlignment[VerticalAlignment["Middle"] = 1] = "Middle";
    VerticalAlignment[VerticalAlignment["Bottom"] = 2] = "Bottom";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
(function (VerticalAlignment) {
    function ToClassname(alignment) {
        switch (alignment) {
            case VerticalAlignment.Top: return " top aligned";
            case VerticalAlignment.Middle: return " middle aligned";
            case VerticalAlignment.Bottom: return " bottom aligned";
            default: return "";
        }
    }
    VerticalAlignment.ToClassname = ToClassname;
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
var TextAlignment;
(function (TextAlignment) {
    TextAlignment[TextAlignment["Left"] = 0] = "Left";
    TextAlignment[TextAlignment["Right"] = 1] = "Right";
    TextAlignment[TextAlignment["Center"] = 2] = "Center";
    TextAlignment[TextAlignment["Justified"] = 3] = "Justified";
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
(function (TextAlignment) {
    function ToClassname(alignment) {
        switch (alignment) {
            case TextAlignment.Left: return " left aligned.";
            case TextAlignment.Right: return " right aligned.";
            case TextAlignment.Center: return " center aligned";
            case TextAlignment.Justified: return " justified";
            default: return "";
        }
    }
    TextAlignment.ToClassname = ToClassname;
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
var Float;
(function (Float) {
    Float[Float["None"] = 0] = "None";
    Float[Float["Right"] = 1] = "Right";
    Float[Float["Left"] = 2] = "Left";
})(Float = exports.Float || (exports.Float = {}));
(function (Float) {
    function ToClassname(float) {
        switch (float) {
            case Float.Left: return " left floated";
            case Float.Right: return " right floated";
            default: return "";
        }
    }
    Float.ToClassname = ToClassname;
})(Float = exports.Float || (exports.Float = {}));
var Attachment;
(function (Attachment) {
    Attachment[Attachment["None"] = 0] = "None";
    Attachment[Attachment["Top"] = 1] = "Top";
    Attachment[Attachment["TopRight"] = 2] = "TopRight";
    Attachment[Attachment["TopLeft"] = 3] = "TopLeft";
    Attachment[Attachment["Bottom"] = 4] = "Bottom";
    Attachment[Attachment["BottomLeft"] = 5] = "BottomLeft";
    Attachment[Attachment["BottomRight"] = 6] = "BottomRight";
    Attachment[Attachment["Right"] = 7] = "Right";
    Attachment[Attachment["Left"] = 8] = "Left";
})(Attachment = exports.Attachment || (exports.Attachment = {}));
(function (Attachment) {
    function ToClassname(attachment) {
        switch (attachment) {
            case Attachment.None: return " attached";
            case Attachment.Top: return " top attached";
            case Attachment.Bottom: return " bottom attached";
            case Attachment.Left: return " left attached";
            case Attachment.Right: return " right attached";
            case Attachment.TopRight: return " top right attached";
            case Attachment.TopLeft: return " top left attached";
            case Attachment.BottomLeft: return " bottom left attached";
            case Attachment.BottomRight: return " bottom right attached";
            default: return "";
        }
    }
    Attachment.ToClassname = ToClassname;
})(Attachment = exports.Attachment || (exports.Attachment = {}));
var Color;
(function (Color) {
    Color[Color["None"] = 0] = "None";
    Color[Color["Primary"] = 1] = "Primary";
    Color[Color["Secondary"] = 2] = "Secondary";
    Color[Color["Success"] = 3] = "Success";
    Color[Color["Info"] = 4] = "Info";
    Color[Color["Warning"] = 5] = "Warning";
    Color[Color["Error"] = 6] = "Error";
})(Color = exports.Color || (exports.Color = {}));
(function (Color) {
    function ToClassname(color) {
        switch (color) {
            case Color.Primary: return " primaryColored";
            case Color.Secondary: return " secondaryColored";
            case Color.Success: return " successColored";
            case Color.Info: return " infoColored";
            case Color.Warning: return " warningColored";
            case Color.Error: return " errorColored ";
            default: return "";
        }
    }
    Color.ToClassname = ToClassname;
})(Color = exports.Color || (exports.Color = {}));
var Animation;
(function (Animation) {
    Animation[Animation["Browse"] = 0] = "Browse";
    Animation[Animation["Drop"] = 1] = "Drop";
    Animation[Animation["Fade"] = 2] = "Fade";
    Animation[Animation["Flip"] = 3] = "Flip";
    Animation[Animation["Scale"] = 4] = "Scale";
    Animation[Animation["Fly"] = 5] = "Fly";
    Animation[Animation["Slide"] = 6] = "Slide";
    Animation[Animation["Swing"] = 7] = "Swing";
    Animation[Animation["Flash"] = 8] = "Flash";
    Animation[Animation["Shake"] = 9] = "Shake";
    Animation[Animation["Bounce"] = 10] = "Bounce";
    Animation[Animation["Tada"] = 11] = "Tada";
    Animation[Animation["Pulse"] = 12] = "Pulse";
    Animation[Animation["Jiggle"] = 13] = "Jiggle";
    Animation[Animation["None"] = 14] = "None";
})(Animation = exports.Animation || (exports.Animation = {}));
(function (Animation) {
    function ToClassname(anim) {
        switch (anim) {
            case Animation.Browse: return " browse";
            case Animation.Drop: return " drop";
            case Animation.Fade: return " fade";
            case Animation.Flip: return " flip";
            case Animation.Scale: return " scale";
            case Animation.Fly: return " fly";
            case Animation.Slide: return " slide";
            case Animation.Swing: return " swing";
            case Animation.Flash: return " flash";
            case Animation.Shake: return " shake";
            case Animation.Bounce: return " bounce";
            case Animation.Tada: return " tada";
            case Animation.Pulse: return " pulse";
            case Animation.Jiggle: return " jiggle";
        }
    }
    Animation.ToClassname = ToClassname;
    function isStatic(anim) {
        var staticAnimations = [Animation.Flash, Animation.Shake,
            Animation.Bounce, Animation.Tada, Animation.Pulse, Animation.Jiggle];
        return staticAnimations.indexOf(anim) !== -1;
    }
    Animation.isStatic = isStatic;
    function isDirectional(anim) {
        var directionAnimations = [Animation.Browse, Animation.Fade,
            Animation.Fly, Animation.Slide, Animation.Swing];
        return directionAnimations.indexOf(anim) !== -1;
    }
    Animation.isDirectional = isDirectional;
})(Animation = exports.Animation || (exports.Animation = {}));
var Direction;
(function (Direction) {
    Direction[Direction["In"] = 0] = "In";
    Direction[Direction["Out"] = 1] = "Out";
    Direction[Direction["None"] = 2] = "None";
})(Direction = exports.Direction || (exports.Direction = {}));
(function (Direction) {
    function ToClassname(direction) {
        return direction === Direction.In ? " in" : " out";
    }
    Direction.ToClassname = ToClassname;
})(Direction = exports.Direction || (exports.Direction = {}));
var AnimationDirection;
(function (AnimationDirection) {
    AnimationDirection[AnimationDirection["Up"] = 0] = "Up";
    AnimationDirection[AnimationDirection["Down"] = 1] = "Down";
    AnimationDirection[AnimationDirection["Left"] = 2] = "Left";
    AnimationDirection[AnimationDirection["Right"] = 3] = "Right";
})(AnimationDirection = exports.AnimationDirection || (exports.AnimationDirection = {}));
(function (AnimationDirection) {
    function ToClassname(dir) {
        switch (dir) {
            case AnimationDirection.Up: return " up";
            case AnimationDirection.Down: return " down";
            case AnimationDirection.Left: return " left";
            case AnimationDirection.Right: return " right";
            default: return "";
        }
    }
    AnimationDirection.ToClassname = ToClassname;
})(AnimationDirection = exports.AnimationDirection || (exports.AnimationDirection = {}));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDOMContent(content) {
    if (!content) {
        return false;
    }
    if (typeof (content) === "string") {
        return true;
    }
    if (content instanceof (Array)) {
        if (content.length === 0) {
            return true;
        }
        else {
            return content[0].sel !== undefined;
        }
        ;
    }
    return false;
}
exports.isDOMContent = isDOMContent;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var XStreamAdapter = {
    adapt: function (originStream, originStreamSubscribe) {
        if (XStreamAdapter.isValidStream(originStream)) {
            return originStream;
        }
        ;
        var dispose = null;
        return xstream_1.default.create({
            start: function (out) {
                var observer = out;
                dispose = originStreamSubscribe(originStream, observer);
            },
            stop: function () {
                if (typeof dispose === 'function') {
                    dispose();
                }
            },
        });
    },
    makeSubject: function () {
        var stream = xstream_1.default.create();
        var observer = {
            next: function (x) { stream.shamefullySendNext(x); },
            error: function (err) { stream.shamefullySendError(err); },
            complete: function () { stream.shamefullySendComplete(); },
        };
        return { observer: observer, stream: stream };
    },
    remember: function (stream) {
        return stream.remember();
    },
    isValidStream: function (stream) {
        return (typeof stream.addListener === 'function' &&
            typeof stream.shamefullySendNext === 'function');
    },
    streamSubscribe: function (stream, observer) {
        stream.addListener(observer);
        return function () { return stream.removeListener(observer); };
    },
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = XStreamAdapter;
//# sourceMappingURL=index.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPath = exports.parsePath = exports.getQueryStringValueFromPath = exports.stripQueryStringValueFromPath = exports.addQueryStringValueToPath = exports.isAbsolutePath = undefined;

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isAbsolutePath = exports.isAbsolutePath = function isAbsolutePath(path) {
  return typeof path === 'string' && path.charAt(0) === '/';
};

var addQueryStringValueToPath = exports.addQueryStringValueToPath = function addQueryStringValueToPath(path, key, value) {
  var _parsePath = parsePath(path);

  var pathname = _parsePath.pathname;
  var search = _parsePath.search;
  var hash = _parsePath.hash;


  return createPath({
    pathname: pathname,
    search: search + (search.indexOf('?') === -1 ? '?' : '&') + key + '=' + value,
    hash: hash
  });
};

var stripQueryStringValueFromPath = exports.stripQueryStringValueFromPath = function stripQueryStringValueFromPath(path, key) {
  var _parsePath2 = parsePath(path);

  var pathname = _parsePath2.pathname;
  var search = _parsePath2.search;
  var hash = _parsePath2.hash;


  return createPath({
    pathname: pathname,
    search: search.replace(new RegExp('([?&])' + key + '=[a-zA-Z0-9]+(&?)'), function (match, prefix, suffix) {
      return prefix === '?' ? prefix : suffix;
    }),
    hash: hash
  });
};

var getQueryStringValueFromPath = exports.getQueryStringValueFromPath = function getQueryStringValueFromPath(path, key) {
  var _parsePath3 = parsePath(path);

  var search = _parsePath3.search;

  var match = search.match(new RegExp('[?&]' + key + '=([a-zA-Z0-9]+)'));
  return match && match[1];
};

var extractPath = function extractPath(string) {
  var match = string.match(/^(https?:)?\/\/[^\/]*/);
  return match == null ? string : string.substring(match[0].length);
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = extractPath(path);
  var search = '';
  var hash = '';

  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(path === pathname, 'A path must be pathname + search + hash only, not a full URL like "%s"', path) : void 0;

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substring(hashIndex);
    pathname = pathname.substring(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substring(searchIndex);
    pathname = pathname.substring(0, searchIndex);
  }

  if (pathname === '') pathname = '/';

  return {
    pathname: pathname,
    search: search,
    hash: hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  if (location == null || typeof location === 'string') return location;

  var basename = location.basename;
  var pathname = location.pathname;
  var search = location.search;
  var hash = location.hash;

  var path = (basename || '') + pathname;

  if (search && search !== '?') path += search;

  if (hash) path += hash;

  return path;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var flattenConcurrently_1 = __webpack_require__(214);
function patchClassList(target, classes, classesToAdd) {
    var className = "";
    if (target.data) {
        var props = target.data.props ? target.data.props : { className: target.sel.split(".").join(" ") };
        var classList = props.className.split(" ");
        classList.forEach(function (item) {
            if (classes.indexOf(item) === -1) {
                className += item + " ";
            }
        });
    }
    className += classesToAdd;
    return Object.assign({}, target.data, {
        "props": {
            className: className
        }
    });
}
exports.patchClassList = patchClassList;
/**
 * Adds one VNode to another and handles updates for stream by replacing based on the identifier class.
 * @param  {VNode}  element    The element to be added.
 * @param  {VNode}  target     The target for the element
 * @param  {string} identifier The identifying class for the element to be added.
 * @return {Array} The target element's children with the element added.
 */
function addElement(element, target, identifier) {
    var c = [];
    if (target.children) {
        c = target.children;
    }
    if (target.text) {
        c.push(target.text);
    }
    for (var i = 0; i < c.length; i++) {
        var child = c[i];
        var cProps = child.data ? child.data.props ? child.data.props : {} : {};
        if (typeof (child) !== "undefined" && typeof (cProps.className) !== "undefined") {
            var classList = child.data.props.className.split(" ");
            for (var _i = 0, classList_1 = classList; _i < classList_1.length; _i++) {
                var s = classList_1[_i];
                if (s === identifier) {
                    c.splice(i, 1);
                }
            }
        }
    }
    c.push(element);
    return c;
}
exports.addElement = addElement;
/**
 * Converts anything to a stream
 * @param  {any} obj - The object.
 * @return {Stream<any>} The object as a stream.
 */
function asStream(obj) {
    if (typeof (obj) !== "undefined") {
        if (typeof (obj.addListener) === "function") {
            return obj;
        }
        if (Object.prototype.toString.call(obj) === "[object Array]") {
            var isStreams = true;
            for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
                var subobj = obj_1[_i];
                if (typeof (subobj.addListener) !== "function") {
                    isStreams = false;
                }
            }
            if (isStreams) {
                return xstream_1.default.combine.apply(this, obj);
            }
        }
        return xstream_1.default.of(obj);
    }
    return xstream_1.default.of("");
}
exports.asStream = asStream;
/**
 * Converts a number of objects to a stream of an Array.
 * @param  {any} ...objs   The objects to include in the stream
 * @return {Stream<any[]>} The objects as a stream of an array.
 */
function asArrayStream() {
    var objs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objs[_i] = arguments[_i];
    }
    var streams = Array.from(arguments);
    streams = streams.map(function (obj) { return asStream(obj); });
    return xstream_1.default.combine.apply(this, streams);
}
exports.asArrayStream = asArrayStream;
/**
 * Flattens a stream of an array of streams into a stream of an array.
 * @param  {Stream<Stream<any>[]>} stream The stream to flatten
 * @return {Stream<any[]>}                The flattened stream.
 */
function flattenStreamArray(stream) {
    var _this = this;
    return flattenConcurrently_1.default(stream.map(function (children) { return xstream_1.default.combine.apply(_this, children); }));
}
exports.flattenStreamArray = flattenStreamArray;
/**
 * Converts a natural number between 1-16 to text.
 * @param  {number} num The number to convert.
 * @return {string}     That number as text.
 */
function numToText(num) {
    switch (num) {
        case 1: return " one";
        case 2: return " two";
        case 3: return " three";
        case 4: return " four";
        case 5: return " five";
        case 6: return " six";
        case 7: return " seven";
        case 8: return " eight";
        case 9: return " nine";
        case 10: return " ten";
        case 11: return " eleven";
        case 12: return " twelve";
        case 13: return " thirteen";
        case 14: return " fourteen";
        case 15: return " fifteen";
        case 16: return " sixteen";
    }
}
exports.numToText = numToText;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign        = __webpack_require__(26)
  , normalizeOpts = __webpack_require__(108)
  , isCallable    = __webpack_require__(102)
  , contains      = __webpack_require__(46)

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.statesAreEqual = exports.createLocation = exports.createQuery = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _PathUtils = __webpack_require__(8);

var _Actions = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createQuery = exports.createQuery = function createQuery(props) {
  return _extends(Object.create(null), props);
};

var createLocation = exports.createLocation = function createLocation() {
  var input = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var object = typeof input === 'string' ? (0, _PathUtils.parsePath)(input) : input;

  var pathname = object.pathname || '/';
  var search = object.search || '';
  var hash = object.hash || '';
  var state = object.state;

  return {
    pathname: pathname,
    search: search,
    hash: hash,
    state: state,
    action: action,
    key: key
  };
};

var isDate = function isDate(object) {
  return Object.prototype.toString.call(object) === '[object Date]';
};

var statesAreEqual = exports.statesAreEqual = function statesAreEqual(a, b) {
  if (a === b) return true;

  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (typeofA !== typeofB) return false;

  !(typeofA !== 'function') ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store functions in location state') : (0, _invariant2.default)(false) : void 0;

  // Not the same object, but same type.
  if (typeofA === 'object') {
    !!(isDate(a) && isDate(b)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store Date objects in location state') : (0, _invariant2.default)(false) : void 0;

    if (!Array.isArray(a)) return Object.keys(a).every(function (key) {
      return statesAreEqual(a[key], b[key]);
    });

    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return statesAreEqual(item, b[index]);
    });
  }

  // All other serializable types (string, number, boolean)
  // should be strict equal.
  return false;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.key === b.key &&
  // a.action === b.action && // Different action !== location change.
  a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && statesAreEqual(a.state, b.state);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var dom_1 = __webpack_require__(1);
var isolate_1 = __webpack_require__(2);
var Transition;
(function (Transition) {
    /**
     * A transition wrapper for animating dom content.
     * Accepts the following targets: VNode
     * Expects the following arguments: {} of
     *   animation: Animation - The animation to use.
     *   direction?: Direction - Wether to animate to visible or invisible.
     *   animationDirection?: AnimationDirection - The direction for the animation.
     * Disregards any content.
     */
    function run(sources) {
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".transition").events(type); };
            sources.args$ = sources.args$ ? sources.args$ : xstream_1.default.of({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var animationEnd$ = evt("animationend").map(function (evt) { return ({
                animation: enums_1.Animation.None,
                direction: evt.currentTarget.classList.contains("out") ? enums_1.Direction.Out : enums_1.Direction.In
            }); });
            var animation$ = xstream_1.default.merge(sources.args$, animationEnd$);
            var vTree$ = xstream_1.default.combine(animation$, sources.target$).map(function (_a) {
                var transition = _a[0], target = _a[1];
                return render(target, transition);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".transition").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Transition.run = run;
    /**
     * A transition wrapper for animating dom content.
     * Accepts the following targets: VNode
     * Expects the following arguments: {} of
     *   animation: Animation - The animation to use.
     *   direction?: Direction - Wether to animate to visible or invisible.
     *   animationDirection?: AnimationDirection - The direction for the animation.
     * Disregards any content.
     */
    function render(target, args) {
        if (args === void 0) { args = { animation: enums_1.Animation.None }; }
        var className = "", c;
        if (target.data) {
            var classList = target.data.props.className.split(" ");
            classList.forEach(function (item) {
                if (["hidden", "visible", "animating", "transition"].indexOf(item) === -1) {
                    className += item + " ";
                }
            });
        }
        className += getClassName(args);
        var data = Object.assign({}, target.data, {
            "props": {
                className: className
            }
        });
        if (target.children) {
            c = target.children;
        }
        if (target.text) {
            c = target.text;
        }
        return dom_1.h(target.sel, data, c);
    }
    Transition.render = render;
    function getClassName(transition) {
        if (transition.animation === enums_1.Animation.None) {
            return transition.direction === enums_1.Direction.Out ? "transition hidden" : "transition visible";
        }
        var animation = enums_1.Animation.ToClassname(transition.animation);
        if (enums_1.Animation.isStatic(transition.animation)) {
            return "visible animating transition " + animation;
        }
        var direction = enums_1.Direction.ToClassname(transition.direction);
        if (enums_1.Animation.isDirectional(transition.animation)) {
            animation += enums_1.AnimationDirection.ToClassname(transition.animationDirection);
        }
        return "visible transition animating " + direction + animation;
    }
})(Transition = exports.Transition || (exports.Transition = {}));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isElement(obj) {
    return typeof HTMLElement === "object" ?
        obj instanceof HTMLElement || obj instanceof DocumentFragment :
        obj && typeof obj === "object" && obj !== null &&
            (obj.nodeType === 1 || obj.nodeType === 11) &&
            typeof obj.nodeName === "string";
}
exports.SCOPE_PREFIX = "$$CYCLEDOM$$-";
function getElement(selectors) {
    var domElement = typeof selectors === 'string' ?
        document.querySelector(selectors) :
        selectors;
    if (typeof selectors === 'string' && domElement === null) {
        throw new Error("Cannot render into unknown element `" + selectors + "`");
    }
    else if (!isElement(domElement)) {
        throw new Error("Given container is not a DOM element neither a " +
            "selector string.");
    }
    return domElement;
}
exports.getElement = getElement;
function getScope(namespace) {
    return namespace
        .filter(function (c) { return c.indexOf(exports.SCOPE_PREFIX) > -1; })
        .map(function (c) { return c.replace(exports.SCOPE_PREFIX, ''); })
        .join("-");
}
exports.getScope = getScope;
function getSelectors(namespace) {
    return namespace.filter(function (c) { return c.indexOf(exports.SCOPE_PREFIX) === -1; }).join(" ");
}
exports.getSelectors = getSelectors;
//# sourceMappingURL=utils.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(122)() ? Symbol : __webpack_require__(124);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(44)()
	? Object.setPrototypeOf
	: __webpack_require__(45);


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Indicates that navigation was caused by a call to history.push.
 */
var PUSH = exports.PUSH = 'PUSH';

/**
 * Indicates that navigation was caused by a call to history.replace.
 */
var REPLACE = exports.REPLACE = 'REPLACE';

/**
 * Indicates that navigation was caused by some other action such
 * as using a browser's back/forward buttons and/or manually manipulating
 * the URL in a browser's location bar. This is the default.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
 * for more information.
 */
var POP = exports.POP = 'POP';

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = {
  array: Array.isArray,
  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Icon;
(function (Icon) {
    /**
     * An icon component for displaying icons.
     * Accepts the following properties in props$:
     *  button?: boolean - Styles the icon to display well on buttons
     * 	bordered?: boolean - Adds a border around the icon.
     * 	circular?: boolean - Styles the icon to appear circular.
     * 	disabled?: boolean - Styles the icon to appear disabled.
     * 	loading?: boolean - Rotates the icon to allow it to be used for loaders.
     * 	fitted?: boolean - Styles the icon for tight fits.
     * 	link?: boolean - Styles the icon to appear clickable.
     * 	flipped?: boolean - Flips the icon.
     * 	rotated?: boolean - Rotates the icon.
     * 	inverted?: boolean - Styles the icon to appear on dark background.
     * 	color?: Color - The color of the icon.
     * 	size?: Size - The size of the icon.
     * Accepts the following type of content in content$: IconType
     * @param  {ComponentSources} sources - The component's sources.
     * @return {ComponentSinks} The Icon component.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ type: "" });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of(0);
            return {
                DOM: xstream_1.default.combine(sources.props$, sources.content$)
                    .map(function (_a) {
                    var props = _a[0], content = _a[1];
                    return render(props, content);
                }),
                Events: function (type) { return sources.DOM.select(".icon").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Icon.run = run;
    /**
     * An icon component for displaying icons.
     * Accepts the following properties:
     *  button?: boolean - Styles the icon to display well on buttons
     * 	bordered?: boolean - Adds a border around the icon.
     * 	circular?: boolean - Styles the icon to appear circular.
     * 	disabled?: boolean - Styles the icon to appear disabled.
     * 	loading?: boolean - Rotates the icon to allow it to be used for loaders.
     * 	fitted?: boolean - Styles the icon for tight fits.
     * 	link?: boolean - Styles the icon to appear clickable.
     * 	flipped?: boolean - Flips the icon.
     * 	rotated?: boolean - Rotates the icon.
     * 	inverted?: boolean - Styles the icon to appear on dark background.
     * 	color?: Color - The color of the icon.
     * 	size?: Size - The size of the icon.
     * Accepts the following type of content: IconType
     * @param  {ComponentSources} sources - The component's sources.
     * @return {ComponentSinks} The Icon component.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = -1; }
        var props = isProps(pOrC) ? pOrC : {};
        var content = isProps(pOrC) ? c : pOrC;
        var className = getClassname(props, content);
        return className !== "ui icon" ? dom_1.i({ props: { className: className } }) : "";
    }
    Icon.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.button) {
            className += " button";
        }
        if (props.bordered) {
            className += " bordered";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.link) {
            className += " link";
        }
        if (props.flipped) {
            className += " flipped";
        }
        if (props.rotated) {
            className += " rotated";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += enums_1.IconType.ToClassname(content);
        return className + " icon";
    }
    function isProps(props) {
        return typeof (props) === "object";
    }
})(Icon = exports.Icon || (exports.Icon = {}));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
function fromEvent(element, eventName, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    return xstream_1.Stream.create({
        element: element,
        next: null,
        start: function start(listener) {
            this.next = function next(event) { listener.next(event); };
            this.element.addEventListener(eventName, this.next, useCapture);
        },
        stop: function stop() {
            this.element.removeEventListener(eventName, this.next, useCapture);
        },
    });
}
exports.fromEvent = fromEvent;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var is = __webpack_require__(21);
var vnode = __webpack_require__(35);
function isGenericStream(x) {
    return !Array.isArray(x) && typeof x.map === "function";
}
function mutateStreamWithNS(vNode) {
    addNS(vNode.data, vNode.children, vNode.sel);
    return vNode;
}
function addNS(data, children, selector) {
    data.ns = "http://www.w3.org/2000/svg";
    if (selector !== "text" && selector !== "foreignObject" &&
        typeof children !== 'undefined' && is.array(children)) {
        for (var i = 0; i < children.length; ++i) {
            if (isGenericStream(children[i])) {
                children[i] = children[i].map(mutateStreamWithNS);
            }
            else {
                addNS(children[i].data, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {};
    var children;
    var text;
    if (arguments.length === 3) {
        data = b;
        if (is.array(c)) {
            children = c;
        }
        else if (is.primitive(c)) {
            text = c;
        }
    }
    else if (arguments.length === 2) {
        if (is.array(b)) {
            children = b;
        }
        else if (is.primitive(b)) {
            text = b;
        }
        else {
            data = b;
        }
    }
    if (is.array(children)) {
        children = children.filter(function (x) { return x; });
        for (var i = 0; i < children.length; ++i) {
            if (is.primitive(children[i])) {
                children[i] = vnode(undefined, undefined, undefined, children[i]);
            }
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
        addNS(data, children, sel);
    }
    return vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
//# sourceMappingURL=hyperscript.js.map

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = Object.prototype.toString

  , id = toString.call((function () { return arguments; }()));

module.exports = function (x) { return (toString.call(x) === id); };


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(97)()
	? Object.assign
	: __webpack_require__(98);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = Object.prototype.toString

  , id = toString.call('');

module.exports = function (x) {
	return (typeof x === 'string') || (x && (typeof x === 'object') &&
		((x instanceof String) || (toString.call(x) === id))) || false;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear    = __webpack_require__(43)
  , assign   = __webpack_require__(26)
  , callable = __webpack_require__(11)
  , value    = __webpack_require__(7)
  , d        = __webpack_require__(10)
  , autoBind = __webpack_require__(89)
  , Symbol   = __webpack_require__(16)

  , defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) return new Iterator(list, context);
	defineProperties(this, {
		__list__: d('w', value(list)),
		__context__: d('w', context),
		__nextIndex__: d('w', 0)
	});
	if (!context) return;
	callable(context.on);
	context.on('_add', this._onAdd);
	context.on('_delete', this._onDelete);
	context.on('_clear', this._onClear);
};

defineProperties(Iterator.prototype, assign({
	constructor: d(Iterator),
	_next: d(function () {
		var i;
		if (!this.__list__) return;
		if (this.__redo__) {
			i = this.__redo__.shift();
			if (i !== undefined) return i;
		}
		if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
		this._unBind();
	}),
	next: d(function () { return this._createResult(this._next()); }),
	_createResult: d(function (i) {
		if (i === undefined) return { done: true, value: undefined };
		return { done: false, value: this._resolve(i) };
	}),
	_resolve: d(function (i) { return this.__list__[i]; }),
	_unBind: d(function () {
		this.__list__ = null;
		delete this.__redo__;
		if (!this.__context__) return;
		this.__context__.off('_add', this._onAdd);
		this.__context__.off('_delete', this._onDelete);
		this.__context__.off('_clear', this._onClear);
		this.__context__ = null;
	}),
	toString: d(function () { return '[object Iterator]'; })
}, autoBind({
	_onAdd: d(function (index) {
		if (index >= this.__nextIndex__) return;
		++this.__nextIndex__;
		if (!this.__redo__) {
			defineProperty(this, '__redo__', d('c', [index]));
			return;
		}
		this.__redo__.forEach(function (redo, i) {
			if (redo >= index) this.__redo__[i] = ++redo;
		}, this);
		this.__redo__.push(index);
	}),
	_onDelete: d(function (index) {
		var i;
		if (index >= this.__nextIndex__) return;
		--this.__nextIndex__;
		if (!this.__redo__) return;
		i = this.__redo__.indexOf(index);
		if (i !== -1) this.__redo__.splice(i, 1);
		this.__redo__.forEach(function (redo, i) {
			if (redo > index) this.__redo__[i] = --redo;
		}, this);
	}),
	_onClear: d(function () {
		if (this.__redo__) clear.call(this.__redo__);
		this.__nextIndex__ = 0;
	})
})));

defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
	return this;
}));
defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.go = exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getUserConfirmation = exports.getCurrentLocation = undefined;

var _LocationUtils = __webpack_require__(12);

var _DOMUtils = __webpack_require__(17);

var _DOMStateStorage = __webpack_require__(49);

var _PathUtils = __webpack_require__(8);

/* eslint-disable no-alert */


var PopStateEvent = 'popstate';

var _createLocation = function _createLocation(historyState) {
  var key = historyState && historyState.key;

  return (0, _LocationUtils.createLocation)({
    pathname: window.location.pathname,
    search: window.location.search,
    hash: window.location.hash,
    state: key ? (0, _DOMStateStorage.readState)(key) : undefined
  }, undefined, key);
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  var historyState = void 0;
  try {
    historyState = window.history.state || {};
  } catch (error) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/mjackson/history/pull/289
    historyState = {};
  }

  return _createLocation(historyState);
};

var getUserConfirmation = exports.getUserConfirmation = function getUserConfirmation(message, callback) {
  return callback(window.confirm(message));
};

var startListener = exports.startListener = function startListener(listener) {
  var handlePopState = function handlePopState(event) {
    if (event.state !== undefined) // Ignore extraneous popstate events in WebKit
      listener(_createLocation(event.state));
  };

  (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);
  };
};

var updateLocation = function updateLocation(location, updateState) {
  var state = location.state;
  var key = location.key;


  if (state !== undefined) (0, _DOMStateStorage.saveState)(key, state);

  updateState({ key: key }, (0, _PathUtils.createPath)(location));
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.pushState(state, null, path);
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.replaceState(state, null, path);
  });
};

var go = exports.go = function go(n) {
  if (n) window.history.go(n);
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AsyncUtils = __webpack_require__(127);

var _PathUtils = __webpack_require__(8);

var _runTransitionHook = __webpack_require__(32);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _Actions = __webpack_require__(20);

var _LocationUtils = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var createHistory = function createHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var getCurrentLocation = options.getCurrentLocation;
  var getUserConfirmation = options.getUserConfirmation;
  var pushLocation = options.pushLocation;
  var replaceLocation = options.replaceLocation;
  var go = options.go;
  var keyLength = options.keyLength;


  var currentLocation = void 0;
  var pendingLocation = void 0;
  var beforeListeners = [];
  var listeners = [];
  var allKeys = [];

  var getCurrentIndex = function getCurrentIndex() {
    if (pendingLocation && pendingLocation.action === _Actions.POP) return allKeys.indexOf(pendingLocation.key);

    if (currentLocation) return allKeys.indexOf(currentLocation.key);

    return -1;
  };

  var updateLocation = function updateLocation(nextLocation) {
    currentLocation = nextLocation;

    var currentIndex = getCurrentIndex();

    if (currentLocation.action === _Actions.PUSH) {
      allKeys = [].concat(_toConsumableArray(allKeys.slice(0, currentIndex + 1)), [currentLocation.key]);
    } else if (currentLocation.action === _Actions.REPLACE) {
      allKeys[currentIndex] = currentLocation.key;
    }

    listeners.forEach(function (listener) {
      return listener(currentLocation);
    });
  };

  var listenBefore = function listenBefore(listener) {
    beforeListeners.push(listener);

    return function () {
      return beforeListeners = beforeListeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var listen = function listen(listener) {
    listeners.push(listener);

    return function () {
      return listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, callback) {
    (0, _AsyncUtils.loopAsync)(beforeListeners.length, function (index, next, done) {
      (0, _runTransitionHook2.default)(beforeListeners[index], location, function (result) {
        return result != null ? done(result) : next();
      });
    }, function (message) {
      if (getUserConfirmation && typeof message === 'string') {
        getUserConfirmation(message, function (ok) {
          return callback(ok !== false);
        });
      } else {
        callback(message !== false);
      }
    });
  };

  var transitionTo = function transitionTo(nextLocation) {
    if (currentLocation && (0, _LocationUtils.locationsAreEqual)(currentLocation, nextLocation) || pendingLocation && (0, _LocationUtils.locationsAreEqual)(pendingLocation, nextLocation)) return; // Nothing to do

    pendingLocation = nextLocation;

    confirmTransitionTo(nextLocation, function (ok) {
      if (pendingLocation !== nextLocation) return; // Transition was interrupted during confirmation

      pendingLocation = null;

      if (ok) {
        // Treat PUSH to same path like REPLACE to be consistent with browsers
        if (nextLocation.action === _Actions.PUSH) {
          var prevPath = (0, _PathUtils.createPath)(currentLocation);
          var nextPath = (0, _PathUtils.createPath)(nextLocation);

          if (nextPath === prevPath && (0, _LocationUtils.statesAreEqual)(currentLocation.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
        }

        if (nextLocation.action === _Actions.POP) {
          updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.PUSH) {
          if (pushLocation(nextLocation) !== false) updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.REPLACE) {
          if (replaceLocation(nextLocation) !== false) updateLocation(nextLocation);
        }
      } else if (currentLocation && nextLocation.action === _Actions.POP) {
        var prevIndex = allKeys.indexOf(currentLocation.key);
        var nextIndex = allKeys.indexOf(nextLocation.key);

        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL
      }
    });
  };

  var push = function push(input) {
    return transitionTo(createLocation(input, _Actions.PUSH));
  };

  var replace = function replace(input) {
    return transitionTo(createLocation(input, _Actions.REPLACE));
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength || 6);
  };

  var createHref = function createHref(location) {
    return (0, _PathUtils.createPath)(location);
  };

  var createLocation = function createLocation(location, action) {
    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
    return (0, _LocationUtils.createLocation)(location, action, key);
  };

  return {
    getCurrentLocation: getCurrentLocation,
    listenBefore: listenBefore,
    listen: listen,
    transitionTo: transitionTo,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    createKey: createKey,
    createPath: _PathUtils.createPath,
    createHref: createHref,
    createLocation: createLocation
  };
};

exports.default = createHistory;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var runTransitionHook = function runTransitionHook(hook, location, callback) {
  var result = hook(location, callback);

  if (hook.length < 2) {
    // Assume the hook runs synchronously and automatically
    // call the callback with the return value.
    callback(result);
  } else {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(result === undefined, 'You should not "return" in a transition hook with a callback argument; ' + 'call the callback instead') : void 0;
  }
};

exports.default = runTransitionHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal ||
  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
    freeSelf || thisGlobal || Function('return this')();

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = root;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module), __webpack_require__(37)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var proto = Element.prototype;
var vendor = proto.matches
  || proto.matchesSelector
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function(sel, data, children, text, elm) {
  var key = data === undefined ? undefined : data.key;
  return {sel: sel, data: data, children: children,
          text: text, elm: elm, key: key};
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var xstream_1 = __webpack_require__(0);
var enums_1 = __webpack_require__(3);
var dom_1 = __webpack_require__(1);
var transition_1 = __webpack_require__(13);
var utils_1 = __webpack_require__(9);
;
var Dimmer;
(function (Dimmer) {
    /**
     * A dimmer wrapper to show extra hidden content on an element.
     * Accepts the following type of target:
     *   VNode - The element to attach the dimmer to.
     *   "Page" - Creates a dimmer for the entire page.
     * Expects the following type of args: Boolean
     * Expects the following type of content: DOMContent
     * @param  {ComponentSources} sources The Component's sources.
     * @return {ComponentSinks} The Dimmer Component.
     */
    function run(sources, invert$) {
        if (invert$ === void 0) { invert$ = xstream_1.default.of(false); }
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".dimmable").events(type); };
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.args$ = sources.args$ ? sources.args$ : onHover(evt);
            var target$ = sources.target$.remember();
            var active$ = sources.args$.remember();
            var transition$ = active$
                .fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? ({ animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out })
                : { animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out
                }; }, ({ animation: enums_1.Animation.None, direction: enums_1.Direction.None }));
            var content$ = xstream_1.default.combine(sources.content$, target$, invert$)
                .map(function (_a) {
                var content = _a[0], target = _a[1], inverted = _a[2];
                return render(content, target, inverted);
            });
            var animatedContent = transition_1.Transition.run({ DOM: sources.DOM, args$: transition$, target$: content$ });
            var vTree$ = xstream_1.default.combine(target$, animatedContent.DOM, active$)
                .map(function (_a) {
                var target = _a[0], content = _a[1], active = _a[2];
                return dimElement(target, content, active);
            });
            return {
                DOM: vTree$,
                Events: animatedContent.Events,
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Dimmer.run = run;
    function render(content, target, inverted) {
        if (content === void 0) { content = ""; }
        if (target === void 0) { target = "page"; }
        if (inverted === void 0) { inverted = false; }
        return target === "page"
            ? dom_1.div({ props: { className: "ui " + (inverted ? "inverted " : "") + "dimmer modals page dimmer" } }, content)
            : dom_1.div({ props: { className: "ui " + (inverted ? "inverted " : "") + "targetted dimmer" } }, [
                dom_1.div({ props: { className: "content" } }, [
                    dom_1.div({ props: { className: "center" } }, content)
                ])
            ]);
    }
    Dimmer.render = render;
    function onHover(events) {
        return xstream_1.default.merge(events("mouseenter"), events("mouseleave"))
            .map(function (evt) { return evt.type === "mouseenter"; }).startWith(false);
    }
    function dimElement(targetOrString, content, active) {
        var isPage = typeof (targetOrString) === "string";
        var target = isPage ? content : targetOrString;
        var className = isPage ? "" : "dimmable", c;
        if (active) {
            className += isPage ? "active" : " dimmed";
        }
        var data = utils_1.patchClassList(target, ["dimmable", "dimmed", "inverted", "active"], className);
        if (isPage) {
            if (target.children) {
                c = target.children;
            }
            else if (target.text) {
                c = target.text;
            }
        }
        else {
            c = utils_1.addElement(content, target, "targetted");
        }
        return dom_1.h(target.sel, data, c);
    }
})(Dimmer = exports.Dimmer || (exports.Dimmer = {}));


/***/ }),
/* 37 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker = (function () {
    function ScopeChecker(scope, isolateModule) {
        this.scope = scope;
        this.isolateModule = isolateModule;
    }
    ScopeChecker.prototype.isStrictlyInRootScope = function (leaf) {
        for (var el = leaf; el; el = el.parentElement) {
            var scope = this.isolateModule.isIsolatedElement(el);
            if (scope && scope !== this.scope) {
                return false;
            }
            if (scope) {
                return true;
            }
        }
        return true;
    };
    return ScopeChecker;
}());
exports.ScopeChecker = ScopeChecker;
//# sourceMappingURL=ScopeChecker.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var xstream_1 = __webpack_require__(0);
function createVTree(vnode, children) {
    return {
        sel: vnode.sel,
        data: vnode.data,
        text: vnode.text,
        elm: vnode.elm,
        key: vnode.key,
        children: children,
    };
}
function makeTransposeVNode(runStreamAdapter) {
    function internalTransposeVNode(vnode) {
        if (!vnode) {
            return null;
        }
        else if (vnode && vnode.data && vnode.data.static) {
            return xstream_1.default.of(vnode);
        }
        else if (runStreamAdapter.isValidStream(vnode)) {
            var xsStream = xstream_adapter_1.default.adapt(vnode, runStreamAdapter.streamSubscribe);
            return xsStream.map(internalTransposeVNode).flatten();
        }
        else if (typeof vnode === "object") {
            if (!vnode.children || vnode.children.length === 0) {
                return xstream_1.default.of(vnode);
            }
            var vnodeChildren = vnode.children
                .map(internalTransposeVNode)
                .filter(function (x) { return x !== null; });
            if (vnodeChildren.length === 0) {
                return xstream_1.default.of(createVTree(vnode, []));
            }
            else {
                return xstream_1.default.combine.apply(xstream_1.default, vnodeChildren)
                    .map(function (children) { return createVTree(vnode, children.slice()); });
            }
        }
        else {
            throw new Error("Unhandled vTree Value");
        }
    }
    ;
    return function transposeVNode(vnode) {
        return internalTransposeVNode(vnode);
    };
}
exports.makeTransposeVNode = makeTransposeVNode;
//# sourceMappingURL=transposition.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * History driver factory
 *
 * This is a function which, when called, returns a History Driver for Cycle.js
 * apps. The driver is also a function, and it takes a stream of new locations
 * (strings representing pathnames or location objects) as input, and outputs
 * another stream of locations that were applied.
 *
 * @param {History} history the History object created by the history library.
 * This object is usually created through `createBrowserHistory()` or
 * `createHashHistory()` or `createMemoryHistory()` from the `history` library.
 * Alternatively, you may use `createServerHistory` from this library.
 * @param {object} options an object with some options specific to this driver.
 * Options may be: `capture`, a boolean to indicate whether the driver should
 * intercept and handle any click event that leads to a link, like on an `<a>`
 * element; `onError`, a callback function that takes an error as argument and
 * handles it, use this to configure what to do with driver errors.
 * @return {Function} the History Driver function
 * @function makeHistoryDriver
 */
var makeHistoryDriver_1 = __webpack_require__(81);
exports.makeHistoryDriver = makeHistoryDriver_1.makeHistoryDriver;
/**
 * Creates a "ServerHistory" object similar to the History objects that the
 * `history` library can create. Use this when you want to support server-side
 * rendering.
 *
 * @param {string|object} location this may be either a string representing the
 * pathname, or a location object with fields like `pathname`, `search`,
 * `query`, `state`, `action`, `key`, `hash`, etc.
 * @return {object} a History object.
 * @function createServerHistory
 */
var serverHistory_1 = __webpack_require__(82);
exports.createServerHistory = serverHistory_1.createServerHistory;
var util_1 = __webpack_require__(41);
exports.supportsHistory = util_1.supportsHistory;
exports.createLocation = util_1.createLocation;
//# sourceMappingURL=index.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var objectAssign = __webpack_require__(55);
function supportsHistory() {
    if (typeof navigator === 'undefined') {
        return false;
    }
    var ua = navigator.userAgent;
    if ((ua.indexOf('Android 2.') !== -1 ||
        ua.indexOf('Android 4.0') !== -1) &&
        ua.indexOf('Mobile Safari') !== -1 &&
        ua.indexOf('Chrome') === -1 &&
        ua.indexOf('Windows Phone') === -1) {
        return false;
    }
    if (typeof window !== 'undefined') {
        return window.history && 'pushState' in window.history;
    }
    else {
        return false;
    }
}
exports.supportsHistory = supportsHistory;
var locationDefaults = {
    pathname: '/',
    action: 'POP',
    hash: '',
    search: '',
    state: undefined,
    key: null,
    query: null,
};
function createLocation(location) {
    if (typeof location === 'string') {
        return objectAssign({}, locationDefaults, { pathname: location });
    }
    return objectAssign({}, locationDefaults, location);
}
exports.createLocation = createLocation;
//# sourceMappingURL=util.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports) {

/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear



var value = __webpack_require__(7);

module.exports = function () {
	value(this).length = 0;
	return this;
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = Object.create, getPrototypeOf = Object.getPrototypeOf
  , x = {};

module.exports = function (/*customCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf
	  , customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== 'function') return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554



var isObject      = __webpack_require__(103)
  , value         = __webpack_require__(7)

  , isPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty = Object.defineProperty
  , nullDesc = { configurable: true, enumerable: false, writable: true,
		value: undefined }
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if ((prototype === null) || isObject(prototype)) return obj;
	throw new TypeError('Prototype must be null or an object');
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, 'level', { configurable: false,
		enumerable: false, writable: false, value: status.level });
}((function () {
	var x = Object.create(null), y = {}, set
	  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');

	if (desc) {
		try {
			set = desc.set; // Opera crashes at this point
			set.call(x, y);
		} catch (ignore) { }
		if (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };
	}

	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 2 };

	x = {};
	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 1 };

	return false;
}())));

__webpack_require__(100);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(110)()
	? String.prototype.contains
	: __webpack_require__(111);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isIterable = __webpack_require__(115);

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(117)() ? Map : __webpack_require__(121);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readState = exports.saveState = undefined;

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR']; /* eslint-disable no-empty */


var SecurityError = 'SecurityError';
var KeyPrefix = '@@History/';

var createKey = function createKey(key) {
  return KeyPrefix + key;
};

var saveState = exports.saveState = function saveState(key, state) {
  if (!window.sessionStorage) {
    // Session storage is not available or hidden.
    // sessionStorage is undefined in Internet Explorer when served via file protocol.
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available') : void 0;
    return;
  }

  try {
    if (state == null) {
      window.sessionStorage.removeItem(createKey(key));
    } else {
      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
    }
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available due to security settings') : void 0;

      return;
    }

    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
      // Safari "private mode" throws QuotaExceededError.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : void 0;

      return;
    }

    throw error;
  }
};

var readState = exports.readState = function readState(key) {
  var json = void 0;
  try {
    json = window.sessionStorage.getItem(createKey(key));
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to read state; sessionStorage is not available due to security settings') : void 0;

      return undefined;
    }
  }

  if (json) {
    try {
      return JSON.parse(json);
    } catch (error) {
      // Ignore invalid JSON.
    }
  }

  return undefined;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 50 */
/***/ (function(module, exports) {

/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeHtmlChar(chr) {
  return htmlEscapes[chr];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value.
 * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
 * for more details.
 *
 * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
 * to reduce XSS vectors.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFor = __webpack_require__(138),
    bindCallback = __webpack_require__(141),
    keys = __webpack_require__(146);

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

/**
 * Creates a function for `_.forOwn` or `_.forOwnRight`.
 *
 * @private
 * @param {Function} objectFunc The function to iterate over an object.
 * @returns {Function} Returns the new each function.
 */
function createForOwn(objectFunc) {
  return function(object, iteratee, thisArg) {
    if (typeof iteratee != 'function' || thisArg !== undefined) {
      iteratee = bindCallback(iteratee, thisArg, 3);
    }
    return objectFunc(object, iteratee);
  };
}

/**
 * Iterates over own enumerable properties of an object invoking `iteratee`
 * for each property. The `iteratee` is bound to `thisArg` and invoked with
 * three arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => logs 'a' and 'b' (iteration order is not guaranteed)
 */
var forOwn = createForOwn(baseForOwn);

module.exports = forOwn;


/***/ }),
/* 53 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isArguments;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = selectorParser;

var _browserSplit = __webpack_require__(42);

var _browserSplit2 = _interopRequireDefault(_browserSplit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

function selectorParser() {
  var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

  var tagName = void 0;
  var id = '';
  var classes = [];

  var tagParts = (0, _browserSplit2.default)(selector, classIdSplit);

  if (notClassId.test(tagParts[1]) || selector === '') {
    tagName = 'div';
  }

  var part = void 0;
  var type = void 0;
  var i = void 0;

  for (i = 0; i < tagParts.length; i++) {
    part = tagParts[i];

    if (!part) {
      continue;
    }

    type = part.charAt(0);

    if (!tagName) {
      tagName = part;
    } else if (type === '.') {
      classes.push(part.substring(1, part.length));
    } else if (type === '#') {
      id = part.substring(1, part.length);
    }
  }

  return {
    tagName: tagName,
    id: id,
    className: classes.join(' ')
  };
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {


// https://github.com/Matt-Esch/virtual-dom/blob/master/virtual-hyperscript/parse-tag.js

var split = __webpack_require__(42);

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

module.exports = function parseSelector(selector, upper) {
  selector = selector || '';
  var tagName;
  var id = '';
  var classes = [];

  var tagParts = split(selector, classIdSplit);

  if (notClassId.test(tagParts[1]) || selector === '') {
    tagName = 'div';
  }

  var part, type, i;

  for (i = 0; i < tagParts.length; i++) {
    part = tagParts[i];

    if (!part) {
      continue;
    }

    type = part.charAt(0);

    if (!tagName) {
      tagName = part;
    } else if (type === '.') {
      classes.push(part.substring(1, part.length));
    } else if (type === '#') {
      id = part.substring(1, part.length);
    }
  }

  return {
    tagName: upper === true ? tagName.toUpperCase() : tagName,
    id: id,
    className: classes.join(' ')
  };
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(204));


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var Menu;
(function (Menu) {
    /**
     * A menu component for displaying an assortment of items.
     * Accepts the following properties:
     * 	secondary?: boolean - Styles the menu to de-emphasize its content.
     * 	pointing?: boolean - Styles the menu to be pointing to nearby content.
     * 	tabular?: boolean - Styles the menu to be suited for tabs.
     * 	text?: boolean - Styles the menu for text content.
     * 	vertical?: boolean - Styles the menu to display its content vertically.
     * 	pagination?: boolean - Formats the menu content to present links to pages of content.
     * 	fixed?: boolean - Styles the menu to appear fixed to its context.
     * 	stackable?: boolean - Ensures the menu content stacks on mobile resolutions.
     * 	inverted?: boolean - Styles the menu to have its colors inverted.
     * 	icon?: boolean - Styles the menu for icon content.
     * 	labelled?: boolean - Styles the menu for labelled icon content.
     * 	compact?: boolean - Styles the menu so that it takes only the amount of space neccesary.
     * 	evenlyDivided?: boolean - Styles the menu so that its content is evenly divided.
     * 	borderless?: boolean - Styles the menu so that there are no borders between its content.
     * 	color?: Color - The color of the menu.
     * 	attachment?: Attachment - The attachment of the menu.
     * 	size?: Size - The size of the menu.
     * Expects the following type of content: Array of {}
     * 	link?: boolean - Styles the item to appear clickable.
     * 	down?: boolean - Styles the item to appear pressed.
     * 	active?: boolean - Styles the item to be more pronounced.
     * 	disabled?: boolean - Styles the item to appear disabled.
     * 	header?: boolean - Styles the item text to be more pronounced.
     * 	fitted?: boolean - Removes the padding of the item.
     *         icon?: boolean - Styles the item for icon content.
     * 	color?: Color - The color of the item.
     * 	float? Float - The alignment of the item.
     * 	href?: string - The link for the item.
     * 	body: DOMContent - The content of the item.
     */
    function run(sources) {
        function main(sources) {
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            var click$ = sources.DOM.select(".ui.menu > .item").events("click");
            var items$ = sources.content$.remember();
            var clickedId$ = click$.map(function (ev) { return parseInt(ev.currentTarget.id); })
                .filter(function (n) { return !isNaN(n) && typeof (n) !== "undefined"; });
            var clickedItem$ = items$.map(function (items) { return clickedId$.map(function (id) { return items[id]; }); }).flatten()
                .filter(function (item) { return !item.disabled; });
            var vtree$ = xstream_1.default.combine(sources.props$, items$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vtree$,
                Events: function (type) { return sources.DOM.select(".menu").events(type); },
                value$: clickedItem$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Menu.run = run;
    /**
     * A menu component for displaying an assortment of items.
     * Accepts the following properties:
     * 	secondary?: boolean - Styles the menu to de-emphasize its content.
     * 	pointing?: boolean - Styles the menu to be pointing to nearby content.
     * 	tabular?: boolean - Styles the menu to be suited for tabs.
     * 	text?: boolean - Styles the menu for text content.
     * 	vertical?: boolean - Styles the menu to display its content vertically.
     * 	pagination?: boolean - Formats the menu content to present links to pages of content.
     * 	fixed?: boolean - Styles the menu to appear fixed to its context.
     * 	stackable?: boolean - Ensures the menu content stacks on mobile resolutions.
     * 	inverted?: boolean - Styles the menu to have its colors inverted.
     * 	icon?: boolean - Styles the menu for icon content.
     * 	labelled?: boolean - Styles the menu for labelled icon content.
     * 	compact?: boolean - Styles the menu so that it takes only the amount of space neccesary.
     * 	evenlyDivided?: boolean - Styles the menu so that its content is evenly divided.
     * 	borderless?: boolean - Styles the menu so that there are no borders between its content.
     * 	color?: Color - The color of the menu.
     * 	attachment?: Attachment - The attachment of the menu.
     * 	size?: Size - The size of the menu.
     * Expects the following type of content: Array of {}
     * 	link?: boolean - Styles the item to appear clickable.
     * 	down?: boolean - Styles the item to appear pressed.
     * 	active?: boolean - Styles the item to be more pronounced.
     * 	disabled?: boolean - Styles the item to appear disabled.
     * 	header?: boolean - Styles the item text to be more pronounced.
     * 	fitted?: boolean - Removes the padding of the item.
     *  icon?: boolean - Styles the item for icon content.
     * 	color?: Color - The color of the item.
     * 	float? Float - The alignment of the item.
     * 	href?: string - The link for the item.
     * 	body: DOMContent - The content of the item.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        var items = content.map(function (item) { return item.href
            ? dom_1.a({ props: { className: getItemClassname(item), id: content.indexOf(item), href: item.href } }, item.body)
            : dom_1.div({ props: { className: getItemClassname(item), id: content.indexOf(item) } }, item.body); });
        return dom_1.div({ props: { className: getClassname(props, content.length) } }, items);
    }
    Menu.render = render;
    function getClassname(props, length) {
        var className;
        if (!props.submenu) {
            className = "ui";
        }
        if (props.secondary) {
            className += " secondary";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (props.tabular) {
            className += " tabular";
        }
        if (props.text) {
            className += " text";
        }
        if (props.vertical) {
            className += " vertical";
        }
        if (props.pagination) {
            className += " pagination";
        }
        if (props.fixed) {
            className += " fixed";
        }
        if (props.stackable) {
            className += " stackable";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.labelled) {
            className += " labelled icon";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.borderless) {
            className += " borderless";
        }
        if (props.evenlyDivided) {
            className += utils_1.numToText(length) + " item";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " menu";
        return className;
    }
    function getItemClassname(item) {
        var className = "";
        if (item.down) {
            className += " down";
        }
        if (item.active) {
            className += " active";
        }
        if (item.header) {
            className += " header";
        }
        if (item.fitted) {
            className += " vertically fitted";
        }
        if (item.link) {
            className += " link";
        }
        if (item.icon) {
            className += " icon";
        }
        if (item.disabled) {
            className += " disabled";
        }
        if (typeof (item.float) !== "undefined") {
            className += enums_1.Float.ToClassname(item.float);
        }
        if (typeof (item.color) !== "undefined") {
            className += enums_1.Color.ToClassname(item.color);
        }
        className += " item";
        return className;
    }
})(Menu = exports.Menu || (exports.Menu = {}));


/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var DebounceOperator = (function () {
    function DebounceOperator(dt, ins) {
        this.dt = dt;
        this.ins = ins;
        this.type = 'debounce';
        this.out = null;
        this.id = null;
    }
    DebounceOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DebounceOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
        this.id = null;
    };
    DebounceOperator.prototype.clearInterval = function () {
        var id = this.id;
        if (id !== null) {
            clearInterval(id);
        }
        this.id = null;
    };
    DebounceOperator.prototype._n = function (t) {
        var _this = this;
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        this.id = setInterval(function () {
            _this.clearInterval();
            u._n(t);
        }, this.dt);
    };
    DebounceOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        u._e(err);
    };
    DebounceOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        u._c();
    };
    return DebounceOperator;
}());
/**
 * Delays events until a certain amount of silence has passed. If that timespan
 * of silence is not met the event is dropped.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2--3--4----5|
 *     debounce(60)
 * -----1----------4--|
 * ```
 *
 * Example:
 *
 * ```js
 * import fromDiagram from 'xstream/extra/fromDiagram'
 * import debounce from 'xstream/extra/debounce'
 *
 * const stream = fromDiagram('--1----2--3--4----5|')
 *  .compose(debounce(60))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1
 * > 4
 * > completed
 * ```
 *
 * @param {number} period The amount of silence required in milliseconds.
 * @return {Stream}
 */
function debounce(period) {
    return function debounceOperator(ins) {
        return new index_1.Stream(new DebounceOperator(period, ins));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = debounce;
//# sourceMappingURL=debounce.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var DelayOperator = (function () {
    function DelayOperator(dt, ins) {
        this.dt = dt;
        this.ins = ins;
        this.type = 'delay';
        this.out = null;
    }
    DelayOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DelayOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
    };
    DelayOperator.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._n(t);
            clearInterval(id);
        }, this.dt);
    };
    DelayOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._e(err);
            clearInterval(id);
        }, this.dt);
    };
    DelayOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._c();
            clearInterval(id);
        }, this.dt);
    };
    return DelayOperator;
}());
/**
 * Delays periodic events by a given time period.
 *
 * Marble diagram:
 *
 * ```text
 * 1----2--3--4----5|
 *     delay(60)
 * ---1----2--3--4----5|
 * ```
 *
 * Example:
 *
 * ```js
 * import fromDiagram from 'xstream/extra/fromDiagram'
 * import delay from 'xstream/extra/delay'
 *
 * const stream = fromDiagram('1----2--3--4----5|')
 *  .compose(delay(60))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1  (after 60 ms)
 * > 2  (after 160 ms)
 * > 3  (after 220 ms)
 * > 4  (after 280 ms)
 * > 5  (after 380 ms)
 * > completed
 * ```
 *
 * @param {number} period The amount of silence required in milliseconds.
 * @return {Stream}
 */
function delay(period) {
    return function delayOperator(ins) {
        return new index_1.Stream(new DelayOperator(period, ins));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = delay;
//# sourceMappingURL=delay.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var empty = {};
var DropRepeatsOperator = (function () {
    function DropRepeatsOperator(ins, fn) {
        this.ins = ins;
        this.fn = fn;
        this.type = 'dropRepeats';
        this.out = null;
        this.v = empty;
    }
    DropRepeatsOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DropRepeatsOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
        this.v = empty;
    };
    DropRepeatsOperator.prototype.isEq = function (x, y) {
        return this.fn ? this.fn(x, y) : x === y;
    };
    DropRepeatsOperator.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        var v = this.v;
        if (v !== empty && this.isEq(t, v))
            return;
        this.v = Array.isArray(t) ? t.slice() : t;
        u._n(t);
    };
    DropRepeatsOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    DropRepeatsOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        u._c();
    };
    return DropRepeatsOperator;
}());
exports.DropRepeatsOperator = DropRepeatsOperator;
/**
 * Drops consecutive duplicate values in a stream.
 *
 * Marble diagram:
 *
 * ```text
 * --1--2--1--1--1--2--3--4--3--3|
 *     dropRepeats
 * --1--2--1--------2--3--4--3---|
 * ```
 *
 * Example:
 *
 * ```js
 * import dropRepeats from 'xstream/extra/dropRepeats'
 *
 * const stream = xs.of(1, 2, 1, 1, 1, 2, 3, 4, 3, 3)
 *   .compose(dropRepeats())
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1
 * > 2
 * > 1
 * > 2
 * > 3
 * > 4
 * > 3
 * > completed
 * ```
 *
 * Example with a custom isEqual function:
 *
 * ```js
 * import dropRepeats from 'xstream/extra/dropRepeats'
 *
 * const stream = xs.of('a', 'b', 'a', 'A', 'B', 'b')
 *   .compose(dropRepeats((x, y) => x.toLowerCase() === y.toLowerCase()))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > a
 * > b
 * > a
 * > B
 * > completed
 * ```
 *
 * @param {Function} isEqual An optional function of type
 * `(x: T, y: T) => boolean` that takes an event from the input stream and
 * checks if it is equal to previous event, by returning a boolean.
 * @return {Stream}
 */
function dropRepeats(isEqual) {
    if (isEqual === void 0) { isEqual = void 0; }
    return function dropRepeatsOperator(ins) {
        return new index_1.Stream(new DropRepeatsOperator(ins, isEqual));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = dropRepeats;
//# sourceMappingURL=dropRepeats.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_run_1 = __webpack_require__(83);
var dom_1 = __webpack_require__(1);
var cyclic_router_1 = __webpack_require__(86);
var history_1 = __webpack_require__(133);
var xstream_1 = __webpack_require__(0);
var switch_path_1 = __webpack_require__(169);
var router_1 = __webpack_require__(177);
var routes_1 = __webpack_require__(178);
var layout_1 = __webpack_require__(175);
var history = cyclic_router_1.supportsHistory()
    ? [history_1.createHistory(), switch_path_1.default, { capture: true }]
    : [history_1.createHashHistory(), switch_path_1.default, { capture: true }];
function app(drivers) {
    var page = router_1.default(Object.assign({}, drivers, { routes: routes_1.default }));
    var layout = layout_1.Layout.run(drivers, page);
    var sinks = {
        DOM: layout.DOM,
        router: xstream_1.default.merge(page.router, layout.router),
    };
    return sinks;
}
xstream_run_1.run(app, {
    DOM: dom_1.makeDOMDriver(".app"),
    router: cyclic_router_1.makeRouterDriver.apply(null, history),
});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var fromEvent_1 = __webpack_require__(23);
var BodyDOMSource = (function () {
    function BodyDOMSource(_runStreamAdapter, _name) {
        this._runStreamAdapter = _runStreamAdapter;
        this._name = _name;
    }
    BodyDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    BodyDOMSource.prototype.elements = function () {
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(xstream_1.default.of(document.body), xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    BodyDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        var stream;
        if (options && typeof options.useCapture === 'boolean') {
            stream = fromEvent_1.fromEvent(document.body, eventType, options.useCapture);
        }
        else {
            stream = fromEvent_1.fromEvent(document.body, eventType);
        }
        var out = this._runStreamAdapter.adapt(stream, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    return BodyDOMSource;
}());
exports.BodyDOMSource = BodyDOMSource;
//# sourceMappingURL=BodyDOMSource.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var fromEvent_1 = __webpack_require__(23);
var DocumentDOMSource = (function () {
    function DocumentDOMSource(_runStreamAdapter, _name) {
        this._runStreamAdapter = _runStreamAdapter;
        this._name = _name;
    }
    DocumentDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    DocumentDOMSource.prototype.elements = function () {
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(xstream_1.default.of(document), xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    DocumentDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        var stream;
        if (options && typeof options.useCapture === 'boolean') {
            stream = fromEvent_1.fromEvent(document, eventType, options.useCapture);
        }
        else {
            stream = fromEvent_1.fromEvent(document, eventType);
        }
        var out = this._runStreamAdapter.adapt(stream, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    return DocumentDOMSource;
}());
exports.DocumentDOMSource = DocumentDOMSource;
//# sourceMappingURL=DocumentDOMSource.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker_1 = __webpack_require__(38);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(34);
}
catch (e) {
    matchesSelector = Function.prototype;
}
function toElArray(input) {
    return Array.prototype.slice.call(input);
}
var ElementFinder = (function () {
    function ElementFinder(namespace, isolateModule) {
        this.namespace = namespace;
        this.isolateModule = isolateModule;
    }
    ElementFinder.prototype.call = function (rootElement) {
        var namespace = this.namespace;
        if (namespace.join("") === "") {
            return rootElement;
        }
        var scope = utils_1.getScope(namespace);
        var scopeChecker = new ScopeChecker_1.ScopeChecker(scope, this.isolateModule);
        var selector = utils_1.getSelectors(namespace);
        var topNode = rootElement;
        var topNodeMatches = [];
        if (scope.length > 0) {
            topNode = this.isolateModule.getIsolatedElement(scope) || rootElement;
            if (selector && matchesSelector(topNode, selector)) {
                topNodeMatches.push(topNode);
            }
        }
        return toElArray(topNode.querySelectorAll(selector))
            .filter(scopeChecker.isStrictlyInRootScope, scopeChecker)
            .concat(topNodeMatches);
    };
    return ElementFinder;
}());
exports.ElementFinder = ElementFinder;
//# sourceMappingURL=ElementFinder.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker_1 = __webpack_require__(38);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(34);
}
catch (e) {
    matchesSelector = Function.prototype;
}
var gDestinationId = 0;
function findDestinationId(arr, searchId) {
    var minIndex = 0;
    var maxIndex = arr.length - 1;
    var currentIndex;
    var currentElement;
    while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0; // tslint:disable-line:no-bitwise
        currentElement = arr[currentIndex];
        var currentId = currentElement.destinationId;
        if (currentId < searchId) {
            minIndex = currentIndex + 1;
        }
        else if (currentId > searchId) {
            maxIndex = currentIndex - 1;
        }
        else {
            return currentIndex;
        }
    }
    return -1;
}
/**
 * Attaches an actual event listener to the DOM root element,
 * handles "destinations" (interested DOMSource output subjects), and bubbling.
 */
var EventDelegator = (function () {
    function EventDelegator(topElement, eventType, useCapture, isolateModule) {
        var _this = this;
        this.topElement = topElement;
        this.eventType = eventType;
        this.useCapture = useCapture;
        this.isolateModule = isolateModule;
        this.destinations = [];
        this.roof = topElement.parentElement;
        if (useCapture) {
            this.domListener = function (ev) { return _this.capture(ev); };
        }
        else {
            this.domListener = function (ev) { return _this.bubble(ev); };
        }
        topElement.addEventListener(eventType, this.domListener, useCapture);
    }
    EventDelegator.prototype.bubble = function (rawEvent) {
        if (!this.topElement.contains(rawEvent.currentTarget)) {
            return;
        }
        var ev = this.patchEvent(rawEvent);
        for (var el = ev.target; el && el !== this.roof; el = el.parentElement) {
            if (!this.topElement.contains(el)) {
                ev.stopPropagation();
            }
            if (ev.propagationHasBeenStopped) {
                return;
            }
            this.matchEventAgainstDestinations(el, ev);
        }
    };
    EventDelegator.prototype.matchEventAgainstDestinations = function (el, ev) {
        for (var i = 0, n = this.destinations.length; i < n; i++) {
            var dest = this.destinations[i];
            if (!dest.scopeChecker.isStrictlyInRootScope(el)) {
                continue;
            }
            if (matchesSelector(el, dest.selector)) {
                this.mutateEventCurrentTarget(ev, el);
                dest.subject._n(ev);
            }
        }
    };
    EventDelegator.prototype.capture = function (ev) {
        for (var i = 0, n = this.destinations.length; i < n; i++) {
            var dest = this.destinations[i];
            if (matchesSelector(ev.target, dest.selector)) {
                dest.subject._n(ev);
            }
        }
    };
    EventDelegator.prototype.addDestination = function (subject, namespace, destinationId) {
        var scope = utils_1.getScope(namespace);
        var selector = utils_1.getSelectors(namespace);
        var scopeChecker = new ScopeChecker_1.ScopeChecker(scope, this.isolateModule);
        this.destinations.push({ subject: subject, scopeChecker: scopeChecker, selector: selector, destinationId: destinationId });
    };
    EventDelegator.prototype.createDestinationId = function () {
        return gDestinationId++;
    };
    EventDelegator.prototype.removeDestinationId = function (destinationId) {
        var i = findDestinationId(this.destinations, destinationId);
        if (i >= 0) {
            this.destinations.splice(i, 1);
        }
    };
    EventDelegator.prototype.patchEvent = function (event) {
        var pEvent = event;
        pEvent.propagationHasBeenStopped = false;
        var oldStopPropagation = pEvent.stopPropagation;
        pEvent.stopPropagation = function stopPropagation() {
            oldStopPropagation.call(this);
            this.propagationHasBeenStopped = true;
        };
        return pEvent;
    };
    EventDelegator.prototype.mutateEventCurrentTarget = function (event, currentTargetElement) {
        try {
            Object.defineProperty(event, "currentTarget", {
                value: currentTargetElement,
                configurable: true,
            });
        }
        catch (err) {
            console.log("please use event.ownerTarget");
        }
        event.ownerTarget = currentTargetElement;
    };
    EventDelegator.prototype.updateTopElement = function (newTopElement) {
        this.topElement.removeEventListener(this.eventType, this.domListener, this.useCapture);
        newTopElement.addEventListener(this.eventType, this.domListener, this.useCapture);
        this.topElement = newTopElement;
    };
    return EventDelegator;
}());
exports.EventDelegator = EventDelegator;
//# sourceMappingURL=EventDelegator.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var HTMLSource = (function () {
    function HTMLSource(html$, runSA, _name) {
        this.runSA = runSA;
        this._name = _name;
        this._html$ = html$;
        this._empty$ = runSA.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
    }
    HTMLSource.prototype.elements = function () {
        var out = this.runSA.adapt(this._html$, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    HTMLSource.prototype.select = function (selector) {
        return new HTMLSource(xstream_1.default.empty(), this.runSA, this._name);
    };
    HTMLSource.prototype.events = function (eventType, options) {
        var out = this._empty$;
        out._isCycleSource = this._name;
        return out;
    };
    return HTMLSource;
}());
exports.HTMLSource = HTMLSource;
//# sourceMappingURL=HTMLSource.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var DocumentDOMSource_1 = __webpack_require__(67);
var BodyDOMSource_1 = __webpack_require__(66);
var xstream_1 = __webpack_require__(0);
var ElementFinder_1 = __webpack_require__(68);
var fromEvent_1 = __webpack_require__(23);
var isolate_1 = __webpack_require__(74);
var EventDelegator_1 = __webpack_require__(69);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(34);
}
catch (e) {
    matchesSelector = Function.prototype;
}
var eventTypesThatDontBubble = [
    "blur",
    "canplay",
    "canplaythrough",
    "change",
    "durationchange",
    "emptied",
    "ended",
    "focus",
    "load",
    "loadeddata",
    "loadedmetadata",
    "mouseenter",
    "mouseleave",
    "pause",
    "play",
    "playing",
    "ratechange",
    "reset",
    "scroll",
    "seeked",
    "seeking",
    "stalled",
    "submit",
    "suspend",
    "timeupdate",
    "unload",
    "volumechange",
    "waiting",
];
function determineUseCapture(eventType, options) {
    var result = false;
    if (typeof options.useCapture === 'boolean') {
        result = options.useCapture;
    }
    if (eventTypesThatDontBubble.indexOf(eventType) !== -1) {
        result = true;
    }
    return result;
}
function filterBasedOnIsolation(domSource, scope) {
    return function filterBasedOnIsolationOperator(rootElement$) {
        return rootElement$
            .fold(function shouldPass(state, element) {
            var hasIsolated = !!domSource._isolateModule.getIsolatedElement(scope);
            var shouldPass = hasIsolated && !state.hadIsolatedMutable;
            return { hadIsolatedMutable: hasIsolated, shouldPass: shouldPass, element: element };
        }, { hadIsolatedMutable: false, shouldPass: false, element: null })
            .drop(1)
            .filter(function (s) { return s.shouldPass; })
            .map(function (s) { return s.element; });
    };
}
var MainDOMSource = (function () {
    function MainDOMSource(_rootElement$, _sanitation$, _runStreamAdapter, _namespace, _isolateModule, _delegators, _name) {
        var _this = this;
        if (_namespace === void 0) { _namespace = []; }
        this._rootElement$ = _rootElement$;
        this._sanitation$ = _sanitation$;
        this._runStreamAdapter = _runStreamAdapter;
        this._namespace = _namespace;
        this._isolateModule = _isolateModule;
        this._delegators = _delegators;
        this._name = _name;
        this.__JANI_EVAKALLIO_WE_WILL_MISS_YOU_PLEASE_COME_BACK_EVENTUALLY = false;
        this.__JANI_EVAKALLIO_WE_WILL_MISS_YOU_PLEASE_COME_BACK_EVENTUALLY = true;
        this.isolateSource = isolate_1.isolateSource;
        this.isolateSink = function (sink, scope) {
            var existingScope = utils_1.getScope(_this._namespace);
            var deeperScope = [existingScope, scope].filter(function (x) { return !!x; }).join('-');
            return isolate_1.isolateSink(sink, deeperScope);
        };
    }
    MainDOMSource.prototype.elements = function () {
        var output$;
        if (this._namespace.length === 0) {
            output$ = this._rootElement$;
        }
        else {
            var elementFinder_1 = new ElementFinder_1.ElementFinder(this._namespace, this._isolateModule);
            output$ = this._rootElement$.map(function (el) { return elementFinder_1.call(el); });
        }
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(output$, xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    Object.defineProperty(MainDOMSource.prototype, "namespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    MainDOMSource.prototype.select = function (selector) {
        if (typeof selector !== 'string') {
            throw new Error("DOM driver's select() expects the argument to be a " +
                "string as a CSS selector");
        }
        if (selector === 'document') {
            return new DocumentDOMSource_1.DocumentDOMSource(this._runStreamAdapter, this._name);
        }
        if (selector === 'body') {
            return new BodyDOMSource_1.BodyDOMSource(this._runStreamAdapter, this._name);
        }
        var trimmedSelector = selector.trim();
        var childNamespace = trimmedSelector === ":root" ?
            this._namespace :
            this._namespace.concat(trimmedSelector);
        return new MainDOMSource(this._rootElement$, this._sanitation$, this._runStreamAdapter, childNamespace, this._isolateModule, this._delegators, this._name);
    };
    MainDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        if (typeof eventType !== "string") {
            throw new Error("DOM driver's events() expects argument to be a " +
                "string representing the event type to listen for.");
        }
        var useCapture = determineUseCapture(eventType, options);
        var namespace = this._namespace;
        var scope = utils_1.getScope(namespace);
        var keyParts = [eventType, useCapture];
        if (scope) {
            keyParts.push(scope);
        }
        var key = keyParts.join('~');
        var domSource = this;
        var rootElement$;
        if (scope) {
            rootElement$ = this._rootElement$
                .compose(filterBasedOnIsolation(domSource, scope));
        }
        else {
            rootElement$ = this._rootElement$.take(2);
        }
        var event$ = rootElement$
            .map(function setupEventDelegatorOnTopElement(rootElement) {
            // Event listener just for the root element
            if (!namespace || namespace.length === 0) {
                return fromEvent_1.fromEvent(rootElement, eventType, useCapture);
            }
            // Event listener on the top element as an EventDelegator
            var delegators = domSource._delegators;
            var top = domSource._isolateModule.getIsolatedElement(scope) || rootElement;
            var delegator;
            if (delegators.has(key)) {
                delegator = delegators.get(key);
                delegator.updateTopElement(top);
            }
            else {
                delegator = new EventDelegator_1.EventDelegator(top, eventType, useCapture, domSource._isolateModule);
                delegators.set(key, delegator);
            }
            if (scope) {
                domSource._isolateModule.addEventDelegator(scope, delegator);
            }
            var destinationId = delegator.createDestinationId();
            var subject = xstream_1.default.create({
                start: function () { },
                stop: function () {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(function () {
                            delegator.removeDestinationId(destinationId);
                        });
                    }
                    else {
                        delegator.removeDestinationId(destinationId);
                    }
                },
            });
            delegator.addDestination(subject, namespace, destinationId);
            return subject;
        })
            .flatten();
        var out = this._runStreamAdapter.adapt(event$, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = domSource._name;
        return out;
    };
    MainDOMSource.prototype.dispose = function () {
        this._sanitation$.shamefullySendNext('');
        this._isolateModule.reset();
    };
    return MainDOMSource;
}());
exports.MainDOMSource = MainDOMSource;
//# sourceMappingURL=MainDOMSource.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hyperscript_1 = __webpack_require__(24);
var classNameFromVNode_1 = __webpack_require__(151);
var selectorParser_1 = __webpack_require__(56);
var VNodeWrapper = (function () {
    function VNodeWrapper(rootElement) {
        this.rootElement = rootElement;
    }
    VNodeWrapper.prototype.call = function (vnode) {
        var _a = selectorParser_1.default(vnode.sel), selectorTagName = _a.tagName, selectorId = _a.id;
        var vNodeClassName = classNameFromVNode_1.default(vnode);
        var vNodeData = vnode.data || {};
        var vNodeDataProps = vNodeData.props || {};
        var _b = vNodeDataProps.id, vNodeId = _b === void 0 ? selectorId : _b;
        var isVNodeAndRootElementIdentical = vNodeId.toUpperCase() === this.rootElement.id.toUpperCase() &&
            selectorTagName.toUpperCase() === this.rootElement.tagName.toUpperCase() &&
            vNodeClassName.toUpperCase() === this.rootElement.className.toUpperCase();
        if (isVNodeAndRootElementIdentical) {
            return vnode;
        }
        var _c = this.rootElement, tagName = _c.tagName, id = _c.id, className = _c.className;
        var elementId = id ? "#" + id : "";
        var elementClassName = className ?
            "." + className.split(" ").join(".") : "";
        return hyperscript_1.h("" + tagName.toLowerCase() + elementId + elementClassName, {}, [
            vnode,
        ]);
    };
    return VNodeWrapper;
}());
exports.VNodeWrapper = VNodeWrapper;
//# sourceMappingURL=VNodeWrapper.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hyperscript_1 = __webpack_require__(24);
function isValidString(param) {
    return typeof param === 'string' && param.length > 0;
}
function isSelector(param) {
    return isValidString(param) && (param[0] === '.' || param[0] === '#');
}
function createTagFunction(tagName) {
    return function hyperscript(first, b, c) {
        if (isSelector(first)) {
            if (typeof b !== 'undefined' && typeof c !== 'undefined') {
                return hyperscript_1.h(tagName + first, b, c);
            }
            else if (typeof b !== 'undefined') {
                return hyperscript_1.h(tagName + first, b);
            }
            else {
                return hyperscript_1.h(tagName + first, {});
            }
        }
        else if (!!b) {
            return hyperscript_1.h(tagName, first, b);
        }
        else if (!!first) {
            return hyperscript_1.h(tagName, first);
        }
        else {
            return hyperscript_1.h(tagName, {});
        }
    };
}
var SVG_TAG_NAMES = [
    'a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
    'animateMotion', 'animateTransform', 'circle', 'clipPath', 'colorProfile',
    'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
    'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting',
    'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB',
    'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',
    'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting',
    'feSpotlight', 'feTile', 'feTurbulence', 'filter', 'font', 'fontFace',
    'fontFaceFormat', 'fontFaceName', 'fontFaceSrc', 'fontFaceUri',
    'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line',
    'linearGradient', 'marker', 'mask', 'metadata', 'missingGlyph', 'mpath',
    'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script',
    'set', 'stop', 'style', 'switch', 'symbol', 'text', 'textPath', 'title',
    'tref', 'tspan', 'use', 'view', 'vkern',
];
var svg = createTagFunction('svg');
SVG_TAG_NAMES.forEach(function (tag) {
    svg[tag] = createTagFunction(tag);
});
var TAG_NAMES = [
    'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base',
    'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption',
    'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'dir', 'div', 'dl',
    'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html',
    'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend',
    'li', 'link', 'main', 'map', 'mark', 'menu', 'meta', 'nav', 'noscript',
    'object', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'progress', 'q',
    'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small',
    'source', 'span', 'strong', 'style', 'sub', 'sup', 'table', 'tbody', 'td',
    'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'u', 'ul', 'video',
];
var exported = { SVG_TAG_NAMES: SVG_TAG_NAMES, TAG_NAMES: TAG_NAMES, svg: svg, isSelector: isSelector, createTagFunction: createTagFunction };
TAG_NAMES.forEach(function (n) {
    exported[n] = createTagFunction(n);
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exported;
//# sourceMappingURL=hyperscript-helpers.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils_1 = __webpack_require__(15);
function isolateSource(source, scope) {
    return source.select(utils_1.SCOPE_PREFIX + scope);
}
exports.isolateSource = isolateSource;
function isolateSink(sink, scope) {
    return sink.map(function (vTree) {
        if (vTree.data && vTree.data.isolate) {
            var existingScope = vTree.data.isolate.replace(/(cycle|\-)/g, '');
            var _scope = scope.replace(/(cycle|\-)/g, '');
            if (isNaN(parseInt(existingScope))
                || isNaN(parseInt(_scope))
                || existingScope > _scope) {
                return vTree;
            }
        }
        vTree.data = vTree.data || {};
        vTree.data.isolate = scope;
        if (typeof vTree.key === 'undefined') {
            vTree.key = utils_1.SCOPE_PREFIX + scope;
        }
        return vTree;
    });
}
exports.isolateSink = isolateSink;
//# sourceMappingURL=isolate.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MapPolyfill = __webpack_require__(48);
var IsolateModule = (function () {
    function IsolateModule(isolatedElements) {
        this.isolatedElements = isolatedElements;
        this.eventDelegators = new MapPolyfill();
    }
    IsolateModule.prototype.setScope = function (elm, scope) {
        this.isolatedElements.set(scope, elm);
    };
    IsolateModule.prototype.removeScope = function (scope) {
        this.isolatedElements.delete(scope);
    };
    IsolateModule.prototype.cleanupVNode = function (_a) {
        var data = _a.data, elm = _a.elm;
        data = data || {};
        var scope = data.isolate || '';
        var isCurrentElm = this.isolatedElements.get(scope) === elm;
        if (scope && isCurrentElm) {
            this.removeScope(scope);
            if (this.eventDelegators.get(scope)) {
                this.eventDelegators.set(scope, []);
            }
        }
    };
    IsolateModule.prototype.getIsolatedElement = function (scope) {
        return this.isolatedElements.get(scope);
    };
    IsolateModule.prototype.isIsolatedElement = function (elm) {
        var iterator = this.isolatedElements.entries();
        for (var result = iterator.next(); !!result.value; result = iterator.next()) {
            var _a = result.value, scope = _a[0], element = _a[1];
            if (elm === element) {
                return scope;
            }
        }
        return false;
    };
    IsolateModule.prototype.addEventDelegator = function (scope, eventDelegator) {
        var delegators = this.eventDelegators.get(scope);
        if (!delegators) {
            delegators = [];
            this.eventDelegators.set(scope, delegators);
        }
        delegators[delegators.length] = eventDelegator;
    };
    IsolateModule.prototype.reset = function () {
        this.isolatedElements.clear();
    };
    IsolateModule.prototype.createModule = function () {
        var self = this;
        return {
            create: function (oldVNode, vNode) {
                var _a = oldVNode.data, oldData = _a === void 0 ? {} : _a;
                var elm = vNode.elm, _b = vNode.data, data = _b === void 0 ? {} : _b;
                var oldScope = oldData.isolate || "";
                var scope = data.isolate || "";
                if (scope) {
                    if (oldScope) {
                        self.removeScope(oldScope);
                    }
                    self.setScope(elm, scope);
                    var delegators = self.eventDelegators.get(scope);
                    if (delegators) {
                        for (var i = 0, len = delegators.length; i < len; ++i) {
                            delegators[i].updateTopElement(elm);
                        }
                    }
                    else if (delegators === void 0) {
                        self.eventDelegators.set(scope, []);
                    }
                }
                if (oldScope && !scope) {
                    self.removeScope(scope);
                }
            },
            update: function (oldVNode, vNode) {
                var _a = oldVNode.data, oldData = _a === void 0 ? {} : _a;
                var elm = vNode.elm, _b = vNode.data, data = _b === void 0 ? {} : _b;
                var oldScope = oldData.isolate || "";
                var scope = data.isolate || "";
                if (scope && scope !== oldScope) {
                    if (oldScope) {
                        self.removeScope(oldScope);
                    }
                    self.setScope(elm, scope);
                }
                if (oldScope && !scope) {
                    self.removeScope(scope);
                }
            },
            remove: function (vNode, cb) {
                self.cleanupVNode(vNode);
                cb();
            },
            destroy: function (vNode) {
                self.cleanupVNode(vNode);
            },
        };
    };
    return IsolateModule;
}());
exports.IsolateModule = IsolateModule;
//# sourceMappingURL=isolateModule.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var snabbdom_1 = __webpack_require__(166);
var xstream_1 = __webpack_require__(0);
var MainDOMSource_1 = __webpack_require__(71);
var VNodeWrapper_1 = __webpack_require__(72);
var utils_1 = __webpack_require__(15);
var modules_1 = __webpack_require__(79);
var isolateModule_1 = __webpack_require__(75);
var transposition_1 = __webpack_require__(39);
var xstream_adapter_1 = __webpack_require__(6);
var MapPolyfill = __webpack_require__(48);
function makeDOMDriverInputGuard(modules) {
    if (!Array.isArray(modules)) {
        throw new Error("Optional modules option must be " +
            "an array for snabbdom modules");
    }
}
function domDriverInputGuard(view$) {
    if (!view$
        || typeof view$.addListener !== "function"
        || typeof view$.fold !== "function") {
        throw new Error("The DOM driver function expects as input a Stream of " +
            "virtual DOM elements");
    }
}
function makeDOMDriver(container, options) {
    if (!options) {
        options = {};
    }
    var transposition = options.transposition || false;
    var modules = options.modules || modules_1.default;
    var isolateModule = new isolateModule_1.IsolateModule((new MapPolyfill()));
    var patch = snabbdom_1.init([isolateModule.createModule()].concat(modules));
    var rootElement = utils_1.getElement(container);
    var vnodeWrapper = new VNodeWrapper_1.VNodeWrapper(rootElement);
    var delegators = new MapPolyfill();
    makeDOMDriverInputGuard(modules);
    function DOMDriver(vnode$, runStreamAdapter, name) {
        domDriverInputGuard(vnode$);
        var transposeVNode = transposition_1.makeTransposeVNode(runStreamAdapter);
        var preprocessedVNode$ = (transposition ? vnode$.map(transposeVNode).flatten() : vnode$);
        var sanitation$ = xstream_1.default.create();
        var rootElement$ = xstream_1.default.merge(preprocessedVNode$.endWhen(sanitation$), sanitation$)
            .map(function (vnode) { return vnodeWrapper.call(vnode); })
            .fold(patch, rootElement)
            .drop(1)
            .map(function unwrapElementFromVNode(vnode) { return vnode.elm; })
            .compose(function (stream) { return xstream_1.default.merge(stream, xstream_1.default.never()); }) // don't complete this stream
            .startWith(rootElement);
        rootElement$.addListener({ next: function () { }, error: function () { }, complete: function () { } });
        return new MainDOMSource_1.MainDOMSource(rootElement$, sanitation$, runStreamAdapter, [], isolateModule, delegators, name);
    }
    ;
    DOMDriver.streamAdapter = xstream_adapter_1.default;
    return DOMDriver;
}
exports.makeDOMDriver = makeDOMDriver;
//# sourceMappingURL=makeDOMDriver.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var transposition_1 = __webpack_require__(39);
var HTMLSource_1 = __webpack_require__(70);
var toHTML = __webpack_require__(153);
var noop = function () { };
function makeHTMLDriver(effect, options) {
    if (!options) {
        options = {};
    }
    var transposition = options.transposition || false;
    function htmlDriver(vnode$, runStreamAdapter, name) {
        var transposeVNode = transposition_1.makeTransposeVNode(runStreamAdapter);
        var preprocessedVNode$ = (transposition ? vnode$.map(transposeVNode).flatten() : vnode$);
        var html$ = preprocessedVNode$.map(toHTML);
        html$.addListener({
            next: effect || noop,
            error: noop,
            complete: noop,
        });
        return new HTMLSource_1.HTMLSource(html$, runStreamAdapter, name);
    }
    ;
    htmlDriver.streamAdapter = xstream_adapter_1.default;
    return htmlDriver;
}
exports.makeHTMLDriver = makeHTMLDriver;
//# sourceMappingURL=makeHTMLDriver.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var xstream_1 = __webpack_require__(0);
var SCOPE_PREFIX = '___';
var MockedDOMSource = (function () {
    function MockedDOMSource(_streamAdapter, _mockConfig) {
        this._streamAdapter = _streamAdapter;
        this._mockConfig = _mockConfig;
        if (_mockConfig.elements) {
            this._elements = _mockConfig.elements;
        }
        else {
            this._elements = _streamAdapter.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
        }
    }
    MockedDOMSource.prototype.elements = function () {
        var out = this._elements;
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.events = function (eventType, options) {
        var mockConfig = this._mockConfig;
        var keys = Object.keys(mockConfig);
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
            var key = keys[i];
            if (key === eventType) {
                var out_1 = mockConfig[key];
                out_1._isCycleSource = 'MockedDOM';
                return out_1;
            }
        }
        var out = this._streamAdapter.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.select = function (selector) {
        var mockConfig = this._mockConfig;
        var keys = Object.keys(mockConfig);
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
            var key = keys[i];
            if (key === selector) {
                return new MockedDOMSource(this._streamAdapter, mockConfig[key]);
            }
        }
        return new MockedDOMSource(this._streamAdapter, {});
    };
    MockedDOMSource.prototype.isolateSource = function (source, scope) {
        return source.select('.' + SCOPE_PREFIX + scope);
    };
    MockedDOMSource.prototype.isolateSink = function (sink, scope) {
        return sink.map(function (vnode) {
            if (vnode.sel && vnode.sel.indexOf(SCOPE_PREFIX + scope) !== -1) {
                return vnode;
            }
            else {
                vnode.sel += "." + SCOPE_PREFIX + scope;
                return vnode;
            }
        });
    };
    return MockedDOMSource;
}());
exports.MockedDOMSource = MockedDOMSource;
function mockDOMSource(streamAdapter, mockConfig) {
    return new MockedDOMSource(streamAdapter, mockConfig);
}
exports.mockDOMSource = mockDOMSource;
//# sourceMappingURL=mockDOMSource.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ClassModule = __webpack_require__(161);
exports.ClassModule = ClassModule;
var PropsModule = __webpack_require__(164);
exports.PropsModule = PropsModule;
var AttrsModule = __webpack_require__(160);
exports.AttrsModule = AttrsModule;
var EventsModule = __webpack_require__(162);
exports.EventsModule = EventsModule;
var StyleModule = __webpack_require__(165);
exports.StyleModule = StyleModule;
var HeroModule = __webpack_require__(163);
exports.HeroModule = HeroModule;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = [StyleModule, ClassModule, PropsModule, AttrsModule];
//# sourceMappingURL=modules.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var clickEvent = 'undefined' !== typeof document && document.ontouchstart ?
    'touchstart' : 'click';
function which(ev) {
    if (typeof window === 'undefined') {
        return false;
    }
    var e = ev || window.event;
    return e.which === null ? e.button : e.which;
}
function sameOrigin(href) {
    if (typeof window === 'undefined') {
        return false;
    }
    return href && href.indexOf(window.location.origin) === 0;
}
function makeClickListener(push) {
    return function clickListener(event) {
        if (which(event) !== 1) {
            return;
        }
        if (event.metaKey || event.ctrlKey || event.shiftKey) {
            return;
        }
        if (event.defaultPrevented) {
            return;
        }
        var element = event.target;
        while (element && element.nodeName !== 'A') {
            element = element.parentNode;
        }
        if (!element || element.nodeName !== 'A') {
            return;
        }
        if (element.hasAttribute('download') ||
            element.getAttribute('rel') === 'external') {
            return;
        }
        if (element.target) {
            return;
        }
        var link = element.getAttribute('href');
        if (link && link.indexOf('mailto:') > -1 || link.charAt(0) === '#') {
            return;
        }
        if (!sameOrigin(element.href)) {
            return;
        }
        event.preventDefault();
        var pathname = element.pathname, search = element.search, _a = element.hash, hash = _a === void 0 ? '' : _a;
        push(pathname + search + hash);
    };
}
function captureClicks(push) {
    var listener = makeClickListener(push);
    if (typeof window !== 'undefined') {
        document.addEventListener(clickEvent, listener, false);
    }
}
exports.captureClicks = captureClicks;
//# sourceMappingURL=captureClicks.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var captureClicks_1 = __webpack_require__(80);
function makeUpdateHistory(history) {
    return function updateHistory(location) {
        if (typeof location === 'string') {
            history.push(history.createLocation(location));
        }
        else if (typeof location === 'object') {
            // suport things like history.replace()
            var _a = location.type, type = _a === void 0 ? 'push' : _a;
            if (type === 'go') {
                history[type](location);
            }
            else {
                history[type](location);
            }
        }
        else {
            throw new Error('History Driver input must be a string or an ' +
                'object but received ${typeof url}');
        }
    };
}
function defaultOnErrorFn(err) {
    if (console && console.error !== void 0) {
        console.error(err);
    }
}
function makeHistoryDriver(history, options) {
    if (!history || typeof history !== 'object'
        || typeof history.createLocation !== 'function'
        || typeof history.createHref !== 'function'
        || typeof history.listen !== 'function'
        || typeof history.push !== 'function') {
        throw new TypeError('makeHistoryDriver requires an valid history object ' +
            'containing createLocation(), createHref(), push(), and listen() methods');
    }
    var capture = options && options.capture || false;
    var onError = options && options.onError || defaultOnErrorFn;
    return function historyDriver(sink$, runSA) {
        var _a = runSA.makeSubject(), observer = _a.observer, stream = _a.stream;
        var history$ = runSA.remember(stream
            .startWith(history.getCurrentLocation())
            .filter(Boolean));
        var unlisten = history.listen(function (location) {
            observer.next(location);
        });
        if (typeof history.addCompleteCallback === 'function'
            && typeof history.complete === 'function') {
            history.addCompleteCallback(function () {
                observer.complete();
            });
        }
        runSA.streamSubscribe(sink$, {
            next: makeUpdateHistory(history),
            error: onError,
            complete: function () {
                unlisten();
                observer.complete();
            },
        });
        if (capture) {
            captureClicks_1.captureClicks(function (pathname) {
                var location = history.createLocation(pathname);
                history.push(location);
            });
        }
        history$.createHref = function (href) { return history.createHref(href); };
        history$.createLocation = function (location) { return history.createLocation(location); };
        return history$;
    };
}
exports.makeHistoryDriver = makeHistoryDriver;
//# sourceMappingURL=makeHistoryDriver.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util_1 = __webpack_require__(41);
var ServerHistory = (function () {
    function ServerHistory(currentLocation) {
        this.currentLocation = currentLocation;
        this.listeners = [];
    }
    ServerHistory.prototype.listen = function (listener) {
        this.listeners.push(listener);
        return function noop() { return void 0; };
    };
    ServerHistory.prototype.push = function (location) {
        var length = this.listeners.length;
        if (length === 0) {
            throw new Error('Must be given at least one listener before pushing');
        }
        for (var i = 0; i < length; ++i) {
            this.listeners[i](util_1.createLocation(location));
        }
    };
    ServerHistory.prototype.replace = function (location) {
        this.push(location);
    };
    ServerHistory.prototype.createHref = function (path) {
        return path;
    };
    ServerHistory.prototype.createLocation = function (location) {
        return util_1.createLocation(location);
    };
    ServerHistory.prototype.getCurrentLocation = function () {
        return this.currentLocation;
    };
    ServerHistory.prototype.addCompleteCallback = function (complete) {
        this._completeCallback = complete;
    };
    ServerHistory.prototype.complete = function () {
        this._completeCallback();
    };
    return ServerHistory;
}());
function createServerHistory(loc) {
    return new ServerHistory(loc ? util_1.createLocation(loc) : null);
}
exports.createServerHistory = createServerHistory;
//# sourceMappingURL=serverHistory.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var base_1 = __webpack_require__(84);
var xstream_adapter_1 = __webpack_require__(6);
/**
 * Takes a `main` function and circularly connects it to the given collection
 * of driver functions.
 *
 * **Example:**
 * ```js
 * import {run} from '@cycle/xstream-run';
 * const dispose = run(main, drivers);
 * // ...
 * dispose();
 * ```
 *
 * The `main` function expects a collection of "source" streams (returned from
 * drivers) as input, and should return a collection of "sink" streams (to be
 * given to drivers). A "collection of streams" is a JavaScript object where
 * keys match the driver names registered by the `drivers` object, and values
 * are the streams. Refer to the documentation of each driver to see more
 * details on what types of sources it outputs and sinks it receives.
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Function} a dispose function, used to terminate the execution of the
 * Cycle.js program, cleaning up resources used.
 * @function run
 */
function run(main, drivers) {
    var _a = base_1.default(main, drivers, { streamAdapter: xstream_adapter_1.default }), run = _a.run, sinks = _a.sinks;
    if (typeof window !== 'undefined' && window['CyclejsDevTool_startGraphSerializer']) {
        window['CyclejsDevTool_startGraphSerializer'](sinks);
    }
    return run();
}
exports.run = run;
/**
 * A function that prepares the Cycle application to be executed. Takes a `main`
 * function and prepares to circularly connects it to the given collection of
 * driver functions. As an output, `Cycle()` returns an object with three
 * properties: `sources`, `sinks` and `run`. Only when `run()` is called will
 * the application actually execute. Refer to the documentation of `run()` for
 * more details.
 *
 * **Example:**
 * ```js
 * import Cycle from '@cycle/xstream-run';
 * const {sources, sinks, run} = Cycle(main, drivers);
 * // ...
 * const dispose = run(); // Executes the application
 * // ...
 * dispose();
 * ```
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Object} an object with three properties: `sources`, `sinks` and
 * `run`. `sources` is the collection of driver sources, `sinks` is the
 * collection of driver sinks, these can be used for debugging or testing. `run`
 * is the function that once called will execute the application.
 * @function Cycle
 */
var Cycle = function (main, drivers) {
    var out = base_1.default(main, drivers, { streamAdapter: xstream_adapter_1.default });
    if (typeof window !== 'undefined' && window['CyclejsDevTool_startGraphSerializer']) {
        window['CyclejsDevTool_startGraphSerializer'](out.sinks);
    }
    return out;
};
Cycle.run = run;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Cycle;
//# sourceMappingURL=index.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function logToConsoleError(err) {
    var target = err.stack || err;
    if (console && console.error) {
        console.error(target);
    }
    else if (console && console.log) {
        console.log(target);
    }
}
function makeSinkProxies(drivers, streamAdapter) {
    var sinkProxies = {};
    for (var name_1 in drivers) {
        if (drivers.hasOwnProperty(name_1)) {
            var subject = streamAdapter.makeSubject();
            var driverStreamAdapter = drivers[name_1].streamAdapter || streamAdapter;
            var stream = driverStreamAdapter.adapt(subject.stream, streamAdapter.streamSubscribe);
            sinkProxies[name_1] = {
                stream: stream,
                observer: subject.observer,
            };
        }
    }
    return sinkProxies;
}
function callDrivers(drivers, sinkProxies, streamAdapter) {
    var sources = {};
    for (var name_2 in drivers) {
        if (drivers.hasOwnProperty(name_2)) {
            var driverOutput = drivers[name_2](sinkProxies[name_2].stream, streamAdapter, name_2);
            var driverStreamAdapter = drivers[name_2].streamAdapter;
            if (driverStreamAdapter && driverStreamAdapter.isValidStream(driverOutput)) {
                sources[name_2] = streamAdapter.adapt(driverOutput, driverStreamAdapter.streamSubscribe);
            }
            else {
                sources[name_2] = driverOutput;
            }
            if (sources[name_2] && typeof sources[name_2] === 'object') {
                sources[name_2]._isCycleSource = name_2;
            }
        }
    }
    return sources;
}
function replicateMany(sinks, sinkProxies, streamAdapter) {
    var sinkNames = Object.keys(sinks).filter(function (name) { return !!sinkProxies[name]; });
    var buffers = {};
    var replicators = {};
    sinkNames.forEach(function (name) {
        buffers[name] = { next: [], error: [], complete: [] };
        replicators[name] = {
            next: function (x) { return buffers[name].next.push(x); },
            error: function (x) { return buffers[name].error.push(x); },
            complete: function (x) { return buffers[name].complete.push(x); },
        };
    });
    var subscriptions = sinkNames.map(function (name) {
        return streamAdapter.streamSubscribe(sinks[name], {
            next: function (x) {
                replicators[name].next(x);
            },
            error: function (err) {
                logToConsoleError(err);
                replicators[name].error(err);
            },
            complete: function (x) {
                replicators[name].complete(x);
            },
        });
    });
    var disposeFunctions = subscriptions
        .filter(function (fn) { return typeof fn === 'function'; });
    sinkNames.forEach(function (name) {
        var observer = sinkProxies[name].observer;
        var next = observer.next;
        var error = observer.error;
        var complete = observer.complete;
        buffers[name].next.forEach(next);
        buffers[name].error.forEach(error);
        buffers[name].complete.forEach(complete);
        replicators[name].next = next;
        replicators[name].error = error;
        replicators[name].complete = complete;
    });
    return function () {
        disposeFunctions.forEach(function (dispose) { return dispose(); });
    };
}
function disposeSources(sources) {
    for (var k in sources) {
        if (sources.hasOwnProperty(k) && sources[k]
            && typeof sources[k].dispose === 'function') {
            sources[k].dispose();
        }
    }
}
var isObjectEmpty = function (obj) { return Object.keys(obj).length === 0; };
function Cycle(main, drivers, options) {
    if (typeof main !== "function") {
        throw new Error("First argument given to Cycle must be the 'main' " +
            "function.");
    }
    if (typeof drivers !== "object" || drivers === null) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with driver functions as properties.");
    }
    if (isObjectEmpty(drivers)) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with at least one driver function declared as a property.");
    }
    var streamAdapter = options.streamAdapter;
    if (!streamAdapter || isObjectEmpty(streamAdapter)) {
        throw new Error("Third argument given to Cycle must be an options object " +
            "with the streamAdapter key supplied with a valid stream adapter.");
    }
    var sinkProxies = makeSinkProxies(drivers, streamAdapter);
    var sources = callDrivers(drivers, sinkProxies, streamAdapter);
    var sinks = main(sources);
    if (typeof window !== 'undefined') {
        window.Cyclejs = { sinks: sinks };
    }
    var run = function () {
        var disposeReplication = replicateMany(sinks, sinkProxies, streamAdapter);
        return function () {
            disposeSources(sources);
            disposeReplication();
        };
    };
    return { sinks: sinks, sources: sources, run: run };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Cycle;
//# sourceMappingURL=index.js.map

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(88);
function isStrictlyInScope(namespace, path) {
    var pathParts = util.splitPath(path);
    return namespace.every(function (v, i) {
        return pathParts[i] === v;
    });
}
function getFilteredPath(namespace, path) {
    var pathParts = util.splitPath(path);
    return '/' + util.filterPath(pathParts, namespace);
}
var RouterSource = (function () {
    function RouterSource(history$, _namespace, _createHref, _runSA, _routeMatcher) {
        this.history$ = history$;
        this._namespace = _namespace;
        this._createHref = _createHref;
        this._runSA = _runSA;
        this._routeMatcher = _routeMatcher;
    }
    RouterSource.prototype.path = function (pathname) {
        var scopedNamespace = this._namespace.concat(util.splitPath(pathname));
        var scopedHistory$ = this._runSA.remember(this.history$
            .filter(function (_a) {
            var _path = _a.pathname;
            return isStrictlyInScope(scopedNamespace, _path);
        }));
        var createHref = this._createHref;
        return new RouterSource(scopedHistory$, scopedNamespace, createHref, this._runSA, this._routeMatcher);
    };
    RouterSource.prototype.define = function (routes, routeMatcher) {
        var _this = this;
        var namespace = this._namespace;
        var _createHref = this._createHref;
        var createHref = util.makeCreateHref(namespace, _createHref);
        var match$ = this._runSA.remember(this.history$
            .map(function (location) {
            var matcher = routeMatcher || _this._routeMatcher;
            var filteredPath = getFilteredPath(namespace, location.pathname);
            var _a = matcher(filteredPath, routes), path = _a.path, value = _a.value;
            return { path: path, value: value, location: location, createHref: createHref };
        }));
        match$.createHref = createHref;
        return match$;
    };
    RouterSource.prototype.createHref = function (path) {
        return util.makeCreateHref(this._namespace, this._createHref)(path);
    };
    return RouterSource;
}());
exports.RouterSource = RouterSource;
//# sourceMappingURL=RouterSource.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var makeRouterDriver_1 = __webpack_require__(87);
exports.makeRouterDriver = makeRouterDriver_1.makeRouterDriver;
var history_1 = __webpack_require__(40);
exports.supportsHistory = history_1.supportsHistory;
exports.createLocation = history_1.createLocation;
exports.createServerHistory = history_1.createServerHistory;
//# sourceMappingURL=index.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var history_1 = __webpack_require__(40);
var RouterSource_1 = __webpack_require__(85);
/**
 * Instantiates an new router driver function using the same arguments required
 * by @cycle/history.
 * @public
 * @method makeRouterDriver
 * @return {routerDriver} The router driver function
 */
function makeRouterDriver(history, routeMatcher, options) {
    var historyDriver = history_1.makeHistoryDriver(history, options);
    /**
     * The actual router driver.
     * @public
     * @typedef {routerDriver}
     * @name routerDriver
     * @method routerDriver
     * @param  {Stream<string|Location>} sink$ - This is the same input that the
     * history driver would expect.
     * @return {routerAPI}
     */
    return function routerDriver(sink$, runSA) {
        var history$ = runSA.remember(historyDriver(sink$, runSA));
        return new RouterSource_1.RouterSource(history$, [], history.createHref, runSA, routeMatcher);
    };
}
exports.makeRouterDriver = makeRouterDriver;
//# sourceMappingURL=makeRouterDriver.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function splitPath(path) {
    return path.split('/').filter(function (p) { return p.length > 0; });
}
exports.splitPath = splitPath;
function filterPath(pathParts, namespace) {
    return pathParts.filter(function (part) { return namespace.indexOf(part) < 0; }).join('/');
}
exports.filterPath = filterPath;
var startsWith = function (param, value) { return param[0] === value; };
var startsWith2 = function (param, value1, value2) {
    return param[0] === value1 && param[1] === value2;
};
function makeCreateHref(namespace, _createHref) {
    /**
     * Function used to create HREFs that are properly namespaced
     * @typedef {createHref}
     * @name createHref
     * @method createHref
     * @param  {string} path - the HREF that will be appended to the current
     * namespace
     * @return {string} a fully qualified HREF composed from the current
     * namespace and the path provided
     */
    return function createHref(path) {
        var fullPath = "" + namespace.join('/') + path;
        return startsWith(fullPath, '/') || startsWith2(fullPath, '#', '/')
            ? _createHref(fullPath)
            : _createHref('/' + fullPath);
    };
}
exports.makeCreateHref = makeCreateHref;
//# sourceMappingURL=util.js.map

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copy       = __webpack_require__(99)
  , map        = __webpack_require__(107)
  , callable   = __webpack_require__(11)
  , validValue = __webpack_require__(7)

  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, bindTo) {
	var value = validValue(desc) && callable(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, bindTo*/) {
	var bindTo = arguments[1];
	return map(props, function (desc, name) {
		return define(name, desc, bindTo);
	});
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toPosInt = __webpack_require__(95)
  , value    = __webpack_require__(7)

  , indexOf = Array.prototype.indexOf
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , abs = Math.abs, floor = Math.floor;

module.exports = function (searchElement/*, fromIndex*/) {
	var i, l, fromIndex, val;
	if (searchElement === searchElement) { //jslint: ignore
		return indexOf.apply(this, arguments);
	}

	l = toPosInt(value(this).length);
	fromIndex = arguments[1];
	if (isNaN(fromIndex)) fromIndex = 0;
	else if (fromIndex >= 0) fromIndex = floor(fromIndex);
	else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

	for (i = fromIndex; i < l; ++i) {
		if (hasOwnProperty.call(this, i)) {
			val = this[i];
			if (val !== val) return i; //jslint: ignore
		}
	}
	return -1;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(92)()
	? Math.sign
	: __webpack_require__(93);


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== 'function') return false;
	return ((sign(10) === 1) && (sign(-20) === -1));
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) return value;
	return (value > 0) ? 1 : -1;
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var sign = __webpack_require__(91)

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if ((value === 0) || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(94)

  , max = Math.max;

module.exports = function (value) { return max(0, toInteger(value)); };


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order



var callable = __webpack_require__(11)
  , value    = __webpack_require__(7)

  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys
  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== 'function') method = list[method];
		return call.call(method, list, function (key, index) {
			if (!propertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys  = __webpack_require__(104)
  , value = __webpack_require__(7)

  , max = Math.max;

module.exports = function (dest, src/*, srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(26)
  , value  = __webpack_require__(7);

module.exports = function (obj) {
	var copy = Object(value(obj));
	if (copy !== obj) return copy;
	return assign({}, obj);
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804



var create = Object.create, shim;

if (!__webpack_require__(44)()) {
	shim = __webpack_require__(45);
}

module.exports = (function () {
	var nullObject, props, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	props = {};
	desc = { configurable: false, enumerable: false, writable: true,
		value: undefined };
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === '__proto__') {
			props[name] = { configurable: true, enumerable: false, writable: true,
				value: undefined };
			return;
		}
		props[name] = desc;
	});
	Object.defineProperties(nullObject, props);

	Object.defineProperty(shim, 'nullPolyfill', { configurable: false,
		enumerable: false, writable: false, value: nullObject });

	return function (prototype, props) {
		return create((prototype === null) ? nullObject : prototype, props);
	};
}());


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(96)('forEach');


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Deprecated



module.exports = function (obj) { return typeof obj === 'function'; };


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var map = { function: true, object: true };

module.exports = function (x) {
	return ((x != null) && map[typeof x]) || false;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(105)()
	? Object.keys
	: __webpack_require__(106);


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callable = __webpack_require__(11)
  , forEach  = __webpack_require__(101)

  , call = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var o = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, obj, index) {
		o[key] = call.call(cb, thisArg, value, key, obj, index);
	});
	return o;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = Array.prototype.forEach, create = Object.create;

module.exports = function (arg/*, args*/) {
	var set = create(null);
	forEach.call(arguments, function (name) { set[name] = true; });
	return set;
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(19)
  , contains       = __webpack_require__(46)
  , d              = __webpack_require__(10)
  , Iterator       = __webpack_require__(28)

  , defineProperty = Object.defineProperty
  , ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
	Iterator.call(this, arr);
	if (!kind) kind = 'value';
	else if (contains.call(kind, 'key+value')) kind = 'key+value';
	else if (contains.call(kind, 'key')) kind = 'key';
	else kind = 'value';
	defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(ArrayIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__list__[i];
		if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
		return i;
	}),
	toString: d(function () { return '[object Array Iterator]'; })
});


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(25)
  , callable    = __webpack_require__(11)
  , isString    = __webpack_require__(27)
  , get         = __webpack_require__(114)

  , isArray = Array.isArray, call = Function.prototype.call
  , some = Array.prototype.some;

module.exports = function (iterable, cb/*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = 'array';
	else if (isString(iterable)) mode = 'string';
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () { broken = true; };
	if (mode === 'array') {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			if (broken) return true;
		});
		return;
	}
	if (mode === 'string') {
		l = iterable.length;
		for (i = 0; i < l; ++i) {
			char = iterable[i];
			if ((i + 1) < l) {
				code = char.charCodeAt(0);
				if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(25)
  , isString       = __webpack_require__(27)
  , ArrayIterator  = __webpack_require__(112)
  , StringIterator = __webpack_require__(116)
  , iterable       = __webpack_require__(47)
  , iteratorSymbol = __webpack_require__(16).iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(25)
  , isString       = __webpack_require__(27)
  , iteratorSymbol = __webpack_require__(16).iterator

  , isArray = Array.isArray;

module.exports = function (value) {
	if (value == null) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return (typeof value[iteratorSymbol] === 'function');
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols



var setPrototypeOf = __webpack_require__(19)
  , d              = __webpack_require__(10)
  , Iterator       = __webpack_require__(28)

  , defineProperty = Object.defineProperty
  , StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) return new StringIterator(str);
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, '__length__', d('', str.length));

};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

StringIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(StringIterator),
	_next: d(function () {
		if (!this.__list__) return;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
		return char;
	}),
	toString: d(function () { return '[object String Iterator]'; })
});


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var map, iterator, result;
	if (typeof Map !== 'function') return false;
	try {
		// WebKit doesn't support arguments and crashes
		map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
	} catch (e) {
		return false;
	}
	if (String(map) !== '[object Map]') return false;
	if (map.size !== 3) return false;
	if (typeof map.clear !== 'function') return false;
	if (typeof map.delete !== 'function') return false;
	if (typeof map.entries !== 'function') return false;
	if (typeof map.forEach !== 'function') return false;
	if (typeof map.get !== 'function') return false;
	if (typeof map.has !== 'function') return false;
	if (typeof map.keys !== 'function') return false;
	if (typeof map.set !== 'function') return false;
	if (typeof map.values !== 'function') return false;

	iterator = map.entries();
	result = iterator.next();
	if (result.done !== false) return false;
	if (!result.value) return false;
	if (result.value[0] !== 'raz') return false;
	if (result.value[1] !== 'one') return false;

	return true;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Exports true if environment provides native `Map` implementation,
// whatever that is.



module.exports = (function () {
	if (typeof Map === 'undefined') return false;
	return (Object.prototype.toString.call(new Map()) === '[object Map]');
}());


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109)('key',
	'value', 'key+value');


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf    = __webpack_require__(19)
  , d                 = __webpack_require__(10)
  , Iterator          = __webpack_require__(28)
  , toStringTagSymbol = __webpack_require__(16).toStringTag
  , kinds             = __webpack_require__(119)

  , defineProperties = Object.defineProperties
  , unBind = Iterator.prototype._unBind
  , MapIterator;

MapIterator = module.exports = function (map, kind) {
	if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
	Iterator.call(this, map.__mapKeysData__, map);
	if (!kind || !kinds[kind]) kind = 'key+value';
	defineProperties(this, {
		__kind__: d('', kind),
		__values__: d('w', map.__mapValuesData__)
	});
};
if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);

MapIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(MapIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__values__[i];
		if (this.__kind__ === 'key') return this.__list__[i];
		return [this.__list__[i], this.__values__[i]];
	}),
	_unBind: d(function () {
		this.__values__ = null;
		unBind.call(this);
	}),
	toString: d(function () { return '[object Map Iterator]'; })
});
Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
	d('c', 'Map Iterator'));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear          = __webpack_require__(43)
  , eIndexOf       = __webpack_require__(90)
  , setPrototypeOf = __webpack_require__(19)
  , callable       = __webpack_require__(11)
  , validValue     = __webpack_require__(7)
  , d              = __webpack_require__(10)
  , ee             = __webpack_require__(126)
  , Symbol         = __webpack_require__(16)
  , iterator       = __webpack_require__(47)
  , forOf          = __webpack_require__(113)
  , Iterator       = __webpack_require__(120)
  , isNative       = __webpack_require__(118)

  , call = Function.prototype.call
  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf
  , MapPoly;

module.exports = MapPoly = function (/*iterable*/) {
	var iterable = arguments[0], keys, values, self;
	if (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (Map !== MapPoly)) {
		self = setPrototypeOf(new Map(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) iterator(iterable);
	defineProperties(self, {
		__mapKeysData__: d('c', keys = []),
		__mapValuesData__: d('c', values = [])
	});
	if (!iterable) return self;
	forOf(iterable, function (value) {
		var key = validValue(value)[0];
		value = value[1];
		if (eIndexOf.call(keys, key) !== -1) return;
		keys.push(key);
		values.push(value);
	}, self);
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
	MapPoly.prototype = Object.create(Map.prototype, {
		constructor: d(MapPoly)
	});
}

ee(defineProperties(MapPoly.prototype, {
	clear: d(function () {
		if (!this.__mapKeysData__.length) return;
		clear.call(this.__mapKeysData__);
		clear.call(this.__mapValuesData__);
		this.emit('_clear');
	}),
	delete: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return false;
		this.__mapKeysData__.splice(index, 1);
		this.__mapValuesData__.splice(index, 1);
		this.emit('_delete', index, key);
		return true;
	}),
	entries: d(function () { return new Iterator(this, 'key+value'); }),
	forEach: d(function (cb/*, thisArg*/) {
		var thisArg = arguments[1], iterator, result;
		callable(cb);
		iterator = this.entries();
		result = iterator._next();
		while (result !== undefined) {
			call.call(cb, thisArg, this.__mapValuesData__[result],
				this.__mapKeysData__[result], this);
			result = iterator._next();
		}
	}),
	get: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return;
		return this.__mapValuesData__[index];
	}),
	has: d(function (key) {
		return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
	}),
	keys: d(function () { return new Iterator(this, 'key'); }),
	set: d(function (key, value) {
		var index = eIndexOf.call(this.__mapKeysData__, key), emit;
		if (index === -1) {
			index = this.__mapKeysData__.push(key) - 1;
			emit = true;
		}
		this.__mapValuesData__[index] = value;
		if (emit) this.emit('_add', index, key);
		return this;
	}),
	size: d.gs(function () { return this.__mapKeysData__.length; }),
	values: d(function () { return new Iterator(this, 'value'); }),
	toString: d(function () { return '[object Map]'; })
}));
Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
	return this.entries();
}));
Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var validTypes = { object: true, symbol: true };

module.exports = function () {
	var symbol;
	if (typeof Symbol !== 'function') return false;
	symbol = Symbol('test symbol');
	try { String(symbol); } catch (e) { return false; }

	// Return 'true' also for polyfills
	if (!validTypes[typeof Symbol.iterator]) return false;
	if (!validTypes[typeof Symbol.toPrimitive]) return false;
	if (!validTypes[typeof Symbol.toStringTag]) return false;

	return true;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (x) {
	if (!x) return false;
	if (typeof x === 'symbol') return true;
	if (!x.constructor) return false;
	if (x.constructor.name !== 'Symbol') return false;
	return (x[x.constructor.toStringTag] === 'Symbol');
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ES2015 Symbol polyfill for environments that do not support it (or partially support it)



var d              = __webpack_require__(10)
  , validateSymbol = __webpack_require__(125)

  , create = Object.create, defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
  , isNativeSafe;

if (typeof Symbol === 'function') {
	NativeSymbol = Symbol;
	try {
		String(NativeSymbol());
		isNativeSafe = true;
	} catch (ignore) {}
}

var generateName = (function () {
	var created = create(null);
	return function (desc) {
		var postfix = 0, name, ie11BugWorkaround;
		while (created[desc + (postfix || '')]) ++postfix;
		desc += (postfix || '');
		created[desc] = true;
		name = '@@' + desc;
		defineProperty(objPrototype, name, d.gs(null, function (value) {
			// For IE11 issue see:
			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
			//    ie11-broken-getters-on-dom-objects
			// https://github.com/medikoo/es6-symbol/issues/12
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		}));
		return name;
	};
}());

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
	return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
	if (isNativeSafe) return NativeSymbol(description);
	symbol = create(HiddenSymbol.prototype);
	description = (description === undefined ? '' : String(description));
	return defineProperties(symbol, {
		__description__: d('', description),
		__name__: d('', generateName(description))
	});
};
defineProperties(SymbolPolyfill, {
	for: d(function (key) {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
	keyFor: d(function (s) {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

	// If there's native implementation of given symbol, let's fallback to it
	// to ensure proper interoperability with other native functions e.g. Array.from
	hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
	isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
		SymbolPolyfill('isConcatSpreadable')),
	iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
	match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
	replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
	search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
	species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
	split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
	toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
	toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
	unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
});

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d('', function () { return this.__name__; })
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
	var symbol = validateSymbol(this);
	if (typeof symbol === 'symbol') return symbol;
	return symbol.toString();
}));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(123);

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d        = __webpack_require__(10)
  , callable = __webpack_require__(11)

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {
  var currentTurn = 0,
      isDone = false;
  var isSync = false,
      hasNext = false,
      doneArgs = void 0;

  var done = function done() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    isDone = true;

    if (isSync) {
      // Iterate instead of recursing if possible.
      doneArgs = args;
      return;
    }

    callback.apply(undefined, args);
  };

  var next = function next() {
    if (isDone) return;

    hasNext = true;

    if (isSync) return; // Iterate instead of recursing if possible.

    isSync = true;

    while (!isDone && currentTurn < turns && hasNext) {
      hasNext = false;
      work(currentTurn++, next, done);
    }

    isSync = false;

    if (isDone) {
      // This means the loop finished synchronously.
      callback.apply(undefined, _toConsumableArray(doneArgs));
      return;
    }

    if (currentTurn >= turns && hasNext) {
      isDone = true;
      callback();
    }
  };

  next();
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = __webpack_require__(29);

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _LocationUtils = __webpack_require__(12);

var _DOMUtils = __webpack_require__(17);

var _DOMStateStorage = __webpack_require__(49);

var _PathUtils = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.substring(index + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var i = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
};

var ensureSlash = function ensureSlash() {
  var path = getHashPath();

  if ((0, _PathUtils.isAbsolutePath)(path)) return true;

  replaceHashPath('/' + path);

  return false;
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation(queryKey) {
  var path = getHashPath();
  var key = (0, _PathUtils.getQueryStringValueFromPath)(path, queryKey);

  var state = void 0;
  if (key) {
    path = (0, _PathUtils.stripQueryStringValueFromPath)(path, queryKey);
    state = (0, _DOMStateStorage.readState)(key);
  }

  var init = (0, _PathUtils.parsePath)(path);
  init.state = state;

  return (0, _LocationUtils.createLocation)(init, undefined, key);
};

var prevLocation = void 0;

var startListener = exports.startListener = function startListener(listener, queryKey) {
  var handleHashChange = function handleHashChange() {
    if (!ensureSlash()) return; // Hash path must always begin with a /

    var currentLocation = getCurrentLocation(queryKey);

    if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key) return; // Ignore extraneous hashchange events

    prevLocation = currentLocation;

    listener(currentLocation);
  };

  ensureSlash();
  (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
  };
};

var updateLocation = function updateLocation(location, queryKey, updateHash) {
  var state = location.state;
  var key = location.key;

  var path = (0, _PathUtils.createPath)(location);

  if (state !== undefined) {
    path = (0, _PathUtils.addQueryStringValueToPath)(path, queryKey, key);
    (0, _DOMStateStorage.saveState)(key, state);
  }

  prevLocation = location;

  updateHash(path);
};

var pushLocation = exports.pushLocation = function pushLocation(location, queryKey) {
  return updateLocation(location, queryKey, function (path) {
    if (getHashPath() !== path) {
      pushHashPath(path);
    } else {
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'You cannot PUSH the same path using hash history') : void 0;
    }
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location, queryKey) {
  return updateLocation(location, queryKey, function (path) {
    if (getHashPath() !== path) replaceHashPath(path);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceLocation = exports.pushLocation = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = __webpack_require__(29);

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(8);

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  return (0, _LocationUtils.createLocation)(window.location);
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  window.location.href = (0, _PathUtils.createPath)(location);
  return false; // Don't update location
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  window.location.replace((0, _PathUtils.createPath)(location));
  return false; // Don't update location
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = __webpack_require__(30);

var _BrowserProtocol = __webpack_require__(29);

var BrowserProtocol = _interopRequireWildcard(_BrowserProtocol);

var _RefreshProtocol = __webpack_require__(129);

var RefreshProtocol = _interopRequireWildcard(_RefreshProtocol);

var _DOMUtils = __webpack_require__(17);

var _createHistory = __webpack_require__(31);

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates and returns a history object that uses HTML5's history API
 * (pushState, replaceState, and the popstate event) to manage history.
 * This is the recommended method of managing history in browsers because
 * it provides the cleanest URLs.
 *
 * Note: In browsers that do not support the HTML5 history API full
 * page reloads will be used to preserve clean URLs. You can force this
 * behavior using { forceRefresh: true } in options.
 */
var createBrowserHistory = function createBrowserHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Browser history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var useRefresh = options.forceRefresh || !(0, _DOMUtils.supportsHistory)();
  var Protocol = useRefresh ? RefreshProtocol : BrowserProtocol;

  var getUserConfirmation = Protocol.getUserConfirmation;
  var getCurrentLocation = Protocol.getCurrentLocation;
  var pushLocation = Protocol.pushLocation;
  var replaceLocation = Protocol.replaceLocation;
  var go = Protocol.go;


  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = BrowserProtocol.startListener(history.transitionTo);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen
  });
};

exports.default = createBrowserHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = __webpack_require__(30);

var _DOMUtils = __webpack_require__(17);

var _HashProtocol = __webpack_require__(128);

var HashProtocol = _interopRequireWildcard(_HashProtocol);

var _createHistory = __webpack_require__(31);

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DefaultQueryKey = '_k';

var createHashHistory = function createHashHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Hash history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var queryKey = options.queryKey;


  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(queryKey !== false, 'Using { queryKey: false } no longer works. Instead, just don\'t ' + 'use location state if you don\'t want a key in your URL query string') : void 0;

  if (typeof queryKey !== 'string') queryKey = DefaultQueryKey;

  var getUserConfirmation = HashProtocol.getUserConfirmation;


  var getCurrentLocation = function getCurrentLocation() {
    return HashProtocol.getCurrentLocation(queryKey);
  };

  var pushLocation = function pushLocation(location) {
    return HashProtocol.pushLocation(location, queryKey);
  };

  var replaceLocation = function replaceLocation(location) {
    return HashProtocol.replaceLocation(location, queryKey);
  };

  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: HashProtocol.go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = HashProtocol.startListener(history.transitionTo, queryKey);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  var goIsSupportedWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var go = function go(n) {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;

    history.go(n);
  };

  var createHref = function createHref(path) {
    return '#' + history.createHref(path);
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen,
    go: go,
    createHref: createHref
  });
};

exports.default = createHashHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(8);

var _createHistory = __webpack_require__(31);

var _createHistory2 = _interopRequireDefault(_createHistory);

var _Actions = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createStateStorage = function createStateStorage(entries) {
  return entries.filter(function (entry) {
    return entry.state;
  }).reduce(function (memo, entry) {
    memo[entry.key] = entry.state;
    return memo;
  }, {});
};

var createMemoryHistory = function createMemoryHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  if (Array.isArray(options)) {
    options = { entries: options };
  } else if (typeof options === 'string') {
    options = { entries: [options] };
  }

  var getCurrentLocation = function getCurrentLocation() {
    var entry = entries[current];
    var path = (0, _PathUtils.createPath)(entry);

    var key = void 0,
        state = void 0;
    if (entry.key) {
      key = entry.key;
      state = readState(key);
    }

    var init = (0, _PathUtils.parsePath)(path);

    return (0, _LocationUtils.createLocation)(_extends({}, init, { state: state }), undefined, key);
  };

  var canGo = function canGo(n) {
    var index = current + n;
    return index >= 0 && index < entries.length;
  };

  var go = function go(n) {
    if (!n) return;

    if (!canGo(n)) {
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Cannot go(%s) there is not enough history', n) : void 0;

      return;
    }

    current += n;
    var currentLocation = getCurrentLocation();

    // Change action to POP
    history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
  };

  var pushLocation = function pushLocation(location) {
    current += 1;

    if (current < entries.length) entries.splice(current);

    entries.push(location);

    saveState(location.key, location.state);
  };

  var replaceLocation = function replaceLocation(location) {
    entries[current] = location;
    saveState(location.key, location.state);
  };

  var history = (0, _createHistory2.default)(_extends({}, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var _options = options;
  var entries = _options.entries;
  var current = _options.current;


  if (typeof entries === 'string') {
    entries = [entries];
  } else if (!Array.isArray(entries)) {
    entries = ['/'];
  }

  entries = entries.map(function (entry) {
    return (0, _LocationUtils.createLocation)(entry);
  });

  if (current == null) {
    current = entries.length - 1;
  } else {
    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : (0, _invariant2.default)(false) : void 0;
  }

  var storage = createStateStorage(entries);

  var saveState = function saveState(key, state) {
    return storage[key] = state;
  };

  var readState = function readState(key) {
    return storage[key];
  };

  return history;
};

exports.default = createMemoryHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.Actions = exports.useQueries = exports.useBeforeUnload = exports.useBasename = exports.createMemoryHistory = exports.createHashHistory = exports.createHistory = undefined;

var _LocationUtils = __webpack_require__(12);

Object.defineProperty(exports, 'locationsAreEqual', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.locationsAreEqual;
  }
});

var _createBrowserHistory = __webpack_require__(130);

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _createHashHistory2 = __webpack_require__(131);

var _createHashHistory3 = _interopRequireDefault(_createHashHistory2);

var _createMemoryHistory2 = __webpack_require__(132);

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

var _useBasename2 = __webpack_require__(134);

var _useBasename3 = _interopRequireDefault(_useBasename2);

var _useBeforeUnload2 = __webpack_require__(135);

var _useBeforeUnload3 = _interopRequireDefault(_useBeforeUnload2);

var _useQueries2 = __webpack_require__(136);

var _useQueries3 = _interopRequireDefault(_useQueries2);

var _Actions2 = __webpack_require__(20);

var _Actions3 = _interopRequireDefault(_Actions2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.createHistory = _createBrowserHistory2.default;
exports.createHashHistory = _createHashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;
exports.useBasename = _useBasename3.default;
exports.useBeforeUnload = _useBeforeUnload3.default;
exports.useQueries = _useQueries3.default;
exports.Actions = _Actions3.default;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _runTransitionHook = __webpack_require__(32);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _PathUtils = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var useBasename = function useBasename(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var basename = options.basename;


    var addBasename = function addBasename(location) {
      if (!location) return location;

      if (basename && location.basename == null) {
        if (location.pathname.indexOf(basename) === 0) {
          location.pathname = location.pathname.substring(basename.length);
          location.basename = basename;

          if (location.pathname === '') location.pathname = '/';
        } else {
          location.basename = '';
        }
      }

      return location;
    };

    var prependBasename = function prependBasename(location) {
      if (!basename) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var pname = object.pathname;
      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
      var pathname = normalizedBasename + normalizedPathname;

      return _extends({}, location, {
        pathname: pathname
      });
    };

    // Override all read methods with basename-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return addBasename(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, addBasename(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(addBasename(location));
      });
    };

    // Override all write methods with basename-aware versions.
    var push = function push(location) {
      return history.push(prependBasename(location));
    };

    var replace = function replace(location) {
      return history.replace(prependBasename(location));
    };

    var createPath = function createPath(location) {
      return history.createPath(prependBasename(location));
    };

    var createHref = function createHref(location) {
      return history.createHref(prependBasename(location));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useBasename;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _DOMUtils = __webpack_require__(17);

var _ExecutionEnvironment = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var startListener = function startListener(getPromptMessage) {
  var handleBeforeUnload = function handleBeforeUnload(event) {
    var message = getPromptMessage();

    if (typeof message === 'string') {
      (event || window.event).returnValue = message;
      return message;
    }

    return undefined;
  };

  (0, _DOMUtils.addEventListener)(window, 'beforeunload', handleBeforeUnload);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, 'beforeunload', handleBeforeUnload);
  };
};

/**
 * Returns a new createHistory function that can be used to create
 * history objects that know how to use the beforeunload event in web
 * browsers to cancel navigation.
 */
var useBeforeUnload = function useBeforeUnload(createHistory) {
  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'useBeforeUnload only works in DOM environments') : (0, _invariant2.default)(false) : void 0;

  return function (options) {
    var history = createHistory(options);

    var listeners = [];
    var stopListener = void 0;

    var getPromptMessage = function getPromptMessage() {
      var message = void 0;
      for (var i = 0, len = listeners.length; message == null && i < len; ++i) {
        message = listeners[i].call();
      }return message;
    };

    var listenBeforeUnload = function listenBeforeUnload(listener) {
      if (listeners.push(listener) === 1) stopListener = startListener(getPromptMessage);

      return function () {
        listeners = listeners.filter(function (item) {
          return item !== listener;
        });

        if (listeners.length === 0 && stopListener) {
          stopListener();
          stopListener = null;
        }
      };
    };

    return _extends({}, history, {
      listenBeforeUnload: listenBeforeUnload
    });
  };
};

exports.default = useBeforeUnload;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _queryString = __webpack_require__(150);

var _runTransitionHook = __webpack_require__(32);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultStringifyQuery = function defaultStringifyQuery(query) {
  return (0, _queryString.stringify)(query).replace(/%20/g, '+');
};

var defaultParseQueryString = _queryString.parse;

/**
 * Returns a new createHistory function that may be used to create
 * history objects that know how to handle URL queries.
 */
var useQueries = function useQueries(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var stringifyQuery = options.stringifyQuery;
    var parseQueryString = options.parseQueryString;


    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;

    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;

    var decodeQuery = function decodeQuery(location) {
      if (!location) return location;

      if (location.query == null) location.query = parseQueryString(location.search.substring(1));

      return location;
    };

    var encodeQuery = function encodeQuery(location, query) {
      if (query == null) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var queryString = stringifyQuery(query);
      var search = queryString ? '?' + queryString : '';

      return _extends({}, object, {
        search: search
      });
    };

    // Override all read methods with query-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return decodeQuery(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, decodeQuery(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(decodeQuery(location));
      });
    };

    // Override all write methods with query-aware versions.
    var push = function push(location) {
      return history.push(encodeQuery(location, location.query));
    };

    var replace = function replace(location) {
      return history.replace(encodeQuery(location, location.query));
    };

    var createPath = function createPath(location) {
      return history.createPath(encodeQuery(location, location.query));
    };

    var createHref = function createHref(location) {
      return history.createHref(encodeQuery(location, location.query));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var newLocation = history.createLocation.apply(history, [encodeQuery(location, location.query)].concat(args));

      if (location.query) newLocation.query = (0, _LocationUtils.createQuery)(location.query);

      return decodeQuery(newLocation);
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useQueries;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArguments = __webpack_require__(53),
    isArray = __webpack_require__(54);

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.flatten` with added support for restricting
 * flattening and specifying the start index.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, isDeep, isStrict, result) {
  result || (result = []);

  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index];
    if (isObjectLike(value) && isArrayLike(value) &&
        (isStrict || isArray(value) || isArguments(value))) {
      if (isDeep) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, isDeep, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = baseFlatten;


/***/ }),
/* 138 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * Creates a base function for methods like `_.forIn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = baseFor;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.indexOf` without support for binary searches.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 * If `fromRight` is provided elements of `array` are iterated from right to left.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 0 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseIndexOf = __webpack_require__(139),
    cacheIndexOf = __webpack_require__(142),
    createCache = __webpack_require__(143);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniq` without support for callback shorthands
 * and `this` binding.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The function invoked per iteration.
 * @returns {Array} Returns the new duplicate-value-free array.
 */
function baseUniq(array, iteratee) {
  var index = -1,
      indexOf = baseIndexOf,
      length = array.length,
      isCommon = true,
      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
      seen = isLarge ? createCache() : null,
      result = [];

  if (seen) {
    indexOf = cacheIndexOf;
    isCommon = false;
  } else {
    isLarge = false;
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

    if (isCommon && value === value) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (indexOf(seen, computed, 0) < 0) {
      if (iteratee || isLarge) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;


/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is in `cache` mimicking the return signature of
 * `_.indexOf` by returning `0` if the value is found, else `-1`.
 *
 * @private
 * @param {Object} cache The cache to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns `0` if `value` is found, else `-1`.
 */
function cacheIndexOf(cache, value) {
  var data = cache.data,
      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

  return result ? 0 : -1;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = cacheIndexOf;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = __webpack_require__(50);

/** Native method references. */
var Set = getNative(global, 'Set');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeCreate = getNative(Object, 'create');

/**
 *
 * Creates a cache object to store unique values.
 *
 * @private
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var length = values ? values.length : 0;

  this.data = { 'hash': nativeCreate(null), 'set': new Set };
  while (length--) {
    this.push(values[length]);
  }
}

/**
 * Adds `value` to the cache.
 *
 * @private
 * @name push
 * @memberOf SetCache
 * @param {*} value The value to cache.
 */
function cachePush(value) {
  var data = this.data;
  if (typeof value == 'string' || isObject(value)) {
    data.set.add(value);
  } else {
    data.hash[value] = true;
  }
}

/**
 * Creates a `Set` cache object to optimize linear searches of large arrays.
 *
 * @private
 * @param {Array} [values] The values to cache.
 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
 */
function createCache(values) {
  return (nativeCreate && Set) ? new SetCache(values) : null;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

// Add functions to the `Set` cache.
SetCache.prototype.push = cachePush;

module.exports = createCache;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)))

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match latin-1 supplementary letters (excluding mathematical operators). */
var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0';

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to map latin-1 supplementary letters to basic latin letters. */
var deburredLetters = {
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss'
};

/**
 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
function deburrLetter(letter) {
  return deburredLetters[letter];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var deburr = __webpack_require__(144),
    words = __webpack_require__(149);

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string)), callback, '');
  };
}

/**
 * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__foo_bar__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

module.exports = kebabCase;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = __webpack_require__(50),
    isArguments = __webpack_require__(53),
    isArray = __webpack_require__(54);

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFlatten = __webpack_require__(137),
    baseUniq = __webpack_require__(140),
    restParam = __webpack_require__(147);

/**
 * Creates an array of unique values, in order, of the provided arrays using
 * `SameValueZero` for equality comparisons.
 *
 * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 * comparisons are like strict equality comparisons, e.g. `===`, except that
 * `NaN` matches `NaN`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([1, 2], [4, 2], [2, 1]);
 * // => [1, 2, 4]
 */
var union = restParam(function(arrays) {
  return baseUniq(baseFlatten(arrays, false, true));
});

module.exports = union;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(33);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match non-compound words composed of alphanumeric characters. */
var reBasicWord = /[a-zA-Z0-9]+/g;

/** Used to match complex or compound words. */
var reComplexWord = RegExp([
  rsUpper + '?' + rsLower + '+(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+',
  rsUpper + '+',
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasComplexWord = /[a-z][A-Z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strictUriEncode = __webpack_require__(168);
var objectAssign = __webpack_require__(55);

function encoderForArrayFormat(opts) {
	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, index) {
				return value === null ? [
					encode(key, opts),
					'[',
					index,
					']'
				].join('') : [
					encode(key, opts),
					'[',
					encode(index, opts),
					']=',
					encode(value, opts)
				].join('');
			};

		case 'bracket':
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'[]=',
					encode(value, opts)
				].join('');
			};

		default:
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'=',
					encode(value, opts)
				].join('');
			};
	}
}

function parserForArrayFormat(opts) {
	var result;

	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, accumulator) {
				result = /\[(\d*)]$/.exec(key);

				key = key.replace(/\[\d*]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return function (key, value, accumulator) {
				result = /(\[])$/.exec(key);

				key = key.replace(/\[]$/, '');

				if (!result || accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		default:
			return function (key, value, accumulator) {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function encode(value, opts) {
	if (opts.encode) {
		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	} else if (typeof input === 'object') {
		return keysSorter(Object.keys(input)).sort(function (a, b) {
			return Number(a) - Number(b);
		}).map(function (key) {
			return input[key];
		});
	}

	return input;
}

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str, opts) {
	opts = objectAssign({arrayFormat: 'none'}, opts);

	var formatter = parserForArrayFormat(opts);

	// Create an object with no prototype
	// https://github.com/sindresorhus/query-string/issues/47
	var ret = Object.create(null);

	if (typeof str !== 'string') {
		return ret;
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return ret;
	}

	str.split('&').forEach(function (param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		formatter(decodeURIComponent(key), val, ret);
	});

	return Object.keys(ret).sort().reduce(function (result, key) {
		var val = ret[key];
		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
			// Sort object keys, not values
			result[key] = keysSorter(val);
		} else {
			result[key] = val;
		}

		return result;
	}, Object.create(null));
};

exports.stringify = function (obj, opts) {
	var defaults = {
		encode: true,
		strict: true,
		arrayFormat: 'none'
	};

	opts = objectAssign(defaults, opts);

	var formatter = encoderForArrayFormat(opts);

	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return encode(key, opts);
		}

		if (Array.isArray(val)) {
			var result = [];

			val.slice().forEach(function (val2) {
				if (val2 === undefined) {
					return;
				}

				result.push(formatter(key, val2, result.length));
			});

			return result.join('&');
		}

		return encode(key, opts) + '=' + encode(val, opts);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = classNameFromVNode;

var _selectorParser2 = __webpack_require__(56);

var _selectorParser3 = _interopRequireDefault(_selectorParser2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function classNameFromVNode(vNode) {
  var _selectorParser = (0, _selectorParser3.default)(vNode.sel);

  var cn = _selectorParser.className;


  if (!vNode.data) {
    return cn;
  }

  var _vNode$data = vNode.data;
  var dataClass = _vNode$data.class;
  var props = _vNode$data.props;


  if (dataClass) {
    var c = Object.keys(vNode.data.class).filter(function (cl) {
      return vNode.data.class[cl];
    });
    cn += ' ' + c.join(' ');
  }

  if (props && props.className) {
    cn += ' ' + props.className;
  }

  return cn.trim();
}

/***/ }),
/* 152 */
/***/ (function(module, exports) {


// All SVG children elements, not in this list, should self-close

module.exports = {
  // http://www.w3.org/TR/SVG/intro.html#TermContainerElement
  'a': true,
  'defs': true,
  'glyph': true,
  'g': true,
  'marker': true,
  'mask': true,
  'missing-glyph': true,
  'pattern': true,
  'svg': true,
  'switch': true,
  'symbol': true,

  // http://www.w3.org/TR/SVG/intro.html#TermDescriptiveElement
  'desc': true,
  'metadata': true,
  'title': true
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {


var init = __webpack_require__(154);

module.exports = init([__webpack_require__(155), __webpack_require__(156)]);

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {


var parseSelector = __webpack_require__(57);
var VOID_ELEMENTS = __webpack_require__(157);
var CONTAINER_ELEMENTS = __webpack_require__(152);

module.exports = function init(modules) {
  function parse(data) {
    return modules.reduce(function (arr, fn) {
      arr.push(fn(data));
      return arr;
    }, []).filter(function (result) {
      return result !== '';
    });
  }

  return function renderToString(vnode) {
    if (!vnode.sel && vnode.text) {
      return vnode.text;
    }

    vnode.data = vnode.data || {};

    // Support thunks
    if (typeof vnode.sel === 'string' && vnode.sel.slice(0, 5) === 'thunk') {
      vnode = vnode.data.fn.apply(null, vnode.data.args);
    }

    var tagName = parseSelector(vnode.sel).tagName;
    var attributes = parse(vnode);
    var svg = vnode.data.ns === 'http://www.w3.org/2000/svg';
    var tag = [];

    // Open tag
    tag.push('<' + tagName);
    if (attributes.length) {
      tag.push(' ' + attributes.join(' '));
    }
    if (svg && CONTAINER_ELEMENTS[tagName] !== true) {
      tag.push(' /');
    }
    tag.push('>');

    // Close tag, if needed
    if (VOID_ELEMENTS[tagName] !== true && !svg || svg && CONTAINER_ELEMENTS[tagName] === true) {
      if (vnode.data.props && vnode.data.props.innerHTML) {
        tag.push(vnode.data.props.innerHTML);
      } else if (vnode.text) {
        tag.push(vnode.text);
      } else if (vnode.children) {
        vnode.children.forEach(function (child) {
          tag.push(renderToString(child));
        });
      }
      tag.push('</' + tagName + '>');
    }

    return tag.join('');
  };
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {


var forOwn = __webpack_require__(52);
var escape = __webpack_require__(51);
var union = __webpack_require__(148);

var parseSelector = __webpack_require__(57);

// data.attrs, data.props, data.class

module.exports = function attributes(vnode) {
  var selector = parseSelector(vnode.sel);
  var parsedClasses = selector.className.split(' ');

  var attributes = [];
  var classes = [];
  var values = {};

  if (selector.id) {
    values.id = selector.id;
  }

  setAttributes(vnode.data.props, values);
  setAttributes(vnode.data.attrs, values); // `attrs` override `props`, not sure if this is good so

  if (vnode.data.class) {
    // Omit `className` attribute if `class` is set on vnode
    values.class = undefined;
  }
  forOwn(vnode.data.class, function (value, key) {
    if (value === true) {
      classes.push(key);
    }
  });
  classes = union(classes, values.class, parsedClasses).filter(function (x) {
    return x !== '';
  });

  if (classes.length) {
    values.class = classes.join(' ');
  }

  forOwn(values, function (value, key) {
    attributes.push(value === true ? key : key + '="' + escape(value) + '"');
  });

  return attributes.length ? attributes.join(' ') : '';
};

function setAttributes(values, target) {
  forOwn(values, function (value, key) {
    if (key === 'htmlFor') {
      target['for'] = value;
      return;
    }
    if (key === 'className') {
      target['class'] = value.split(' ');
      return;
    }
    if (key === 'innerHTML') {
      return;
    }
    target[key] = value;
  });
}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var forOwn = __webpack_require__(52);
var escape = __webpack_require__(51);
var kebabCase = __webpack_require__(145);

// data.style

module.exports = function style(vnode) {
  var styles = [];
  var style = vnode.data.style || {};

  // merge in `delayed` properties
  if (style.delayed) {
    _extends(style, style.delayed);
  }

  forOwn(style, function (value, key) {
    // omit hook objects
    if (typeof value === 'string') {
      styles.push(kebabCase(key) + ': ' + escape(value));
    }
  });

  return styles.length ? 'style="' + styles.join('; ') + '"' : '';
};

/***/ }),
/* 157 */
/***/ (function(module, exports) {


// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements

module.exports = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var VNode = __webpack_require__(35);
var is = __webpack_require__(21);

function addNS(data, children) {
  data.ns = 'http://www.w3.org/2000/svg';
  if (children !== undefined) {
    for (var i = 0; i < children.length; ++i) {
      addNS(children[i].data, children[i].children);
    }
  }
}

module.exports = function h(sel, b, c) {
  var data = {}, children, text, i;
  if (c !== undefined) {
    data = b;
    if (is.array(c)) { children = c; }
    else if (is.primitive(c)) { text = c; }
  } else if (b !== undefined) {
    if (is.array(b)) { children = b; }
    else if (is.primitive(b)) { text = b; }
    else { data = b; }
  }
  if (is.array(children)) {
    for (i = 0; i < children.length; ++i) {
      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
    }
  }
  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
    addNS(data, children);
  }
  return VNode(sel, data, children, text, undefined);
};


/***/ }),
/* 159 */
/***/ (function(module, exports) {

function createElement(tagName){
  return document.createElement(tagName);
}

function createElementNS(namespaceURI, qualifiedName){
  return document.createElementNS(namespaceURI, qualifiedName);
}

function createTextNode(text){
  return document.createTextNode(text);
}


function insertBefore(parentNode, newNode, referenceNode){
  parentNode.insertBefore(newNode, referenceNode);
}


function removeChild(node, child){
  node.removeChild(child);
}

function appendChild(node, child){
  node.appendChild(child);
}

function parentNode(node){
  return node.parentElement;
}

function nextSibling(node){
  return node.nextSibling;
}

function tagName(node){
  return node.tagName;
}

function setTextContent(node, text){
  node.textContent = text;
}

module.exports = {
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  appendChild: appendChild,
  removeChild: removeChild,
  insertBefore: insertBefore,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent
};


/***/ }),
/* 160 */
/***/ (function(module, exports) {

var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", 
                "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", 
                "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", 
                "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", 
                "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", 
                "truespeed", "typemustmatch", "visible"];
    
var booleanAttrsDict = {};
for(var i=0, len = booleanAttrs.length; i < len; i++) {
  booleanAttrsDict[booleanAttrs[i]] = true;
}
    
function updateAttrs(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
  
  // update modified attributes, add new attributes
  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      // TODO: add support to namespaced attributes (setAttributeNS)
      if(!cur && booleanAttrsDict[key])
        elm.removeAttribute(key);
      else
        elm.setAttribute(key, cur);
    }
  }
  //remove removed attributes
  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
  // the other option is to remove all attributes with value == undefined
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}

module.exports = {create: updateAttrs, update: updateAttrs};


/***/ }),
/* 161 */
/***/ (function(module, exports) {

function updateClass(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldClass = oldVnode.data.class || {},
      klass = vnode.data.class || {};
  for (name in oldClass) {
    if (!klass[name]) {
      elm.classList.remove(name);
    }
  }
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      elm.classList[cur ? 'add' : 'remove'](name);
    }
  }
}

module.exports = {create: updateClass, update: updateClass};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var is = __webpack_require__(21);

function arrInvoker(arr) {
  return function() {
    if (!arr.length) return;
    // Special case when length is two, for performance
    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));
  };
}

function fnInvoker(o) {
  return function(ev) { 
    if (o.fn === null) return;
    o.fn(ev); 
  };
}

function updateEventListeners(oldVnode, vnode) {
  var name, cur, old, elm = vnode.elm,
      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
  if (!on) return;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    if (old === undefined) {
      if (is.array(cur)) {
        elm.addEventListener(name, arrInvoker(cur));
      } else {
        cur = {fn: cur};
        on[name] = cur;
        elm.addEventListener(name, fnInvoker(cur));
      }
    } else if (is.array(old)) {
      // Deliberately modify old array since it's captured in closure created with `arrInvoker`
      old.length = cur.length;
      for (var i = 0; i < old.length; ++i) old[i] = cur[i];
      on[name]  = old;
    } else {
      old.fn = cur;
      on[name] = old;
    }
  }
  if (oldOn) {
    for (name in oldOn) {
      if (on[name] === undefined) {
        var old = oldOn[name];
        if (is.array(old)) {
          old.length = 0;
        }
        else {
          old.fn = null;
        }
      }
    }
  }
}

module.exports = {create: updateEventListeners, update: updateEventListeners};


/***/ }),
/* 163 */
/***/ (function(module, exports) {

var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function getTextNodeRect(textNode) {
  var rect;
  if (document.createRange) {
    var range = document.createRange();
    range.selectNodeContents(textNode);
    if (range.getBoundingClientRect) {
        rect = range.getBoundingClientRect();
    }
  }
  return rect;
}

function calcTransformOrigin(isTextNode, textRect, boundingRect) {
  if (isTextNode) {
    if (textRect) {
      //calculate pixels to center of text from left edge of bounding box
      var relativeCenterX = textRect.left + textRect.width/2 - boundingRect.left;
      var relativeCenterY = textRect.top + textRect.height/2 - boundingRect.top;
      return relativeCenterX + 'px ' + relativeCenterY + 'px';
    }
  }
  return '0 0'; //top left
}

function getTextDx(oldTextRect, newTextRect) {
  if (oldTextRect && newTextRect) {
    return ((oldTextRect.left + oldTextRect.width/2) - (newTextRect.left + newTextRect.width/2));
  }
  return 0;
}
function getTextDy(oldTextRect, newTextRect) {
  if (oldTextRect && newTextRect) {
    return ((oldTextRect.top + oldTextRect.height/2) - (newTextRect.top + newTextRect.height/2));
  }
  return 0;
}

function isTextElement(elm) {
  return elm.childNodes.length === 1 && elm.childNodes[0].nodeType === 3;
}

var removed, created;

function pre(oldVnode, vnode) {
  removed = {};
  created = [];
}

function create(oldVnode, vnode) {
  var hero = vnode.data.hero;
  if (hero && hero.id) {
    created.push(hero.id);
    created.push(vnode);
  }
}

function destroy(vnode) {
  var hero = vnode.data.hero;
  if (hero && hero.id) {
    var elm = vnode.elm;
    vnode.isTextNode = isTextElement(elm); //is this a text node?
    vnode.boundingRect = elm.getBoundingClientRect(); //save the bounding rectangle to a new property on the vnode
    vnode.textRect = vnode.isTextNode ? getTextNodeRect(elm.childNodes[0]) : null; //save bounding rect of inner text node
    var computedStyle = window.getComputedStyle(elm, null); //get current styles (includes inherited properties)
    vnode.savedStyle = JSON.parse(JSON.stringify(computedStyle)); //save a copy of computed style values
    removed[hero.id] = vnode;
  }
}

function post() {
  var i, id, newElm, oldVnode, oldElm, hRatio, wRatio,
      oldRect, newRect, dx, dy, origTransform, origTransition,
      newStyle, oldStyle, newComputedStyle, isTextNode,
      newTextRect, oldTextRect;
  for (i = 0; i < created.length; i += 2) {
    id = created[i];
    newElm = created[i+1].elm;
    oldVnode = removed[id];
    if (oldVnode) {
      isTextNode = oldVnode.isTextNode && isTextElement(newElm); //Are old & new both text?
      newStyle = newElm.style;
      newComputedStyle = window.getComputedStyle(newElm, null); //get full computed style for new element
      oldElm = oldVnode.elm;
      oldStyle = oldElm.style;
      //Overall element bounding boxes
      newRect = newElm.getBoundingClientRect();
      oldRect = oldVnode.boundingRect; //previously saved bounding rect
      //Text node bounding boxes & distances
      if (isTextNode) {
        newTextRect = getTextNodeRect(newElm.childNodes[0]);
        oldTextRect = oldVnode.textRect;
        dx = getTextDx(oldTextRect, newTextRect);
        dy = getTextDy(oldTextRect, newTextRect);
      } else {
        //Calculate distances between old & new positions
        dx = oldRect.left - newRect.left;
        dy = oldRect.top - newRect.top;
      }
      hRatio = newRect.height / (Math.max(oldRect.height, 1));
      wRatio = isTextNode ? hRatio : newRect.width / (Math.max(oldRect.width, 1)); //text scales based on hRatio
      // Animate new element
      origTransform = newStyle.transform;
      origTransition = newStyle.transition;
      if (newComputedStyle.display === 'inline') //inline elements cannot be transformed
        newStyle.display = 'inline-block';        //this does not appear to have any negative side effects
      newStyle.transition = origTransition + 'transform 0s';
      newStyle.transformOrigin = calcTransformOrigin(isTextNode, newTextRect, newRect);
      newStyle.opacity = '0';
      newStyle.transform = origTransform + 'translate('+dx+'px, '+dy+'px) ' +
                               'scale('+1/wRatio+', '+1/hRatio+')';
      setNextFrame(newStyle, 'transition', origTransition);
      setNextFrame(newStyle, 'transform', origTransform);
      setNextFrame(newStyle, 'opacity', '1');
      // Animate old element
      for (var key in oldVnode.savedStyle) { //re-apply saved inherited properties
        if (parseInt(key) != key) {
          var ms = key.substring(0,2) === 'ms';
          var moz = key.substring(0,3) === 'moz';
          var webkit = key.substring(0,6) === 'webkit';
      	  if (!ms && !moz && !webkit) //ignore prefixed style properties
        	  oldStyle[key] = oldVnode.savedStyle[key];
        }
      }
      oldStyle.position = 'absolute';
      oldStyle.top = oldRect.top + 'px'; //start at existing position
      oldStyle.left = oldRect.left + 'px';
      oldStyle.width = oldRect.width + 'px'; //Needed for elements who were sized relative to their parents
      oldStyle.height = oldRect.height + 'px'; //Needed for elements who were sized relative to their parents
      oldStyle.margin = 0; //Margin on hero element leads to incorrect positioning
      oldStyle.transformOrigin = calcTransformOrigin(isTextNode, oldTextRect, oldRect);
      oldStyle.transform = '';
      oldStyle.opacity = '1';
      document.body.appendChild(oldElm);
      setNextFrame(oldStyle, 'transform', 'translate('+ -dx +'px, '+ -dy +'px) scale('+wRatio+', '+hRatio+')'); //scale must be on far right for translate to be correct
      setNextFrame(oldStyle, 'opacity', '0');
      oldElm.addEventListener('transitionend', function(ev) {
        if (ev.propertyName === 'transform')
          document.body.removeChild(ev.target);
      });
    }
  }
  removed = created = undefined;
}

module.exports = {pre: pre, create: create, destroy: destroy, post: post};


/***/ }),
/* 164 */
/***/ (function(module, exports) {

function updateProps(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
  for (key in oldProps) {
    if (!props[key]) {
      delete elm[key];
    }
  }
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}

module.exports = {create: updateProps, update: updateProps};


/***/ }),
/* 165 */
/***/ (function(module, exports) {

var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function updateStyle(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldStyle = oldVnode.data.style || {},
      style = vnode.data.style || {},
      oldHasDel = 'delayed' in oldStyle;
  for (name in oldStyle) {
    if (!style[name]) {
      elm.style[name] = '';
    }
  }
  for (name in style) {
    cur = style[name];
    if (name === 'delayed') {
      for (name in style.delayed) {
        cur = style.delayed[name];
        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
          setNextFrame(elm.style, name, cur);
        }
      }
    } else if (name !== 'remove' && cur !== oldStyle[name]) {
      elm.style[name] = cur;
    }
  }
}

function applyDestroyStyle(vnode) {
  var style, name, elm = vnode.elm, s = vnode.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}

function applyRemoveStyle(vnode, rm) {
  var s = vnode.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
      compStyle, style = s.remove, amount = 0, applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle['transition-property'].split(', ');
  for (; i < props.length; ++i) {
    if(applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener('transitionend', function(ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}

module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint newcap: false
/* global require, module, document, Node */


var VNode = __webpack_require__(35);
var is = __webpack_require__(21);
var domApi = __webpack_require__(159);

function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }

var emptyNode = VNode('', {}, [], undefined, undefined);

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, map = {}, key;
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) map[key] = i;
  }
  return map;
}

var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

function init(modules, api) {
  var i, j, cbs = {};

  if (isUndef(api)) api = domApi;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
    }
  }

  function emptyNodeAt(elm) {
    return VNode(api.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    return function() {
      if (--listeners === 0) {
        var parent = api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }

  function createElm(vnode, insertedVnodeQueue) {
    var i, data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode);
        data = vnode.data;
      }
    }
    var elm, children = vnode.children, sel = vnode.sel;
    if (isDef(sel)) {
      // Parse selector
      var hashIdx = sel.indexOf('#');
      var dotIdx = sel.indexOf('.', hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                                                          : api.createElement(tag);
      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          api.appendChild(elm, createElm(children[i], insertedVnodeQueue));
        }
      } else if (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (i.create) i.create(emptyNode, vnode);
        if (i.insert) insertedVnodeQueue.push(vnode);
      }
    } else {
      elm = vnode.elm = api.createTextNode(vnode.text);
    }
    return vnode.elm;
  }

  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j, data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i, listeners, rm, ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
            i(ch, rm);
          } else {
            rm();
          }
        } else { // Text node
          api.removeChild(parentElm, ch.elm);
        }
      }
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    var oldStartIdx = 0, newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, before;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) { // New element
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
          oldCh[idxInOld] = undefined;
          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
    var i, hook;
    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
    if (oldVnode === vnode) return;
    if (!sameVnode(oldVnode, vnode)) {
      var parentElm = api.parentNode(oldVnode.elm);
      elm = createElm(vnode, insertedVnodeQueue);
      api.insertBefore(parentElm, elm, oldVnode.elm);
      removeVnodes(parentElm, [oldVnode], 0, 0);
      return;
    }
    if (isDef(vnode.data)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
      i = vnode.data.hook;
      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, '');
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      api.setTextContent(elm, vnode.text);
    }
    if (isDef(hook) && isDef(i = hook.postpatch)) {
      i(oldVnode, vnode);
    }
  }

  return function(oldVnode, vnode) {
    var i, elm, parent;
    var insertedVnodeQueue = [];
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();

    if (isUndef(oldVnode.sel)) {
      oldVnode = emptyNodeAt(oldVnode);
    }

    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent = api.parentNode(elm);

      createElm(vnode, insertedVnodeQueue);

      if (parent !== null) {
        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }

    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
}

module.exports = {init: init};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var h = __webpack_require__(158);

function copyToThunk(vnode, thunk) {
  thunk.elm = vnode.elm;
  vnode.data.fn = thunk.data.fn;
  vnode.data.args = thunk.data.args;
  thunk.data = vnode.data;
  thunk.children = vnode.children;
  thunk.text = vnode.text;
  thunk.elm = vnode.elm;
}

function init(thunk) {
  var i, cur = thunk.data;
  var vnode = cur.fn.apply(undefined, cur.args);
  copyToThunk(vnode, thunk);
}

function prepatch(oldVnode, thunk) {
  var i, old = oldVnode.data, cur = thunk.data, vnode;
  var oldArgs = old.args, args = cur.args;
  if (old.fn !== cur.fn || oldArgs.length !== args.length) {
    copyToThunk(cur.fn.apply(undefined, args), thunk);
  }
  for (i = 0; i < args.length; ++i) {
    if (oldArgs[i] !== args[i]) {
      copyToThunk(cur.fn.apply(undefined, args), thunk);
      return;
    }
  }
  copyToThunk(oldVnode, thunk);
}

module.exports = function(sel, key, fn, args) {
  if (args === undefined) {
    args = fn;
    fn = key;
    key = undefined;
  }
  return h(sel, {
    key: key,
    hook: {init: init, prepatch: prepatch},
    fn: fn,
    args: args
  });
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(170);
/* harmony export (immutable) */ __webpack_exports__["default"] = switchPath;

function switchPathInputGuard(path, routes) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["a" /* isPattern */])(path)) {
        throw new Error("First parameter to switchPath must be a route path.");
    }
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(routes)) {
        throw new Error("Second parameter to switchPath must be an object " +
            "containing route patterns.");
    }
}
function validatePath(sourcePath, matchedPath) {
    var sourceParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(sourcePath);
    var matchedParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(matchedPath);
    for (var i = 0; i < matchedParts.length; ++i) {
        if (matchedParts[i] !== sourceParts[i]) {
            return null;
        }
    }
    return "/" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* extractPartial */])(sourcePath, matchedPath);
}
function betterMatch(candidate, reference) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */])(candidate)) {
        return false;
    }
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */])(reference)) {
        return true;
    }
    if (!validatePath(candidate, reference)) {
        return false;
    }
    return candidate.length >= reference.length;
}
function matchesWithParams(sourcePath, pattern) {
    var sourceParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(sourcePath);
    var patternParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(pattern);
    var params = patternParts
        .map(function (part, i) { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isParam */])(part) ? sourceParts[i] : null; })
        .filter(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */]);
    var matched = patternParts
        .every(function (part, i) { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isParam */])(part) || part === sourceParts[i]; });
    return matched ? params : [];
}
function getParamFnValue(paramFn, params) {
    var _paramFn = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(paramFn) ? paramFn["/"] : paramFn;
    return typeof _paramFn === "function" ? _paramFn.apply(void 0, params) : _paramFn;
}
function validate(_a) {
    var sourcePath = _a.sourcePath, matchedPath = _a.matchedPath, matchedValue = _a.matchedValue, routes = _a.routes;
    var path = matchedPath ? validatePath(sourcePath, matchedPath) : null;
    var value = matchedValue;
    if (!path) {
        path = routes["*"] ? sourcePath : null;
        value = path ? routes["*"] : null;
    }
    return { path: path, value: value };
}
function switchPath(sourcePath, routes) {
    switchPathInputGuard(sourcePath, routes);
    var matchedPath = null;
    var matchedValue = null;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["g" /* traverseRoutes */])(routes, function matchPattern(pattern) {
        if (sourcePath.search(pattern) === 0 && betterMatch(pattern, matchedPath)) {
            matchedPath = pattern;
            matchedValue = routes[pattern];
        }
        var params = matchesWithParams(sourcePath, pattern).filter(Boolean);
        if (params.length > 0 && betterMatch(sourcePath, matchedPath)) {
            matchedPath = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* extractPartial */])(sourcePath, pattern);
            matchedValue = getParamFnValue(routes[pattern], params);
        }
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(routes[pattern]) && params.length === 0) {
            if (sourcePath !== "/") {
                var child = switchPath(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["h" /* unprefixed */])(sourcePath, pattern) || "/", routes[pattern]);
                var nestedPath = pattern + child.path;
                if (child.path !== null &&
                    betterMatch(nestedPath, matchedPath)) {
                    matchedPath = nestedPath;
                    matchedValue = child.value;
                }
            }
        }
    });
    return validate({ sourcePath: sourcePath, matchedPath: matchedPath, matchedValue: matchedValue, routes: routes });
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isPattern;
/* harmony export (immutable) */ __webpack_exports__["b"] = isRouteDefinition;
/* harmony export (immutable) */ __webpack_exports__["g"] = traverseRoutes;
/* harmony export (immutable) */ __webpack_exports__["e"] = isNotNull;
/* harmony export (immutable) */ __webpack_exports__["c"] = splitPath;
/* harmony export (immutable) */ __webpack_exports__["f"] = isParam;
/* harmony export (immutable) */ __webpack_exports__["d"] = extractPartial;
/* harmony export (immutable) */ __webpack_exports__["h"] = unprefixed;
function isPattern(candidate) {
    return candidate.charAt(0) === "/" || candidate === "*";
}
function isRouteDefinition(candidate) {
    return !candidate || typeof candidate !== "object" ?
        false : isPattern(Object.keys(candidate)[0]);
}
function traverseRoutes(routes, callback) {
    var keys = Object.keys(routes);
    for (var i = 0; i < keys.length; ++i) {
        var pattern = keys[i];
        if (pattern === "*")
            continue;
        callback(pattern);
    }
}
function isNotNull(candidate) {
    return candidate !== null;
}
function splitPath(path) {
    return path.split("/").filter(function (s) { return !!s; });
}
function isParam(candidate) {
    return candidate.match(/:\w+/) !== null;
}
function extractPartial(sourcePath, pattern) {
    var patternParts = splitPath(pattern);
    var sourceParts = splitPath(sourcePath);
    var matchedParts = [];
    for (var i = 0; i < patternParts.length; ++i) {
        matchedParts.push(sourceParts[i]);
    }
    return matchedParts.filter(isNotNull).join("/");
}
function unprefixed(fullString, prefix) {
    return fullString.split(prefix)[1];
}
//# sourceMappingURL=util.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(172);


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(173);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37), __webpack_require__(60)(module)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(58);
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var Index;
(function (Index) {
    function run(sources) {
        var vTree$ = xstream_1.default.of(dom_1.div(".centered", [
            UI.Container.render([
                UI.Grid.render({ centered: true }, [
                    UI.Row.render([
                        UI.Header.render({ size: UI.Size.Huge }, "Welcome.", {
                            subtext: "At the moment the docs are a WIP. Planned pages are scaffolded in the sidemenu."
                        }),
                    ])
                ])
            ])
        ]));
        return {
            DOM: vTree$,
            router: xstream_1.default.never()
        };
    }
    Index.run = run;
})(Index = exports.Index || (exports.Index = {}));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable-next-line:no-unused-variable
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var sidebar_1 = __webpack_require__(176);
var Layout;
(function (Layout) {
    function run(sources, page) {
        /*** Create components ***/
        var sidebar = sidebar_1.Sidebar.run(sources);
        /*** Compose view ***/
        var vTree$ = xstream_1.default.combine(sidebar.DOM, page.DOM)
            .map(function (_a) {
            var sidebar = _a[0], page = _a[1];
            return dom_1.div(".full.height", [
                dom_1.div(".content.pusher", [
                    sidebar,
                    page
                ]),
            ]);
        });
        return {
            DOM: vTree$,
            router: page.router
        };
    }
    Layout.run = run;
})(Layout = exports.Layout || (exports.Layout = {}));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(58);
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var Sidebar;
(function (Sidebar) {
    function run(sources) {
        var currentPage$ = sources.router.history$.map(function (x) { return x.pathname; });
        var prefix = "/cycle-semantic-ui";
        var vTree$ = currentPage$.map(function (page) {
            return dom_1.div(".left.menu", [
                dom_1.div(".fixed", [
                    UI.Menu.render({
                        vertical: true, inverted: true,
                        attachment: UI.Attachment.None, size: UI.Size.Fluid
                    }, [{
                            header: true,
                            body: ["Introduction", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/", active: page === prefix + "/" || page === prefix + "/home",
                                        body: "About"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Elements", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/elements/button", active: page === prefix + "/elements/button",
                                        body: "Button"
                                    }, {
                                        link: true, href: prefix + "/elements/container", active: page === prefix + "/elements/container",
                                        body: "Container"
                                    }, {
                                        link: true, href: prefix + "/elements/divider", active: page === prefix + "/elements/divider",
                                        body: "Divider"
                                    }, {
                                        link: true, href: prefix + "/elements/header", active: page === prefix + "/elements/header",
                                        body: "Header"
                                    }, {
                                        link: true, href: prefix + "/elements/icon", active: page === prefix + "/elements/icon",
                                        body: "Icon"
                                    }, {
                                        link: true, href: prefix + "/elements/image", active: page === prefix + "/elements/image",
                                        body: "Image"
                                    }, {
                                        link: true, href: prefix + "/elements/label", active: page === prefix + "/elements/label",
                                        body: "Label"
                                    }, {
                                        link: true, href: prefix + "/elements/list", active: page === prefix + "/elements/list",
                                        body: "List"
                                    }, {
                                        link: true, href: prefix + "/elements/loader", active: page === prefix + "/elements/loader",
                                        body: "Loader"
                                    }, {
                                        link: true, href: prefix + "/elements/segment", active: page === prefix + "/elements/segment",
                                        body: "Segment"
                                    }, {
                                        link: true, href: prefix + "/elements/step", active: page === prefix + "/elements/step",
                                        body: "Step"
                                    }, {
                                        link: true, href: prefix + "/elements/textbox", active: page === prefix + "/elements/textbox",
                                        body: "Textbox"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Collections", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/collections/breadcrumb", active: page === prefix + "/collections/breadcrumb",
                                        body: "Breadcrumb"
                                    }, {
                                        link: true, href: prefix + "/collections/form", active: page === prefix + "/collections/form",
                                        body: "Form"
                                    }, {
                                        link: true, href: prefix + "/collections/grid", active: page === prefix + "/collections/grid",
                                        body: "Grid"
                                    }, {
                                        link: true, href: prefix + "/collections/menu", active: page === prefix + "/collections/menu",
                                        body: "Menu"
                                    }, {
                                        link: true, href: prefix + "/collections/message", active: page === prefix + "/collections/message",
                                        body: "Message"
                                    }, {
                                        link: true, href: prefix + "/collections/table", active: page === prefix + "/collections/table",
                                        body: "Table"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Modules", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/modules/checkbox", active: page === prefix + "/modules/checkbox",
                                        body: "Checkbox"
                                    }, {
                                        link: true, href: prefix + "/modules/dimmer", active: page === prefix + "/modules/dimmer",
                                        body: "Dimmer"
                                    }, {
                                        link: true, href: prefix + "/modules/dropdown", active: page === prefix + "/modules/dropdown",
                                        body: "Dropdown"
                                    }, {
                                        link: true, href: prefix + "/modules/modal", active: page === prefix + "/modules/modal",
                                        body: "Modal"
                                    }, {
                                        link: true, href: prefix + "/modules/popup", active: page === prefix + "/modules/popup",
                                        body: "Popup"
                                    }, {
                                        link: true, href: prefix + "/modules/progress", active: page === prefix + "/modules/progress",
                                        body: "Progress"
                                    }, {
                                        link: true, href: prefix + "/modules/transition", active: page === prefix + "/modules/transition",
                                        body: "Transition"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Views", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/views/statistic", active: page === prefix + "/views/statistic",
                                        body: "Statistic"
                                    }])]
                        }])
                ])
            ]);
        });
        return {
            DOM: vTree$,
            router: xstream_1.default.never()
        };
    }
    Sidebar.run = run;
})(Sidebar = exports.Sidebar || (exports.Sidebar = {}));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var xstream_1 = __webpack_require__(0);
var callPage = function (sources) {
    return function (_a) {
        var path = _a.path, value = _a.value;
        var pSources = Object.assign({}, sources, { router: sources.router.path(path) });
        var isolatedPage = isolate_1.default(value)(pSources);
        return isolatedPage;
    };
};
function propOrNever(key, x) {
    if (x.hasOwnProperty(key)) {
        return x[key];
    }
    return xstream_1.default.never();
}
function flattenByKey(key, stream) {
    return stream.map(function (x) { return propOrNever(key, x); }).flatten();
}
function ComponentRouter(sources) {
    var component$ = sources.router.define(sources.routes)
        .map(function (route) { return callPage(sources)(route); })
        .remember()
        .debug(function () { }); //State$ does not work without this line. Unable to reproduce in webpackbin.
    var pluck = function (key) { return flattenByKey(key, component$); };
    var sinks = {
        pluck: pluck,
        DOM: pluck("DOM"),
        router: pluck("router"),
    };
    return sinks;
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = function (sources) { return isolate_1.default(ComponentRouter)(sources); };


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(174);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    "/": index_1.Index.run
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var Breadcrumb;
(function (Breadcrumb) {
    /**
     * An interactive Breadcrumb component for displaying a history of links.
     * Accepts the following properties in props$:
     *  arrow?: boolean - Styles the breadcrumb to use arrow icons.
     *  checvron?: boolean - Styles the breadcrumb to use chevron icons.
     * Expects the following type of content: Array of {}
     *   active?: boolean - Highlights the section as the current state.
     *   text?: string - The text for the section.
     *   href?: string - The location for the section to point towards.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var breadcrumb$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: breadcrumb$,
                Events: function (type) { return sources.DOM.select(".breadcrumb").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Breadcrumb.run = run;
    /**
     * A static Breadcrumb component for displaying a history of links.
     * Accepts the following properties
     *  arrow?: boolean - Styles the breadcrumb to use arrow icons.
     *  checvron?: boolean - Styles the breadcrumb to use chevron icons.
     * Expects the following type of content: Array of {}
     *   active?: boolean - Highlights the section as the current state.
     *   text?: string - The text for the section.
     *   href?: string - The location for the section to point towards.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var children = content.map(function (c) { return [
            section(c), divider(props)
        ]; }).reduce(function (a, n) { return a.concat(n); });
        children.splice(-1, 1);
        return dom_1.div({ props: { className: "ui breadcrumb" } }, children);
    }
    Breadcrumb.render = render;
    function section(section) {
        return section.active
            ? dom_1.div({ props: { className: "active section" } }, section.text)
            : dom_1.a({ props: { className: "section", href: section.href } }, section.text);
    }
    function divider(props) {
        return dom_1.span({ props: { className: "divider" } }, dividerIcon(props));
    }
    function dividerIcon(props) {
        if (props.arrow) {
            return dom_1.i({ props: { className: "right arrow icon divider" } });
        }
        if (props.chevron) {
            return dom_1.i({ props: { className: "right chevron icon divider" } });
        }
        return (" / ");
    }
    function isContent(propsOrContent) {
        return propsOrContent !== undefined && propsOrContent.push !== undefined;
    }
})(Breadcrumb = exports.Breadcrumb || (exports.Breadcrumb = {}));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Field;
(function (Field) {
    /**
     * Wraps content in a Field suitable for the Form component.
     * Accepts the following properties in props$:
     *   width?: number - The width of the field in grid columns.
     *   inline?: boolean - Styles the label to be next to the field instead of above it.
     *   centered?: boolean - Styles the content of the field to be centered.
     *   required?: boolean - Styles the field to show it is mandatory.
     * Expects the following type of content in content$: {} of
     *   label?: DOMContent - The label for the field.
     *   body: DOMContent - The field input.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extra = _a[2];
                return render(props, content, extra);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".field").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Field.run = run;
    /**
     * Wraps content in a Field suitable for the Form component.
     * Accepts the following properties:
     *   width?: number - The width of the field in grid columns.
     *   inline?: boolean - Styles the label to be next to the field instead of above it.
     *   centered?: boolean - Styles the content of the field to be centered.
     *   required?: boolean - Styles the field to show it is mandatory.
     * Expects the following type of content: {} of
     *   label?: DOMContent - The label for the field.
     *   body: DOMContent - The field input.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var extra = interfaces_1.isDOMContent(pOrC) ? (c === "") ? e : c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [].concat(extra ? dom_1.label(extra) : "", content));
    }
    Field.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.width) {
            className += utils_1.numToText(props.width) + " wide";
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.centered) {
            className += " centered";
        }
        if (props.required) {
            className += " required";
        }
        className += " field";
        return className;
    }
})(Field = exports.Field || (exports.Field = {}));


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Fields;
(function (Fields) {
    /**
     * Wraps multiple related Field components together.
     * Accepts the following properties in props$:
     *   label?: DOMContent - A label for the fields.
     *   equalWidth?: boolean - Divides fields in equal width.
     *   grouped?: boolean - Groups fields together for related choices.
     *   inline?: boolean - Styles the labels to be next to the fields instead of above them.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".fields").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Fields.run = run;
    /**
     * Wraps multiple related Field components together.
     * Accepts the following properties:
     *   label?: DOMContent - A label for the fields.
     *   equalWidth?: boolean - Divides fields in equal width.
     *   grouped?: boolean - Groups fields together for related choices.
     *   inline?: boolean - Styles the labels to be next to the fields instead of above them.
     *   required?: boolean - Styles the the fields to make them appear mandetory.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var lbl = props.label ? dom_1.label(props.label) : "";
        var children = content.length ? [lbl].concat(content) : [lbl, content];
        return dom_1.div({ props: { className: getClassname(props, content) } }, children);
    }
    Fields.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.equalWidth && content.length) {
            className += utils_1.numToText(content.length);
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.grouped) {
            className += " grouped";
        }
        if (props.required) {
            className += " required";
        }
        className += " fields";
        return className;
    }
})(Fields = exports.Fields || (exports.Fields = {}));


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Form;
(function (Form) {
    /**
     * A form component for capturing groups of user input.
     * Accepts the following properties in props$:
     *   loading?: boolean - Styles the form with a loader.
     *   equalWidth?: boolean - Styles the form content to have equal widths per row.
     *   inverted?: boolean - Styles the form for dark backgrounds.
     *   size?: Size - The size of the form's content.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".form").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Form.run = run;
    /**
     * A form component for capturing groups of user input.
     * Accepts the following properties:
     *   loading?: boolean - Styles the form with a loader.
     *   equalWidth?: boolean - Styles the form content to have equal widths per row.
     *   inverted?: boolean - Styles the form for dark backgrounds.
     *   size?: Size - The size of the form's content.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Form.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.loading) {
            className += " loading";
        }
        if (props.equalWidth) {
            className += " equal width";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " form";
        return className;
    }
})(Form = exports.Form || (exports.Form = {}));


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(182));
__export(__webpack_require__(180));
__export(__webpack_require__(181));


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Column;
(function (Column) {
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties in props$:
     *   float?: Float - Wether the column should be left or right floated.
     *   width?: int - The default width of the column.
     *   mobile?: int - The width of the column on mobile devices.
     *   tablet?: int - The width of the column on tablet devices.
     *   computer?: int - The width of the column on computer devices.
     *   largescreen?: int - The width of the column on large screen devices.
     *   size?: Size - The size of the column.
     *   alignment?: VerticalAlignment - The vertical alignment of the column.
     *   textAlignment?: TextAlignment - The text alignment of the column.
     * Expects the following type of content in Content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".column").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Column.run = run;
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties:
     *   float?: Float - Wether the column should be left or right floated.
     *   width?: int - The default width of the column.
     *   mobile?: int - The width of the column on mobile devices.
     *   tablet?: int - The width of the column on tablet devices.
     *   computer?: int - The width of the column on computer devices.
     *   largescreen?: int - The width of the column on large screen devices.
     *   size?: Size - The size of the column.
     *   alignment?: VerticalAlignment - The vertical alignment of the column.
     *   textAlignment?: TextAlignment - The text alignment of the column.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Column.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.float && props.float === enums_1.Float.Right) {
            className += " right floated";
        }
        if (props.float && props.float === enums_1.Float.Left) {
            className += " left floated";
        }
        if (props.mobile) {
            className += utils_1.numToText(props.mobile) + " wide mobile";
        }
        if (props.tablet) {
            className += utils_1.numToText(props.tablet) + " wide tablet";
        }
        if (props.computer) {
            className += utils_1.numToText(props.computer) + " wide computer";
        }
        if (props.largescreen) {
            className += utils_1.numToText(props.largescreen) + " wide largescreen";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        if (props.width) {
            className += utils_1.numToText(props.width) + " wide";
        }
        className += " column";
        return className;
    }
})(Column = exports.Column || (exports.Column = {}));


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Grid;
(function (Grid) {
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties in props$:
     *   equallyDivided?: boolean - Styles grid content to take up equal amounts of space.
     *   divided?: boolean - Use dividers to seperate content in the Grid.
     *   container? : boolean - Wraps the grid in a container.
     *   celled?: boolean - Divides the grid into cells.
     *   intCelled?: boolean - Divides the grid into cells with only internal dividers.
     *   padded?: boolean - Adds vertical and horizontal gutters to the grid.
     *   relaxed?: boolean - Increases the amount of negative space.
     *   centered?: boolean - Centers the content of the Grid.
     *   alignment?: VerticalAlignment: Determines the alignment of content in the Grid.
     *   textAlignment?: TextAlignment: Determines the text alignment of content in the Grid.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".grid").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Grid.run = run;
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties:
     *   equallyDivided?: boolean - Styles grid content to take up equal amounts of space.
     *   divided?: boolean - Use dividers to seperate content in the Grid.
     *   container? : boolean - Wraps the grid in a container.
     *   celled?: boolean - Divides the grid into cells.
     *   intCelled?: boolean - Divides the grid into cells with only internal dividers.
     *   padded?: boolean - Adds vertical and horizontal gutters to the grid.
     *   relaxed?: boolean - Increases the amount of negative space.
     *   centered?: boolean - Centers the content of the Grid.
     *   alignment?: VerticalAlignment: Determines the alignment of content in the Grid.
     *   textAlignment?: TextAlignment: Determines the text alignment of content in the Grid.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props, content) } }, content);
    }
    Grid.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.equallyDivided) {
            className += utils_1.numToText(content.length ? content.length : 1) + " column";
        }
        if (props.divided) {
            className += " divided";
        }
        if (props.container) {
            className += " container";
        }
        if (props.celled) {
            className += " celled";
        }
        if (props.intCelled) {
            className += " internally celled";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.relaxed) {
            className += " relaxed";
        }
        if (props.centered) {
            className += " centered";
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        className += " grid";
        return className;
    }
    Grid.getClassname = getClassname;
})(Grid = exports.Grid || (exports.Grid = {}));


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(185));
__export(__webpack_require__(187));
__export(__webpack_require__(184));


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Row;
(function (Row) {
    /**
     * Creates a Row component that wraps Column content.
     * Accepts the following properties in props$:
     *   stretched?: boolean - Ensures the columns are stretched to equal height.
     *   mobile?: boolean - Makes the row visible only on mobile devices.
     *   tablet?: boolean - Makes the row visible only on tablet devices.
     *   computer?: boolean - Makes the row visible only on computer devices.
     *   largescreen?: boolean - Makes the row visible only on largescreen devices.
     *   equallyDivided?: boolean - Makes each column of the row equal in width.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".row").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Row.run = run;
    /**
     * Creates a Row component that wraps Column content.
     * Accepts the following properties:
     *   stretched?: boolean - Ensures the columns are stretched to equal height.
     *   mobile?: boolean - Makes the row visible only on mobile devices.
     *   tablet?: boolean - Makes the row visible only on tablet devices.
     *   computer?: boolean - Makes the row visible only on computer devices.
     *   largescreen?: boolean - Makes the row visible only on largescreen devices.
     *   equallyDivided?: boolean - Makes each column of the row equal in width.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props, content) } }, content);
    }
    Row.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.stretched) {
            className += " stretched";
        }
        if (props.mobile) {
            className += " mobile only";
        }
        if (props.tablet) {
            className += " tablet only";
        }
        if (props.computer) {
            className += " computer only";
        }
        if (props.largescreen) {
            className += " largescreen only";
        }
        if (props.equallyDivided) {
            className += utils_1.numToText(content.length ? content.length : 1) + " column";
        }
        className += " row";
        return className;
    }
})(Row = exports.Row || (exports.Row = {}));


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(179));
__export(__webpack_require__(183));
__export(__webpack_require__(186));
__export(__webpack_require__(59));
__export(__webpack_require__(189));
__export(__webpack_require__(190));


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var icon_1 = __webpack_require__(22);
var transition_1 = __webpack_require__(13);
var Message;
(function (Message) {
    /**
     * A message component to present messages to users.
     * Accepts the following properties in props$:
     *   on$?: Stream<boolean> - When to show/hide the message.
     *   closeable?: boolean - Provides a close icon for the message for dismissal.
     *   icon?: boolean - Formats the message to support an icon.
     *   floating?: boolean - Formats the message to float above related content.
     *   compact?: boolean - Formats a message to only occupy width needed by its content.
     *   attached?: boolean - Formats the message to appear attached to other content.
     *   size?: Size - The size of the message.
     *   color?: Color - The color of the message.
     * Expects the following type of content in content$: {}
     *   icon?: String|VNode - A message can have an icon signifying the type of message.
     *   header?: String|VNode - A message can have a header text.
     *   body?: String|VNode - A message can have additionaly body content.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var icon = icon_1.Icon.run({ DOM: sources.DOM, props$: xstream_1.default.of({ type: "close" }) });
            var close$ = icon.Events("click").mapTo(false);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, icon.DOM)
                .map(function (_a) {
                var props = _a[0], content = _a[1], closeIcon = _a[2];
                return dom_1.div({ props: { className: getClassname(props) } }, [
                    content.icon,
                    props.closeable ? closeIcon : "",
                    dom_1.div({ props: { className: "content" } }, [].concat(content.header ? dom_1.div({ props: { className: "header" } }, content.header) : "", content.body))
                ]);
            });
            var on$ = sources.props$.map(function (props) { return props.on$ ? props.on$ : xstream_1.default.of(true); }).flatten();
            var active$ = xstream_1.default.merge(on$, close$);
            var transition$ = active$.fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? { animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out }
                : { animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out }; }, { animation: enums_1.Animation.None, direction: enums_1.Direction.None });
            var animatedVTree$ = transition_1.Transition.run({ DOM: sources.DOM, target$: vTree$, args$: transition$ }).DOM;
            return {
                DOM: animatedVTree$,
                Events: function (type) { return sources.DOM.select(".message").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Message.run = run;
    /**
     * A message component to present messages to users.
     * Accepts the following properties:
     *   on$?: Stream<boolean> - When to show/hide the message.
     *   closeable?: boolean - Provides a close icon for the message for dismissal.
     *   icon?: boolean - Formats the message to support an icon.
     *   floating?: boolean - Formats the message to float above related content.
     *   compact?: boolean - Formats a message to only occupy width needed by its content.
     *   attached?: boolean - Formats the message to appear attached to other content.
     *   size?: Size - The size of the message.
     *   color?: Color - The color of the message.
     * Expects the following type of content: {}
     *   icon?: String|VNode - A message can have an icon signifying the type of message.
     *   header?: String|VNode - A message can have a header text.
     *   body?: String|VNode - A message can have additionaly body content.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = {}; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var closeIcon = icon_1.Icon.render({}, enums_1.IconType.Close);
        return dom_1.div({ props: { className: getClassname(props) } }, [
            content.icon ? icon_1.Icon.render(content.icon) : "",
            props.closeable ? closeIcon : "",
            dom_1.div({ props: { className: "content" } }, [].concat(content.header ? dom_1.div({ props: { className: "header" } }, content.header) : "", content.body))
        ]);
    }
    Message.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.icon) {
            className += " icon";
        }
        if (props.floating) {
            className += " floating";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.attached) {
            className += " attached";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " message";
        return className;
    }
    function isContent(content) {
        return content !== undefined && (interfaces_1.isDOMContent(content.icon) || interfaces_1.isDOMContent(content.header) || interfaces_1.isDOMContent(content.body));
    }
})(Message = exports.Message || (exports.Message = {}));


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Table;
(function (Table) {
    /**
     * A table component to show content in a table.
     * Accepts the following properties in props$:
     *   singleline?: boolean - Formats the content of the table to fit on a single line.
     *   fixed?: boolean - Stops resizing of table cells based on content.
     *   selectable?: boolean - Styles the rows of the table to be selectable.
     *   striped?: boolean - Styles the rows of the table to alternate colors.
     *   celled?: boolean - Divides each row into seperate cells.
     *   basic?: boolean - Reduces the complexity of the table.
     *   verybasic?: boolean - Reduces the complexity of the table by a lot.
     *   collapsing?: boolean - Makes the table only take up as much space as needed.
     *   padded?: boolean - Adds extra padding to the table content.
     *   verypadded?: boolean - Adds a lot of extra padding to the table content.
     *   compact?: boolean - Styles the table content to be more compact, to allow for more rows.
     *   verycompact?: boolean - Styles the table content to be greatly compacted.
     *   size?: Size - The size of the table content.
     *   color?: Color - The colour of the table.
     * Expects the following type of content in content$: {} of
     * 	headers: [DOMContent]
     * 	body: [[DomContent]]
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of({ body: [] });
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".table").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Table.run = run;
    /**
     * A table component to show content in a table.
     * Accepts the following properties in props$:
     *   singleline?: boolean - Formats the content of the table to fit on a single line.
     *   fixed?: boolean - Stops resizing of table cells based on content.
     *   selectable?: boolean - Styles the rows of the table to be selectable.
     *   striped?: boolean - Styles the rows of the table to alternate colors.
     *   celled?: boolean - Divides each row into seperate cells.
     *   basic?: boolean - Reduces the complexity of the table.
     *   verybasic?: boolean - Reduces the complexity of the table by a lot.
     *   collapsing?: boolean - Makes the table only take up as much space as needed.
     *   padded?: boolean - Adds extra padding to the table content.
     *   verypadded?: boolean - Adds a lot of extra padding to the table content.
     *   compact?: boolean - Styles the table content to be more compact, to allow for more rows.
     *   verycompact?: boolean - Styles the table content to be greatly compacted.
     *   size?: Size - The size of the table content.
     *   color?: Color - The colour of the table.
     * Expects the following type of content in content$: {} of
     * 	headers: [DOMContent]
     * 	body: [[DomContent]]
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = { body: [] }; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var header = content.header ? dom_1.thead([dom_1.tr(content.header.map(function (h) { return dom_1.th(h); }))]) : "";
        var footer;
        if (interfaces_1.isDOMContent(content.footer)) {
            footer = dom_1.tfoot(content.footer);
        }
        else {
            footer = content.footer ? dom_1.tfoot([dom_1.tr(content.footer.map(function (f) { return dom_1.th(f); }))]) : "";
        }
        return dom_1.table({ props: { className: getClassname(props) } }, [
            header,
            dom_1.tbody(content.body.map(function (r) { return dom_1.tr(r.map(function (c) { return dom_1.td(c); })); })),
            footer
        ]);
    }
    Table.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.singleline) {
            className += " single line";
        }
        if (props.fixed) {
            className += " fixed";
        }
        if (props.selectable) {
            className += " selectable";
        }
        if (props.striped) {
            className += " striped";
        }
        if (props.celled) {
            className += " celled";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.verybasic) {
            className += " very basic";
        }
        if (props.collapsing) {
            className += " collapsing";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.verypadded) {
            className += " very padded";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.verycompact) {
            className += " very compact";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " table";
        return className;
    }
    function isContent(content) {
        return content !== undefined && (content.body !== undefined &&
            (content.header !== undefined ||
                content.footer !== undefined));
    }
})(Table = exports.Table || (exports.Table = {}));


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Button;
(function (Button) {
    /**
     * An interactive button component for user interaction through clicking.
     * Accepts the following type of properties in props$:
     *   animated? : boolean - Allows for an animation in the button to show hidden content.
     *   verticalAnimated?: boolean - See animated. This animation is vertical.
     *   labeled?: boolean - Adds styling for labeled buttons.
     *   icon?: boolean - Adds styling for buttons with an icon.
     *   basic?: boolean - Styles the button to appear simpler.
     *   inverted?: boolean - Styles the button to appear on dark backgrounds.
     *   active?: boolean - Sets the button to the active state.
     *   disabled?: boolean - Styles the button to appear disabled.
     *   loading?: boolean - Styles the button show that it is loading / working.
     *   compact?: boolean - Styles the button for a tight fit.
     *   circular?: boolean - Styles the button to appear circular.
     *   fluid?: boolean - Styles the button to be as wide as possible.
     *   href?: string - Outputs the button as a link to to the href.
     *   attachment?: Attachment - Where the button should be attached to.
     *   size?: Size - The size of the button.
     *   float?: Float - The left or right float of the button.
     *   color?: Color - The color of the button.
     * Expects the following type of content in content$: {} of
     *   body?: DOMContent - The body content to display on the button.
     *   hidden?: DOMContent - The hidden content to display for animated buttons.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vtree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vtree$,
                Events: function (type) { return sources.DOM.select(".ui.button").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Button.run = run;
    /**
     * A static button component for user interaction through clicking.
     * Accepts the following type of properties:
     *   animated? : boolean - Allows for an animation in the button to show hidden content.
     *   verticalAnimated?: boolean - See animated. This animation is vertical.
     *   labeled?: boolean - Adds styling for labeled buttons.
     *   icon?: boolean - Adds styling for buttons with an icon.
     *   basic?: boolean - Styles the button to appear simpler.
     *   inverted?: boolean - Styles the button to appear on dark backgrounds.
     *   active?: boolean - Sets the button to the active state.
     *   disabled?: boolean - Styles the button to appear disabled.
     *   loading?: boolean - Styles the button show that it is loading / working.
     *   compact?: boolean - Styles the button for a tight fit.
     *   circular?: boolean - Styles the button to appear circular.
     *   fluid?: boolean - Styles the button to be as wide as possible.
     *   href?: string - Outputs the button as a link to to the href.
     *   attachment?: Attachment - Where the button should be attached to.
     *   size?: Size - The size of the button.
     *   float?: Float - The left or right float of the button.
     *   color?: Color - The color of the button.
     * Expects the following type of content: {} of
     *   body?: DOMContent - The body content to display on the button.
     *   hidden?: DOMContent - The hidden content to display for animated buttons.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var extra = interfaces_1.isDOMContent(pOrC) ? (c !== "") ? c : e : e;
        var children = extra
            ? [dom_1.div({ props: { className: "visible content" } }, content),
                dom_1.div({ props: { className: "hidden content" } }, extra)]
            : content;
        return props.href
            ? dom_1.a({ props: { href: props.href, className: getClassname(props) } }, children)
            : dom_1.div({ props: { className: getClassname(props) } }, children);
    }
    Button.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.animated) {
            className += " animated";
        }
        if (props.verticalAnimated) {
            className += " vertical.animated";
        }
        if (props.labeled) {
            className += " labeled";
        }
        if (props.rightlabeled) {
            className += " right labeled";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.active) {
            className += " active";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.fluid) {
            className += " fluid";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " button";
        return className;
    }
})(Button = exports.Button || (exports.Button = {}));


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Container;
(function (Container) {
    /**
    * A responsive container component to host other content.
    * Does not accept any properties in props$.
    * Expects the following type of content in content$: DOMContent
    */
    function run(sources) {
        function main(sources) {
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = sources.content$.map(function (content) { return render(content); });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".container").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Container.run = run;
    /**
    * A responsive container component to host other content.
    * Does not accept any properties.
    * Expects the following type of content: DOMContent
    */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        // let props = isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: "ui container" } }, content);
    }
    Container.render = render;
})(Container = exports.Container || (exports.Container = {}));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Divider;
(function (Divider) {
    /**
     * Creates a divider element to seperate content on page.
     * Accepts the following properties in props$:
     * 	content?: VNode - The content to add to the divider.
     * 	horizontal?: boolean - Needed to render text horizontally in the divider.
     * 	vertical?: boolean - Determines vertical/horizontal orientation of the divider.
     * 	inverted?: boolean - For dark backgrounds.
     * 	fitted?: boolean - Minimizes the space between divided content.
     * 	hidden?: boolean - Creates an invisible divider that divides the content.
     * 	section?: boolean - Provides greater margins for between divided content.
     * 	clearing?: boolean - Clears floated content.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".divider").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Divider.run = run;
    /**
     * Creates a divider element to seperate content on page.
     * Accepts the following properties:
     * 	content?: VNode - The content to add to the divider.
     * 	horizontal?: boolean - Needed to render text horizontally in the divider.
     * 	vertical?: boolean - Determines vertical/horizontal orientation of the divider.
     * 	inverted?: boolean - For dark backgrounds.
     * 	fitted?: boolean - Minimizes the space between divided content.
     * 	hidden?: boolean - Creates an invisible divider that divides the content.
     * 	section?: boolean - Provides greater margins for between divided content.
     * 	clearing?: boolean - Clears floated content.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassName(props, content) } }, content);
    }
    Divider.render = render;
    function getClassName(props, content) {
        var className = "ui";
        if (props.vertical) {
            className += " vertical";
        }
        else if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.hidden) {
            className += " hidden";
        }
        if (props.section) {
            className += " section";
        }
        if (props.clearing) {
            className += " clearing";
        }
        if (props.header) {
            className += " header";
        }
        className += " divider";
        return className;
    }
})(Divider = exports.Divider || (exports.Divider = {}));


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Header;
(function (Header) {
    /**
     * Creates a header for important text.
     * Accepts the following properties in props$:
     *   icon?: boolean - Adds styling for icon headers.
     *   divider?: boolean - Adds styling for headers to seperate content.
     *   block?: boolean - Wraps header in a block.
     *   disabled?: boolean - Styling for disabled content.
     *   inverted?: boolean - Styling for dark backgrounds.
     *   attachment?: Attachment - Styling for headers attached to other content.
     *   float?: Float - Floats the header to the left or right.
     *   textAlignment?: TextAlignment - Text alignment of the header text.
     *   size?: Size - Determines the size of the header.
     *   color?: Color - The color of the header.
     * Expects the following type of content in content$: {} of
     *   text: DOMContent - The header text.
     *   subtext?: DOMContent- An optional sub-header to accompany the header.
     *   icon?: DOMContent - Optional image/icon content for the header.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of({});
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".header").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Header.run = run;
    /**
     * Creates a header for important text.
     * Accepts the following properties:
     *   icon?: boolean - Adds styling for icon headers.
     *   divider?: boolean - Adds styling for headers to seperate content.
     *   block?: boolean - Wraps header in a block.
     *   disabled?: boolean - Styling for disabled content.
     *   inverted?: boolean - Styling for dark backgrounds.
     *   attachment?: Attachment - Styling for headers attached to other content.
     *   float?: Float - Floats the header to the left or right.
     *   textAlignment?: TextAlignment - Text alignment of the header text.
     *   size?: Size - Determines the size of the header.
     *   color?: Color - The color of the header.
     * Expects the following type of content: {} of
     *   text: DOMContent - The header text.
     *   subtext?: DOMContent- An optional sub-header to accompany the header.
     *   icon?: DOMContent - Optional image/icon content for the header.
     */
    function render(pOrCorE, cOrE, e) {
        if (pOrCorE === void 0) { pOrCorE = {}; }
        if (cOrE === void 0) { cOrE = {}; }
        if (e === void 0) { e = {}; }
        var props = interfaces_1.isDOMContent(pOrCorE) ? {} : isExtras(pOrCorE) ? {} : pOrCorE;
        var content = interfaces_1.isDOMContent(pOrCorE) ? pOrCorE : interfaces_1.isDOMContent(cOrE) ? cOrE : "";
        var extras = isExtras(pOrCorE) ? pOrCorE : isExtras(cOrE) ? cOrE : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            extras.icon ? extras.icon : "",
            dom_1.div({ props: { className: "content" } }, [].concat(content, extras.subtext ? dom_1.div({ props: { className: "sub header" } }, extras.subtext) : ""))
        ]);
    }
    Header.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.icon) {
            className += " icon";
        }
        if (props.divider) {
            className += " divider";
        }
        if (props.block) {
            className += " block";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " header";
        return className;
    }
    function isExtras(extra) {
        return extra !== undefined && (extra.subtext !== undefined
            || (extra.icon !== undefined && typeof (extra.icon) !== "boolean"));
    }
})(Header = exports.Header || (exports.Header = {}));


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var Image;
(function (Image) {
    /**
     * An image component for displaying images.
     * Accepts the following properties in props$:
     *   href?: string - Styles the image as a link towards the location.
     *   hidden?: boolean - Hides the image.
     *   disabled?: boolean - Styles the image to appear disabled.
     *   avatar?: boolean - Styles the image for usage as an avatar.
     *   bordered?: boolean - Styles the image with a border.
     *   spaced?: boolean - Styles the image with extra spacing to seperate it from nearby content.
     *   circular?: boolean - Styles the image to be circular.
     *   rounded?: boolean - Styles the image to have rounded edges.
     *   float?: Float - The float orientation of the image.
     *   size?: Size - The size of the image.
     *   verticalAlignment?: VerticalAlignment - The vertical alignment of text nearby the image.
     * Expects the following type of content in content$: string - The src url.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".image").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Image.run = run;
    /**
     * An image component for displaying images.
     * Accepts the following properties:
     *   link?: boolean - Styles the image as a link.
     *   hidden?: boolean - Hides the image.
     *   disabled?: boolean - Styles the image to appear disabled.
     *   avatar?: boolean - Styles the image for usage as an avatar.
     *   bordered?: boolean - Styles the image with a border.
     *   spaced?: boolean - Styles the image with extra spacing to seperate it from nearby content.
     *   circular?: boolean - Styles the image to be circular.
     *   rounded?: boolean - Styles the image to have rounded edges.
     *   float?: Float - The float orientation of the image.
     *   size?: Size - The size of the image.
     *   verticalAlignment?: VerticalAlignment - The vertical alignment of text nearby the image.
     * Expects the following type of content: string - The src url.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = typeof (pOrC) === "string" ? {} : pOrC;
        var content = typeof (pOrC) === "string" ? pOrC : c;
        var image = dom_1.img({ props: { className: getClassname(props), src: content } });
        return props.href ? dom_1.a({ props: { href: props.href } }, image) : image;
    }
    Image.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.href) {
            className += " link";
        }
        if (props.hidden) {
            className += " hidden";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.avatar) {
            className += " avatar";
        }
        if (props.bordered) {
            className += " bordered";
        }
        if (props.spaced) {
            className += " spaced";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.rounded) {
            className += " rounded";
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.verticalAlignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.verticalAlignment);
        }
        return className + " image";
    }
})(Image = exports.Image || (exports.Image = {}));


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(191));
__export(__webpack_require__(192));
__export(__webpack_require__(193));
__export(__webpack_require__(194));
__export(__webpack_require__(22));
__export(__webpack_require__(195));
__export(__webpack_require__(197));
__export(__webpack_require__(198));
__export(__webpack_require__(199));
__export(__webpack_require__(200));
__export(__webpack_require__(201));
__export(__webpack_require__(202));


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Label;
(function (Label) {
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties in props$:
     *   circular?: boolean - Styles the label to be circular.
     *   empty?: boolean - Styles the label for empty content.
     *   pointing?: boolean - Styles the label to be pointing towards nearby content.
     *   basic?: boolean - Styles the label to be minimalistic.
     *   leftCorner?: boolean - Attaches the label to the top-left corner of nearby content.
     *   rightCorner?: boolean - Attaches the label to the top-right corner of nearby content.
     *   tag?: boolean - Styles the label to look like a tag.
     *   ribbon?: boolean - Styles the label to look like a ribbon over the left side of content.
     *   invRibbon?: boolean - Styles the label to look like a ribbon over the right side of content.
     *   horizontal?: boolean - Styles the label for horizontal content.
     *   floating?: boolean - Styles the label to be floating over nearby content.
     *   attachment?: Attachment - Where the label should be attached to.
     *   size?: Size - The size of the label.
     *   color?: Color - The color of the label.
     * Expects the following type of content and extras: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".label").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Label.run = run;
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties:
     *   circular?: boolean - Styles the label to be circular.
     *   empty?: boolean - Styles the label for empty content.
     *   pointing?: boolean - Styles the label to be pointing towards nearby content.
     *   basic?: boolean - Styles the label to be minimalistic.
     *   leftCorner?: boolean - Attaches the label to the top-left corner of nearby content.
     *   rightCorner?: boolean - Attaches the label to the top-right corner of nearby content.
     *   tag?: boolean - Styles the label to look like a tag.
     *   ribbon?: boolean - Styles the label to look like a ribbon over the left side of content.
     *   invRibbon?: boolean - Styles the label to look like a ribbon over the right side of content.
     *   horizontal?: boolean - Styles the label for horizontal content.
     *   floating?: boolean - Styles the label to be floating over nearby content.
     *   attachment?: Attachment - Where the label should be attached to.
     *   size?: Size - The size of the label.
     *   color?: Color - The color of the label.
     * Expects the following type of content and extras: DOMContent
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var detail = interfaces_1.isDOMContent(pOrC) ? c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            content,
            detail ? dom_1.div({ props: { className: "detail" } }, detail) : ""
        ]);
    }
    Label.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.circular) {
            className += " circular";
        }
        if (props.empty) {
            className += " empty";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.leftCorner) {
            className += " left corner";
        }
        if (props.rightCorner) {
            className += " right corner";
        }
        if (props.tag) {
            className += " tag";
        }
        if (props.ribbon) {
            className += " ribbon";
        }
        if (props.invRibbon) {
            className += " right ribbon";
        }
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.floating) {
            className += " floating ";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " label";
        return className;
    }
})(Label = exports.Label || (exports.Label = {}));


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var List;
(function (List) {
    /**
     * Creates a List component for showing lists of content.
     * Accepts the following properties in props$:
     *   bulleted?: boolean - Displays list as a bulleted list.
     *   ordered?: boolean - Displays list as an ordered list.
     *   link?: boolean - Styling for lists with links.
     *   horizontal?: boolean - Displays list horizontally.
     *   inverted?: boolean - Styling for lists on dark backgrounds.
     *   selection?: boolean - Styling for lists meant to display a selection.
     *   animated?: boolean - Adds an animation to display currently selected item.
     *   relaxed?: boolean - Adds more negative space arround the list.
     *   divided?: boolean - Adds horizontal dividers between content of list.
     *   celled?: boolean - Wraps content of list in cells.
     *   size?: Size - The size of the list and its content.
     *   alignment?: VerticalAlignment - The vertical alignment of list's content.
     *   float?: Float - Wether the list should be left or right floating.
     * Expects the following type of content: Array of {}
     *   left?: DOMContent - Left floated content for the item.
     *   body?: DOMContent - Body content for the item.
     *   right?: DOMContent - Right floated content for the item.
     *   header?: DOMContent - Name of the list item
     *   description?: DOMContent - Description of the list item.
     *   href?: string - Link for link lists
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".list").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    List.run = run;
    /**
     * Creates a List component for showing lists of content.
     * Accepts the following properties in props$:
     *   bulleted?: boolean - Displays list as a bulleted list.
     *   ordered?: boolean - Displays list as an ordered list.
     *   link?: boolean - Styling for lists with links.
     *   horizontal?: boolean - Displays list horizontally.
     *   inverted?: boolean - Styling for lists on dark backgrounds.
     *   selection?: boolean - Styling for lists meant to display a selection.
     *   animated?: boolean - Adds an animation to display currently selected item.
     *   relaxed?: boolean - Adds more negative space arround the list.
     *   divided?: boolean - Adds horizontal dividers between content of list.
     *   celled?: boolean - Wraps content of list in cells.
     *   size?: Size - The size of the list and its content.
     *   alignment?: VerticalAlignment - The vertical alignment of list's content.
     *   float?: Float - Wether the list should be left or right floating.
     * Expects the following type of content: Array of {}
     *   left?: DOMContent - Left floated content for the item.
     *   body?: DOMContent - Body content for the item.
     *   right?: DOMContent - Right floated content for the item.
     *   header?: DOMContent - Name of the list item
     *   description?: DOMContent - Description of the list item.
     *   href?: string - Link for link lists
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content.map(function (_a) {
            var header = _a.header, icon = _a.icon, content = _a.content, description = _a.description, href = _a.href, left = _a.left, right = _a.right;
            var l = left ? dom_1.div({ props: { className: "left floated content" } }, left) : undefined;
            var r = right ? dom_1.div({ props: { className: "right floated content" } }, right) : undefined;
            var h = header ? dom_1.div({ props: { className: "header" } }, header) : undefined;
            var d = description ? dom_1.div({ props: { className: "description" } }, description) : undefined;
            var i = icon ? icon : "";
            var c = dom_1.div({ props: { className: "content" } }, [].concat(h, d, content));
            var children = [].concat(l, i, c, r);
            return href
                ? dom_1.a({ props: { className: "item" } }, { props: { href: href } }, children)
                : dom_1.div({ props: { className: "item" } }, children);
        }));
    }
    List.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.bulleted) {
            className += " bulleted";
        }
        if (props.ordered) {
            className += " ordered";
        }
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.selection) {
            className += " selection";
        }
        if (props.animated) {
            className += " animated";
        }
        if (props.relaxed) {
            className += " relaxed";
        }
        if (props.divided) {
            className += " divided";
        }
        if (props.celled) {
            className += " celled";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        className += " list";
        return className;
    }
})(List = exports.List || (exports.List = {}));


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var dimmer_1 = __webpack_require__(36);
var Loader;
(function (Loader) {
    /**
     * A loader component to show that certain content or a page is loading.
     * Accepts the following properties in props$:
     *   type: LoaderType - The type of loader to use. See exported enum.
     *   element?: Stream<VNode> - The element to mark as loaded. (Only used for type.Content)
     *   on$: Stream<boolean> - When to show/hide the loader. (Not used for inline, add disabled property instead.)
     *   centered?: boolean - Centers the loader spinner in its parent component.
     *   active?: boolean - Always shows the loader.
     *   disabled?: boolean - Always hides the loader.
     *   indeterminate?: boolean - Makes the loader spin indicate its unsure of how long a task will take.
     *   text?: boolean - Positions the loader to leave space for text.
     *   size?: Size - The size of the loader.
     * Expects the following type of content in content$ of: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ type: LoaderType.Inline });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var props$ = sources.props$.remember();
            var vTree$ = xstream_1.default.combine(props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            var on$ = props$.map(function (props) { return props.on$; }).flatten();
            var target$ = props$.map(function (props) { return props.type === LoaderType.Page ? xstream_1.default.of("page") : props.element; }).flatten();
            var dimmer = dimmer_1.Dimmer.run({ DOM: sources.DOM, args$: on$, target$: target$, content$: vTree$ }, props$.map(function (props) { return props.inverted; }));
            var result$ = props$.map(function (props) { return props.type === LoaderType.Inline ? vTree$ : dimmer.DOM; }).flatten();
            return {
                DOM: result$,
                Events: function (type) { return sources.DOM.select(".loader").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Loader.run = run;
    /**
     * A loader component to show that certain content or a page is loading.
     * Accepts the following properties:
     *   type: LoaderType - The type of loader to use. See exported enum.
     *   element?: Stream<VNode> - The element to mark as loaded. (Only used for type.Content)
     *   on$: Stream<boolean> - When to show/hide the loader. (Not used for inline, add disabled property instead.)
     *   centered?: boolean - Centers the loader spinner in its parent component.
     *   active?: boolean - Always shows the loader.
     *   disabled?: boolean - Always hides the loader.
     *   indeterminate?: boolean - Makes the loader spin indicate its unsure of how long a task will take.
     *   text?: boolean - Positions the loader to leave space for text.
     *   size?: Size - The size of the loader.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = { type: LoaderType.Page }; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? { type: LoaderType.Page } : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return [dom_1.div({ props: { className: getClassname(props) } }, content)];
    }
    Loader.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.active) {
            className += " active";
        }
        if (props.centered) {
            className += " centered";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.indeterminate) {
            className += " indeterminate";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.text) {
            className += " text";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += LoaderType.ToClassname(props.type);
        return className;
    }
    var LoaderType;
    (function (LoaderType) {
        LoaderType[LoaderType["Inline"] = 0] = "Inline";
        LoaderType[LoaderType["Page"] = 1] = "Page";
        LoaderType[LoaderType["Content"] = 2] = "Content";
    })(LoaderType = Loader.LoaderType || (Loader.LoaderType = {}));
    (function (LoaderType) {
        function ToClassname(type) {
            switch (type) {
                case LoaderType.Inline: return " inline loader";
                case LoaderType.Page: return " loader";
                case LoaderType.Content: return " loader";
            }
        }
        LoaderType.ToClassname = ToClassname;
    })(LoaderType = Loader.LoaderType || (Loader.LoaderType = {}));
})(Loader = exports.Loader || (exports.Loader = {}));


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Segment;
(function (Segment) {
    /**
     * A segment component to divide up page content into segments.
     * Accepts the following properties in props$:
     *   raised?: boolean? - Styles the segment to appear floating above nearby content.
     *   stacked?: boolean? - Styles the segment to appear like a stack of papers.
     *   tallStacked?: boolean? - Styles the segment to appear like a tall stack of papers.
     *   piled?: boolean? - Styles the segment to appear like a pile of papers.
     *   vertical?: boolean? - Styles the segment content to be aligned as part of a vertical group.
     *   loading?: boolean? - Styles the segment with a loading icon.
     *   inverted?: boolean? - Styles the segment for dark content.
     *   padded?: boolean? - Increases the padding on the segment.
     *   veryPadded?: boolean - Increases the padding on the segment by a lot.
     *   compact?: boolean - Makes the segment take up only the space needed by its content.
     *   circular?: boolean - Styles the segment to be circular.
     *   clearing?: boolean - Clears floated content.
     *   basic?: boolean - Removes any special styling.
     *   color?: Color - The color of the segment.
     *   attachment?: Attachment - The attachment of the segment.
     *   float?: Float - Where the segment should float.
     *   textAlignment?: TextAlignment - The text alignment of the segment.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".segment").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Segment.run = run;
    /**
     * A segment component to divide up page content into segments.
     * Accepts the following properties:
     *   raised?: boolean? - Styles the segment to appear floating above nearby content.
     *   stacked?: boolean? - Styles the segment to appear like a stack of papers.
     *   tallStacked?: boolean? - Styles the segment to appear like a tall stack of papers.
     *   piled?: boolean? - Styles the segment to appear like a pile of papers.
     *   vertical?: boolean? - Styles the segment content to be aligned as part of a vertical group.
     *   loading?: boolean? - Styles the segment with a loading icon.
     *   inverted?: boolean? - Styles the segment for dark content.
     *   padded?: boolean? - Increases the padding on the segment.
     *   veryPadded?: boolean - Increases the padding on the segment by a lot.
     *   compact?: boolean - Makes the segment take up only the space needed by its content.
     *   circular?: boolean - Styles the segment to be circular.
     *   clearing?: boolean - Clears floated content.
     *   basic?: boolean - Removes any special styling.
     *   color?: Color - The color of the segment.
     *   attachment?: Attachment - The attachment of the segment.
     *   float?: Float - Where the segment should float.
     *   textAlignment?: TextAlignment - The text alignment of the segment.
     * Expects the following type of content : DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Segment.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.raised) {
            className += " raised";
        }
        if (props.stacked) {
            className += " stacked";
        }
        if (props.tallStacked) {
            className += " tall stacked";
        }
        if (props.piled) {
            className += " piled";
        }
        if (props.vertical) {
            className += " vertical";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.veryPadded) {
            className += " very padded";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.clearing) {
            className += " clearing";
        }
        if (props.basic) {
            className += " basic";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        className += " segment";
        return className;
    }
})(Segment = exports.Segment || (exports.Segment = {}));


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(9);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Steps;
(function (Steps) {
    /**
     * A steps component to show the completion status of a series of activities.
     * Accepts the following properties in props$:
     *  link?: boolean - Styles to steps to display as a link.
     * 	vertical?: boolean - Styles the steps to align vertically.
     * 	stackable?: boolean - Lets the steps realign vertically on smaller screens.
     * 	evenlyDivided?: boolean - Arranges the steps to take up equal amount of width of their parent.
     * 	fluid?: boolean - Styles the steps to take up the full width of their parent.
     * 	size?: Size - The size of the steps.
     * 	attachment?: Attachment - Styles the steps to appear attached to nearby content.
     * Expects the following type of content in content$: Array of {}
     * 	icon?: DOMContent The icon to use for the step.
     * 	header?: DOMContent - The title for the step.
     * 	description?: DOMContent - The description for the step.
     * 	isCompleted?: boolean - Marks the step as completed.
     * 	isActive?: boolean - Marks the step as the current step.
     * 	isDisabled?: boolean - Marks the step as disabled.
     *  link?: boolean - Style the step to be clickable.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            var evt = function (type) { return sources.DOM.select(".step").events(type); };
            return {
                DOM: vTree$,
                Events: evt,
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Steps.run = run;
    /**
     * A steps component to show the completion status of a series of activities.
     * Accepts the following properties:
     *  link?: boolean - Styles to steps to display as a link.
     * 	vertical?: boolean - Styles the steps to align vertically.
     * 	stackable?: boolean - Lets the steps realign vertically on smaller screens.
     * 	evenlyDivided?: boolean - Arranges the steps to take up equal amount of width of their parent.
     * 	fluid?: boolean - Styles the steps to take up the full width of their parent.
     * 	size?: Size - The size of the steps.
     * 	attachment?: Attachment - Styles the steps to appear attached to nearby content.
     * Expects the following type of content: Array of {}
     * 	icon?: DOMContent The icon to use for the step.
     * 	header?: DOMContent - The title for the step.
     * 	description?: DOMContent - The description for the step.
     * 	isCompleted?: boolean - Marks the step as completed.
     * 	isActive?: boolean - Marks the step as the current step.
     * 	isDisabled?: boolean - Marks the step as disabled.
     *  link?: boolean - Style the step to be clickable.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = pOrC instanceof Array ? {} : pOrC;
        var content = pOrC instanceof Array ? pOrC : c;
        var children = content.map(function (_a, i) {
            var icon = _a.icon, header = _a.header, description = _a.description, isCompleted = _a.isCompleted, isActive = _a.isActive, isDisabled = _a.isDisabled, link = _a.link;
            return props.link
                ? dom_1.a({ props: { id: i, className: getStepClassname(isCompleted, isActive, isDisabled, link) } }, [
                    icon,
                    dom_1.div({ props: { className: "content" } }, [
                        dom_1.div({ props: { className: "title" } }, header),
                        dom_1.div({ props: { className: "description" } }, description)
                    ])
                ])
                : dom_1.div({ props: { id: i, className: getStepClassname(isCompleted, isActive, isDisabled, link) } }, [
                    icon,
                    dom_1.div({ props: { className: "content" } }, [
                        dom_1.div({ props: { className: "title" } }, header),
                        dom_1.div({ props: { className: "description" } }, description)
                    ])
                ]);
        });
        return dom_1.div({ props: { className: getClassname(props, content.length) } }, children);
    }
    Steps.render = render;
    function getStepClassname(isCompleted, isActive, isDisabled, link) {
        var className = "";
        if (isActive) {
            className += "active";
        }
        if (isCompleted) {
            className += " completed";
        }
        if (isDisabled) {
            className += " disabled";
        }
        if (link) {
            className += " link";
        }
        className += " step";
        return className;
    }
    function getClassname(props, length) {
        var className = "ui";
        if (props.vertical) {
            className += " vertical";
        }
        if (props.stackable) {
            className += " stackable";
        }
        if (props.fluid) {
            className += " fluid";
        }
        if (props.evenlyDivided) {
            className += utils_1.numToText(length);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        className += " steps";
        return className;
    }
})(Steps = exports.Steps || (exports.Steps = {}));


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Textbox;
(function (Textbox) {
    /**
     * A textbox component for capturing user input.
     * Accepts the following properties in props$:
     *   initial?: string - The initial value of the textbox.
     *   placeholder?: string - The placeholder text of the textbox.
     *   icon?: boolean - Styles the textbox for displaying an icon in the textbox.
     *   labeled?: boolean - Styles the textbox for displaying a label in the textbox.
     *   action?: boolean - Styles the textbox for displaying an action component in the textbox.
     *   leftContent?: boolean - Adds content to the left side of the textbox.
     *   rightContent?: boolean - Adds content to the right side of the textbox.
     *   transparent?: boolean - Styles the textbox to appear transparent.
     *   inverted?: boolean - Styles the textbox for darker backgrounds.
     *   focus?: boolean - Styles the textbox to show it has focus.
     *   loading?: boolean - Styles the textbox with a loading icon.
     *   disabled?: boolean - Styles the textbox to appear disabled.
     *   color?: Color - The color of the textbox.
     *   size?: Size - The size of the textbox.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var evt = function (type) { return sources.DOM.select(".input").events(type); };
            var props$ = sources.props$.remember();
            // const initialValue$ = props$.map(props => props.initial);
            var newValue$ = evt("input").map(function (ev) { return ev.target.value; }).remember();
            // const value$ = xs.merge(initialValue$, newValue$);
            var vtree$ = xstream_1.default.combine(props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vtree$,
                Events: evt,
                value$: newValue$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Textbox.run = run;
    /**
     * A textbox component for capturing user input.
     * Accepts the following properties:
     *   initial?: string - The initial value of the textbox.
     *   placeholder?: string - The placeholder text of the textbox.
     *   icon?: boolean - Styles the textbox for displaying an icon in the textbox.
     *   labeled?: boolean - Styles the textbox for displaying a label in the textbox.
     *   action?: boolean - Styles the textbox for displaying an action component in the textbox.
     *   leftContent?: boolean - Adds content to the left side of the textbox.
     *   rightContent?: boolean - Adds content to the right side of the textbox.
     *   transparent?: boolean - Styles the textbox to appear transparent.
     *   inverted?: boolean - Styles the textbox for darker backgrounds.
     *   focus?: boolean - Styles the textbox to show it has focus.
     *   loading?: boolean - Styles the textbox with a loading icon.
     *   disabled?: boolean - Styles the textbox to appear disabled.
     *   color?: Color - The color of the textbox.
     *   size?: Size - The size of the textbox.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var textbox = props.large
            ? dom_1.textarea({ props: { value: props.initial, placeholder: props.placeholder } })
            : dom_1.input({ props: { type: props.type ? props.type : "text", value: props.initial, placeholder: props.placeholder } });
        return props.rightContent
            ? dom_1.div({ props: { className: getClassname(props) } }, [
                textbox,
                content
            ])
            : dom_1.div({ props: { className: getClassname(props) } }, [
                content,
                textbox
            ]);
    }
    Textbox.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.leftContent) {
            className += " left";
        }
        if (props.rightContent) {
            className += " right";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.labeled) {
            className += " labeled";
        }
        if (props.action) {
            className += " action";
        }
        if (props.transparent) {
            className += " transparent";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.focus) {
            className += " focus";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " input";
        return className;
    }
})(Textbox = exports.Textbox || (exports.Textbox = {}));


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IconType;
(function (IconType) {
    function ToClassname(type) {
        if (type < 0)
            return "";
        var name = IconType[type];
        return " " + name.match(/[A-Z][a-z]+/g).join(" ").toLowerCase();
    }
    IconType.ToClassname = ToClassname;
    function GetNames() {
        var names = [];
        for (var n in IconType) {
            if (typeof IconType[n] === 'number')
                names.push(n);
        }
        return names;
    }
    IconType.GetNames = GetNames;
})(IconType = exports.IconType || (exports.IconType = {}));
(function (IconType) {
    IconType[IconType["Search"] = 0] = "Search";
    IconType[IconType["MailOutline"] = 1] = "MailOutline";
    IconType[IconType["External"] = 2] = "External";
    IconType[IconType["Signal"] = 3] = "Signal";
    IconType[IconType["Setting"] = 4] = "Setting";
    IconType[IconType["Home"] = 5] = "Home";
    IconType[IconType["Inbox"] = 6] = "Inbox";
    IconType[IconType["Browser"] = 7] = "Browser";
    IconType[IconType["Tag"] = 8] = "Tag";
    IconType[IconType["Tags"] = 9] = "Tags";
    IconType[IconType["Calendar"] = 10] = "Calendar";
    IconType[IconType["Comment"] = 11] = "Comment";
    IconType[IconType["Comments"] = 12] = "Comments";
    IconType[IconType["Shop"] = 13] = "Shop";
    IconType[IconType["Privacy"] = 14] = "Privacy";
    IconType[IconType["Settings"] = 15] = "Settings";
    IconType[IconType["Trophy"] = 16] = "Trophy";
    IconType[IconType["Payment"] = 17] = "Payment";
    IconType[IconType["Feed"] = 18] = "Feed";
    IconType[IconType["AlarmOutline"] = 19] = "AlarmOutline";
    IconType[IconType["Tasks"] = 20] = "Tasks";
    IconType[IconType["Cloud"] = 21] = "Cloud";
    IconType[IconType["Lab"] = 22] = "Lab";
    IconType[IconType["Mail"] = 23] = "Mail";
    IconType[IconType["Idea"] = 24] = "Idea";
    IconType[IconType["Dashboard"] = 25] = "Dashboard";
    IconType[IconType["Sitemap"] = 26] = "Sitemap";
    IconType[IconType["Alarm"] = 27] = "Alarm";
    IconType[IconType["Terminal"] = 28] = "Terminal";
    IconType[IconType["Code"] = 29] = "Code";
    IconType[IconType["Protect"] = 30] = "Protect";
    IconType[IconType["CalendarOutline"] = 31] = "CalendarOutline";
    IconType[IconType["Ticket"] = 32] = "Ticket";
    IconType[IconType["ExternalSquare"] = 33] = "ExternalSquare";
    IconType[IconType["Map"] = 34] = "Map";
    IconType[IconType["Bug"] = 35] = "Bug";
    IconType[IconType["MailSquare"] = 36] = "MailSquare";
    IconType[IconType["History"] = 37] = "History";
    IconType[IconType["Options"] = 38] = "Options";
    IconType[IconType["CommentOutline"] = 39] = "CommentOutline";
    IconType[IconType["CommentsOutline"] = 40] = "CommentsOutline";
    IconType[IconType["TextTelephone"] = 41] = "TextTelephone";
    IconType[IconType["Find"] = 42] = "Find";
    IconType[IconType["Wifi"] = 43] = "Wifi";
    IconType[IconType["AlarmSlash"] = 44] = "AlarmSlash";
    IconType[IconType["AlarmSlashOutline"] = 45] = "AlarmSlashOutline";
    IconType[IconType["Copyright"] = 46] = "Copyright";
    IconType[IconType["At"] = 47] = "At";
    IconType[IconType["Eyedropper"] = 48] = "Eyedropper";
    IconType[IconType["PaintBrush"] = 49] = "PaintBrush";
    IconType[IconType["Heartbeat"] = 50] = "Heartbeat";
    IconType[IconType["Download"] = 51] = "Download";
    IconType[IconType["Repeat"] = 52] = "Repeat";
    IconType[IconType["Refresh"] = 53] = "Refresh";
    IconType[IconType["Lock"] = 54] = "Lock";
    IconType[IconType["Bookmark"] = 55] = "Bookmark";
    IconType[IconType["Print"] = 56] = "Print";
    IconType[IconType["Write"] = 57] = "Write";
    IconType[IconType["Theme"] = 58] = "Theme";
    IconType[IconType["Adjust"] = 59] = "Adjust";
    IconType[IconType["Edit"] = 60] = "Edit";
    IconType[IconType["ExternalShare"] = 61] = "ExternalShare";
    IconType[IconType["Ban"] = 62] = "Ban";
    IconType[IconType["MailForward"] = 63] = "MailForward";
    IconType[IconType["Share"] = 64] = "Share";
    IconType[IconType["Expand"] = 65] = "Expand";
    IconType[IconType["Compress"] = 66] = "Compress";
    IconType[IconType["Unhide"] = 67] = "Unhide";
    IconType[IconType["Hide"] = 68] = "Hide";
    IconType[IconType["Random"] = 69] = "Random";
    IconType[IconType["Retweet"] = 70] = "Retweet";
    IconType[IconType["SignOut"] = 71] = "SignOut";
    IconType[IconType["Pin"] = 72] = "Pin";
    IconType[IconType["SignIn"] = 73] = "SignIn";
    IconType[IconType["Upload"] = 74] = "Upload";
    IconType[IconType["Call"] = 75] = "Call";
    IconType[IconType["CallSquare"] = 76] = "CallSquare";
    IconType[IconType["RemoveBookmark"] = 77] = "RemoveBookmark";
    IconType[IconType["Unlock"] = 78] = "Unlock";
    IconType[IconType["Configure"] = 79] = "Configure";
    IconType[IconType["Filter"] = 80] = "Filter";
    IconType[IconType["Wizard"] = 81] = "Wizard";
    IconType[IconType["Undo"] = 82] = "Undo";
    IconType[IconType["Exchange"] = 83] = "Exchange";
    IconType[IconType["CloudDownload"] = 84] = "CloudDownload";
    IconType[IconType["CloudUpload"] = 85] = "CloudUpload";
    IconType[IconType["Reply"] = 86] = "Reply";
    IconType[IconType["ReplyAll"] = 87] = "ReplyAll";
    IconType[IconType["Erase"] = 88] = "Erase";
    IconType[IconType["UnlockAlternate"] = 89] = "UnlockAlternate";
    IconType[IconType["Archive"] = 90] = "Archive";
    IconType[IconType["Translate"] = 91] = "Translate";
    IconType[IconType["Recycle"] = 92] = "Recycle";
    IconType[IconType["Send"] = 93] = "Send";
    IconType[IconType["SendOutline"] = 94] = "SendOutline";
    IconType[IconType["ShareAlternate"] = 95] = "ShareAlternate";
    IconType[IconType["ShareAlternateSquare"] = 96] = "ShareAlternateSquare";
    IconType[IconType["Wait"] = 97] = "Wait";
    IconType[IconType["WriteSquare"] = 98] = "WriteSquare";
    IconType[IconType["ShareSquare"] = 99] = "ShareSquare";
    IconType[IconType["AddToCart"] = 100] = "AddToCart";
    IconType[IconType["InCart"] = 101] = "InCart";
    IconType[IconType["AddUser"] = 102] = "AddUser";
    IconType[IconType["RemoveUser"] = 103] = "RemoveUser";
    IconType[IconType["HelpCircle"] = 104] = "HelpCircle";
    IconType[IconType["InfoCircle"] = 105] = "InfoCircle";
    IconType[IconType["Warning"] = 106] = "Warning";
    IconType[IconType["WarningCircle"] = 107] = "WarningCircle";
    IconType[IconType["WarningSign"] = 108] = "WarningSign";
    IconType[IconType["Help"] = 109] = "Help";
    IconType[IconType["Info"] = 110] = "Info";
    IconType[IconType["Announcement"] = 111] = "Announcement";
    IconType[IconType["Birthday"] = 112] = "Birthday";
    IconType[IconType["Users"] = 113] = "Users";
    IconType[IconType["Doctor"] = 114] = "Doctor";
    IconType[IconType["Child"] = 115] = "Child";
    IconType[IconType["User"] = 116] = "User";
    IconType[IconType["Handicap"] = 117] = "Handicap";
    IconType[IconType["Student"] = 118] = "Student";
    IconType[IconType["Spy"] = 119] = "Spy";
    IconType[IconType["GridLayout"] = 120] = "GridLayout";
    IconType[IconType["ListLayout"] = 121] = "ListLayout";
    IconType[IconType["BlockLayout"] = 122] = "BlockLayout";
    IconType[IconType["Zoom"] = 123] = "Zoom";
    IconType[IconType["ZoomOut"] = 124] = "ZoomOut";
    IconType[IconType["ResizeVertical"] = 125] = "ResizeVertical";
    IconType[IconType["ResizeHorizontal"] = 126] = "ResizeHorizontal";
    IconType[IconType["Maximize"] = 127] = "Maximize";
    IconType[IconType["Crop"] = 128] = "Crop";
    IconType[IconType["Female"] = 129] = "Female";
    IconType[IconType["Male"] = 130] = "Male";
    IconType[IconType["Woman"] = 131] = "Woman";
    IconType[IconType["Man"] = 132] = "Man";
    IconType[IconType["NonBinaryTransgender"] = 133] = "NonBinaryTransgender";
    IconType[IconType["Intergender"] = 134] = "Intergender";
    IconType[IconType["Transgender"] = 135] = "Transgender";
    IconType[IconType["Lesbian"] = 136] = "Lesbian";
    IconType[IconType["Gay"] = 137] = "Gay";
    IconType[IconType["Heterosexual"] = 138] = "Heterosexual";
    IconType[IconType["OtherGender"] = 139] = "OtherGender";
    IconType[IconType["OtherGenderVertical"] = 140] = "OtherGenderVertical";
    IconType[IconType["OtherGenderHorizontal"] = 141] = "OtherGenderHorizontal";
    IconType[IconType["Neuter"] = 142] = "Neuter";
    IconType[IconType["Cocktail"] = 143] = "Cocktail";
    IconType[IconType["Road"] = 144] = "Road";
    IconType[IconType["Flag"] = 145] = "Flag";
    IconType[IconType["Book"] = 146] = "Book";
    IconType[IconType["Gift"] = 147] = "Gift";
    IconType[IconType["Leaf"] = 148] = "Leaf";
    IconType[IconType["Fire"] = 149] = "Fire";
    IconType[IconType["Plane"] = 150] = "Plane";
    IconType[IconType["Magnet"] = 151] = "Magnet";
    IconType[IconType["Legal"] = 152] = "Legal";
    IconType[IconType["Lemon"] = 153] = "Lemon";
    IconType[IconType["World"] = 154] = "World";
    IconType[IconType["Travel"] = 155] = "Travel";
    IconType[IconType["Shipping"] = 156] = "Shipping";
    IconType[IconType["Money"] = 157] = "Money";
    IconType[IconType["Lightning"] = 158] = "Lightning";
    IconType[IconType["Rain"] = 159] = "Rain";
    IconType[IconType["Treatment"] = 160] = "Treatment";
    IconType[IconType["Suitcase"] = 161] = "Suitcase";
    IconType[IconType["Bar"] = 162] = "Bar";
    IconType[IconType["FlagOutline"] = 163] = "FlagOutline";
    IconType[IconType["FlagCheckered"] = 164] = "FlagCheckered";
    IconType[IconType["Puzzle"] = 165] = "Puzzle";
    IconType[IconType["FireExtinguisher"] = 166] = "FireExtinguisher";
    IconType[IconType["Rocket"] = 167] = "Rocket";
    IconType[IconType["Anchor"] = 168] = "Anchor";
    IconType[IconType["Bullseye"] = 169] = "Bullseye";
    IconType[IconType["Sun"] = 170] = "Sun";
    IconType[IconType["Moon"] = 171] = "Moon";
    IconType[IconType["Fax"] = 172] = "Fax";
    IconType[IconType["LifeRing"] = 173] = "LifeRing";
    IconType[IconType["Bomb"] = 174] = "Bomb";
    IconType[IconType["Soccer"] = 175] = "Soccer";
    IconType[IconType["Calculator"] = 176] = "Calculator";
    IconType[IconType["Diamond"] = 177] = "Diamond";
    IconType[IconType["Crosshairs"] = 178] = "Crosshairs";
    IconType[IconType["Asterisk"] = 179] = "Asterisk";
    IconType[IconType["Certificate"] = 180] = "Certificate";
    IconType[IconType["Circle"] = 181] = "Circle";
    IconType[IconType["QuoteLeft"] = 182] = "QuoteLeft";
    IconType[IconType["QuoteRight"] = 183] = "QuoteRight";
    IconType[IconType["EllipsisHorizontal"] = 184] = "EllipsisHorizontal";
    IconType[IconType["EllipsisVertical"] = 185] = "EllipsisVertical";
    IconType[IconType["Cube"] = 186] = "Cube";
    IconType[IconType["Cubes"] = 187] = "Cubes";
    IconType[IconType["CircleNotched"] = 188] = "CircleNotched";
    IconType[IconType["CircleThin"] = 189] = "CircleThin";
    IconType[IconType["SquareOutline"] = 190] = "SquareOutline";
    IconType[IconType["Square"] = 191] = "Square";
    IconType[IconType["Checkmark"] = 192] = "Checkmark";
    IconType[IconType["Remove"] = 193] = "Remove";
    IconType[IconType["CheckmarkBox"] = 194] = "CheckmarkBox";
    IconType[IconType["Move"] = 195] = "Move";
    IconType[IconType["AddCircle"] = 196] = "AddCircle";
    IconType[IconType["MinusCircle"] = 197] = "MinusCircle";
    IconType[IconType["RemoveCircle"] = 198] = "RemoveCircle";
    IconType[IconType["CheckCircle"] = 199] = "CheckCircle";
    IconType[IconType["RemoveCircleOutline"] = 200] = "RemoveCircleOutline";
    IconType[IconType["CheckCircleOutline"] = 201] = "CheckCircleOutline";
    IconType[IconType["Plus"] = 202] = "Plus";
    IconType[IconType["Minus"] = 203] = "Minus";
    IconType[IconType["AddSquare"] = 204] = "AddSquare";
    IconType[IconType["Radio"] = 205] = "Radio";
    IconType[IconType["SelectedRadio"] = 206] = "SelectedRadio";
    IconType[IconType["MinusSquare"] = 207] = "MinusSquare";
    IconType[IconType["MinusSquareOutline"] = 208] = "MinusSquareOutline";
    IconType[IconType["CheckSquare"] = 209] = "CheckSquare";
    IconType[IconType["PlusSquareOutline"] = 210] = "PlusSquareOutline";
    IconType[IconType["ToggleOff"] = 211] = "ToggleOff";
    IconType[IconType["ToggleOn"] = 212] = "ToggleOn";
    IconType[IconType["Film"] = 213] = "Film";
    IconType[IconType["Sound"] = 214] = "Sound";
    IconType[IconType["Photo"] = 215] = "Photo";
    IconType[IconType["BarChart"] = 216] = "BarChart";
    IconType[IconType["CameraRetro"] = 217] = "CameraRetro";
    IconType[IconType["Newspaper"] = 218] = "Newspaper";
    IconType[IconType["AreaChart"] = 219] = "AreaChart";
    IconType[IconType["PieChart"] = 220] = "PieChart";
    IconType[IconType["LineChart"] = 221] = "LineChart";
    IconType[IconType["ArrowCircleOutlineDown"] = 222] = "ArrowCircleOutlineDown";
    IconType[IconType["ArrowCircleOutlineUp"] = 223] = "ArrowCircleOutlineUp";
    IconType[IconType["ChevronLeft"] = 224] = "ChevronLeft";
    IconType[IconType["ChevronRight"] = 225] = "ChevronRight";
    IconType[IconType["ArrowLeft"] = 226] = "ArrowLeft";
    IconType[IconType["ArrowRight"] = 227] = "ArrowRight";
    IconType[IconType["ArrowUp"] = 228] = "ArrowUp";
    IconType[IconType["ArrowDown"] = 229] = "ArrowDown";
    IconType[IconType["ChevronUp"] = 230] = "ChevronUp";
    IconType[IconType["ChevronDown"] = 231] = "ChevronDown";
    IconType[IconType["PointingRight"] = 232] = "PointingRight";
    IconType[IconType["PointingLeft"] = 233] = "PointingLeft";
    IconType[IconType["PointingUp"] = 234] = "PointingUp";
    IconType[IconType["PointingDown"] = 235] = "PointingDown";
    IconType[IconType["ArrowCircleLeft"] = 236] = "ArrowCircleLeft";
    IconType[IconType["ArrowCircleRight"] = 237] = "ArrowCircleRight";
    IconType[IconType["ArrowCircleUp"] = 238] = "ArrowCircleUp";
    IconType[IconType["ArrowCircleDown"] = 239] = "ArrowCircleDown";
    IconType[IconType["CaretDown"] = 240] = "CaretDown";
    IconType[IconType["CaretUp"] = 241] = "CaretUp";
    IconType[IconType["CaretLeft"] = 242] = "CaretLeft";
    IconType[IconType["CaretRight"] = 243] = "CaretRight";
    IconType[IconType["AngleDoubleLeft"] = 244] = "AngleDoubleLeft";
    IconType[IconType["AngleDoubleRight"] = 245] = "AngleDoubleRight";
    IconType[IconType["AngleDoubleUp"] = 246] = "AngleDoubleUp";
    IconType[IconType["AngleDoubleDown"] = 247] = "AngleDoubleDown";
    IconType[IconType["AngleLeft"] = 248] = "AngleLeft";
    IconType[IconType["AngleRight"] = 249] = "AngleRight";
    IconType[IconType["AngleUp"] = 250] = "AngleUp";
    IconType[IconType["AngleDown"] = 251] = "AngleDown";
    IconType[IconType["ChevronCircleLeft"] = 252] = "ChevronCircleLeft";
    IconType[IconType["ChevronCircleRight"] = 253] = "ChevronCircleRight";
    IconType[IconType["ChevronCircleUp"] = 254] = "ChevronCircleUp";
    IconType[IconType["ChevronCircleDown"] = 255] = "ChevronCircleDown";
    IconType[IconType["ToggleDown"] = 256] = "ToggleDown";
    IconType[IconType["ToggleUp"] = 257] = "ToggleUp";
    IconType[IconType["ToggleRight"] = 258] = "ToggleRight";
    IconType[IconType["LongArrowDown"] = 259] = "LongArrowDown";
    IconType[IconType["LongArrowUp"] = 260] = "LongArrowUp";
    IconType[IconType["LongArrowLeft"] = 261] = "LongArrowLeft";
    IconType[IconType["LongArrowRight"] = 262] = "LongArrowRight";
    IconType[IconType["ArrowCircleOutlineRight"] = 263] = "ArrowCircleOutlineRight";
    IconType[IconType["ArrowCircleOutlineLeft"] = 264] = "ArrowCircleOutlineLeft";
    IconType[IconType["ToggleLeft"] = 265] = "ToggleLeft";
    IconType[IconType["Power"] = 266] = "Power";
    IconType[IconType["Trash"] = 267] = "Trash";
    IconType[IconType["TrashOutline"] = 268] = "TrashOutline";
    IconType[IconType["DiskOutline"] = 269] = "DiskOutline";
    IconType[IconType["Desktop"] = 270] = "Desktop";
    IconType[IconType["Laptop"] = 271] = "Laptop";
    IconType[IconType["Tablet"] = 272] = "Tablet";
    IconType[IconType["Mobile"] = 273] = "Mobile";
    IconType[IconType["Game"] = 274] = "Game";
    IconType[IconType["Keyboard"] = 275] = "Keyboard";
    IconType[IconType["Plug"] = 276] = "Plug";
    IconType[IconType["Folder"] = 277] = "Folder";
    IconType[IconType["FolderOpen"] = 278] = "FolderOpen";
    IconType[IconType["LevelUp"] = 279] = "LevelUp";
    IconType[IconType["LevelDown"] = 280] = "LevelDown";
    IconType[IconType["File"] = 281] = "File";
    IconType[IconType["FileOutline"] = 282] = "FileOutline";
    IconType[IconType["FileText"] = 283] = "FileText";
    IconType[IconType["FileTextOutline"] = 284] = "FileTextOutline";
    IconType[IconType["FolderOutline"] = 285] = "FolderOutline";
    IconType[IconType["FolderOpenOutline"] = 286] = "FolderOpenOutline";
    IconType[IconType["FilePdfOutline"] = 287] = "FilePdfOutline";
    IconType[IconType["FileWordOutline"] = 288] = "FileWordOutline";
    IconType[IconType["FileExcelOutline"] = 289] = "FileExcelOutline";
    IconType[IconType["FilePowerpointOutline"] = 290] = "FilePowerpointOutline";
    IconType[IconType["FileImageOutline"] = 291] = "FileImageOutline";
    IconType[IconType["FileArchiveOutline"] = 292] = "FileArchiveOutline";
    IconType[IconType["FileAudioOutline"] = 293] = "FileAudioOutline";
    IconType[IconType["FileVideoOutline"] = 294] = "FileVideoOutline";
    IconType[IconType["FileCodeOutline"] = 295] = "FileCodeOutline";
    IconType[IconType["Barcode"] = 296] = "Barcode";
    IconType[IconType["Qrcode"] = 297] = "Qrcode";
    IconType[IconType["Fork"] = 298] = "Fork";
    IconType[IconType["Html5"] = 299] = "Html5";
    IconType[IconType["Css3"] = 300] = "Css3";
    IconType[IconType["Rss"] = 301] = "Rss";
    IconType[IconType["RssSquare"] = 302] = "RssSquare";
    IconType[IconType["Openid"] = 303] = "Openid";
    IconType[IconType["Database"] = 304] = "Database";
    IconType[IconType["Server"] = 305] = "Server";
    IconType[IconType["Heart"] = 306] = "Heart";
    IconType[IconType["Star"] = 307] = "Star";
    IconType[IconType["EmptyStar"] = 308] = "EmptyStar";
    IconType[IconType["ThumbsOutlineUp"] = 309] = "ThumbsOutlineUp";
    IconType[IconType["ThumbsOutlineDown"] = 310] = "ThumbsOutlineDown";
    IconType[IconType["StarHalf"] = 311] = "StarHalf";
    IconType[IconType["EmptyHeart"] = 312] = "EmptyHeart";
    IconType[IconType["Smile"] = 313] = "Smile";
    IconType[IconType["Frown"] = 314] = "Frown";
    IconType[IconType["Meh"] = 315] = "Meh";
    IconType[IconType["StarHalfEmpty"] = 316] = "StarHalfEmpty";
    IconType[IconType["ThumbsUp"] = 317] = "ThumbsUp";
    IconType[IconType["ThumbsDown"] = 318] = "ThumbsDown";
    IconType[IconType["Music"] = 319] = "Music";
    IconType[IconType["VideoPlayOutline"] = 320] = "VideoPlayOutline";
    IconType[IconType["VolumeOff"] = 321] = "VolumeOff";
    IconType[IconType["VolumeDown"] = 322] = "VolumeDown";
    IconType[IconType["VolumeUp"] = 323] = "VolumeUp";
    IconType[IconType["Record"] = 324] = "Record";
    IconType[IconType["StepBackward"] = 325] = "StepBackward";
    IconType[IconType["FastBackward"] = 326] = "FastBackward";
    IconType[IconType["Backward"] = 327] = "Backward";
    IconType[IconType["Play"] = 328] = "Play";
    IconType[IconType["Pause"] = 329] = "Pause";
    IconType[IconType["Stop"] = 330] = "Stop";
    IconType[IconType["Forward"] = 331] = "Forward";
    IconType[IconType["FastForward"] = 332] = "FastForward";
    IconType[IconType["StepForward"] = 333] = "StepForward";
    IconType[IconType["Eject"] = 334] = "Eject";
    IconType[IconType["Unmute"] = 335] = "Unmute";
    IconType[IconType["Mute"] = 336] = "Mute";
    IconType[IconType["VideoPlay"] = 337] = "VideoPlay";
    IconType[IconType["ClosedCaptioning"] = 338] = "ClosedCaptioning";
    IconType[IconType["Marker"] = 339] = "Marker";
    IconType[IconType["Coffee"] = 340] = "Coffee";
    IconType[IconType["Food"] = 341] = "Food";
    IconType[IconType["BuildingOutline"] = 342] = "BuildingOutline";
    IconType[IconType["Hospital"] = 343] = "Hospital";
    IconType[IconType["Emergency"] = 344] = "Emergency";
    IconType[IconType["FirstAid"] = 345] = "FirstAid";
    IconType[IconType["Military"] = 346] = "Military";
    IconType[IconType["H"] = 347] = "H";
    IconType[IconType["LocationArrow"] = 348] = "LocationArrow";
    IconType[IconType["SpaceShuttle"] = 349] = "SpaceShuttle";
    IconType[IconType["University"] = 350] = "University";
    IconType[IconType["Building"] = 351] = "Building";
    IconType[IconType["Paw"] = 352] = "Paw";
    IconType[IconType["Spoon"] = 353] = "Spoon";
    IconType[IconType["Car"] = 354] = "Car";
    IconType[IconType["Taxi"] = 355] = "Taxi";
    IconType[IconType["Tree"] = 356] = "Tree";
    IconType[IconType["Bicycle"] = 357] = "Bicycle";
    IconType[IconType["Bus"] = 358] = "Bus";
    IconType[IconType["Ship"] = 359] = "Ship";
    IconType[IconType["Motorcycle"] = 360] = "Motorcycle";
    IconType[IconType["StreetView"] = 361] = "StreetView";
    IconType[IconType["Hotel"] = 362] = "Hotel";
    IconType[IconType["Train"] = 363] = "Train";
    IconType[IconType["Subway"] = 364] = "Subway";
    IconType[IconType["Table"] = 365] = "Table";
    IconType[IconType["Columns"] = 366] = "Columns";
    IconType[IconType["Sort"] = 367] = "Sort";
    IconType[IconType["SortAscending"] = 368] = "SortAscending";
    IconType[IconType["SortDescending"] = 369] = "SortDescending";
    IconType[IconType["SortAlphabetAscending"] = 370] = "SortAlphabetAscending";
    IconType[IconType["SortAlphabetDescending"] = 371] = "SortAlphabetDescending";
    IconType[IconType["SortContentAscending"] = 372] = "SortContentAscending";
    IconType[IconType["SortContentDescending"] = 373] = "SortContentDescending";
    IconType[IconType["SortNumericAscending"] = 374] = "SortNumericAscending";
    IconType[IconType["SortNumericDescending"] = 375] = "SortNumericDescending";
    IconType[IconType["Font"] = 376] = "Font";
    IconType[IconType["Bold"] = 377] = "Bold";
    IconType[IconType["Italic"] = 378] = "Italic";
    IconType[IconType["TextHeight"] = 379] = "TextHeight";
    IconType[IconType["TextWidth"] = 380] = "TextWidth";
    IconType[IconType["AlignLeft"] = 381] = "AlignLeft";
    IconType[IconType["AlignCenter"] = 382] = "AlignCenter";
    IconType[IconType["AlignRight"] = 383] = "AlignRight";
    IconType[IconType["AlignJustify"] = 384] = "AlignJustify";
    IconType[IconType["List"] = 385] = "List";
    IconType[IconType["Outdent"] = 386] = "Outdent";
    IconType[IconType["Indent"] = 387] = "Indent";
    IconType[IconType["Linkify"] = 388] = "Linkify";
    IconType[IconType["Cut"] = 389] = "Cut";
    IconType[IconType["Copy"] = 390] = "Copy";
    IconType[IconType["Attach"] = 391] = "Attach";
    IconType[IconType["Save"] = 392] = "Save";
    IconType[IconType["Content"] = 393] = "Content";
    IconType[IconType["UnorderedList"] = 394] = "UnorderedList";
    IconType[IconType["OrderedList"] = 395] = "OrderedList";
    IconType[IconType["Strikethrough"] = 396] = "Strikethrough";
    IconType[IconType["Underline"] = 397] = "Underline";
    IconType[IconType["Paste"] = 398] = "Paste";
    IconType[IconType["Unlink"] = 399] = "Unlink";
    IconType[IconType["Superscript"] = 400] = "Superscript";
    IconType[IconType["Subscript"] = 401] = "Subscript";
    IconType[IconType["Header"] = 402] = "Header";
    IconType[IconType["Paragraph"] = 403] = "Paragraph";
    IconType[IconType["Euro"] = 404] = "Euro";
    IconType[IconType["Pound"] = 405] = "Pound";
    IconType[IconType["Dollar"] = 406] = "Dollar";
    IconType[IconType["Rupee"] = 407] = "Rupee";
    IconType[IconType["Yen"] = 408] = "Yen";
    IconType[IconType["Ruble"] = 409] = "Ruble";
    IconType[IconType["Won"] = 410] = "Won";
    IconType[IconType["Lira"] = 411] = "Lira";
    IconType[IconType["Shekel"] = 412] = "Shekel";
    IconType[IconType["Paypal"] = 413] = "Paypal";
    IconType[IconType["PaypalCard"] = 414] = "PaypalCard";
    IconType[IconType["GoogleWallet"] = 415] = "GoogleWallet";
    IconType[IconType["Visa"] = 416] = "Visa";
    IconType[IconType["Mastercard"] = 417] = "Mastercard";
    IconType[IconType["Discover"] = 418] = "Discover";
    IconType[IconType["AmericanExpress"] = 419] = "AmericanExpress";
    IconType[IconType["Stripe"] = 420] = "Stripe";
    IconType[IconType["TwitterSquare"] = 421] = "TwitterSquare";
    IconType[IconType["FacebookSquare"] = 422] = "FacebookSquare";
    IconType[IconType["LinkedinSquare"] = 423] = "LinkedinSquare";
    IconType[IconType["GithubSquare"] = 424] = "GithubSquare";
    IconType[IconType["Twitter"] = 425] = "Twitter";
    IconType[IconType["Facebook"] = 426] = "Facebook";
    IconType[IconType["Github"] = 427] = "Github";
    IconType[IconType["Pinterest"] = 428] = "Pinterest";
    IconType[IconType["PinterestSquare"] = 429] = "PinterestSquare";
    IconType[IconType["GooglePlusSquare"] = 430] = "GooglePlusSquare";
    IconType[IconType["GooglePlus"] = 431] = "GooglePlus";
    IconType[IconType["Linkedin"] = 432] = "Linkedin";
    IconType[IconType["GithubAlternate"] = 433] = "GithubAlternate";
    IconType[IconType["Maxcdn"] = 434] = "Maxcdn";
    IconType[IconType["Bitcoin"] = 435] = "Bitcoin";
    IconType[IconType["YoutubeSquare"] = 436] = "YoutubeSquare";
    IconType[IconType["Youtube"] = 437] = "Youtube";
    IconType[IconType["Xing"] = 438] = "Xing";
    IconType[IconType["XingSquare"] = 439] = "XingSquare";
    IconType[IconType["YoutubePlay"] = 440] = "YoutubePlay";
    IconType[IconType["Dropbox"] = 441] = "Dropbox";
    IconType[IconType["StackOverflow"] = 442] = "StackOverflow";
    IconType[IconType["Instagram"] = 443] = "Instagram";
    IconType[IconType["Flickr"] = 444] = "Flickr";
    IconType[IconType["Adn"] = 445] = "Adn";
    IconType[IconType["Bitbucket"] = 446] = "Bitbucket";
    IconType[IconType["BitbucketSquare"] = 447] = "BitbucketSquare";
    IconType[IconType["Tumblr"] = 448] = "Tumblr";
    IconType[IconType["TumblrSquare"] = 449] = "TumblrSquare";
    IconType[IconType["Apple"] = 450] = "Apple";
    IconType[IconType["Windows"] = 451] = "Windows";
    IconType[IconType["Android"] = 452] = "Android";
    IconType[IconType["Linux"] = 453] = "Linux";
    IconType[IconType["Dribbble"] = 454] = "Dribbble";
    IconType[IconType["Skype"] = 455] = "Skype";
    IconType[IconType["Foursquare"] = 456] = "Foursquare";
    IconType[IconType["Trello"] = 457] = "Trello";
    IconType[IconType["Gittip"] = 458] = "Gittip";
    IconType[IconType["Vk"] = 459] = "Vk";
    IconType[IconType["Weibo"] = 460] = "Weibo";
    IconType[IconType["Renren"] = 461] = "Renren";
    IconType[IconType["Pagelines"] = 462] = "Pagelines";
    IconType[IconType["StackExchange"] = 463] = "StackExchange";
    IconType[IconType["Vimeo"] = 464] = "Vimeo";
    IconType[IconType["Slack"] = 465] = "Slack";
    IconType[IconType["Wordpress"] = 466] = "Wordpress";
    IconType[IconType["Yahoo"] = 467] = "Yahoo";
    IconType[IconType["Google"] = 468] = "Google";
    IconType[IconType["Reddit"] = 469] = "Reddit";
    IconType[IconType["RedditSquare"] = 470] = "RedditSquare";
    IconType[IconType["StumbleuponCircle"] = 471] = "StumbleuponCircle";
    IconType[IconType["Stumbleupon"] = 472] = "Stumbleupon";
    IconType[IconType["Delicious"] = 473] = "Delicious";
    IconType[IconType["Digg"] = 474] = "Digg";
    IconType[IconType["PiedPiper"] = 475] = "PiedPiper";
    IconType[IconType["PiedPiperAlternate"] = 476] = "PiedPiperAlternate";
    IconType[IconType["Drupal"] = 477] = "Drupal";
    IconType[IconType["Joomla"] = 478] = "Joomla";
    IconType[IconType["Behance"] = 479] = "Behance";
    IconType[IconType["BehanceSquare"] = 480] = "BehanceSquare";
    IconType[IconType["Steam"] = 481] = "Steam";
    IconType[IconType["SteamSquare"] = 482] = "SteamSquare";
    IconType[IconType["Spotify"] = 483] = "Spotify";
    IconType[IconType["Deviantart"] = 484] = "Deviantart";
    IconType[IconType["Soundcloud"] = 485] = "Soundcloud";
    IconType[IconType["Vine"] = 486] = "Vine";
    IconType[IconType["Codepen"] = 487] = "Codepen";
    IconType[IconType["Jsfiddle"] = 488] = "Jsfiddle";
    IconType[IconType["Rebel"] = 489] = "Rebel";
    IconType[IconType["Empire"] = 490] = "Empire";
    IconType[IconType["GitSquare"] = 491] = "GitSquare";
    IconType[IconType["Git"] = 492] = "Git";
    IconType[IconType["HackerNews"] = 493] = "HackerNews";
    IconType[IconType["TencentWeibo"] = 494] = "TencentWeibo";
    IconType[IconType["Qq"] = 495] = "Qq";
    IconType[IconType["Wechat"] = 496] = "Wechat";
    IconType[IconType["Slideshare"] = 497] = "Slideshare";
    IconType[IconType["Twitch"] = 498] = "Twitch";
    IconType[IconType["Yelp"] = 499] = "Yelp";
    IconType[IconType["Lastfm"] = 500] = "Lastfm";
    IconType[IconType["LastfmSquare"] = 501] = "LastfmSquare";
    IconType[IconType["Ioxhost"] = 502] = "Ioxhost";
    IconType[IconType["Angellist"] = 503] = "Angellist";
    IconType[IconType["Meanpath"] = 504] = "Meanpath";
    IconType[IconType["Buysellads"] = 505] = "Buysellads";
    IconType[IconType["Connectdevelop"] = 506] = "Connectdevelop";
    IconType[IconType["Dashcube"] = 507] = "Dashcube";
    IconType[IconType["Forumbee"] = 508] = "Forumbee";
    IconType[IconType["Leanpub"] = 509] = "Leanpub";
    IconType[IconType["Sellsy"] = 510] = "Sellsy";
    IconType[IconType["Shirtsinbulk"] = 511] = "Shirtsinbulk";
    IconType[IconType["Simplybuilt"] = 512] = "Simplybuilt";
    IconType[IconType["Skyatlas"] = 513] = "Skyatlas";
    IconType[IconType["Whatsapp"] = 514] = "Whatsapp";
    IconType[IconType["Viacoin"] = 515] = "Viacoin";
    IconType[IconType["Medium"] = 516] = "Medium";
    IconType[IconType["Like"] = 517] = "Like";
    IconType[IconType["Favorite"] = 518] = "Favorite";
    IconType[IconType["Video"] = 519] = "Video";
    IconType[IconType["Check"] = 520] = "Check";
    IconType[IconType["Close"] = 521] = "Close";
    IconType[IconType["Cancel"] = 522] = "Cancel";
    IconType[IconType["Delete"] = 523] = "Delete";
    IconType[IconType["X"] = 524] = "X";
    IconType[IconType["UserTimes"] = 525] = "UserTimes";
    IconType[IconType["UserClose"] = 526] = "UserClose";
    IconType[IconType["UserCancel"] = 527] = "UserCancel";
    IconType[IconType["UserDelete"] = 528] = "UserDelete";
    IconType[IconType["UserX"] = 529] = "UserX";
    IconType[IconType["ZoomIn"] = 530] = "ZoomIn";
    IconType[IconType["Magnify"] = 531] = "Magnify";
    IconType[IconType["Shutdown"] = 532] = "Shutdown";
    IconType[IconType["Clock"] = 533] = "Clock";
    IconType[IconType["Time"] = 534] = "Time";
    IconType[IconType["PlayCircleOutline"] = 535] = "PlayCircleOutline";
    IconType[IconType["Headphone"] = 536] = "Headphone";
    IconType[IconType["Camera"] = 537] = "Camera";
    IconType[IconType["VideoCamera"] = 538] = "VideoCamera";
    IconType[IconType["Picture"] = 539] = "Picture";
    IconType[IconType["Pencil"] = 540] = "Pencil";
    IconType[IconType["Compose"] = 541] = "Compose";
    IconType[IconType["Point"] = 542] = "Point";
    IconType[IconType["Tint"] = 543] = "Tint";
    IconType[IconType["Signup"] = 544] = "Signup";
    IconType[IconType["PlusCircle"] = 545] = "PlusCircle";
    IconType[IconType["Dont"] = 546] = "Dont";
    IconType[IconType["Minimize"] = 547] = "Minimize";
    IconType[IconType["Add"] = 548] = "Add";
    IconType[IconType["Eye"] = 549] = "Eye";
    IconType[IconType["Attention"] = 550] = "Attention";
    IconType[IconType["Cart"] = 551] = "Cart";
    IconType[IconType["Shuffle"] = 552] = "Shuffle";
    IconType[IconType["Talk"] = 553] = "Talk";
    IconType[IconType["Chat"] = 554] = "Chat";
    IconType[IconType["ShoppingCart"] = 555] = "ShoppingCart";
    IconType[IconType["BarGraph"] = 556] = "BarGraph";
    IconType[IconType["AreaGraph"] = 557] = "AreaGraph";
    IconType[IconType["PieGraph"] = 558] = "PieGraph";
    IconType[IconType["LineGraph"] = 559] = "LineGraph";
    IconType[IconType["Key"] = 560] = "Key";
    IconType[IconType["Cogs"] = 561] = "Cogs";
    IconType[IconType["Discussions"] = 562] = "Discussions";
    IconType[IconType["LikeOutline"] = 563] = "LikeOutline";
    IconType[IconType["DislikeOutline"] = 564] = "DislikeOutline";
    IconType[IconType["HeartOutline"] = 565] = "HeartOutline";
    IconType[IconType["LogOut"] = 566] = "LogOut";
    IconType[IconType["ThumbTack"] = 567] = "ThumbTack";
    IconType[IconType["Winner"] = 568] = "Winner";
    IconType[IconType["BookmarkOutline"] = 569] = "BookmarkOutline";
    IconType[IconType["Phone"] = 570] = "Phone";
    IconType[IconType["PhoneSquare"] = 571] = "PhoneSquare";
    IconType[IconType["CreditCard"] = 572] = "CreditCard";
    IconType[IconType["HddOutline"] = 573] = "HddOutline";
    IconType[IconType["Bullhorn"] = 574] = "Bullhorn";
    IconType[IconType["Bell"] = 575] = "Bell";
    IconType[IconType["BellOutline"] = 576] = "BellOutline";
    IconType[IconType["BellSlash"] = 577] = "BellSlash";
    IconType[IconType["BellSlashOutline"] = 578] = "BellSlashOutline";
    IconType[IconType["HandOutlineRight"] = 579] = "HandOutlineRight";
    IconType[IconType["HandOutlineLeft"] = 580] = "HandOutlineLeft";
    IconType[IconType["HandOutlineUp"] = 581] = "HandOutlineUp";
    IconType[IconType["HandOutlineDown"] = 582] = "HandOutlineDown";
    IconType[IconType["Globe"] = 583] = "Globe";
    IconType[IconType["Wrench"] = 584] = "Wrench";
    IconType[IconType["Briefcase"] = 585] = "Briefcase";
    IconType[IconType["Group"] = 586] = "Group";
    IconType[IconType["Flask"] = 587] = "Flask";
    IconType[IconType["Sidebar"] = 588] = "Sidebar";
    IconType[IconType["Bars"] = 589] = "Bars";
    IconType[IconType["ListUl"] = 590] = "ListUl";
    IconType[IconType["ListOl"] = 591] = "ListOl";
    IconType[IconType["NumberedList"] = 592] = "NumberedList";
    IconType[IconType["Magic"] = 593] = "Magic";
    IconType[IconType["Truck"] = 594] = "Truck";
    IconType[IconType["Currency"] = 595] = "Currency";
    IconType[IconType["TriangleDown"] = 596] = "TriangleDown";
    IconType[IconType["Dropdown"] = 597] = "Dropdown";
    IconType[IconType["TriangleUp"] = 598] = "TriangleUp";
    IconType[IconType["TriangleLeft"] = 599] = "TriangleLeft";
    IconType[IconType["TriangleRight"] = 600] = "TriangleRight";
    IconType[IconType["Envelope"] = 601] = "Envelope";
    IconType[IconType["Conversation"] = 602] = "Conversation";
    IconType[IconType["Umbrella"] = 603] = "Umbrella";
    IconType[IconType["Clipboard"] = 604] = "Clipboard";
    IconType[IconType["Lightbulb"] = 605] = "Lightbulb";
    IconType[IconType["Ambulance"] = 606] = "Ambulance";
    IconType[IconType["Medkit"] = 607] = "Medkit";
    IconType[IconType["FighterJet"] = 608] = "FighterJet";
    IconType[IconType["Beer"] = 609] = "Beer";
    IconType[IconType["PlusSquare"] = 610] = "PlusSquare";
    IconType[IconType["Computer"] = 611] = "Computer";
    IconType[IconType["CircleOutline"] = 612] = "CircleOutline";
    IconType[IconType["Intersex"] = 613] = "Intersex";
    IconType[IconType["Asexual"] = 614] = "Asexual";
    IconType[IconType["Spinner"] = 615] = "Spinner";
    IconType[IconType["Gamepad"] = 616] = "Gamepad";
    IconType[IconType["StarHalfFull"] = 617] = "StarHalfFull";
    IconType[IconType["Question"] = 618] = "Question";
    IconType[IconType["Eraser"] = 619] = "Eraser";
    IconType[IconType["Microphone"] = 620] = "Microphone";
    IconType[IconType["MicrophoneSlash"] = 621] = "MicrophoneSlash";
    IconType[IconType["Shield"] = 622] = "Shield";
    IconType[IconType["Target"] = 623] = "Target";
    IconType[IconType["PlayCircle"] = 624] = "PlayCircle";
    IconType[IconType["PencilSquare"] = 625] = "PencilSquare";
    IconType[IconType["Compass"] = 626] = "Compass";
    IconType[IconType["Amex"] = 627] = "Amex";
    IconType[IconType["Eur"] = 628] = "Eur";
    IconType[IconType["Gbp"] = 629] = "Gbp";
    IconType[IconType["Usd"] = 630] = "Usd";
    IconType[IconType["Inr"] = 631] = "Inr";
    IconType[IconType["Cny"] = 632] = "Cny";
    IconType[IconType["Rmb"] = 633] = "Rmb";
    IconType[IconType["Jpy"] = 634] = "Jpy";
    IconType[IconType["Rouble"] = 635] = "Rouble";
    IconType[IconType["Rub"] = 636] = "Rub";
    IconType[IconType["Krw"] = 637] = "Krw";
    IconType[IconType["Btc"] = 638] = "Btc";
    IconType[IconType["Sheqel"] = 639] = "Sheqel";
    IconType[IconType["Ils"] = 640] = "Ils";
    IconType[IconType["Try"] = 641] = "Try";
    IconType[IconType["Zip"] = 642] = "Zip";
    IconType[IconType["DotCircleOutline"] = 643] = "DotCircleOutline";
    IconType[IconType["Sliders"] = 644] = "Sliders";
    IconType[IconType["Wi"] = 645] = "Wi";
    IconType[IconType["Graduation"] = 646] = "Graduation";
    IconType[IconType["Weixin"] = 647] = "Weixin";
    IconType[IconType["Binoculars"] = 648] = "Binoculars";
    IconType[IconType["Gratipay"] = 649] = "Gratipay";
    IconType[IconType["Genderless"] = 650] = "Genderless";
    IconType[IconType["Teletype"] = 651] = "Teletype";
    IconType[IconType["PowerCord"] = 652] = "PowerCord";
    IconType[IconType["Tty"] = 653] = "Tty";
    IconType[IconType["Cc"] = 654] = "Cc";
    IconType[IconType["PlusCart"] = 655] = "PlusCart";
    IconType[IconType["ArrowDownCart"] = 656] = "ArrowDownCart";
    IconType[IconType["Detective"] = 657] = "Detective";
    IconType[IconType["Venus"] = 658] = "Venus";
    IconType[IconType["Mars"] = 659] = "Mars";
    IconType[IconType["Mercury"] = 660] = "Mercury";
    IconType[IconType["VenusDouble"] = 661] = "VenusDouble";
    IconType[IconType["FemaleHomosexual"] = 662] = "FemaleHomosexual";
    IconType[IconType["MarsDouble"] = 663] = "MarsDouble";
    IconType[IconType["MaleHomosexual"] = 664] = "MaleHomosexual";
    IconType[IconType["VenusMars"] = 665] = "VenusMars";
    IconType[IconType["MarsStroke"] = 666] = "MarsStroke";
    IconType[IconType["MarsAlternate"] = 667] = "MarsAlternate";
    IconType[IconType["MarsVertical"] = 668] = "MarsVertical";
    IconType[IconType["MarsHorizontal"] = 669] = "MarsHorizontal";
    IconType[IconType["MarsStrokeVertical"] = 670] = "MarsStrokeVertical";
    IconType[IconType["MarsStrokeHorizontal"] = 671] = "MarsStrokeHorizontal";
    IconType[IconType["FacebookOfficial"] = 672] = "FacebookOfficial";
    IconType[IconType["PinterestOfficial"] = 673] = "PinterestOfficial";
    IconType[IconType["Bed"] = 674] = "Bed";
})(IconType = exports.IconType || (exports.IconType = {}));


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(188));
__export(__webpack_require__(196));
__export(__webpack_require__(207));
__export(__webpack_require__(211));
__export(__webpack_require__(4));
__export(__webpack_require__(3));


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Checkbox;
(function (Checkbox) {
    /**
    * Creates a checkbox element on the page.
    * Accepts the following properties in props$:
    *   readonly?: boolean - Styles the checkbox to appear read-only.
    *   checked?: boolean - Styles the checkbox to appear checked.
    *   disabled?: boolean - Styles the checkbox to appear disabled.
    *   fitted?: boolean - Styles the checkbox for tight fits with nearby content.
    *   radio?: string - Styles the checkbox to appear like a radio button belonging to the group.
    *   toggle?: boolean - Styles the checkbox to appear like a toggle.
    * Expects the following type of content in content$: DOMContent
    * @param {ComponentSources} sources The default component sources.
    */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var evt = function (type) { return sources.DOM.select("input").events(type); };
            var clicked$ = evt("click");
            var props$ = sources.props$.remember();
            var checked$ = props$.map(function (props) {
                return clicked$.fold(function (acc, evt) { return evt.srcElement.checked; }, props.checked ? true : false);
            }).flatten().remember();
            // const renderProps$ =  xs.combine(props$, checked$).map(
            //   ([props, checked]) => Object.assign({}, props, {checked})
            // );
            var vTree$ = xstream_1.default.combine(props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: evt,
                value$: checked$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Checkbox.run = run;
    /**
    * Creates a checkbox element on the page.
    * Accepts the following properties in props$:
    *   readonly?: boolean - Styles the checkbox to appear read-only.
    *   checked?: boolean - Styles the checkbox to appear checked.
    *   disabled?: boolean - Styles the checkbox to appear disabled.
    *   fitted?: boolean - Styles the checkbox for tight fits with nearby content.
    *   radio?: string - Styles the checkbox to appear like a radio button belonging to the group.
    *   toggle?: boolean - Styles the checkbox to appear like a toggle.
    * Expects the following type of content in content$: DOMContent
    * @param {ComponentSources} sources The default component sources.
    */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassName(props) } }, [
            dom_1.input({ props: {
                    type: props.radio ? "radio" : "checkbox",
                    name: props.name,
                    checked: props.checked,
                    disabled: props.readonly || props.disabled
                } }),
            dom_1.label({ props: { for: props.name } }, props.fitted ? "" : content)
        ]);
    }
    Checkbox.render = render;
    function getClassName(props) {
        var className = "ui";
        if (props.readonly) {
            className += " read-only";
        }
        if (props.checked) {
            className += " checked";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.radio) {
            className += " radio";
        }
        if (props.toggle) {
            className += " toggle";
        }
        return className + " checkbox";
    }
})(Checkbox = exports.Checkbox || (exports.Checkbox = {}));


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var dropRepeats_1 = __webpack_require__(63);
var debounce_1 = __webpack_require__(61);
var concat_1 = __webpack_require__(213);
var isolate_1 = __webpack_require__(2);
var delay_1 = __webpack_require__(62);
var dom_1 = __webpack_require__(1);
var menu_1 = __webpack_require__(59);
var icon_1 = __webpack_require__(22);
var transition_1 = __webpack_require__(13);
var Dropdown;
(function (Dropdown) {
    /**
     * A dropdown component for capturing user input.
     * Accepts the following properties in props$:
     *  active?: boolean,
     *  initial?: any
     *  default?: string
     *  selection?: boolean
     *  inline?: boolean
     *  floating?: boolean
     *  loading?: boolean
     *  disabled?: boolean
     *  scrolling?: boolean
     *  search?: boolean
     *  compact?: boolean
     *  size?: Size
     *  color?: Color
     * Expects the following type of content in content$: Array of {
     *  body: DOMContent,
     *  value: any,
     *  header?: boolean,
     *  fitted?: boolean,
     *  disabled?: boolean,
     *  active?: boolean
     * }
     */
    function run(sources) {
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".dropdown").events(type); };
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var props$ = sources.props$.remember();
            var itemClick$proxy = xstream_1.default.create();
            var value$proxy = xstream_1.default.create();
            var dropdownClick$ = evt("click")
                .filter(function (evt) { return !evt.srcElement.classList.contains("item"); })
                .mapTo(enums_1.Direction.In);
            var mouseleave$ = xstream_1.default.merge(evt("mouseleave").filter(function (evt) { return evt.srcElement.className.indexOf("icon") === -1; }), evt("mouseenter"))
                .map(function (evt) { return evt.type === "mouseenter" ? enums_1.Direction.In : enums_1.Direction.Out; })
                .compose(debounce_1.default(250))
                .filter(function (dir) { return dir === enums_1.Direction.Out; });
            var transition$ = xstream_1.default.merge(dropdownClick$, itemClick$proxy, mouseleave$)
                .startWith(enums_1.Direction.Out)
                .map(function (dir) { return ({
                animation: enums_1.Animation.Fade,
                direction: dir
            }); })
                .compose(dropRepeats_1.default(function (a, b) { return a.direction === b.direction
                && a.animation === b.animation; }))
                .drop(1)
                .startWith({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var filter$ = sources.DOM.select("input").events("keyup")
                .map(function (ev) { return ev.target.value; })
                .startWith("");
            var filteredContent$ = xstream_1.default.combine(sources.content$, filter$).map(function (_a) {
                var content = _a[0], filter = _a[1];
                return content.filter(function (c) { return filterContent(c, filter); });
            }).remember();
            var content$ = xstream_1.default.combine(filteredContent$, value$proxy).map(function (_a) {
                var content = _a[0], value = _a[1];
                return content.map(function (item) { return item.value === value ? Object.assign({}, item, { active: true }) : item; });
            }).remember();
            var menu = menu_1.Menu.run({ DOM: sources.DOM, content$: content$ });
            var transitionedMenu = transition_1.Transition.run({ DOM: sources.DOM, target$: menu.DOM, args$: transition$ });
            var itemClick$ = evt("click").filter(function (x) { return x.target.classList.contains("item"); }).remember();
            itemClick$proxy.imitate(itemClick$.mapTo(enums_1.Direction.Out));
            var clickedId$ = itemClick$
                .map(function (ev) { return parseInt(ev.target.id); })
                .filter(function (n) { return !isNaN(n) && typeof (n) !== "undefined"; });
            var emittedValue$ = clickedId$.map(function (id) { return filteredContent$.map(function (items) { return items[id].value; }).take(1); }).flatten().remember();
            var initialValue$ = props$.map(function (props) { return props.initial; }).remember();
            value$proxy.imitate(xstream_1.default.merge(initialValue$, emittedValue$));
            var icon = icon_1.Icon.render({}, enums_1.IconType.Dropdown);
            var active$ = xstream_1.default.merge(transition$.filter(function (x) { return x.direction === enums_1.Direction.In; }).mapTo(true), transition$.filter(function (x) { return x.direction === enums_1.Direction.Out; }).compose(delay_1.default(250)).mapTo(false));
            var streams = xstream_1.default.combine(props$, active$, transitionedMenu.DOM, content$.map(function (content) { return content.filter(function (item) { return item.active; })[0]; }));
            var vtree$ = streams.map(function (_a) {
                var props = _a[0], active = _a[1], menu = _a[2], item = _a[3];
                return dom_1.div({ props: { className: getClassName(props, active) } }, [
                    getText(item, props),
                    props.search ? dom_1.input({ props: { className: "search" } }) : "",
                    icon, menu
                ]);
            }).remember();
            //Todo find cleaner way to clear input using snabbdom hooks?
            emittedValue$.map(function (_) { return vtree$.take(1); }).flatten().addListener(new ExecuteListener(function (vnode) {
                function clear() {
                    if (typeof (vnode.elm) !== "undefined") {
                        var elm = vnode.elm.getElementsByTagName("input");
                        if (elm[0] && elm[0].value !== "") {
                            {
                                console.log("Sending next");
                            }
                            elm[0].value = "";
                            filter$.shamefullySendNext("");
                        }
                    }
                    else {
                        setTimeout(clear, 100);
                    }
                }
                clear();
            }));
            return {
                DOM: vtree$,
                Events: evt,
                value$: concat_1.default(initialValue$, emittedValue$)
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Dropdown.run = run;
    /**
     * A dropdown component for capturing user input.
     * Accepts the following properties:
     *  active?: boolean,
     *  initial?: any
     *  default?: string
     *  selection?: boolean
     *  inline?: boolean
     *  floating?: boolean
     *  loading?: boolean
     *  disabled?: boolean
     *  scrolling?: boolean
     *  search?: boolean
     *  compact?: boolean
     *  size?: Size
     *  color?: Color
     * Expects the following type of content: Array of {
     *  body: DOMContent,
     *  value: any,
     *  header?: boolean,
     *  fitted?: boolean,
     *  disabled?: boolean,
     *  active?: boolean
     * }
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        var icon = icon_1.Icon.render({}, enums_1.IconType.Dropdown);
        var menu = menu_1.Menu.render({}, content);
        var item = content.filter(function (item) { return item.active; })[0];
        return dom_1.div({ props: { className: getClassName(props) } }, [
            getText(item, props),
            props.search ? dom_1.input({ props: { className: "search" } }) : "",
            icon, menu
        ]);
    }
    Dropdown.render = render;
    function getClassName(props, active) {
        var className = "ui";
        if (props.rightAligned) {
            className += " right";
        }
        if (props.selection) {
            className += " selection";
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.floating) {
            className += " floating";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.scrolling) {
            className += " scrolling";
        }
        if (props.search) {
            className += " search";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (active || props.active) {
            className += " active";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        return className + " dropdown";
    }
    function getText(item, props) {
        if (typeof (props.static) !== "undefined") {
            return dom_1.div({ props: { className: "text" } }, props.static);
        }
        if (item === null) {
            return dom_1.div({ props: { className: "default text" } }, props.default);
        }
        return dom_1.div({ props: { className: "text" } }, item.body);
    }
    function filterContent(item, filter) {
        function f(node) {
            if (node.text) {
                return node.text.indexOf(filter) !== -1 || !filter;
            }
            else {
                for (var c in node.children) {
                    if (f(c)) {
                        return true;
                    }
                }
                return false;
            }
        }
        if (typeof (item.body === "string")) {
            return item.body.indexOf(filter) !== -1 || !filter;
        }
        if (!item.body.push) {
            return f(item.body);
        }
        for (var c in item.body.children) {
            if (f(c)) {
                return true;
            }
        }
        return false;
    }
    var ExecuteListener = (function () {
        function ExecuteListener(f) {
            this.f = f;
        }
        ExecuteListener.prototype.next = function (i) { this.f(i); };
        ExecuteListener.prototype.error = function (i) { };
        ExecuteListener.prototype.complete = function () { };
        return ExecuteListener;
    }());
})(Dropdown = exports.Dropdown || (exports.Dropdown = {}));


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(205));
__export(__webpack_require__(36));
__export(__webpack_require__(206));
__export(__webpack_require__(208));
__export(__webpack_require__(209));
__export(__webpack_require__(210));
__export(__webpack_require__(13));


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var enums_1 = __webpack_require__(3);
var dimmer_1 = __webpack_require__(36);
var icon_1 = __webpack_require__(22);
var transition_1 = __webpack_require__(13);
var Modal;
(function (Modal) {
    /**
     * A modal component for displaying content in a modal.
     * Accepts the following type of properties in props$:
     *   header: String - The header text for the component.
     *   on$: Stream<Boolean> - When to display the modal.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ on$: xstream_1.default.of(false) });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.actions$ = sources.actions$ ? sources.actions$ : xstream_1.default.of("");
            sources.target$ = sources.target$ ? sources.target$ : xstream_1.default.of("page");
            var closeIcon = icon_1.Icon.run({ DOM: sources.DOM, props$: xstream_1.default.of({ link: true }), content$: xstream_1.default.of(enums_1.IconType.Close) });
            var close$ = closeIcon.Events("click").mapTo(false);
            /*** Render modal ***/
            var dimmerclick$proxy = xstream_1.default.create();
            var on$ = xstream_1.default.merge(sources.on$, dimmerclick$proxy, close$).remember();
            var content$ = xstream_1.default.combine(sources.props$, sources.content$, sources.actions$, closeIcon.DOM).map(function (_a) {
                var props = _a[0], content = _a[1], actions = _a[2], icon = _a[3];
                return dom_1.div({ props: { className: "ui scrolling active modal" } }, [
                    icon,
                    dom_1.div({ props: { className: "header" } }, props.header),
                    dom_1.div({ props: { className: "content" } }, content),
                    actions ? dom_1.div({ props: { className: "actions" } }, actions) : ""
                ]);
            }).remember();
            /*** Animation ***/
            var transition$ = on$
                .fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? ({ animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out })
                : {
                    animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out
                }; }, ({ animation: enums_1.Animation.None, direction: enums_1.Direction.None }));
            var animatedContent = transition_1.Transition.run({ DOM: sources.DOM, target$: content$, args$: transition$ });
            /*** Activate dimmer ***/
            var dimmerContent$ = animatedContent.DOM.map(function (x) { return [x]; });
            var dimmer = dimmer_1.Dimmer.run({ DOM: sources.DOM, target$: sources.target$, args$: on$, content$: dimmerContent$ }, sources.props$.map(function (x) { return x.inverted; }));
            var dimmerclick$ = dimmer.Events("mousedown")
                .filter(function (evt) { return evt.srcElement === evt.currentTarget; })
                .mapTo(false);
            dimmerclick$proxy.imitate(dimmerclick$);
            var fadeOutEnd$ = on$.map(function (active) { return !active ? dimmer.Events("animationend") : xstream_1.default.never(); }).flatten().mapTo(false);
            // const active$ = xs.merge(sources.on$, fadeOutEnd$).remember();
            return {
                active$: xstream_1.default.merge(sources.on$, fadeOutEnd$),
                DOM: dimmer.DOM,
                Events: animatedContent.Events
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Modal.run = run;
})(Modal = exports.Modal || (exports.Modal = {}));


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var transition_1 = __webpack_require__(13);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var debounce_1 = __webpack_require__(61);
var dropRepeats_1 = __webpack_require__(63);
var delay_1 = __webpack_require__(62);
var Popup;
(function (Popup) {
    function run(sources) {
        function main(sources) {
            sources.args$ = sources.args$ ? sources.args$ : xstream_1.default.of({ active: false, attachment: PopupAttachment.BottomLeft });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var args$ = sources.args$.remember();
            var vTree$ = xstream_1.default.combine(args$, sources.content$).map(function (_a) {
                var args = _a[0], content = _a[1];
                return render(args, content);
            });
            var mouseleave$proxy = xstream_1.default.create();
            var mouseenter$proxy = xstream_1.default.create();
            var active$ = args$.map(function (arg) { return arg.active ? enums_1.Direction.In : enums_1.Direction.Out; }).drop(1);
            var timer$ = active$.map(function (dir) { return dir === enums_1.Direction.Out ? xstream_1.default.of(enums_1.Direction.Out)
                : xstream_1.default.of(enums_1.Direction.Out).compose(delay_1.default(1000)).endWhen(mouseenter$proxy); }).flatten();
            var transition$ = xstream_1.default.merge(active$, mouseleave$proxy, timer$)
                .map(function (dir) { return ({
                animation: enums_1.Animation.Fade,
                direction: dir
            }); })
                .compose(dropRepeats_1.default(function (a, b) { return a.direction === b.direction
                && a.animation === b.animation; }))
                .startWith({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var animatedPopup = transition_1.Transition.run({ DOM: sources.DOM, target$: vTree$, args$: transition$ });
            var mouseenter$ = animatedPopup.Events("mouseenter");
            var mouseleave$ = xstream_1.default.merge(animatedPopup.Events("mouseleave"), mouseenter$)
                .map(function (evt) { return evt.type === "mouseenter" ? enums_1.Direction.In : enums_1.Direction.Out; })
                .compose(debounce_1.default(200))
                .filter(function (dir) { return dir === enums_1.Direction.Out; });
            mouseleave$proxy.imitate(mouseleave$);
            mouseenter$proxy.imitate(mouseenter$);
            var popup$ = animatedPopup.DOM.remember();
            return {
                DOM: popup$,
                Events: animatedPopup.Events,
                tether: xstream_1.default.combine(popup$, sources.target$, args$)
                    .map(function (_a) {
                    var element = _a[0], target = _a[1], args = _a[2];
                    return ({ element: element, target: target, args: args });
                })
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Popup.run = run;
    function render(args, content) {
        if (args === void 0) { args = { active: true, attachment: PopupAttachment.BottomLeft }; }
        if (content === void 0) { content = ""; }
        return dom_1.div({ props: { className: getClassname(args) } }, [
            args.header ? dom_1.div({ props: { className: "header" } }, args.header) : "",
            content
        ]);
    }
    Popup.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.wide) {
            className += " wide";
        }
        if (props.veryWide) {
            className += " very wide";
        }
        if (props.flowing) {
            className += " flowing";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += PopupAttachment.ToClassname(props.attachment) + " popup";
        return className;
    }
    var PopupAttachment;
    (function (PopupAttachment) {
        PopupAttachment[PopupAttachment["TopLeft"] = 0] = "TopLeft";
        PopupAttachment[PopupAttachment["TopMiddle"] = 1] = "TopMiddle";
        PopupAttachment[PopupAttachment["TopRight"] = 2] = "TopRight";
        PopupAttachment[PopupAttachment["LeftCenter"] = 3] = "LeftCenter";
        PopupAttachment[PopupAttachment["RightCenter"] = 4] = "RightCenter";
        PopupAttachment[PopupAttachment["BottomLeft"] = 5] = "BottomLeft";
        PopupAttachment[PopupAttachment["BottomMiddle"] = 6] = "BottomMiddle";
        PopupAttachment[PopupAttachment["BottomRight"] = 7] = "BottomRight";
        PopupAttachment[PopupAttachment["Center"] = 8] = "Center";
    })(PopupAttachment = Popup.PopupAttachment || (Popup.PopupAttachment = {}));
    (function (PopupAttachment) {
        function ToClassname(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return " top left";
                case PopupAttachment.TopMiddle: return " top center";
                case PopupAttachment.TopRight: return " top right";
                case PopupAttachment.LeftCenter: return " left center";
                case PopupAttachment.RightCenter: return " right center";
                case PopupAttachment.BottomLeft: return " bottom left";
                case PopupAttachment.BottomMiddle: return " bottom center";
                case PopupAttachment.BottomRight: return " bottom right";
                case PopupAttachment.Center: return " center";
                default: return " bottom left";
            }
        }
        PopupAttachment.ToClassname = ToClassname;
        function ToTether(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return "top left";
                case PopupAttachment.TopMiddle: return "top center";
                case PopupAttachment.TopRight: return "top right";
                case PopupAttachment.LeftCenter: return "left middle";
                case PopupAttachment.RightCenter: return "right middle";
                case PopupAttachment.BottomLeft: return "bottom left";
                case PopupAttachment.BottomMiddle: return "bottom center";
                case PopupAttachment.BottomRight: return "bottom right";
                case PopupAttachment.Center: return "center";
                default: return "bottom left";
            }
        }
        PopupAttachment.ToTether = ToTether;
        function ToOppositeTether(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return "bottom right";
                case PopupAttachment.TopMiddle: return "bottom center";
                case PopupAttachment.TopRight: return "bottom left";
                case PopupAttachment.LeftCenter: return "right middle";
                case PopupAttachment.RightCenter: return "left middle";
                case PopupAttachment.BottomLeft: return "top right";
                case PopupAttachment.BottomMiddle: return "top center";
                case PopupAttachment.BottomRight: return "top left";
                case PopupAttachment.Center: return "center";
                default: return "bottom left";
            }
        }
        PopupAttachment.ToOppositeTether = ToOppositeTether;
    })(PopupAttachment = Popup.PopupAttachment || (Popup.PopupAttachment = {}));
})(Popup = exports.Popup || (exports.Popup = {}));


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var ProgressBar;
(function (ProgressBar) {
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties in props$:
     *   progress: number - The % of progress the progress bar should reflect.
     *   active?: boolean - Styles the progress bar to reflect activitiy.
     *   disabled?: boolean - Styles the progress bar to appear disabled.
     *   inverted?: boolean - Styles the progress bar for dark backgrounds.
     *   attachment?: Attachment - Where the progress bar should be attached to.
     *   size?: Size - The size of the progress bar.
     *   color?: Color - The color of the progress bar.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ progress: 0 });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".progress").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    ProgressBar.run = run;
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following propertiea:
     *   progress: number - The % of progress the progress bar should reflect.
     *   active?: boolean - Styles the progress bar to reflect activitiy.
     *   disabled?: boolean - Styles the progress bar to appear disabled.
     *   inverted?: boolean - Styles the progress bar for dark backgrounds.
     *   attachment?: Attachment - Where the progress bar should be attached to.
     *   size?: Size - The size of the progress bar.
     *   color?: Color - The color of the progress bar.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = { progress: 0 }; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? { progress: 0 } : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            dom_1.div({ props: { className: "bar" } }, { style: { width: props.progress + "%" } }, [
                dom_1.div({ props: { className: "progress" } }, [props.progress + "%"])
            ]),
            dom_1.div({ props: { className: "label" } }, content)
        ]);
    }
    ProgressBar.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.active) {
            className += " active";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " progress";
        return className;
    }
})(ProgressBar = exports.ProgressBar || (exports.ProgressBar = {}));


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(212));


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Statistic;
(function (Statistic) {
    /**
     * A statistic component to show statistics.
     * Accepts the following properties in props$:
     *   horizontal?: boolean - Styles the statistic to display horizontally.
     *   inverted?: boolean - Styles the statistic for a dark background.
     *   color?: Color - The color of the statistic.
     *   size?: Size - The size of the statistic.
     *   float?: Float - Where to float the statistic.
     * Expects the following type of content in content$: {} of
     *   value: String|VNode - The value for the statistic.
     *   label: String|VNode - The label for the statistic.
     *   isText?: boolean - Formats the statistic value for text based values.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".statistic").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Statistic.run = run;
    /**
     * A statistic component to show statistics.
     * Accepts the following properties:
     *   horizontal?: boolean - Styles the statistic to display horizontally.
     *   inverted?: boolean - Styles the statistic for a dark background.
     *   color?: Color - The color of the statistic.
     *   size?: Size - The size of the statistic.
     *   float?: Float - Where to float the statistic.
     * Expects the following type of content: {} of
     *   value: String|VNode - The value for the statistic.
     *   label: String|VNode - The label for the statistic.
     *   isText?: boolean - Formats the statistic value for text based values.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var label = interfaces_1.isDOMContent(pOrC) ? c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            dom_1.div({ props: { className: props.text ? "text value" : "value" } }, content),
            dom_1.div({ props: { className: "label" } }, label)
        ]);
    }
    Statistic.render = render;
    function getClassname(props) {
        var className = "ui ";
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        className += " statistic";
        return className;
    }
})(Statistic = exports.Statistic || (exports.Statistic = {}));


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var ConcatProducer = (function () {
    function ConcatProducer(streams) {
        this.streams = streams;
        this.type = 'concat';
        this.out = null;
        this.i = 0;
    }
    ConcatProducer.prototype._start = function (out) {
        this.out = out;
        this.streams[this.i]._add(this);
    };
    ConcatProducer.prototype._stop = function () {
        var streams = this.streams;
        if (this.i < streams.length) {
            streams[this.i]._remove(this);
        }
        this.i = 0;
        this.out = null;
    };
    ConcatProducer.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        u._n(t);
    };
    ConcatProducer.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    ConcatProducer.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        var streams = this.streams;
        streams[this.i]._remove(this);
        if (++this.i < streams.length) {
            streams[this.i]._add(this);
        }
        else {
            u._c();
        }
    };
    return ConcatProducer;
}());
/**
 * Puts one stream after the other. *concat* is a factory that takes multiple
 * streams as arguments, and starts the `n+1`-th stream only when the `n`-th
 * stream has completed. It concatenates those streams together.
 *
 * Marble diagram:
 *
 * ```text
 * --1--2---3---4-|
 * ...............--a-b-c--d-|
 *           concat
 * --1--2---3---4---a-b-c--d-|
 * ```
 *
 * Example:
 *
 * ```js
 * import concat from 'xstream/extra/concat'
 *
 * const streamA = xs.of('a', 'b', 'c')
 * const streamB = xs.of(10, 20, 30)
 * const streamC = xs.of('X', 'Y', 'Z')
 *
 * const outputStream = concat(streamA, streamB, streamC)
 *
 * outputStream.addListener({
 *   next: (x) => console.log(x),
 *   error: (err) => console.error(err),
 *   complete: () => console.log('concat completed'),
 * })
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to concatenate together with other streams.
 * @param {Stream} stream2 A stream to concatenate together with other streams. Two
 * or more streams may be given as arguments.
 * @return {Stream}
 */
function concat() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new index_1.Stream(new ConcatProducer(streams));
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var FCIL = (function () {
    function FCIL(out, op) {
        this.out = out;
        this.op = op;
    }
    FCIL.prototype._n = function (t) {
        this.out._n(t);
    };
    FCIL.prototype._e = function (err) {
        this.out._e(err);
    };
    FCIL.prototype._c = function () {
        this.op.less();
    };
    return FCIL;
}());
var FlattenConcOperator = (function () {
    function FlattenConcOperator(ins) {
        this.ins = ins;
        this.type = 'flattenConcurrently';
        this.active = 1; // number of outers and inners that have not yet ended
        this.out = null;
    }
    FlattenConcOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    FlattenConcOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.active = 1;
        this.out = null;
    };
    FlattenConcOperator.prototype.less = function () {
        if (--this.active === 0) {
            var u = this.out;
            if (!u)
                return;
            u._c();
        }
    };
    FlattenConcOperator.prototype._n = function (s) {
        var u = this.out;
        if (!u)
            return;
        this.active++;
        s._add(new FCIL(u, this));
    };
    FlattenConcOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    FlattenConcOperator.prototype._c = function () {
        this.less();
    };
    return FlattenConcOperator;
}());
exports.FlattenConcOperator = FlattenConcOperator;
/**
 * Flattens a "stream of streams", handling multiple concurrent nested streams
 * simultaneously.
 *
 * If the input stream is a stream that emits streams, then this operator will
 * return an output stream which is a flat stream: emits regular events. The
 * flattening happens concurrently. It works like this: when the input stream
 * emits a nested stream, *flattenConcurrently* will start imitating that
 * nested one. When the next nested stream is emitted on the input stream,
 * *flattenConcurrently* will also imitate that new one, but will continue to
 * imitate the previous nested streams as well.
 *
 * Marble diagram:
 *
 * ```text
 * --+--------+---------------
 *   \        \
 *    \       ----1----2---3--
 *    --a--b----c----d--------
 *     flattenConcurrently
 * -----a--b----c-1--d-2---3--
 * ```
 *
 * @return {Stream}
 */
function flattenConcurrently(ins) {
    return new index_1.Stream(new FlattenConcOperator(ins));
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = flattenConcurrently;
//# sourceMappingURL=flattenConcurrently.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(65);
module.exports = __webpack_require__(64);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDA4Yjc0ZDYzYzQ5NzBmYmRkMzQiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaXNvbGF0ZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmZhY2VzL2luZGV4LnRzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL3hzdHJlYW0tYWRhcHRlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3RyYW5zaXRpb24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9pcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvaWNvbi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2Zyb21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2h5cGVyc2NyaXB0LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy9pcy1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9Ccm93c2VyUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fcm9vdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21hdGNoZXMtc2VsZWN0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS92bm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9kaW1tZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL1Njb3BlQ2hlY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL3RyYW5zcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaGlzdG9yeS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaGlzdG9yeS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXItc3BsaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L2FycmF5LyMvY2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2dldG5hdGl2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5lc2NhcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guZm9yb3duL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmlzYXJndW1lbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tc2VsZWN0b3IvbGliL3NlbGVjdG9yUGFyc2VyLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tdG8taHRtbC9saWIvcGFyc2Utc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvdWkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL21lbnUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3hzdHJlYW0vZXh0cmEvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2V4dHJhL2RlbGF5LmpzIiwid2VicGFjazovLy8uL34veHN0cmVhbS9leHRyYS9kcm9wUmVwZWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9kb2NzLmxlc3MiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvYXBwLnRzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvQm9keURPTVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL0RvY3VtZW50RE9NU291cmNlLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvRWxlbWVudEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL0V2ZW50RGVsZWdhdG9yLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvSFRNTFNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL01haW5ET01Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9WTm9kZVdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9oeXBlcnNjcmlwdC1oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvaXNvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2lzb2xhdGVNb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9tYWtlRE9NRHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvbWFrZUhUTUxEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9tb2NrRE9NU291cmNlLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvbW9kdWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi9jYXB0dXJlQ2xpY2tzLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2hpc3RvcnkvbGliL21ha2VIaXN0b3J5RHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2hpc3RvcnkvbGliL3NlcnZlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUveHN0cmVhbS1ydW4vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL3hzdHJlYW0tcnVuL34vQGN5Y2xlL2Jhc2UvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvUm91dGVyU291cmNlLmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jeWNsaWMtcm91dGVyL2xpYi9tYWtlUm91dGVyRHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2QvYXV0by1iaW5kLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L21hdGgvc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvbWF0aC9zaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9tYXRoL3NpZ24vc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvbnVtYmVyL3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L251bWJlci90by1wb3MtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L19pdGVyYXRlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9jb3B5LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvbWFwLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9wcmltaXRpdmUtc2V0LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci9mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtaXRlcmF0b3IvZ2V0LmpzIiwid2VicGFjazovLy8uL34vZXM2LWl0ZXJhdG9yL2lzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vZXM2LWl0ZXJhdG9yL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtbWFwL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvbGliL2l0ZXJhdG9yLWtpbmRzLmpzIiwid2VicGFjazovLy8uL34vZXM2LW1hcC9saWIvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtbWFwL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL34vZXM2LXN5bWJvbC9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvaXMtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vZXM2LXN5bWJvbC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9IYXNoUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9SZWZyZXNoUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VCZWZvcmVVbmxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9iYXNlZmxhdHRlbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fYmFzZWZvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fYmFzZWluZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2Jhc2V1bmlxL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9iaW5kY2FsbGJhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2NhY2hlaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fY3JlYXRlY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guZGVidXJyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmtlYmFiY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLnJlc3RwYXJhbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC51bmlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC53b3Jkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9jbGFzc05hbWVGcm9tVk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9jb250YWluZXItZWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL2luaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL3N0eWxlLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tdG8taHRtbC9saWIvdm9pZC1lbGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9odG1sZG9tYXBpLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9tb2R1bGVzL2hlcm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9tb2R1bGVzL3Byb3BzLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL3NuYWJiZG9tLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vdGh1bmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N3aXRjaC1wYXRoL2xpYi9lczIwMTUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zd2l0Y2gtcGF0aC9saWIvZXMyMDE1L3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9pbmRleC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9sYXlvdXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvbGF5b3V0L3NpZGViYXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvcm91dGVyLnRzIiwid2VicGFjazovLy8uL2RvY3Mtc3JjL3JvdXRlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvYnJlYWRjcnVtYi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9maWVsZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9maWVsZHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL2Zvcm0vZm9ybS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9jb2x1bW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL2dyaWQvZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9yb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9tZXNzYWdlL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy90YWJsZS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvYnV0dG9uL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9jb250YWluZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2RpdmlkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2hlYWRlci9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvaW1hZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9sYWJlbC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvbGlzdC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvbG9hZGVyL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9zZWdtZW50L2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9zdGVwL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy90ZXh0Ym94L2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbnVtcy9pY29uVHlwZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvY2hlY2tib3gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZHJvcGRvd24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvbW9kYWwvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvcG9wdXAvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvcHJvZ3Jlc3MvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9zdGF0aXN0aWMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2V4dHJhL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3hzdHJlYW0vZXh0cmEvZmxhdHRlbkNvbmN1cnJlbnRseS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsV0FBVyxFQUFFO0FBQ2pELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHlCQUF5QixFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNENBQTRDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUM7Ozs7Ozs7QUN4ekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDLHNDQUFzQyxXQUFXO0FBQ2pELE1BQU07QUFDTjtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7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QTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxvQzs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0M7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsK0M7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUM7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvRUFBb0U7QUFDcEUsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUM7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDLEVBQUU7QUFDdEU7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0IsRUFBRTtBQUM3RSx3Q0FBd0MsbUVBQW1FLEVBQUU7QUFDN0c7QUFDQSxrQ0FBa0Msb0JBQW9CLEVBQUUsc0JBQXNCLEVBQUUseUJBQXlCLEVBQUUsRUFBRTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxtQzs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUU7QUFDOUQ7QUFDQTs7Ozs7Ozs7QUNSQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNQQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsMEJBQTBCLGtDQUFrQyxFQUFFO0FBQzlELENBQUM7Ozs7Ozs7O0FDN0JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDBCQUEwQixtQ0FBbUMsRUFBRTtBQUMvRCxDQUFDOzs7Ozs7OztBQ3BDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDL0JBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNSRDs7QUFFQTtBQUNBOzs7Ozs7OztBQ0hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiwwQkFBMEIsZ0NBQWdDLEVBQUU7QUFDNUQsQ0FBQztBQUNEO0FBQ0E7Ozs7Ozs7O0FDckNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YseUJBQXlCLHdDQUF3QyxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Ysc0JBQXNCLGtDQUFrQyxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRix5QkFBeUIsb0NBQW9DLEVBQUU7QUFDL0Qsd0JBQXdCLG9DQUFvQyxFQUFFO0FBQzlELDBCQUEwQix1QkFBdUIsRUFBRTtBQUNuRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUN2R0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCLEVBQUUsWUFBWSxjQUFjOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2hCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCLEVBQUU7QUFDdEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQWdFLEVBQUU7QUFDNUYseUJBQXlCLDZCQUE2QixFQUFFO0FBQ3hELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JIQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25JQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxrQ0FBa0MsMEJBQTBCLDBDQUEwQyxnQkFBZ0IsT0FBTyxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsT0FBTyx3QkFBd0IsRUFBRTs7QUFFak07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEU7Ozs7Ozs7K0NDNURBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBLGdHQUFnRzs7QUFFaEc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEU7Ozs7Ozs7O0FDdklBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEU7Ozs7Ozs7K0NDdENBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsNEVBQTRFLEVBQUUsRUFBRSxzQkFBc0IsZUFBZSxFQUFFOztBQUUzUSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsdUM7Ozs7Ozs7OytDQzlGQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsNkJBQTZCLFlBQVksRUFBRSxPQUFPLGlCQUFpQixtQkFBbUIsdUJBQXVCLDRFQUE0RSxFQUFFLEVBQUUsc0JBQXNCLGVBQWUsRUFBRTs7QUFFM1Esc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGOztBQUVBO0FBQ0Esd0VBQXdFOztBQUV4RTs7QUFFQTs7O0FBR0EsNkZBQTZGLGtCQUFrQjs7QUFFL0c7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxvQzs7Ozs7Ozs7K0NDaEhBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBLGVBQWU7QUFDZixHQUFHO0FBQ0gsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXlELFNBQVMsZUFBZTtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLG9CQUFvQix1QkFBdUI7QUFDL0U7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQzs7Ozs7Ozs7QUMzSUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7QUNwREE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsbURBQW1ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFOVA7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQSwwRUFBMEU7O0FBRTFFO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0ZBQXdGLGFBQWE7QUFDckc7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsOEI7Ozs7Ozs7K0NDOUdBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxrQzs7Ozs7Ozs7QUMvRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsbURBQW1ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFOVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0ZBQXdGLGFBQWE7QUFDckc7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsNkI7Ozs7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFh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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixZQUFZLE9BQU87QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNyTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjs7Ozs7Ozs7QUMxTUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNB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O0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwrQyIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjE1KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBkMDhiNzRkNjNjNDk3MGZiZGQzNCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgc3ltYm9sX29ic2VydmFibGVfMSA9IHJlcXVpcmUoXCJzeW1ib2wtb2JzZXJ2YWJsZVwiKTtcbnZhciBOTyA9IHt9O1xuZXhwb3J0cy5OTyA9IE5PO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZnVuY3Rpb24gY3AoYSkge1xuICAgIHZhciBsID0gYS5sZW5ndGg7XG4gICAgdmFyIGIgPSBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSlcbiAgICAgICAgYltpXSA9IGFbaV07XG4gICAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBhbmQoZjEsIGYyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuZEZuKHQpIHtcbiAgICAgICAgcmV0dXJuIGYxKHQpICYmIGYyKHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBfdHJ5KGMsIHQsIHUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYy5mKHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB1Ll9lKGUpO1xuICAgICAgICByZXR1cm4gTk87XG4gICAgfVxufVxudmFyIE5PX0lMID0ge1xuICAgIF9uOiBub29wLFxuICAgIF9lOiBub29wLFxuICAgIF9jOiBub29wLFxufTtcbmV4cG9ydHMuTk9fSUwgPSBOT19JTDtcbi8vIG11dGF0ZXMgdGhlIGlucHV0XG5mdW5jdGlvbiBpbnRlcm5hbGl6ZVByb2R1Y2VyKHByb2R1Y2VyKSB7XG4gICAgcHJvZHVjZXIuX3N0YXJ0ID0gZnVuY3Rpb24gX3N0YXJ0KGlsKSB7XG4gICAgICAgIGlsLm5leHQgPSBpbC5fbjtcbiAgICAgICAgaWwuZXJyb3IgPSBpbC5fZTtcbiAgICAgICAgaWwuY29tcGxldGUgPSBpbC5fYztcbiAgICAgICAgdGhpcy5zdGFydChpbCk7XG4gICAgfTtcbiAgICBwcm9kdWNlci5fc3RvcCA9IHByb2R1Y2VyLnN0b3A7XG59XG52YXIgU3RyZWFtU3ViID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJlYW1TdWIoX3N0cmVhbSwgX2xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbSA9IF9zdHJlYW07XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gX2xpc3RlbmVyO1xuICAgIH1cbiAgICBTdHJlYW1TdWIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdHJlYW0ucmVtb3ZlTGlzdGVuZXIodGhpcy5fbGlzdGVuZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmVhbVN1Yjtcbn0oKSk7XG52YXIgT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVyKF9saXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lciA9IF9saXN0ZW5lcjtcbiAgICB9XG4gICAgT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIuX24odmFsdWUpO1xuICAgIH07XG4gICAgT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lci5fZShlcnIpO1xuICAgIH07XG4gICAgT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lci5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmVyO1xufSgpKTtcbnZhciBGcm9tT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJvbU9ic2VydmFibGUob2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnJvbU9ic2VydmFibGUnO1xuICAgICAgICB0aGlzLmlucyA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3N1YiA9IHRoaXMuaW5zLnN1YnNjcmliZShuZXcgT2JzZXJ2ZXIob3V0KSk7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICB0aGlzLl9zdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YilcbiAgICAgICAgICAgIHRoaXMuX3N1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIEZyb21PYnNlcnZhYmxlO1xufSgpKTtcbnZhciBNZXJnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2UoaW5zQXJyKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtZXJnZSc7XG4gICAgICAgIHRoaXMuaW5zQXJyID0gaW5zQXJyO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmFjID0gMDtcbiAgICB9XG4gICAgTWVyZ2UucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbnNBcnI7XG4gICAgICAgIHZhciBMID0gcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWMgPSBMO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgIHNbaV0uX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluc0FycjtcbiAgICAgICAgdmFyIEwgPSBzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBMOyBpKyspXG4gICAgICAgICAgICBzW2ldLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICBNZXJnZS5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBNZXJnZS5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgTWVyZ2UucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoLS10aGlzLmFjIDw9IDApIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdS5fYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2U7XG59KCkpO1xudmFyIENvbWJpbmVMaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxpc3RlbmVyKGksIG91dCwgcCkge1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgcC5pbHMucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgQ29tYmluZUxpc3RlbmVyLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wLCBvdXQgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKG91dCA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwLnVwKHQsIHRoaXMuaSkpXG4gICAgICAgICAgICBvdXQuX24ocC52YWxzKTtcbiAgICB9O1xuICAgIENvbWJpbmVMaXN0ZW5lci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKG91dCA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG91dC5fZShlcnIpO1xuICAgIH07XG4gICAgQ29tYmluZUxpc3RlbmVyLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnA7XG4gICAgICAgIGlmIChwLm91dCA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgtLXAuTmMgPT09IDApXG4gICAgICAgICAgICBwLm91dC5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJpbmVMaXN0ZW5lcjtcbn0oKSk7XG52YXIgQ29tYmluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tYmluZShpbnNBcnIpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbWJpbmUnO1xuICAgICAgICB0aGlzLmluc0FyciA9IGluc0FycjtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5pbHMgPSBbXTtcbiAgICAgICAgdGhpcy5OYyA9IHRoaXMuTm4gPSAwO1xuICAgICAgICB0aGlzLnZhbHMgPSBbXTtcbiAgICB9XG4gICAgQ29tYmluZS5wcm90b3R5cGUudXAgPSBmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICB2YXIgdiA9IHRoaXMudmFsc1tpXTtcbiAgICAgICAgdmFyIE5uID0gIXRoaXMuTm4gPyAwIDogdiA9PT0gTk8gPyAtLXRoaXMuTm4gOiB0aGlzLk5uO1xuICAgICAgICB0aGlzLnZhbHNbaV0gPSB0O1xuICAgICAgICByZXR1cm4gTm4gPT09IDA7XG4gICAgfTtcbiAgICBDb21iaW5lLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB2YXIgcyA9IHRoaXMuaW5zQXJyO1xuICAgICAgICB2YXIgbiA9IHRoaXMuTmMgPSB0aGlzLk5uID0gcy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWxzID0gdGhpcy52YWxzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgb3V0Ll9uKFtdKTtcbiAgICAgICAgICAgIG91dC5fYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWxzW2ldID0gTk87XG4gICAgICAgICAgICAgICAgc1tpXS5fYWRkKG5ldyBDb21iaW5lTGlzdGVuZXIoaSwgb3V0LCB0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJpbmUucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuaW5zQXJyO1xuICAgICAgICB2YXIgbiA9IHMubGVuZ3RoO1xuICAgICAgICB2YXIgaWxzID0gdGhpcy5pbHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgc1tpXS5fcmVtb3ZlKGlsc1tpXSk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuaWxzID0gW107XG4gICAgICAgIHRoaXMudmFscyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJpbmU7XG59KCkpO1xudmFyIEZyb21BcnJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJvbUFycmF5KGEpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Zyb21BcnJheSc7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgfVxuICAgIEZyb21BcnJheS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIG91dC5fbihhW2ldKTtcbiAgICAgICAgb3V0Ll9jKCk7XG4gICAgfTtcbiAgICBGcm9tQXJyYXkucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIEZyb21BcnJheTtcbn0oKSk7XG52YXIgRnJvbVByb21pc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZyb21Qcm9taXNlKHApIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Zyb21Qcm9taXNlJztcbiAgICAgICAgdGhpcy5vbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgIH1cbiAgICBGcm9tUHJvbWlzZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB2YXIgcHJvZCA9IHRoaXM7XG4gICAgICAgIHRoaXMub24gPSB0cnVlO1xuICAgICAgICB0aGlzLnAudGhlbihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHByb2Qub24pIHtcbiAgICAgICAgICAgICAgICBvdXQuX24odik7XG4gICAgICAgICAgICAgICAgb3V0Ll9jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBvdXQuX2UoZSk7XG4gICAgICAgIH0pLnRoZW4obm9vcCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRnJvbVByb21pc2UucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbVByb21pc2U7XG59KCkpO1xudmFyIFBlcmlvZGljID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJpb2RpYyhwZXJpb2QpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BlcmlvZGljJztcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJRCA9IC0xO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgIH1cbiAgICBQZXJpb2RpYy5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIGludGVydmFsSGFuZGxlcigpIHsgb3V0Ll9uKHNlbGYuaSsrKTsgfVxuICAgICAgICB0aGlzLmludGVydmFsSUQgPSBzZXRJbnRlcnZhbChpbnRlcnZhbEhhbmRsZXIsIHRoaXMucGVyaW9kKTtcbiAgICB9O1xuICAgIFBlcmlvZGljLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJRCAhPT0gLTEpXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJRCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJRCA9IC0xO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIFBlcmlvZGljO1xufSgpKTtcbnZhciBEZWJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVidWcoaW5zLCBhcmcpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2RlYnVnJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMucyA9IG5vb3A7XG4gICAgICAgIHRoaXMubCA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aGlzLmwgPSBhcmc7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aGlzLnMgPSBhcmc7XG4gICAgfVxuICAgIERlYnVnLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRGVidWcucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgRGVidWcucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcyA9IHRoaXMucywgbCA9IHRoaXMubDtcbiAgICAgICAgaWYgKHMgIT09IG5vb3ApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcyh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdS5fZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsKVxuICAgICAgICAgICAgY29uc29sZS5sb2cobCArICc6JywgdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHQpO1xuICAgICAgICB1Ll9uKHQpO1xuICAgIH07XG4gICAgRGVidWcucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIERlYnVnLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVidWc7XG59KCkpO1xudmFyIERyb3AgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERyb3AobWF4LCBpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Ryb3AnO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuZHJvcHBlZCA9IDA7XG4gICAgfVxuICAgIERyb3AucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuZHJvcHBlZCA9IDA7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBEcm9wLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIERyb3AucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5kcm9wcGVkKysgPj0gdGhpcy5tYXgpXG4gICAgICAgICAgICB1Ll9uKHQpO1xuICAgIH07XG4gICAgRHJvcC5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRHJvcC5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIERyb3A7XG59KCkpO1xudmFyIEVuZFdoZW5MaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5kV2hlbkxpc3RlbmVyKG91dCwgb3ApIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgRW5kV2hlbkxpc3RlbmVyLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcC5lbmQoKTtcbiAgICB9O1xuICAgIEVuZFdoZW5MaXN0ZW5lci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMub3V0Ll9lKGVycik7XG4gICAgfTtcbiAgICBFbmRXaGVuTGlzdGVuZXIucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wLmVuZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEVuZFdoZW5MaXN0ZW5lcjtcbn0oKSk7XG52YXIgRW5kV2hlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5kV2hlbihvLCBpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2VuZFdoZW4nO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5vID0gbztcbiAgICAgICAgdGhpcy5vaWwgPSBOT19JTDtcbiAgICB9XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vLl9hZGQodGhpcy5vaWwgPSBuZXcgRW5kV2hlbkxpc3RlbmVyKG91dCwgdGhpcykpO1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuby5fcmVtb3ZlKHRoaXMub2lsKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5vaWwgPSBOT19JTDtcbiAgICB9O1xuICAgIEVuZFdoZW4ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICBFbmRXaGVuLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIEVuZFdoZW4ucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIEVuZFdoZW4ucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEVuZFdoZW47XG59KCkpO1xudmFyIEZpbHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsdGVyKHBhc3NlcywgaW5zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmaWx0ZXInO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5mID0gcGFzc2VzO1xuICAgIH1cbiAgICBGaWx0ZXIucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgRmlsdGVyLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHIgPSBfdHJ5KHRoaXMsIHQsIHUpO1xuICAgICAgICBpZiAociA9PT0gTk8gfHwgIXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIEZpbHRlci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlcjtcbn0oKSk7XG52YXIgRmxhdHRlbkxpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGbGF0dGVuTGlzdGVuZXIob3V0LCBvcCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5vdXQuX24odCk7XG4gICAgfTtcbiAgICBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLm91dC5fZShlcnIpO1xuICAgIH07XG4gICAgRmxhdHRlbkxpc3RlbmVyLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcC5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLm9wLmxlc3MoKTtcbiAgICB9O1xuICAgIHJldHVybiBGbGF0dGVuTGlzdGVuZXI7XG59KCkpO1xudmFyIEZsYXR0ZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZsYXR0ZW4oaW5zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmbGF0dGVuJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgIH1cbiAgICBGbGF0dGVuLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmlubmVyID0gTk87XG4gICAgICAgIHRoaXMuaWwgPSBOT19JTDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIEZsYXR0ZW4ucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pbm5lciAhPT0gTk8pXG4gICAgICAgICAgICB0aGlzLmlubmVyLl9yZW1vdmUodGhpcy5pbCk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgIH07XG4gICAgRmxhdHRlbi5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMub3BlbiAmJiB0aGlzLmlubmVyID09PSBOTylcbiAgICAgICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIEZsYXR0ZW4ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBpbm5lciA9IF9hLmlubmVyLCBpbCA9IF9hLmlsO1xuICAgICAgICBpZiAoaW5uZXIgIT09IE5PICYmIGlsICE9PSBOT19JTClcbiAgICAgICAgICAgIGlubmVyLl9yZW1vdmUoaWwpO1xuICAgICAgICAodGhpcy5pbm5lciA9IHMpLl9hZGQodGhpcy5pbCA9IG5ldyBGbGF0dGVuTGlzdGVuZXIodSwgdGhpcykpO1xuICAgIH07XG4gICAgRmxhdHRlbi5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRmxhdHRlbi5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlc3MoKTtcbiAgICB9O1xuICAgIHJldHVybiBGbGF0dGVuO1xufSgpKTtcbnZhciBGb2xkID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb2xkKGYsIHNlZWQsIGlucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZm9sZCc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmYgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZihfdGhpcy5hY2MsIHQpOyB9O1xuICAgICAgICB0aGlzLmFjYyA9IHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgfVxuICAgIEZvbGQucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuYWNjID0gdGhpcy5zZWVkO1xuICAgICAgICBvdXQuX24odGhpcy5hY2MpO1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRm9sZC5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuYWNjID0gdGhpcy5zZWVkO1xuICAgIH07XG4gICAgRm9sZC5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByID0gX3RyeSh0aGlzLCB0LCB1KTtcbiAgICAgICAgaWYgKHIgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9uKHRoaXMuYWNjID0gcik7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9sZDtcbn0oKSk7XG52YXIgTGFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGFzdChpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2xhc3QnO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5oYXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWwgPSBOTztcbiAgICB9XG4gICAgTGFzdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5oYXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIExhc3QucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLnZhbCA9IE5PO1xuICAgIH07XG4gICAgTGFzdC5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmhhcyA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsID0gdDtcbiAgICB9O1xuICAgIExhc3QucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIExhc3QucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmhhcykge1xuICAgICAgICAgICAgdS5fbih0aGlzLnZhbCk7XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdS5fZShuZXcgRXJyb3IoJ2xhc3QoKSBmYWlsZWQgYmVjYXVzZSBpbnB1dCBzdHJlYW0gY29tcGxldGVkJykpO1xuICAgIH07XG4gICAgcmV0dXJuIExhc3Q7XG59KCkpO1xudmFyIE1hcEZsYXR0ZW5MaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwRmxhdHRlbkxpc3RlbmVyKG91dCwgb3ApIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgTWFwRmxhdHRlbkxpc3RlbmVyLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHRoaXMub3V0Ll9uKHIpO1xuICAgIH07XG4gICAgTWFwRmxhdHRlbkxpc3RlbmVyLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5vdXQuX2UoZXJyKTtcbiAgICB9O1xuICAgIE1hcEZsYXR0ZW5MaXN0ZW5lci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3AuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5vcC5sZXNzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwRmxhdHRlbkxpc3RlbmVyO1xufSgpKTtcbnZhciBNYXBGbGF0dGVuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBGbGF0dGVuKG1hcE9wKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IG1hcE9wLnR5cGUgKyBcIitmbGF0dGVuXCI7XG4gICAgICAgIHRoaXMuaW5zID0gbWFwT3AuaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm1hcE9wID0gbWFwT3A7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgIH1cbiAgICBNYXBGbGF0dGVuLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlubmVyID0gTk87XG4gICAgICAgIHRoaXMuaWwgPSBOT19JTDtcbiAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXBPcC5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hcE9wLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pbm5lciAhPT0gTk8pXG4gICAgICAgICAgICB0aGlzLmlubmVyLl9yZW1vdmUodGhpcy5pbCk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgIH07XG4gICAgTWFwRmxhdHRlbi5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW4gJiYgdGhpcy5pbm5lciA9PT0gTk8pIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdS5fYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXBGbGF0dGVuLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaW5uZXIgPSBfYS5pbm5lciwgaWwgPSBfYS5pbDtcbiAgICAgICAgdmFyIHMgPSBfdHJ5KHRoaXMubWFwT3AsIHYsIHUpO1xuICAgICAgICBpZiAocyA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpbm5lciAhPT0gTk8gJiYgaWwgIT09IE5PX0lMKVxuICAgICAgICAgICAgaW5uZXIuX3JlbW92ZShpbCk7XG4gICAgICAgICh0aGlzLmlubmVyID0gcykuX2FkZCh0aGlzLmlsID0gbmV3IE1hcEZsYXR0ZW5MaXN0ZW5lcih1LCB0aGlzKSk7XG4gICAgfTtcbiAgICBNYXBGbGF0dGVuLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBNYXBGbGF0dGVuLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVzcygpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcEZsYXR0ZW47XG59KCkpO1xudmFyIE1hcE9wID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBPcChwcm9qZWN0LCBpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ21hcCc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmYgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBNYXBPcC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIE1hcE9wLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIE1hcE9wLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHIgPSBfdHJ5KHRoaXMsIHQsIHUpO1xuICAgICAgICBpZiAociA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX24ocik7XG4gICAgfTtcbiAgICBNYXBPcC5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgTWFwT3AucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBPcDtcbn0oKSk7XG52YXIgRmlsdGVyTWFwRnVzaW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsdGVyTWFwRnVzaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbHRlck1hcEZ1c2lvbihwYXNzZXMsIHByb2plY3QsIGlucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9qZWN0LCBpbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnZmlsdGVyK21hcCc7XG4gICAgICAgIF90aGlzLnBhc3NlcyA9IHBhc3NlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaWx0ZXJNYXBGdXNpb24ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhc3Nlcyh0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgciA9IF90cnkodGhpcywgdCwgdSk7XG4gICAgICAgIGlmIChyID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbihyKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJNYXBGdXNpb247XG59KE1hcE9wKSk7XG52YXIgUmVtZW1iZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbWVtYmVyKGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVtZW1iZXInO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9XG4gICAgUmVtZW1iZXIucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQob3V0KTtcbiAgICB9O1xuICAgIFJlbWVtYmVyLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzLm91dCk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICByZXR1cm4gUmVtZW1iZXI7XG59KCkpO1xudmFyIFJlcGxhY2VFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVwbGFjZUVycm9yKHJlcGxhY2VyLCBpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JlcGxhY2VFcnJvcic7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmYgPSByZXBsYWNlcjtcbiAgICB9XG4gICAgUmVwbGFjZUVycm9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgUmVwbGFjZUVycm9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIFJlcGxhY2VFcnJvci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBSZXBsYWNlRXJyb3IucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgKHRoaXMuaW5zID0gdGhpcy5mKGVycikpLl9hZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHUuX2UoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcGxhY2VFcnJvci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGxhY2VFcnJvcjtcbn0oKSk7XG52YXIgU3RhcnRXaXRoID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGFydFdpdGgoaW5zLCB2YWwpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0YXJ0V2l0aCc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICB9XG4gICAgU3RhcnRXaXRoLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm91dC5fbih0aGlzLnZhbCk7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQob3V0KTtcbiAgICB9O1xuICAgIFN0YXJ0V2l0aC5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcy5vdXQpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXJ0V2l0aDtcbn0oKSk7XG52YXIgVGFrZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZShtYXgsIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAndGFrZSc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy50YWtlbiA9IDA7XG4gICAgfVxuICAgIFRha2UucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMudGFrZW4gPSAwO1xuICAgICAgICBpZiAodGhpcy5tYXggPD0gMClcbiAgICAgICAgICAgIG91dC5fYygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgVGFrZS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICBUYWtlLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG0gPSArK3RoaXMudGFrZW47XG4gICAgICAgIGlmIChtIDwgdGhpcy5tYXgpXG4gICAgICAgICAgICB1Ll9uKHQpO1xuICAgICAgICBlbHNlIGlmIChtID09PSB0aGlzLm1heCkge1xuICAgICAgICAgICAgdS5fbih0KTtcbiAgICAgICAgICAgIHUuX2MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFrZS5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgVGFrZS5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2U7XG59KCkpO1xudmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyZWFtKHByb2R1Y2VyKSB7XG4gICAgICAgIHRoaXMuX3Byb2QgPSBwcm9kdWNlciB8fCBOTztcbiAgICAgICAgdGhpcy5faWxzID0gW107XG4gICAgICAgIHRoaXMuX3N0b3BJRCA9IE5PO1xuICAgICAgICB0aGlzLl9kbCA9IE5PO1xuICAgICAgICB0aGlzLl9kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IE5PO1xuICAgICAgICB0aGlzLl9lcnIgPSBOTztcbiAgICB9XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5faWxzO1xuICAgICAgICB2YXIgTCA9IGEubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fZClcbiAgICAgICAgICAgIHRoaXMuX2RsLl9uKHQpO1xuICAgICAgICBpZiAoTCA9PSAxKVxuICAgICAgICAgICAgYVswXS5fbih0KTtcbiAgICAgICAgZWxzZSBpZiAoTCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiID0gY3AoYSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgICAgICBiW2ldLl9uKHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5fZXJyICE9PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fZXJyID0gZXJyO1xuICAgICAgICB2YXIgYSA9IHRoaXMuX2lscztcbiAgICAgICAgdmFyIEwgPSBhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5feCgpO1xuICAgICAgICBpZiAodGhpcy5fZClcbiAgICAgICAgICAgIHRoaXMuX2RsLl9lKGVycik7XG4gICAgICAgIGlmIChMID09IDEpXG4gICAgICAgICAgICBhWzBdLl9lKGVycik7XG4gICAgICAgIGVsc2UgaWYgKEwgPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYiA9IGNwKGEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBMOyBpKyspXG4gICAgICAgICAgICAgICAgYltpXS5fZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZCAmJiBMID09IDApXG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnI7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuX2lscztcbiAgICAgICAgdmFyIEwgPSBhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5feCgpO1xuICAgICAgICBpZiAodGhpcy5fZClcbiAgICAgICAgICAgIHRoaXMuX2RsLl9jKCk7XG4gICAgICAgIGlmIChMID09IDEpXG4gICAgICAgICAgICBhWzBdLl9jKCk7XG4gICAgICAgIGVsc2UgaWYgKEwgPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYiA9IGNwKGEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBMOyBpKyspXG4gICAgICAgICAgICAgICAgYltpXS5fYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faWxzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2QgIT09IE5PKVxuICAgICAgICAgICAgdGhpcy5fcHJvZC5fc3RvcCgpO1xuICAgICAgICB0aGlzLl9lcnIgPSBOTztcbiAgICAgICAgdGhpcy5faWxzID0gW107XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9zdG9wTm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXQVJOSU5HOiBjb2RlIHRoYXQgY2FsbHMgdGhpcyBtZXRob2Qgc2hvdWxkXG4gICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHRoaXMuX3Byb2QgaXMgdmFsaWQgKG5vdCBgTk9gKVxuICAgICAgICB0aGlzLl9wcm9kLl9zdG9wKCk7XG4gICAgICAgIHRoaXMuX2VyciA9IE5PO1xuICAgICAgICB0aGlzLl9zdG9wSUQgPSBOTztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uIChpbCkge1xuICAgICAgICB2YXIgdGEgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgIGlmICh0YSAhPT0gTk8pXG4gICAgICAgICAgICByZXR1cm4gdGEuX2FkZChpbCk7XG4gICAgICAgIHZhciBhID0gdGhpcy5faWxzO1xuICAgICAgICBhLnB1c2goaWwpO1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fc3RvcElEICE9PSBOTykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0b3BJRCk7XG4gICAgICAgICAgICB0aGlzLl9zdG9wSUQgPSBOTztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5fcHJvZDtcbiAgICAgICAgICAgIGlmIChwICE9PSBOTylcbiAgICAgICAgICAgICAgICBwLl9zdGFydCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKGlsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YSA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgaWYgKHRhICE9PSBOTylcbiAgICAgICAgICAgIHJldHVybiB0YS5fcmVtb3ZlKGlsKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9pbHM7XG4gICAgICAgIHZhciBpID0gYS5pbmRleE9mKGlsKTtcbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvZCAhPT0gTk8gJiYgYS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VyciA9IE5PO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3N0b3BOb3coKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BydW5lQ3ljbGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGFsbCBwYXRocyBzdGVtbWluZyBmcm9tIGB0aGlzYCBzdHJlYW0gZXZlbnR1YWxseSBlbmQgYXQgYHRoaXNgXG4gICAgLy8gc3RyZWFtLCB0aGVuIHdlIHJlbW92ZSB0aGUgc2luZ2xlIGxpc3RlbmVyIG9mIGB0aGlzYCBzdHJlYW0sIHRvXG4gICAgLy8gZm9yY2UgaXQgdG8gZW5kIGl0cyBleGVjdXRpb24gYW5kIGRpc3Bvc2UgcmVzb3VyY2VzLiBUaGlzIG1ldGhvZFxuICAgIC8vIGFzc3VtZXMgYXMgYSBwcmVjb25kaXRpb24gdGhhdCB0aGlzLl9pbHMgaGFzIGp1c3Qgb25lIGxpc3RlbmVyLlxuICAgIFN0cmVhbS5wcm90b3R5cGUuX3BydW5lQ3ljbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzTm9TaW5rcyh0aGlzLCBbXSkpXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUodGhpcy5faWxzWzBdKTtcbiAgICB9O1xuICAgIC8vIENoZWNrcyB3aGV0aGVyICp0aGVyZSBpcyBubyogcGF0aCBzdGFydGluZyBmcm9tIGB4YCB0aGF0IGxlYWRzIHRvIGFuIGVuZFxuICAgIC8vIGxpc3RlbmVyIChzaW5rKSBpbiB0aGUgc3RyZWFtIGdyYXBoLCBmb2xsb3dpbmcgZWRnZXMgQS0+QiB3aGVyZSBCIGlzIGFcbiAgICAvLyBsaXN0ZW5lciBvZiBBLiBUaGlzIG1lYW5zIHRoZXNlIHBhdGhzIGNvbnN0aXR1dGUgYSBjeWNsZSBzb21laG93LiBJcyBnaXZlblxuICAgIC8vIGEgdHJhY2Ugb2YgYWxsIHZpc2l0ZWQgbm9kZXMgc28gZmFyLlxuICAgIFN0cmVhbS5wcm90b3R5cGUuX2hhc05vU2lua3MgPSBmdW5jdGlvbiAoeCwgdHJhY2UpIHtcbiAgICAgICAgaWYgKHRyYWNlLmluZGV4T2YoeCkgIT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHgub3V0ID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHgub3V0ICYmIHgub3V0ICE9PSBOTylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNOb1NpbmtzKHgub3V0LCB0cmFjZS5jb25jYXQoeCkpO1xuICAgICAgICBlbHNlIGlmICh4Ll9pbHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0geC5faWxzLmxlbmd0aDsgaSA8IE47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hhc05vU2lua3MoeC5faWxzW2ldLCB0cmFjZS5jb25jYXQoeCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgTWVtb3J5U3RyZWFtID8gTWVtb3J5U3RyZWFtIDogU3RyZWFtO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIExpc3RlbmVyIHRvIHRoZSBTdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIuX24gPSBsaXN0ZW5lci5uZXh0IHx8IG5vb3A7XG4gICAgICAgIGxpc3RlbmVyLl9lID0gbGlzdGVuZXIuZXJyb3IgfHwgbm9vcDtcbiAgICAgICAgbGlzdGVuZXIuX2MgPSBsaXN0ZW5lci5jb21wbGV0ZSB8fCBub29wO1xuICAgICAgICB0aGlzLl9hZGQobGlzdGVuZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIExpc3RlbmVyIGZyb20gdGhlIFN0cmVhbSwgYXNzdW1pbmcgdGhlIExpc3RlbmVyIHdhcyBhZGRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGlzdGVuZXI8VD59IGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9yZW1vdmUobGlzdGVuZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIExpc3RlbmVyIHRvIHRoZSBTdHJlYW0gcmV0dXJuaW5nIGEgU3Vic2NyaXB0aW9uIHRvIHJlbW92ZSB0aGF0XG4gICAgICogbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm5zIHtTdWJzY3JpcHRpb259XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtU3ViKHRoaXMsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBpbnRlcm9wIGJldHdlZW4gbW9zdC5qcyBhbmQgUnhKUyA1XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGVbc3ltYm9sX29ic2VydmFibGVfMS5kZWZhdWx0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0cmVhbSBnaXZlbiBhIFByb2R1Y2VyLlxuICAgICAqXG4gICAgICogQGZhY3RvcnkgdHJ1ZVxuICAgICAqIEBwYXJhbSB7UHJvZHVjZXJ9IHByb2R1Y2VyIEFuIG9wdGlvbmFsIFByb2R1Y2VyIHRoYXQgZGljdGF0ZXMgaG93IHRvXG4gICAgICogc3RhcnQsIGdlbmVyYXRlIGV2ZW50cywgYW5kIHN0b3AgdGhlIFN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLmNyZWF0ZSA9IGZ1bmN0aW9uIChwcm9kdWNlcikge1xuICAgICAgICBpZiAocHJvZHVjZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvZHVjZXIuc3RhcnQgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICB8fCB0eXBlb2YgcHJvZHVjZXIuc3RvcCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2R1Y2VyIHJlcXVpcmVzIGJvdGggc3RhcnQgYW5kIHN0b3AgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgICBpbnRlcm5hbGl6ZVByb2R1Y2VyKHByb2R1Y2VyKTsgLy8gbXV0YXRlcyB0aGUgaW5wdXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShwcm9kdWNlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1lbW9yeVN0cmVhbSBnaXZlbiBhIFByb2R1Y2VyLlxuICAgICAqXG4gICAgICogQGZhY3RvcnkgdHJ1ZVxuICAgICAqIEBwYXJhbSB7UHJvZHVjZXJ9IHByb2R1Y2VyIEFuIG9wdGlvbmFsIFByb2R1Y2VyIHRoYXQgZGljdGF0ZXMgaG93IHRvXG4gICAgICogc3RhcnQsIGdlbmVyYXRlIGV2ZW50cywgYW5kIHN0b3AgdGhlIFN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtNZW1vcnlTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLmNyZWF0ZVdpdGhNZW1vcnkgPSBmdW5jdGlvbiAocHJvZHVjZXIpIHtcbiAgICAgICAgaWYgKHByb2R1Y2VyKVxuICAgICAgICAgICAgaW50ZXJuYWxpemVQcm9kdWNlcihwcm9kdWNlcik7IC8vIG11dGF0ZXMgdGhlIGlucHV0XG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtKHByb2R1Y2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgd2hlbiBzdGFydGVkLiBJdCBuZXZlciBlbWl0cyBhbnkgZXZlbnQuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAgICAgICAgICBuZXZlclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5uZXZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oeyBfc3RhcnQ6IG5vb3AsIF9zdG9wOiBub29wIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFN0cmVhbSB0aGF0IGltbWVkaWF0ZWx5IGVtaXRzIHRoZSBcImNvbXBsZXRlXCIgbm90aWZpY2F0aW9uIHdoZW5cbiAgICAgKiBzdGFydGVkLCBhbmQgdGhhdCdzIGl0LlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogZW1wdHlcbiAgICAgKiAtfFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGZhY3RvcnkgdHJ1ZVxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKHtcbiAgICAgICAgICAgIF9zdGFydDogZnVuY3Rpb24gKGlsKSB7IGlsLl9jKCk7IH0sXG4gICAgICAgICAgICBfc3RvcDogbm9vcCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgZW1pdHMgYW4gXCJlcnJvclwiIG5vdGlmaWNhdGlvbiB3aXRoIHRoZVxuICAgICAqIHZhbHVlIHlvdSBwYXNzZWQgYXMgdGhlIGBlcnJvcmAgYXJndW1lbnQgd2hlbiB0aGUgc3RyZWFtIHN0YXJ0cywgYW5kIHRoYXQnc1xuICAgICAqIGl0LlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogdGhyb3coWClcbiAgICAgKiAtWFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGZhY3RvcnkgdHJ1ZVxuICAgICAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3IgZXZlbnQgdG8gZW1pdCBvbiB0aGUgY3JlYXRlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS50aHJvdyA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbSh7XG4gICAgICAgICAgICBfc3RhcnQ6IGZ1bmN0aW9uIChpbCkgeyBpbC5fZShlcnJvcik7IH0sXG4gICAgICAgICAgICBfc3RvcDogbm9vcCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyZWFtIGZyb20gYW4gQXJyYXksIFByb21pc2UsIG9yIGFuIE9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheXxQcm9taXNlfE9ic2VydmFibGV9IGlucHV0IFRoZSBpbnB1dCB0byBtYWtlIGEgc3RyZWFtIGZyb20uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5mcm9tID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRbc3ltYm9sX29ic2VydmFibGVfMS5kZWZhdWx0XSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW0uZnJvbU9ic2VydmFibGUoaW5wdXQpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW0uZnJvbVByb21pc2UoaW5wdXQpO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW0uZnJvbUFycmF5KGlucHV0KTtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGUgb2YgaW5wdXQgdG8gZnJvbSgpIG11c3QgYmUgYW4gQXJyYXksIFByb21pc2UsIG9yIE9ic2VydmFibGVcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgZW1pdHMgdGhlIGFyZ3VtZW50cyB0aGF0IHlvdSBnaXZlIHRvXG4gICAgICogKm9mKiwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiBvZigxLDIsMylcbiAgICAgKiAxMjN8XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIHlvdSB3YW50IHRvIGVtaXQgYXMgYW4gZXZlbnQgb24gdGhlIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHlvdSB3YW50IHRvIGVtaXQgYXMgYW4gZXZlbnQgb24gdGhlIHN0cmVhbS4gT25lXG4gICAgICogb3IgbW9yZSBvZiB0aGVzZSB2YWx1ZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLm9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tQXJyYXkoaXRlbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gYXJyYXkgdG8gYSBzdHJlYW0uIFRoZSByZXR1cm5lZCBzdHJlYW0gd2lsbCBlbWl0IHN5bmNocm9ub3VzbHlcbiAgICAgKiBhbGwgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSwgYW5kIHRoZW4gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiBmcm9tQXJyYXkoWzEsMiwzXSlcbiAgICAgKiAxMjN8XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGJlIGNvbnZlcnRlZCBhcyBhIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgRnJvbUFycmF5KGFycmF5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHByb21pc2UgdG8gYSBzdHJlYW0uIFRoZSByZXR1cm5lZCBzdHJlYW0gd2lsbCBlbWl0IHRoZSByZXNvbHZlZFxuICAgICAqIHZhbHVlIG9mIHRoZSBwcm9taXNlLCBhbmQgdGhlbiBjb21wbGV0ZS4gSG93ZXZlciwgaWYgdGhlIHByb21pc2UgaXNcbiAgICAgKiByZWplY3RlZCwgdGhlIHN0cmVhbSB3aWxsIGVtaXQgdGhlIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiBmcm9tUHJvbWlzZSggLS0tLTQyIClcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLTQyfFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGZhY3RvcnkgdHJ1ZVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgcHJvbWlzZSB0byBiZSBjb252ZXJ0ZWQgYXMgYSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBGcm9tUHJvbWlzZShwcm9taXNlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBPYnNlcnZhYmxlIGludG8gYSBTdHJlYW0uXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHthbnl9IG9ic2VydmFibGUgVGhlIG9ic2VydmFibGUgdG8gYmUgY29udmVydGVkIGFzIGEgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uZnJvbU9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JzKSB7XG4gICAgICAgIGlmIChvYnMuZW5kV2hlbilcbiAgICAgICAgICAgIHJldHVybiBvYnM7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBGcm9tT2JzZXJ2YWJsZShvYnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdHJlYW0gdGhhdCBwZXJpb2RpY2FsbHkgZW1pdHMgaW5jcmVtZW50YWwgbnVtYmVycywgZXZlcnlcbiAgICAgKiBgcGVyaW9kYCBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAgICAgcGVyaW9kaWMoMTAwMClcbiAgICAgKiAtLS0wLS0tMS0tLTItLS0zLS0tNC0tLS4uLlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGZhY3RvcnkgdHJ1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2QgVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byB1c2UgYXMgYSByYXRlIG9mXG4gICAgICogZW1pc3Npb24uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wZXJpb2RpYyA9IGZ1bmN0aW9uIChwZXJpb2QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IFBlcmlvZGljKHBlcmlvZCkpO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fbWFwID0gZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9kO1xuICAgICAgICB2YXIgY3RvciA9IHRoaXMuY3RvcigpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcihuZXcgRmlsdGVyTWFwRnVzaW9uKHAuZiwgcHJvamVjdCwgcC5pbnMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKG5ldyBNYXBPcChwcm9qZWN0LCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGVhY2ggZXZlbnQgZnJvbSB0aGUgaW5wdXQgU3RyZWFtIHRocm91Z2ggYSBgcHJvamVjdGAgZnVuY3Rpb24sXG4gICAgICogdG8gZ2V0IGEgU3RyZWFtIHRoYXQgZW1pdHMgdGhvc2UgdHJhbnNmb3JtZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS0xLS0tMy0tNS0tLS0tNy0tLS0tLVxuICAgICAqICAgIG1hcChpID0+IGkgKiAxMClcbiAgICAgKiAtLTEwLS0zMC01MC0tLS03MC0tLS0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9qZWN0IEEgZnVuY3Rpb24gb2YgdHlwZSBgKHQ6IFQpID0+IFVgIHRoYXQgdGFrZXMgZXZlbnRcbiAgICAgKiBgdGAgb2YgdHlwZSBgVGAgZnJvbSB0aGUgaW5wdXQgU3RyZWFtIGFuZCBwcm9kdWNlcyBhbiBldmVudCBvZiB0eXBlIGBVYCwgdG9cbiAgICAgKiBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgU3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAocHJvamVjdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdCdzIGxpa2UgYG1hcGAsIGJ1dCB0cmFuc2Zvcm1zIGVhY2ggaW5wdXQgZXZlbnQgdG8gYWx3YXlzIHRoZSBzYW1lXG4gICAgICogY29uc3RhbnQgdmFsdWUgb24gdGhlIG91dHB1dCBTdHJlYW0uXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0zLS01LS0tLS03LS0tLS1cbiAgICAgKiAgICAgICBtYXBUbygxMClcbiAgICAgKiAtLTEwLS0xMC0xMC0tLS0xMC0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9qZWN0ZWRWYWx1ZSBBIHZhbHVlIHRvIGVtaXQgb24gdGhlIG91dHB1dCBTdHJlYW0gd2hlbmV2ZXIgdGhlXG4gICAgICogaW5wdXQgU3RyZWFtIGVtaXRzIGFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5tYXBUbyA9IGZ1bmN0aW9uIChwcm9qZWN0ZWRWYWx1ZSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb2plY3RlZFZhbHVlOyB9KTtcbiAgICAgICAgdmFyIG9wID0gcy5fcHJvZDtcbiAgICAgICAgb3AudHlwZSA9IG9wLnR5cGUucmVwbGFjZSgnbWFwJywgJ21hcFRvJyk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT25seSBhbGxvd3MgZXZlbnRzIHRoYXQgcGFzcyB0aGUgdGVzdCBnaXZlbiBieSB0aGUgYHBhc3Nlc2AgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBFYWNoIGV2ZW50IGZyb20gdGhlIGlucHV0IHN0cmVhbSBpcyBnaXZlbiB0byB0aGUgYHBhc3Nlc2AgZnVuY3Rpb24uIElmIHRoZVxuICAgICAqIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgLCB0aGUgZXZlbnQgaXMgZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtLFxuICAgICAqIG90aGVyd2lzZSBpdCBpcyBpZ25vcmVkIGFuZCBub3QgZm9yd2FyZGVkLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS0xLS0tMi0tMy0tLS0tNC0tLS0tNS0tLTYtLTctOC0tXG4gICAgICogICAgIGZpbHRlcihpID0+IGkgJSAyID09PSAwKVxuICAgICAqIC0tLS0tLTItLS0tLS0tLTQtLS0tLS0tLS02LS0tLTgtLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFzc2VzIEEgZnVuY3Rpb24gb2YgdHlwZSBgKHQ6IFQpICs+IGJvb2xlYW5gIHRoYXQgdGFrZXNcbiAgICAgKiBhbiBldmVudCBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gYW5kIGNoZWNrcyBpZiBpdCBwYXNzZXMsIGJ5IHJldHVybmluZyBhXG4gICAgICogYm9vbGVhbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAocGFzc2VzKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5fcHJvZDtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBGaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgRmlsdGVyKGFuZChwLmYsIHBhc3NlcyksIHAuaW5zKSk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBGaWx0ZXIocGFzc2VzLCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMZXRzIHRoZSBmaXJzdCBgYW1vdW50YCBtYW55IGV2ZW50cyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gcGFzcyB0byB0aGVcbiAgICAgKiBvdXRwdXQgc3RyZWFtLCB0aGVuIG1ha2VzIHRoZSBvdXRwdXQgc3RyZWFtIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS1hLS0tYi0tYy0tLS1kLS0tZS0tXG4gICAgICogICAgdGFrZSgzKVxuICAgICAqIC0tYS0tLWItLWN8XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IEhvdyBtYW55IGV2ZW50cyB0byBhbGxvdyBmcm9tIHRoZSBpbnB1dCBzdHJlYW1cbiAgICAgKiBiZWZvcmUgY29tcGxldGluZyB0aGUgb3V0cHV0IHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS50YWtlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmN0b3IoKSkobmV3IFRha2UoYW1vdW50LCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZ25vcmVzIHRoZSBmaXJzdCBgYW1vdW50YCBtYW55IGV2ZW50cyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIGFuZCB0aGVuXG4gICAgICogYWZ0ZXIgdGhhdCBzdGFydHMgZm9yd2FyZGluZyBldmVudHMgZnJvbSB0aGUgaW5wdXQgc3RyZWFtIHRvIHRoZSBvdXRwdXRcbiAgICAgKiBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLWEtLS1iLS1jLS0tLWQtLS1lLS1cbiAgICAgKiAgICAgICBkcm9wKDMpXG4gICAgICogLS0tLS0tLS0tLS0tLS1kLS0tZS0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IEhvdyBtYW55IGV2ZW50cyB0byBpZ25vcmUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtXG4gICAgICogYmVmb3JlIGZvcndhcmRpbmcgYWxsIGV2ZW50cyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gdG8gdGhlIG91dHB1dCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuZHJvcCA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IERyb3AoYW1vdW50LCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBpbnB1dCBzdHJlYW0gY29tcGxldGVzLCB0aGUgb3V0cHV0IHN0cmVhbSB3aWxsIGVtaXQgdGhlIGxhc3QgZXZlbnRcbiAgICAgKiBlbWl0dGVkIGJ5IHRoZSBpbnB1dCBzdHJlYW0sIGFuZCB0aGVuIHdpbGwgYWxzbyBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tYS0tLWItLWMtLWQtLS0tfFxuICAgICAqICAgICAgIGxhc3QoKVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tZHxcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBMYXN0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoZSBnaXZlbiBgaW5pdGlhbGAgdmFsdWUgdG8gdGhlIHNlcXVlbmNlIG9mIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZVxuICAgICAqIGlucHV0IHN0cmVhbS4gVGhlIHJldHVybmVkIHN0cmVhbSBpcyBhIE1lbW9yeVN0cmVhbSwgd2hpY2ggbWVhbnMgaXQgaXNcbiAgICAgKiBhbHJlYWR5IGByZW1lbWJlcigpYCdkLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS0tMS0tLTItLS0tLTMtLS1cbiAgICAgKiAgIHN0YXJ0V2l0aCgwKVxuICAgICAqIDAtLTEtLS0yLS0tLS0zLS0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5pdGlhbCBUaGUgdmFsdWUgb3IgZXZlbnQgdG8gcHJlcGVuZC5cbiAgICAgKiBAcmV0dXJuIHtNZW1vcnlTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5zdGFydFdpdGggPSBmdW5jdGlvbiAoaW5pdGlhbCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVN0cmVhbShuZXcgU3RhcnRXaXRoKHRoaXMsIGluaXRpYWwpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZXMgYW5vdGhlciBzdHJlYW0gdG8gZGV0ZXJtaW5lIHdoZW4gdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgc3RyZWFtLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgZ2l2ZW4gYG90aGVyYCBzdHJlYW0gZW1pdHMgYW4gZXZlbnQgb3IgY29tcGxldGVzLCB0aGUgb3V0cHV0XG4gICAgICogc3RyZWFtIHdpbGwgY29tcGxldGUuIEJlZm9yZSB0aGF0IGhhcHBlbnMsIHRoZSBvdXRwdXQgc3RyZWFtIHdpbGwgYmVoYXZlc1xuICAgICAqIGxpa2UgdGhlIGlucHV0IHN0cmVhbS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tLTEtLS0yLS0tLS0zLS00LS0tLTUtLS0tNi0tLVxuICAgICAqICAgZW5kV2hlbiggLS0tLS0tLS1hLS1iLS18IClcbiAgICAgKiAtLS0xLS0tMi0tLS0tMy0tNC0tfFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIFNvbWUgb3RoZXIgc3RyZWFtIHRoYXQgaXMgdXNlZCB0byBrbm93IHdoZW4gc2hvdWxkIHRoZSBvdXRwdXRcbiAgICAgKiBzdHJlYW0gb2YgdGhpcyBvcGVyYXRvciBjb21wbGV0ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5lbmRXaGVuID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3RvcigpKShuZXcgRW5kV2hlbihvdGhlciwgdGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogXCJGb2xkc1wiIHRoZSBzdHJlYW0gb250byBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBDb21iaW5lcyBldmVudHMgZnJvbSB0aGUgcGFzdCB0aHJvdWdob3V0XG4gICAgICogdGhlIGVudGlyZSBleGVjdXRpb24gb2YgdGhlIGlucHV0IHN0cmVhbSwgYWxsb3dpbmcgeW91IHRvIGFjY3VtdWxhdGUgdGhlbVxuICAgICAqIHRvZ2V0aGVyLiBJdCdzIGVzc2VudGlhbGx5IGxpa2UgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgLiBUaGUgcmV0dXJuZWRcbiAgICAgKiBzdHJlYW0gaXMgYSBNZW1vcnlTdHJlYW0sIHdoaWNoIG1lYW5zIGl0IGlzIGFscmVhZHkgYHJlbWVtYmVyKClgJ2QuXG4gICAgICpcbiAgICAgKiBUaGUgb3V0cHV0IHN0cmVhbSBzdGFydHMgYnkgZW1pdHRpbmcgdGhlIGBzZWVkYCB3aGljaCB5b3UgZ2l2ZSBhcyBhcmd1bWVudC5cbiAgICAgKiBUaGVuLCB3aGVuIGFuIGV2ZW50IGhhcHBlbnMgb24gdGhlIGlucHV0IHN0cmVhbSwgaXQgaXMgY29tYmluZWQgd2l0aCB0aGF0XG4gICAgICogc2VlZCB2YWx1ZSB0aHJvdWdoIHRoZSBgYWNjdW11bGF0ZWAgZnVuY3Rpb24sIGFuZCB0aGUgb3V0cHV0IHZhbHVlIGlzXG4gICAgICogZW1pdHRlZCBvbiB0aGUgb3V0cHV0IHN0cmVhbS4gYGZvbGRgIHJlbWVtYmVycyB0aGF0IG91dHB1dCB2YWx1ZSBhcyBgYWNjYFxuICAgICAqIChcImFjY3VtdWxhdG9yXCIpLCBhbmQgdGhlbiB3aGVuIGEgbmV3IGlucHV0IGV2ZW50IGB0YCBoYXBwZW5zLCBgYWNjYCB3aWxsIGJlXG4gICAgICogY29tYmluZWQgd2l0aCB0aGF0IHRvIHByb2R1Y2UgdGhlIG5ldyBgYWNjYCBhbmQgc28gZm9ydGguXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLS0tLS0xLS0tLS0xLS0yLS0tLTEtLS0tMS0tLS0tLVxuICAgICAqICAgZm9sZCgoYWNjLCB4KSA9PiBhY2MgKyB4LCAzKVxuICAgICAqIDMtLS0tLTQtLS0tLTUtLTctLS0tOC0tLS05LS0tLS0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY2N1bXVsYXRlIEEgZnVuY3Rpb24gb2YgdHlwZSBgKGFjYzogUiwgdDogVCkgPT4gUmAgdGhhdFxuICAgICAqIHRha2VzIHRoZSBwcmV2aW91cyBhY2N1bXVsYXRlZCB2YWx1ZSBgYWNjYCBhbmQgdGhlIGluY29taW5nIGV2ZW50IGZyb20gdGhlXG4gICAgICogaW5wdXQgc3RyZWFtIGFuZCBwcm9kdWNlcyB0aGUgbmV3IGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBpbml0aWFsIGFjY3VtdWxhdGVkIHZhbHVlLCBvZiB0eXBlIGBSYC5cbiAgICAgKiBAcmV0dXJuIHtNZW1vcnlTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24gKGFjY3VtdWxhdGUsIHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0obmV3IEZvbGQoYWNjdW11bGF0ZSwgc2VlZCwgdGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW4gZXJyb3Igd2l0aCBhbm90aGVyIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIFdoZW4gKGFuZCBpZikgYW4gZXJyb3IgaGFwcGVucyBvbiB0aGUgaW5wdXQgc3RyZWFtLCBpbnN0ZWFkIG9mIGZvcndhcmRpbmdcbiAgICAgKiB0aGF0IGVycm9yIHRvIHRoZSBvdXRwdXQgc3RyZWFtLCAqcmVwbGFjZUVycm9yKiB3aWxsIGNhbGwgdGhlIGByZXBsYWNlYFxuICAgICAqIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHN0cmVhbSB0aGF0IHRoZSBvdXRwdXQgc3RyZWFtIHdpbGwgcmVwbGljYXRlLlxuICAgICAqIEFuZCwgaW4gY2FzZSB0aGF0IG5ldyBzdHJlYW0gYWxzbyBlbWl0cyBhbiBlcnJvciwgYHJlcGxhY2VgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogYWdhaW4gdG8gZ2V0IGFub3RoZXIgc3RyZWFtIHRvIHN0YXJ0IHJlcGxpY2F0aW5nLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS0xLS0tMi0tLS0tMy0tNC0tLS0tWFxuICAgICAqICAgcmVwbGFjZUVycm9yKCAoKSA9PiAtLTEwLS18IClcbiAgICAgKiAtLTEtLS0yLS0tLS0zLS00LS0tLS0tLS0xMC0tfFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVwbGFjZSBBIGZ1bmN0aW9uIG9mIHR5cGUgYChlcnIpID0+IFN0cmVhbWAgdGhhdCB0YWtlc1xuICAgICAqIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkIG9uIHRoZSBpbnB1dCBzdHJlYW0gb3Igb24gdGhlIHByZXZpb3VzIHJlcGxhY2VtZW50XG4gICAgICogc3RyZWFtIGFuZCByZXR1cm5zIGEgbmV3IHN0cmVhbS4gVGhlIG91dHB1dCBzdHJlYW0gd2lsbCBiZWhhdmUgbGlrZSB0aGVcbiAgICAgKiBzdHJlYW0gdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMuXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUucmVwbGFjZUVycm9yID0gZnVuY3Rpb24gKHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jdG9yKCkpKG5ldyBSZXBsYWNlRXJyb3IocmVwbGFjZSwgdGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBcInN0cmVhbSBvZiBzdHJlYW1zXCIsIGhhbmRsaW5nIG9ubHkgb25lIG5lc3RlZCBzdHJlYW0gYXQgYSB0aW1lXG4gICAgICogKG5vIGNvbmN1cnJlbmN5KS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBpbnB1dCBzdHJlYW0gaXMgYSBzdHJlYW0gdGhhdCBlbWl0cyBzdHJlYW1zLCB0aGVuIHRoaXMgb3BlcmF0b3Igd2lsbFxuICAgICAqIHJldHVybiBhbiBvdXRwdXQgc3RyZWFtIHdoaWNoIGlzIGEgZmxhdCBzdHJlYW06IGVtaXRzIHJlZ3VsYXIgZXZlbnRzLiBUaGVcbiAgICAgKiBmbGF0dGVuaW5nIGhhcHBlbnMgd2l0aG91dCBjb25jdXJyZW5jeS4gSXQgd29ya3MgbGlrZSB0aGlzOiB3aGVuIHRoZSBpbnB1dFxuICAgICAqIHN0cmVhbSBlbWl0cyBhIG5lc3RlZCBzdHJlYW0sICpmbGF0dGVuKiB3aWxsIHN0YXJ0IGltaXRhdGluZyB0aGF0IG5lc3RlZFxuICAgICAqIG9uZS4gSG93ZXZlciwgYXMgc29vbiBhcyB0aGUgbmV4dCBuZXN0ZWQgc3RyZWFtIGlzIGVtaXR0ZWQgb24gdGhlIGlucHV0XG4gICAgICogc3RyZWFtLCAqZmxhdHRlbiogd2lsbCBmb3JnZXQgdGhlIHByZXZpb3VzIG5lc3RlZCBvbmUgaXQgd2FzIGltaXRhdGluZywgYW5kXG4gICAgICogd2lsbCBzdGFydCBpbWl0YXRpbmcgdGhlIG5ldyBuZXN0ZWQgb25lLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS0rLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tXG4gICAgICogICBcXCAgICAgICAgXFxcbiAgICAgKiAgICBcXCAgICAgICAtLS0tMS0tLS0yLS0tMy0tXG4gICAgICogICAgLS1hLS1iLS0tLWMtLS0tZC0tLS0tLS0tXG4gICAgICogICAgICAgICAgIGZsYXR0ZW5cbiAgICAgKiAtLS0tLWEtLWItLS0tLS0xLS0tLTItLS0zLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5fcHJvZDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0ocCBpbnN0YW5jZW9mIE1hcE9wICYmICEocCBpbnN0YW5jZW9mIEZpbHRlck1hcEZ1c2lvbikgP1xuICAgICAgICAgICAgbmV3IE1hcEZsYXR0ZW4ocCkgOlxuICAgICAgICAgICAgbmV3IEZsYXR0ZW4odGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFzc2VzIHRoZSBpbnB1dCBzdHJlYW0gdG8gYSBjdXN0b20gb3BlcmF0b3IsIHRvIHByb2R1Y2UgYW4gb3V0cHV0IHN0cmVhbS5cbiAgICAgKlxuICAgICAqICpjb21wb3NlKiBpcyBhIGhhbmR5IHdheSBvZiB1c2luZyBhbiBleGlzdGluZyBmdW5jdGlvbiBpbiBhIGNoYWluZWQgc3R5bGUuXG4gICAgICogSW5zdGVhZCBvZiB3cml0aW5nIGBvdXRTdHJlYW0gPSBmKGluU3RyZWFtKWAgeW91IGNhbiB3cml0ZVxuICAgICAqIGBvdXRTdHJlYW0gPSBpblN0cmVhbS5jb21wb3NlKGYpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0cmVhbSBhcyBpbnB1dCBhbmRcbiAgICAgKiByZXR1cm5zIGEgc3RyZWFtIGFzIHdlbGwuXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuY29tcG9zZSA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICByZXR1cm4gb3BlcmF0b3IodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG91dHB1dCBzdHJlYW0gdGhhdCBiZWhhdmVzIGxpa2UgdGhlIGlucHV0IHN0cmVhbSwgYnV0IGFsc29cbiAgICAgKiByZW1lbWJlcnMgdGhlIG1vc3QgcmVjZW50IGV2ZW50IHRoYXQgaGFwcGVucyBvbiB0aGUgaW5wdXQgc3RyZWFtLCBzbyB0aGF0IGFcbiAgICAgKiBuZXdseSBhZGRlZCBsaXN0ZW5lciB3aWxsIGltbWVkaWF0ZWx5IHJlY2VpdmUgdGhhdCBtZW1vcmlzZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNZW1vcnlTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5yZW1lbWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0obmV3IFJlbWVtYmVyKHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb3V0cHV0IHN0cmVhbSB0aGF0IGlkZW50aWNhbGx5IGJlaGF2ZXMgbGlrZSB0aGUgaW5wdXQgc3RyZWFtLFxuICAgICAqIGJ1dCBhbHNvIHJ1bnMgYSBgc3B5YCBmdW5jdGlvbiBmbyBlYWNoIGV2ZW50LCB0byBoZWxwIHlvdSBkZWJ1ZyB5b3VyIGFwcC5cbiAgICAgKlxuICAgICAqICpkZWJ1ZyogdGFrZXMgYSBgc3B5YCBmdW5jdGlvbiBhcyBhcmd1bWVudCwgYW5kIHJ1bnMgdGhhdCBmb3IgZWFjaCBldmVudFxuICAgICAqIGhhcHBlbmluZyBvbiB0aGUgaW5wdXQgc3RyZWFtLiBJZiB5b3UgZG9uJ3QgcHJvdmlkZSB0aGUgYHNweWAgYXJndW1lbnQsXG4gICAgICogdGhlbiAqZGVidWcqIHdpbGwganVzdCBgY29uc29sZS5sb2dgIGVhY2ggZXZlbnQuIFRoaXMgaGVscHMgeW91IHRvXG4gICAgICogdW5kZXJzdGFuZCB0aGUgZmxvdyBvZiBldmVudHMgdGhyb3VnaCBzb21lIG9wZXJhdG9yIGNoYWluLlxuICAgICAqXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCBpZiB0aGUgb3V0cHV0IHN0cmVhbSBoYXMgbm8gbGlzdGVuZXJzLCB0aGVuIGl0IHdpbGwgbm90XG4gICAgICogc3RhcnQsIHdoaWNoIG1lYW5zIGBzcHlgIHdpbGwgbmV2ZXIgcnVuIGJlY2F1c2Ugbm8gYWN0dWFsIGV2ZW50IGhhcHBlbnMgaW5cbiAgICAgKiB0aGF0IGNhc2UuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0tMi0tLS0tMy0tLS0tNC0tXG4gICAgICogICAgICAgICBkZWJ1Z1xuICAgICAqIC0tMS0tLS0yLS0tLS0zLS0tLS00LS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxhYmVsT3JTcHkgQSBzdHJpbmcgdG8gdXNlIGFzIHRoZSBsYWJlbCB3aGVuIHByaW50aW5nXG4gICAgICogZGVidWcgaW5mb3JtYXRpb24gb24gdGhlIGNvbnNvbGUsIG9yIGEgJ3NweScgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBldmVudFxuICAgICAqIGFzIGFyZ3VtZW50LCBhbmQgZG9lcyBub3QgbmVlZCB0byByZXR1cm4gYW55dGhpbmcuXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobGFiZWxPclNweSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmN0b3IoKSkobmV3IERlYnVnKHRoaXMsIGxhYmVsT3JTcHkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqICppbWl0YXRlKiBjaGFuZ2VzIHRoaXMgY3VycmVudCBTdHJlYW0gdG8gZW1pdCB0aGUgc2FtZSBldmVudHMgdGhhdCB0aGVcbiAgICAgKiBgb3RoZXJgIGdpdmVuIFN0cmVhbSBkb2VzLiBUaGlzIG1ldGhvZCByZXR1cm5zIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gYWxsb3cgb25lIHRoaW5nOiAqKmNpcmN1bGFyIGRlcGVuZGVuY3kgb2Ygc3RyZWFtcyoqLlxuICAgICAqIEZvciBpbnN0YW5jZSwgbGV0J3MgaW1hZ2luZSB0aGF0IGZvciBzb21lIHJlYXNvbiB5b3UgbmVlZCB0byBjcmVhdGUgYVxuICAgICAqIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2hlcmUgc3RyZWFtIGBmaXJzdCRgIGRlcGVuZHMgb24gc3RyZWFtIGBzZWNvbmQkYFxuICAgICAqIHdoaWNoIGluIHR1cm4gZGVwZW5kcyBvbiBgZmlyc3QkYDpcbiAgICAgKlxuICAgICAqIDwhLS0gc2tpcC1leGFtcGxlIC0tPlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IGRlbGF5IGZyb20gJ3hzdHJlYW0vZXh0cmEvZGVsYXknXG4gICAgICpcbiAgICAgKiB2YXIgZmlyc3QkID0gc2Vjb25kJC5tYXAoeCA9PiB4ICogMTApLnRha2UoMyk7XG4gICAgICogdmFyIHNlY29uZCQgPSBmaXJzdCQubWFwKHggPT4geCArIDEpLnN0YXJ0V2l0aCgxKS5jb21wb3NlKGRlbGF5KDEwMCkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSG93ZXZlciwgdGhhdCBpcyBpbnZhbGlkIEphdmFTY3JpcHQsIGJlY2F1c2UgYHNlY29uZCRgIGlzIHVuZGVmaW5lZFxuICAgICAqIG9uIHRoZSBmaXJzdCBsaW5lLiBUaGlzIGlzIGhvdyAqaW1pdGF0ZSogY2FuIGhlbHAgc29sdmUgaXQ6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBkZWxheSBmcm9tICd4c3RyZWFtL2V4dHJhL2RlbGF5J1xuICAgICAqXG4gICAgICogdmFyIHNlY29uZFByb3h5JCA9IHhzLmNyZWF0ZSgpO1xuICAgICAqIHZhciBmaXJzdCQgPSBzZWNvbmRQcm94eSQubWFwKHggPT4geCAqIDEwKS50YWtlKDMpO1xuICAgICAqIHZhciBzZWNvbmQkID0gZmlyc3QkLm1hcCh4ID0+IHggKyAxKS5zdGFydFdpdGgoMSkuY29tcG9zZShkZWxheSgxMDApKTtcbiAgICAgKiBzZWNvbmRQcm94eSQuaW1pdGF0ZShzZWNvbmQkKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdlIGNyZWF0ZSBgc2Vjb25kUHJveHkkYCBiZWZvcmUgdGhlIG90aGVycywgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlXG4gICAgICogZGVjbGFyYXRpb24gb2YgYGZpcnN0JGAuIFRoZW4sIGFmdGVyIGJvdGggYGZpcnN0JGAgYW5kIGBzZWNvbmQkYCBhcmVcbiAgICAgKiBkZWZpbmVkLCB3ZSBob29rIGBzZWNvbmRQcm94eSRgIHdpdGggYHNlY29uZCRgIHdpdGggYGltaXRhdGUoKWAgdG8gdGVsbFxuICAgICAqIHRoYXQgdGhleSBhcmUgXCJ0aGUgc2FtZVwiLiBgaW1pdGF0ZWAgd2lsbCBub3QgdHJpZ2dlciB0aGUgc3RhcnQgb2YgYW55XG4gICAgICogc3RyZWFtLCBpdCBqdXN0IGJpbmRzIGBzZWNvbmRQcm94eSRgIGFuZCBgc2Vjb25kJGAgdG9nZXRoZXIuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgd2hlcmUgYGltaXRhdGUoKWAgaXMgaW1wb3J0YW50IGluIEN5Y2xlLmpzXG4gICAgICogYXBwbGljYXRpb25zLiBBIHBhcmVudCBjb21wb25lbnQgY29udGFpbnMgc29tZSBjaGlsZCBjb21wb25lbnRzLiBBIGNoaWxkXG4gICAgICogaGFzIGFuIGFjdGlvbiBzdHJlYW0gd2hpY2ggaXMgZ2l2ZW4gdG8gdGhlIHBhcmVudCB0byBkZWZpbmUgaXRzIHN0YXRlOlxuICAgICAqXG4gICAgICogPCEtLSBza2lwLWV4YW1wbGUgLS0+XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBjaGlsZEFjdGlvblByb3h5JCA9IHhzLmNyZWF0ZSgpO1xuICAgICAqIGNvbnN0IHBhcmVudCA9IFBhcmVudCh7Li4uc291cmNlcywgY2hpbGRBY3Rpb24kOiBjaGlsZEFjdGlvblByb3h5JH0pO1xuICAgICAqIGNvbnN0IGNoaWxkQWN0aW9uJCA9IHBhcmVudC5zdGF0ZSQubWFwKHMgPT4gcy5jaGlsZC5hY3Rpb24kKS5mbGF0dGVuKCk7XG4gICAgICogY2hpbGRBY3Rpb25Qcm94eSQuaW1pdGF0ZShjaGlsZEFjdGlvbiQpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90ZSwgdGhvdWdoLCB0aGF0ICoqYGltaXRhdGUoKWAgZG9lcyBub3Qgc3VwcG9ydCBNZW1vcnlTdHJlYW1zKiouIElmIHdlXG4gICAgICogd291bGQgYXR0ZW1wdCB0byBpbWl0YXRlIGEgTWVtb3J5U3RyZWFtIGluIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgd2Ugd291bGRcbiAgICAgKiBlaXRoZXIgZ2V0IGEgcmFjZSBjb25kaXRpb24gKHdoZXJlIHRoZSBzeW1wdG9tIHdvdWxkIGJlIFwibm90aGluZyBoYXBwZW5zXCIpXG4gICAgICogb3IgYW4gaW5maW5pdGUgY3ljbGljIGVtaXNzaW9uIG9mIHZhbHVlcy4gSXQncyB1c2VmdWwgdG8gdGhpbmsgYWJvdXRcbiAgICAgKiBNZW1vcnlTdHJlYW1zIGFzIGNlbGxzIGluIGEgc3ByZWFkc2hlZXQuIEl0IGRvZXNuJ3QgbWFrZSBhbnkgc2Vuc2UgdG9cbiAgICAgKiBkZWZpbmUgYSBzcHJlYWRzaGVldCBjZWxsIGBBMWAgd2l0aCBhIGZvcm11bGEgdGhhdCBkZXBlbmRzIG9uIGBCMWAgYW5kXG4gICAgICogY2VsbCBgQjFgIGRlZmluZWQgd2l0aCBhIGZvcm11bGEgdGhhdCBkZXBlbmRzIG9uIGBBMWAuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZmluZCB5b3Vyc2VsZiB3YW50aW5nIHRvIHVzZSBgaW1pdGF0ZSgpYCB3aXRoIGFcbiAgICAgKiBNZW1vcnlTdHJlYW0sIHlvdSBzaG91bGQgcmV3b3JrIHlvdXIgY29kZSBhcm91bmQgYGltaXRhdGUoKWAgdG8gdXNlIGFcbiAgICAgKiBTdHJlYW0gaW5zdGVhZC4gTG9vayBmb3IgdGhlIHN0cmVhbSBpbiB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeSB0aGF0XG4gICAgICogcmVwcmVzZW50cyBhbiBldmVudCBzdHJlYW0sIGFuZCB0aGF0IHdvdWxkIGJlIGEgY2FuZGlkYXRlIGZvciBjcmVhdGluZyBhXG4gICAgICogcHJveHkgU3RyZWFtIHdoaWNoIHRoZW4gaW1pdGF0ZXMgdGhlIHRhcmdldCBTdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmVhbX0gdGFyZ2V0IFRoZSBvdGhlciBzdHJlYW0gdG8gaW1pdGF0ZSBvbiB0aGUgY3VycmVudCBvbmUuIE11c3RcbiAgICAgKiBub3QgYmUgYSBNZW1vcnlTdHJlYW0uXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5pbWl0YXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWVtb3J5U3RyZWFtKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIE1lbW9yeVN0cmVhbSB3YXMgZ2l2ZW4gdG8gaW1pdGF0ZSgpLCBidXQgaXQgb25seSAnICtcbiAgICAgICAgICAgICAgICAnc3VwcG9ydHMgYSBTdHJlYW0uIFJlYWQgbW9yZSBhYm91dCB0aGlzIHJlc3RyaWN0aW9uIGhlcmU6ICcgK1xuICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vc3RhbHR6L3hzdHJlYW0jZmFxJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgZm9yICh2YXIgaWxzID0gdGhpcy5faWxzLCBOID0gaWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBOOyBpKyspXG4gICAgICAgICAgICB0YXJnZXQuX2FkZChpbHNbaV0pO1xuICAgICAgICB0aGlzLl9pbHMgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgU3RyZWFtIHRvIGVtaXQgdGhlIGdpdmVuIHZhbHVlIHRvIGl0cyBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBBcyB0aGUgbmFtZSBpbmRpY2F0ZXMsIGlmIHlvdSB1c2UgdGhpcywgeW91IGFyZSBtb3N0IGxpa2VseSBkb2luZyBzb21ldGhpbmdcbiAgICAgKiBUaGUgV3JvbmcgV2F5LiBQbGVhc2UgdHJ5IHRvIHVuZGVyc3RhbmQgdGhlIHJlYWN0aXZlIHdheSBiZWZvcmUgdXNpbmcgdGhpc1xuICAgICAqIG1ldGhvZC4gVXNlIGl0IG9ubHkgd2hlbiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIFwibmV4dFwiIHZhbHVlIHlvdSB3YW50IHRvIGJyb2FkY2FzdCB0byBhbGwgbGlzdGVuZXJzIG9mXG4gICAgICogdGhpcyBTdHJlYW0uXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5zaGFtZWZ1bGx5U2VuZE5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbih2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIFN0cmVhbSB0byBlbWl0IHRoZSBnaXZlbiBlcnJvciB0byBpdHMgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQXMgdGhlIG5hbWUgaW5kaWNhdGVzLCBpZiB5b3UgdXNlIHRoaXMsIHlvdSBhcmUgbW9zdCBsaWtlbHkgZG9pbmcgc29tZXRoaW5nXG4gICAgICogVGhlIFdyb25nIFdheS4gUGxlYXNlIHRyeSB0byB1bmRlcnN0YW5kIHRoZSByZWFjdGl2ZSB3YXkgYmVmb3JlIHVzaW5nIHRoaXNcbiAgICAgKiBtZXRob2QuIFVzZSBpdCBvbmx5IHdoZW4geW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGVycm9yIFRoZSBlcnJvciB5b3Ugd2FudCB0byBicm9hZGNhc3QgdG8gYWxsIHRoZSBsaXN0ZW5lcnMgb2ZcbiAgICAgKiB0aGlzIFN0cmVhbS5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnNoYW1lZnVsbHlTZW5kRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZShlcnJvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIFN0cmVhbSB0byBlbWl0IHRoZSBcImNvbXBsZXRlZFwiIGV2ZW50IHRvIGl0cyBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBBcyB0aGUgbmFtZSBpbmRpY2F0ZXMsIGlmIHlvdSB1c2UgdGhpcywgeW91IGFyZSBtb3N0IGxpa2VseSBkb2luZyBzb21ldGhpbmdcbiAgICAgKiBUaGUgV3JvbmcgV2F5LiBQbGVhc2UgdHJ5IHRvIHVuZGVyc3RhbmQgdGhlIHJlYWN0aXZlIHdheSBiZWZvcmUgdXNpbmcgdGhpc1xuICAgICAqIG1ldGhvZC4gVXNlIGl0IG9ubHkgd2hlbiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5zaGFtZWZ1bGx5U2VuZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgXCJkZWJ1Z1wiIGxpc3RlbmVyIHRvIHRoZSBzdHJlYW0uIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBkZWJ1Z1xuICAgICAqIGxpc3RlbmVyLCB0aGF0J3Mgd2h5IHRoaXMgaXMgJ3NldERlYnVnTGlzdGVuZXInLiBUbyByZW1vdmUgdGhlIGRlYnVnXG4gICAgICogbGlzdGVuZXIsIGp1c3QgY2FsbCBzZXREZWJ1Z0xpc3RlbmVyKG51bGwpLlxuICAgICAqXG4gICAgICogQSBkZWJ1ZyBsaXN0ZW5lciBpcyBsaWtlIGFueSBvdGhlciBsaXN0ZW5lci4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGFcbiAgICAgKiBkZWJ1ZyBsaXN0ZW5lciBpcyBcInN0ZWFsdGh5XCI6IGl0cyBwcmVzZW5jZS9hYnNlbmNlIGRvZXMgbm90IHRyaWdnZXIgdGhlXG4gICAgICogc3RhcnQvc3RvcCBvZiB0aGUgc3RyZWFtIChvciB0aGUgcHJvZHVjZXIgaW5zaWRlIHRoZSBzdHJlYW0pLiBUaGlzIGlzXG4gICAgICogdXNlZnVsIHNvIHlvdSBjYW4gaW5zcGVjdCB3aGF0IGlzIGdvaW5nIG9uIHdpdGhvdXQgY2hhbmdpbmcgdGhlIGJlaGF2aW9yXG4gICAgICogb2YgdGhlIHByb2dyYW0uIElmIHlvdSBoYXZlIGFuIGlkbGUgc3RyZWFtIGFuZCB5b3UgYWRkIGEgbm9ybWFsIGxpc3RlbmVyIHRvXG4gICAgICogaXQsIHRoZSBzdHJlYW0gd2lsbCBzdGFydCBleGVjdXRpbmcuIEJ1dCBpZiB5b3Ugc2V0IGEgZGVidWcgbGlzdGVuZXIgb24gYW5cbiAgICAgKiBpZGxlIHN0cmVhbSwgaXQgd29uJ3Qgc3RhcnQgZXhlY3V0aW5nIChub3QgdW50aWwgdGhlIGZpcnN0IG5vcm1hbCBsaXN0ZW5lclxuICAgICAqIGlzIGFkZGVkKS5cbiAgICAgKlxuICAgICAqIEFzIHRoZSBuYW1lIGluZGljYXRlcywgd2UgZG9uJ3QgcmVjb21tZW5kIHVzaW5nIHRoaXMgbWV0aG9kIHRvIGJ1aWxkIGFwcFxuICAgICAqIGxvZ2ljLiBJbiBmYWN0LCBpbiBtb3N0IGNhc2VzIHRoZSBkZWJ1ZyBvcGVyYXRvciB3b3JrcyBqdXN0IGZpbmUuIE9ubHkgdXNlXG4gICAgICogdGhpcyBvbmUgaWYgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xpc3RlbmVyPFQ+fSBsaXN0ZW5lclxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuc2V0RGVidWdMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kbCA9IE5PO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZCA9IHRydWU7XG4gICAgICAgICAgICBsaXN0ZW5lci5fbiA9IGxpc3RlbmVyLm5leHQgfHwgbm9vcDtcbiAgICAgICAgICAgIGxpc3RlbmVyLl9lID0gbGlzdGVuZXIuZXJyb3IgfHwgbm9vcDtcbiAgICAgICAgICAgIGxpc3RlbmVyLl9jID0gbGlzdGVuZXIuY29tcGxldGUgfHwgbm9vcDtcbiAgICAgICAgICAgIHRoaXMuX2RsID0gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdHJlYW07XG59KCkpO1xuLyoqXG4gKiBCbGVuZHMgbXVsdGlwbGUgc3RyZWFtcyB0b2dldGhlciwgZW1pdHRpbmcgZXZlbnRzIGZyb20gYWxsIG9mIHRoZW1cbiAqIGNvbmN1cnJlbnRseS5cbiAqXG4gKiAqbWVyZ2UqIHRha2VzIG11bHRpcGxlIHN0cmVhbXMgYXMgYXJndW1lbnRzLCBhbmQgY3JlYXRlcyBhIHN0cmVhbSB0aGF0XG4gKiBiZWhhdmVzIGxpa2UgZWFjaCBvZiB0aGUgYXJndW1lbnQgc3RyZWFtcywgaW4gcGFyYWxsZWwuXG4gKlxuICogTWFyYmxlIGRpYWdyYW06XG4gKlxuICogYGBgdGV4dFxuICogLS0xLS0tLTItLS0tLTMtLS0tLS0tLTQtLS1cbiAqIC0tLS1hLS0tLS1iLS0tLWMtLS1kLS0tLS0tXG4gKiAgICAgICAgICAgIG1lcmdlXG4gKiAtLTEtYS0tMi0tYi0tMy1jLS0tZC0tNC0tLVxuICogYGBgXG4gKlxuICogQGZhY3RvcnkgdHJ1ZVxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTEgQSBzdHJlYW0gdG8gbWVyZ2UgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTIgQSBzdHJlYW0gdG8gbWVyZ2UgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLiBUd29cbiAqIG9yIG1vcmUgc3RyZWFtcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnRzLlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5TdHJlYW0ubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICB2YXIgc3RyZWFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IE1lcmdlKHN0cmVhbXMpKTtcbn07XG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGlucHV0IHN0cmVhbXMgdG9nZXRoZXIgdG8gcmV0dXJuIGEgc3RyZWFtIHdob3NlIGV2ZW50c1xuICogYXJlIGFycmF5cyB0aGF0IGNvbGxlY3QgdGhlIGxhdGVzdCBldmVudHMgZnJvbSBlYWNoIGlucHV0IHN0cmVhbS5cbiAqXG4gKiAqY29tYmluZSogaW50ZXJuYWxseSByZW1lbWJlcnMgdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gZWFjaCBvZiB0aGUgaW5wdXRcbiAqIHN0cmVhbXMuIFdoZW4gYW55IG9mIHRoZSBpbnB1dCBzdHJlYW1zIGVtaXRzIGFuIGV2ZW50LCB0aGF0IGV2ZW50IHRvZ2V0aGVyXG4gKiB3aXRoIGFsbCB0aGUgb3RoZXIgc2F2ZWQgZXZlbnRzIGFyZSBjb21iaW5lZCBpbnRvIGFuIGFycmF5LiBUaGF0IGFycmF5IHdpbGxcbiAqIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBzdHJlYW0uIEl0J3MgZXNzZW50aWFsbHkgYSB3YXkgb2Ygam9pbmluZyB0b2dldGhlclxuICogdGhlIGV2ZW50cyBmcm9tIG11bHRpcGxlIHN0cmVhbXMuXG4gKlxuICogTWFyYmxlIGRpYWdyYW06XG4gKlxuICogYGBgdGV4dFxuICogLS0xLS0tLTItLS0tLTMtLS0tLS0tLTQtLS1cbiAqIC0tLS1hLS0tLS1iLS0tLS1jLS1kLS0tLS0tXG4gKiAgICAgICAgICBjb21iaW5lXG4gKiAtLS0tMWEtMmEtMmItM2ItM2MtM2QtNGQtLVxuICogYGBgXG4gKlxuICogTm90ZTogdG8gbWluaW1pemUgZ2FyYmFnZSBjb2xsZWN0aW9uLCAqY29tYmluZSogdXNlcyB0aGUgc2FtZSBhcnJheVxuICogaW5zdGFuY2UgZm9yIGVhY2ggZW1pc3Npb24uICBJZiB5b3UgbmVlZCB0byBjb21wYXJlIGVtaXNzaW9ucyBvdmVyIHRpbWUsXG4gKiBjYWNoZSB0aGUgdmFsdWVzIHdpdGggYG1hcGAgZmlyc3Q6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBwYWlyd2lzZSBmcm9tICd4c3RyZWFtL2V4dHJhL3BhaXJ3aXNlJ1xuICpcbiAqIGNvbnN0IHN0cmVhbTEgPSB4cy5vZigxKTtcbiAqIGNvbnN0IHN0cmVhbTIgPSB4cy5vZigyKTtcbiAqXG4gKiB4cy5jb21iaW5lKHN0cmVhbTEsIHN0cmVhbTIpLm1hcChcbiAqICAgY29tYmluZWRFbWlzc2lvbnMgPT4gKFsgLi4uY29tYmluZWRFbWlzc2lvbnMgXSlcbiAqICkuY29tcG9zZShwYWlyd2lzZSlcbiAqIGBgYFxuICpcbiAqIEBmYWN0b3J5IHRydWVcbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0xIEEgc3RyZWFtIHRvIGNvbWJpbmUgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTIgQSBzdHJlYW0gdG8gY29tYmluZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuXG4gKiBNdWx0aXBsZSBzdHJlYW1zLCBub3QganVzdCB0d28sIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cblN0cmVhbS5jb21iaW5lID0gZnVuY3Rpb24gY29tYmluZSgpIHtcbiAgICB2YXIgc3RyZWFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IENvbWJpbmUoc3RyZWFtcykpO1xufTtcbmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtO1xudmFyIE1lbW9yeVN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbW9yeVN0cmVhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZW1vcnlTdHJlYW0ocHJvZHVjZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvZHVjZXIpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9oYXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy5fdiA9IHg7XG4gICAgICAgIHRoaXMuX2hhcyA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX24uY2FsbCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uIChpbCkge1xuICAgICAgICB2YXIgdGEgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgIGlmICh0YSAhPT0gTk8pXG4gICAgICAgICAgICByZXR1cm4gdGEuX2FkZChpbCk7XG4gICAgICAgIHZhciBhID0gdGhpcy5faWxzO1xuICAgICAgICBhLnB1c2goaWwpO1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzKVxuICAgICAgICAgICAgICAgIGlsLl9uKHRoaXMuX3YpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdG9wSUQgIT09IE5PKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzKVxuICAgICAgICAgICAgICAgIGlsLl9uKHRoaXMuX3YpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0b3BJRCk7XG4gICAgICAgICAgICB0aGlzLl9zdG9wSUQgPSBOTztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9oYXMpXG4gICAgICAgICAgICBpbC5fbih0aGlzLl92KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuX3Byb2Q7XG4gICAgICAgICAgICBpZiAocCAhPT0gTk8pXG4gICAgICAgICAgICAgICAgcC5fc3RhcnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuX3N0b3BOb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhcyA9IGZhbHNlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zdG9wTm93LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLl94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9oYXMgPSBmYWxzZTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5feC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAocHJvamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHByb2plY3QpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5tYXBUbyA9IGZ1bmN0aW9uIChwcm9qZWN0ZWRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5tYXBUby5jYWxsKHRoaXMsIHByb2plY3RlZFZhbHVlKTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUudGFrZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudGFrZS5jYWxsKHRoaXMsIGFtb3VudCk7XG4gICAgfTtcbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLmVuZFdoZW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZW5kV2hlbi5jYWxsKHRoaXMsIG90aGVyKTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUucmVwbGFjZUVycm9yID0gZnVuY3Rpb24gKHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVwbGFjZUVycm9yLmNhbGwodGhpcywgcmVwbGFjZSk7XG4gICAgfTtcbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLnJlbWVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobGFiZWxPclNweSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZWJ1Zy5jYWxsKHRoaXMsIGxhYmVsT3JTcHkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lbW9yeVN0cmVhbTtcbn0oU3RyZWFtKSk7XG5leHBvcnRzLk1lbW9yeVN0cmVhbSA9IE1lbW9yeVN0cmVhbTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHRodW5rID0gcmVxdWlyZSgnc25hYmJkb20vdGh1bmsnKTtcbmV4cG9ydHMudGh1bmsgPSB0aHVuaztcbi8qKlxuICogQSBmYWN0b3J5IGZvciB0aGUgRE9NIGRyaXZlciBmdW5jdGlvbi5cbiAqXG4gKiBUYWtlcyBhIGBjb250YWluZXJgIHRvIGRlZmluZSB0aGUgdGFyZ2V0IG9uIHRoZSBleGlzdGluZyBET00gd2hpY2ggdGhpc1xuICogZHJpdmVyIHdpbGwgb3BlcmF0ZSBvbiwgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gVGhlXG4gKiBpbnB1dCB0byB0aGlzIGRyaXZlciBpcyBhIHN0cmVhbSBvZiB2aXJ0dWFsIERPTSBvYmplY3RzLCBvciBpbiBvdGhlciB3b3JkcyxcbiAqIFNuYWJiZG9tIFwiVk5vZGVcIiBvYmplY3RzLiBUaGUgb3V0cHV0IG9mIHRoaXMgZHJpdmVyIGlzIGEgXCJET01Tb3VyY2VcIjogYVxuICogY29sbGVjdGlvbiBvZiBPYnNlcnZhYmxlcyBxdWVyaWVkIHdpdGggdGhlIG1ldGhvZHMgYHNlbGVjdCgpYCBhbmQgYGV2ZW50cygpYC5cbiAqXG4gKiBgRE9NU291cmNlLnNlbGVjdChzZWxlY3RvcilgIHJldHVybnMgYSBuZXcgRE9NU291cmNlIHdpdGggc2NvcGUgcmVzdHJpY3RlZCB0b1xuICogdGhlIGVsZW1lbnQocykgdGhhdCBtYXRjaGVzIHRoZSBDU1MgYHNlbGVjdG9yYCBnaXZlbi5cbiAqXG4gKiBgRE9NU291cmNlLmV2ZW50cyhldmVudFR5cGUsIG9wdGlvbnMpYCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyBvZlxuICogYGV2ZW50VHlwZWAgaGFwcGVuaW5nIG9uIHRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBjdXJyZW50IERPTVNvdXJjZS4gVGhlXG4gKiBldmVudCBvYmplY3QgY29udGFpbnMgdGhlIGBvd25lclRhcmdldGAgcHJvcGVydHkgdGhhdCBiZWhhdmVzIGV4YWN0bHkgbGlrZVxuICogYGN1cnJlbnRUYXJnZXRgLiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgc29tZSBicm93c2VycyBkb2Vzbid0IGFsbG93XG4gKiBgY3VycmVudFRhcmdldGAgcHJvcGVydHkgdG8gYmUgbXV0YXRlZCwgaGVuY2UgYSBuZXcgcHJvcGVydHkgaXMgY3JlYXRlZC4gVGhlXG4gKiByZXR1cm5lZCBzdHJlYW0gaXMgYW4gKnhzdHJlYW0qIFN0cmVhbSBpZiB5b3UgdXNlIGBAY3ljbGUveHN0cmVhbS1ydW5gIHRvIHJ1blxuICogeW91ciBhcHAgd2l0aCB0aGlzIGRyaXZlciwgb3IgaXQgaXMgYW4gUnhKUyBPYnNlcnZhYmxlIGlmIHlvdSB1c2VcbiAqIGBAY3ljbGUvcnhqcy1ydW5gLCBhbmQgc28gZm9ydGguIFRoZSBgb3B0aW9uc2AgcGFyYW1ldGVyIGNhbiBoYXZlIHRoZVxuICogcHJvcGVydHkgYHVzZUNhcHR1cmVgLCB3aGljaCBpcyBieSBkZWZhdWx0IGBmYWxzZWAsIGV4Y2VwdCBpdCBpcyBgdHJ1ZWAgZm9yXG4gKiBldmVudCB0eXBlcyB0aGF0IGRvIG5vdCBidWJibGUuIFJlYWQgbW9yZSBoZXJlXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICogYWJvdXQgdGhlIGB1c2VDYXB0dXJlYCBhbmQgaXRzIHB1cnBvc2UuXG4gKlxuICogYERPTVNvdXJjZS5lbGVtZW50cygpYCByZXR1cm5zIGEgc3RyZWFtIG9mIHRoZSBET00gZWxlbWVudChzKSBtYXRjaGVkIGJ5IHRoZVxuICogc2VsZWN0b3JzIGluIHRoZSBET01Tb3VyY2UuIEFsc28sIGBET01Tb3VyY2Uuc2VsZWN0KCc6cm9vdCcpLmVsZW1lbnRzKClgXG4gKiByZXR1cm5zIGEgc3RyZWFtIG9mIERPTSBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3QgKG9yIGNvbnRhaW5lcikgb2ZcbiAqIHRoZSBhcHAgb24gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8SFRNTEVsZW1lbnQpfSBjb250YWluZXIgdGhlIERPTSBzZWxlY3RvciBmb3IgdGhlIGVsZW1lbnRcbiAqIChvciB0aGUgZWxlbWVudCBpdHNlbGYpIHRvIGNvbnRhaW4gdGhlIHJlbmRlcmluZyBvZiB0aGUgVlRyZWVzLlxuICogQHBhcmFtIHtET01Ecml2ZXJPcHRpb25zfSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIHR3byBvcHRpb25hbCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgbW9kdWxlczogYXJyYXlgIG92ZXJyaWRlcyBgQGN5Y2xlL2RvbWAncyBkZWZhdWx0IFNuYWJiZG9tIG1vZHVsZXMgYXNcbiAqICAgICBhcyBkZWZpbmVkIGluIFtgc3JjL21vZHVsZXMudHNgXSguL3NyYy9tb2R1bGVzLnRzKS5cbiAqICAgLSBgdHJhbnNwb3NpdGlvbjogYm9vbGVhbmAgZW5hYmxlcy9kaXNhYmxlcyB0cmFuc3Bvc2l0aW9uIG9mIGlubmVyIHN0cmVhbXNcbiAqICAgICBpbiB0aGUgdmlydHVhbCBET00gdHJlZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgRE9NIGRyaXZlciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIGV4cGVjdHMgYSBzdHJlYW0gb2ZcbiAqIFZOb2RlIGFzIGlucHV0LCBhbmQgb3V0cHV0cyB0aGUgRE9NU291cmNlIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBtYWtlRE9NRHJpdmVyXG4gKi9cbnZhciBtYWtlRE9NRHJpdmVyXzEgPSByZXF1aXJlKCcuL21ha2VET01Ecml2ZXInKTtcbmV4cG9ydHMubWFrZURPTURyaXZlciA9IG1ha2VET01Ecml2ZXJfMS5tYWtlRE9NRHJpdmVyO1xuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIHRoZSBIVE1MIGRyaXZlciBmdW5jdGlvbi5cbiAqXG4gKiBUYWtlcyBhbiBgZWZmZWN0YCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdCBhcyBhcmd1bWVudHMuIFRoZVxuICogaW5wdXQgdG8gdGhpcyBkcml2ZXIgaXMgYSBzdHJlYW0gb2YgdmlydHVhbCBET00gb2JqZWN0cywgb3IgaW4gb3RoZXIgd29yZHMsXG4gKiBTbmFiYmRvbSBcIlZOb2RlXCIgb2JqZWN0cy4gVGhlIG91dHB1dCBvZiB0aGlzIGRyaXZlciBpcyBhIFwiRE9NU291cmNlXCI6IGFcbiAqIGNvbGxlY3Rpb24gb2YgT2JzZXJ2YWJsZXMgcXVlcmllZCB3aXRoIHRoZSBtZXRob2RzIGBzZWxlY3QoKWAgYW5kIGBldmVudHMoKWAuXG4gKlxuICogVGhlIEhUTUwgRHJpdmVyIGlzIHN1cHBsZW1lbnRhcnkgdG8gdGhlIERPTSBEcml2ZXIuIEluc3RlYWQgb2YgcHJvZHVjaW5nXG4gKiBlbGVtZW50cyBvbiB0aGUgRE9NLCBpdCBnZW5lcmF0ZXMgSFRNTCBhcyBzdHJpbmdzIGFuZCBkb2VzIGEgc2lkZSBlZmZlY3Qgb25cbiAqIHRob3NlIEhUTUwgc3RyaW5ncy4gVGhhdCBzaWRlIGVmZmVjdCBpcyBkZXNjcmliZWQgYnkgdGhlIGBlZmZlY3RgIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gU28sIGlmIHlvdSB3YW50IHRvIHVzZSB0aGUgSFRNTCBEcml2ZXIgb24gdGhlIHNlcnZlci1zaWRlIHRvIHJlbmRlclxuICogeW91ciBhcHBsaWNhdGlvbiBhcyBIVE1MIGFuZCBzZW5kIGFzIGEgcmVzcG9uc2UgKHdoaWNoIGlzIHRoZSB0eXBpY2FsIHVzZVxuICogY2FzZSBmb3IgdGhlIEhUTUwgRHJpdmVyKSwgeW91IG5lZWQgdG8gcGFzcyBzb21ldGhpbmcgbGlrZSB0aGVcbiAqIGBodG1sID0+IHJlc3BvbnNlLnNlbmQoaHRtbClgIGZ1bmN0aW9uIGFzIHRoZSBgZWZmZWN0YCBhcmd1bWVudC4gVGhpcyB3YXksXG4gKiB0aGUgZHJpdmVyIGtub3dzIHdoYXQgc2lkZSBlZmZlY3QgdG8gY2F1c2UgYmFzZWQgb24gdGhlIEhUTUwgc3RyaW5nIGl0IGp1c3RcbiAqIHJlbmRlcmVkLlxuICpcbiAqIFRoZSBIVE1MIGRyaXZlciBpcyB1c2VmdWwgb25seSBmb3IgdGhhdCBzaWRlIGVmZmVjdCBpbiB0aGUgYGVmZmVjdGAgY2FsbGJhY2suXG4gKiBJdCBjYW4gYmUgY29uc2lkZXJlZCBhIHNpbmstb25seSBkcml2ZXIuIEhvd2V2ZXIsIGluIG9yZGVyIHRvIHNlcnZlIGFzIGFcbiAqIHRyYW5zcGFyZW50IHJlcGxhY2VtZW50IHRvIHRoZSBET00gRHJpdmVyIHdoZW4gcmVuZGVyaW5nIGZyb20gdGhlIHNlcnZlciwgdGhlXG4gKiBIVE1MIGRyaXZlciByZXR1cm5zIGEgc291cmNlIG9iamVjdCB0aGF0IGJlaGF2ZXMganVzdCBsaWtlIHRoZSBET01Tb3VyY2UuXG4gKiBUaGlzIGhlbHBzIHJldXNlIHRoZSBzYW1lIGFwcGxpY2F0aW9uIHRoYXQgaXMgd3JpdHRlbiBmb3IgdGhlIERPTSBEcml2ZXIuXG4gKiBUaGlzIGZha2UgRE9NU291cmNlIHJldHVybnMgZW1wdHkgc3RyZWFtcyB3aGVuIHlvdSBxdWVyeSBpdCwgYmVjYXVzZSB0aGVyZVxuICogYXJlIG5vIHVzZXIgZXZlbnRzIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogYERPTVNvdXJjZS5zZWxlY3Qoc2VsZWN0b3IpYCByZXR1cm5zIGEgbmV3IERPTVNvdXJjZSB3aXRoIHNjb3BlIHJlc3RyaWN0ZWQgdG9cbiAqIHRoZSBlbGVtZW50KHMpIHRoYXQgbWF0Y2hlcyB0aGUgQ1NTIGBzZWxlY3RvcmAgZ2l2ZW4uXG4gKlxuICogYERPTVNvdXJjZS5ldmVudHMoZXZlbnRUeXBlLCBvcHRpb25zKWAgcmV0dXJucyBhbiBlbXB0eSBzdHJlYW0uIFRoZSByZXR1cm5lZFxuICogc3RyZWFtIGlzIGFuICp4c3RyZWFtKiBTdHJlYW0gaWYgeW91IHVzZSBgQGN5Y2xlL3hzdHJlYW0tcnVuYCB0byBydW4geW91ciBhcHBcbiAqIHdpdGggdGhpcyBkcml2ZXIsIG9yIGl0IGlzIGFuIFJ4SlMgT2JzZXJ2YWJsZSBpZiB5b3UgdXNlIGBAY3ljbGUvcnhqcy1ydW5gLFxuICogYW5kIHNvIGZvcnRoLlxuICpcbiAqIGBET01Tb3VyY2UuZWxlbWVudHMoKWAgcmV0dXJucyB0aGUgc3RyZWFtIG9mIEhUTUwgc3RyaW5nIHJlbmRlcmVkIGZyb20geW91clxuICogc2luayB2aXJ0dWFsIERPTSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWZmZWN0IGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0cmluZyBvZiByZW5kZXJlZFxuICogSFRNTCBhcyBpbnB1dCBhbmQgc2hvdWxkIHJ1biBhIHNpZGUgZWZmZWN0LCByZXR1cm5pbmcgbm90aGluZy5cbiAqIEBwYXJhbSB7SFRNTERyaXZlck9wdGlvbnN9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggb25lIG9wdGlvbmFsIHByb3BlcnR5OlxuICogYHRyYW5zcG9zaXRpb246IGJvb2xlYW5gIGVuYWJsZXMvZGlzYWJsZXMgdHJhbnNwb3NpdGlvbiBvZiBpbm5lciBzdHJlYW1zIGluXG4gKiB0aGUgdmlydHVhbCBET00gdHJlZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgSFRNTCBkcml2ZXIgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBleHBlY3RzIGEgc3RyZWFtIG9mXG4gKiBWTm9kZSBhcyBpbnB1dCwgYW5kIG91dHB1dHMgdGhlIERPTVNvdXJjZSBvYmplY3QuXG4gKiBAZnVuY3Rpb24gbWFrZUhUTUxEcml2ZXJcbiAqL1xudmFyIG1ha2VIVE1MRHJpdmVyXzEgPSByZXF1aXJlKCcuL21ha2VIVE1MRHJpdmVyJyk7XG5leHBvcnRzLm1ha2VIVE1MRHJpdmVyID0gbWFrZUhUTUxEcml2ZXJfMS5tYWtlSFRNTERyaXZlcjtcbi8qKlxuICogQSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBtb2NrZWQgRE9NU291cmNlIG9iamVjdHMsIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICpcbiAqIFRha2VzIGEgYHN0cmVhbUFkYXB0ZXJgIGFuZCBhIGBtb2NrQ29uZmlnYCBvYmplY3QgYXMgYXJndW1lbnRzLCBhbmQgcmV0dXJuc1xuICogYSBET01Tb3VyY2UgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gYW55IEN5Y2xlLmpzIGFwcCB0aGF0IGV4cGVjdHMgYSBET01Tb3VyY2UgaW5cbiAqIHRoZSBzb3VyY2VzLCBmb3IgdGVzdGluZy5cbiAqXG4gKiBUaGUgYHN0cmVhbUFkYXB0ZXJgIHBhcmFtZXRlciBpcyBhIHBhY2thZ2Ugc3VjaCBhcyBgQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcmAsXG4gKiBgQGN5Y2xlL3J4anMtYWRhcHRlcmAsIGV0Yy4gSW1wb3J0IGl0IGFzIGBpbXBvcnQgYSBmcm9tICdAY3ljbGUvcngtYWRhcHRlcmAsXG4gKiB0aGVuIHByb3ZpZGUgaXQgdG8gYG1vY2tET01Tb3VyY2UuIFRoaXMgaXMgaW1wb3J0YW50IHNvIHRoZSBET01Tb3VyY2UgY3JlYXRlZFxuICoga25vd3Mgd2hpY2ggc3RyZWFtIGxpYnJhcnkgc2hvdWxkIGl0IHVzZSB0byBleHBvcnQgaXRzIHN0cmVhbXMgd2hlbiB5b3UgY2FsbFxuICogYERPTVNvdXJjZS5ldmVudHMoKWAgZm9yIGluc3RhbmNlLlxuICpcbiAqIFRoZSBgbW9ja0NvbmZpZ2AgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHNlbGVjdG9ycywgZXZlbnRUeXBlcyBhbmRcbiAqIHRoZWlyIHN0cmVhbXMuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGRvbVNvdXJjZSA9IG1vY2tET01Tb3VyY2UoUnhBZGFwdGVyLCB7XG4gKiAgICcuZm9vJzoge1xuICogICAgICdjbGljayc6IFJ4Lk9ic2VydmFibGUub2Yoe3RhcmdldDoge319KSxcbiAqICAgICAnbW91c2VvdmVyJzogUnguT2JzZXJ2YWJsZS5vZih7dGFyZ2V0OiB7fX0pLFxuICogICB9LFxuICogICAnLmJhcic6IHtcbiAqICAgICAnc2Nyb2xsJzogUnguT2JzZXJ2YWJsZS5vZih7dGFyZ2V0OiB7fX0pLFxuICogICAgIGVsZW1lbnRzOiBSeC5PYnNlcnZhYmxlLm9mKHt0YWdOYW1lOiAnZGl2J30pLFxuICogICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2FnZVxuICogY29uc3QgY2xpY2skID0gZG9tU291cmNlLnNlbGVjdCgnLmZvbycpLmV2ZW50cygnY2xpY2snKTtcbiAqIGNvbnN0IGVsZW1lbnQkID0gZG9tU291cmNlLnNlbGVjdCgnLmJhcicpLmVsZW1lbnRzKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgbW9ja2VkIERPTSBTb3VyY2Ugc3VwcG9ydHMgaXNvbGF0aW9uLiBJdCBoYXMgdGhlIGZ1bmN0aW9ucyBgaXNvbGF0ZVNpbmtgXG4gKiBhbmQgYGlzb2xhdGVTb3VyY2VgIGF0dGFjaGVkIHRvIGl0LCBhbmQgcGVyZm9ybXMgc2ltcGxlIGlzb2xhdGlvbiB1c2luZ1xuICogY2xhc3NOYW1lcy4gKmlzb2xhdGVTaW5rKiB3aXRoIHNjb3BlIGBmb29gIHdpbGwgYXBwZW5kIHRoZSBjbGFzcyBgX19fZm9vYCB0b1xuICogdGhlIHN0cmVhbSBvZiB2aXJ0dWFsIERPTSBub2RlcywgYW5kICppc29sYXRlU291cmNlKiB3aXRoIHNjb3BlIGBmb29gIHdpbGxcbiAqIHBlcmZvcm0gYSBjb252ZW50aW9uYWwgYG1vY2tlZERPTVNvdXJjZS5zZWxlY3QoJy5fX2ZvbycpYCBjYWxsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2NrQ29uZmlnIGFuIG9iamVjdCB3aGVyZSBrZXlzIGFyZSBzZWxlY3RvciBzdHJpbmdzXG4gKiBhbmQgdmFsdWVzIGFyZSBvYmplY3RzLiBUaG9zZSBuZXN0ZWQgb2JqZWN0cyBoYXZlIGBldmVudFR5cGVgIHN0cmluZ3MgYXMga2V5c1xuICogYW5kIHZhbHVlcyBhcmUgc3RyZWFtcyB5b3UgY3JlYXRlZC5cbiAqIEByZXR1cm4ge09iamVjdH0gZmFrZSBET00gc291cmNlIG9iamVjdCwgd2l0aCBhbiBBUEkgY29udGFpbmluZyBgc2VsZWN0KClgXG4gKiBhbmQgYGV2ZW50cygpYCBhbmQgYGVsZW1lbnRzKClgIHdoaWNoIGNhbiBiZSB1c2VkIGp1c3QgbGlrZSB0aGUgRE9NIERyaXZlcidzXG4gKiBET01Tb3VyY2UuXG4gKlxuICogQGZ1bmN0aW9uIG1vY2tET01Tb3VyY2VcbiAqL1xudmFyIG1vY2tET01Tb3VyY2VfMSA9IHJlcXVpcmUoJy4vbW9ja0RPTVNvdXJjZScpO1xuZXhwb3J0cy5tb2NrRE9NU291cmNlID0gbW9ja0RPTVNvdXJjZV8xLm1vY2tET01Tb3VyY2U7XG4vKipcbiAqIFRoZSBoeXBlcnNjcmlwdCBmdW5jdGlvbiBgaCgpYCBpcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSB2aXJ0dWFsIERPTSBvYmplY3RzLFxuICogYWxzbyBrbm93biBhcyBWTm9kZXMuIENhbGxcbiAqXG4gKiBgYGBqc1xuICogaCgnZGl2Lm15Q2xhc3MnLCB7c3R5bGU6IHtjb2xvcjogJ3JlZCd9fSwgW10pXG4gKiBgYGBcbiAqXG4gKiB0byBjcmVhdGUgYSBWTm9kZSB0aGF0IHJlcHJlc2VudHMgYSBgRElWYCBlbGVtZW50IHdpdGggY2xhc3NOYW1lIGBteUNsYXNzYCxcbiAqIHN0eWxlZCB3aXRoIHJlZCBjb2xvciwgYW5kIG5vIGNoaWxkcmVuIGJlY2F1c2UgdGhlIGBbXWAgYXJyYXkgd2FzIHBhc3NlZC4gVGhlXG4gKiBBUEkgaXMgYGgodGFnT3JTZWxlY3Rvciwgb3B0aW9uYWxEYXRhLCBvcHRpb25hbENoaWxkcmVuT3JUZXh0KWAuXG4gKlxuICogSG93ZXZlciwgdXN1YWxseSB5b3Ugc2hvdWxkIHVzZSBcImh5cGVyc2NyaXB0IGhlbHBlcnNcIiwgd2hpY2ggYXJlIHNob3J0Y3V0XG4gKiBmdW5jdGlvbnMgYmFzZWQgb24gaHlwZXJzY3JpcHQuIFRoZXJlIGlzIG9uZSBoeXBlcnNjcmlwdCBoZWxwZXIgZnVuY3Rpb24gZm9yXG4gKiBlYWNoIERPTSB0YWdOYW1lLCBzdWNoIGFzIGBoMSgpYCwgYGgyKClgLCBgZGl2KClgLCBgc3BhbigpYCwgYGxhYmVsKClgLFxuICogYGlucHV0KClgLiBGb3IgaW5zdGFuY2UsIHRoZSBwcmV2aW91cyBleGFtcGxlIGNvdWxkIGhhdmUgYmVlbiB3cml0dGVuXG4gKiBhczpcbiAqXG4gKiBgYGBqc1xuICogZGl2KCcubXlDbGFzcycsIHtzdHlsZToge2NvbG9yOiAncmVkJ319LCBbXSlcbiAqIGBgYFxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIFNWRyBoZWxwZXIgZnVuY3Rpb25zLCB3aGljaCBhcHBseSB0aGUgYXBwcm9wcmlhdGUgU1ZHXG4gKiBuYW1lc3BhY2UgdG8gdGhlIHJlc3VsdGluZyBlbGVtZW50cy4gYHN2ZygpYCBmdW5jdGlvbiBjcmVhdGVzIHRoZSB0b3AtbW9zdFxuICogU1ZHIGVsZW1lbnQsIGFuZCBgc3ZnLmdgLCBgc3ZnLnBvbHlnb25gLCBgc3ZnLmNpcmNsZWAsIGBzdmcucGF0aGAgYXJlIGZvclxuICogU1ZHLXNwZWNpZmljIGNoaWxkIGVsZW1lbnRzLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBzdmcoe3dpZHRoOiAxNTAsIGhlaWdodDogMTUwfSwgW1xuICogICBzdmcucG9seWdvbih7XG4gKiAgICAgYXR0cnM6IHtcbiAqICAgICAgIGNsYXNzOiAndHJpYW5nbGUnLFxuICogICAgICAgcG9pbnRzOiAnMjAgMCAyMCAxNTAgMTUwIDIwJ1xuICogICAgIH1cbiAqICAgfSlcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb24gaFxuICovXG52YXIgaHlwZXJzY3JpcHRfMSA9IHJlcXVpcmUoJy4vaHlwZXJzY3JpcHQnKTtcbmV4cG9ydHMuaCA9IGh5cGVyc2NyaXB0XzEuaDtcbnZhciBoeXBlcnNjcmlwdF9oZWxwZXJzXzEgPSByZXF1aXJlKCcuL2h5cGVyc2NyaXB0LWhlbHBlcnMnKTtcbmV4cG9ydHMuc3ZnID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3ZnO1xuZXhwb3J0cy5hID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYTtcbmV4cG9ydHMuYWJiciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmFiYnI7XG5leHBvcnRzLmFkZHJlc3MgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hZGRyZXNzO1xuZXhwb3J0cy5hcmVhID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYXJlYTtcbmV4cG9ydHMuYXJ0aWNsZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmFydGljbGU7XG5leHBvcnRzLmFzaWRlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYXNpZGU7XG5leHBvcnRzLmF1ZGlvID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYXVkaW87XG5leHBvcnRzLmIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iO1xuZXhwb3J0cy5iYXNlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYmFzZTtcbmV4cG9ydHMuYmRpID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYmRpO1xuZXhwb3J0cy5iZG8gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iZG87XG5leHBvcnRzLmJsb2NrcXVvdGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ibG9ja3F1b3RlO1xuZXhwb3J0cy5ib2R5ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYm9keTtcbmV4cG9ydHMuYnIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5icjtcbmV4cG9ydHMuYnV0dG9uID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYnV0dG9uO1xuZXhwb3J0cy5jYW52YXMgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5jYW52YXM7XG5leHBvcnRzLmNhcHRpb24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5jYXB0aW9uO1xuZXhwb3J0cy5jaXRlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuY2l0ZTtcbmV4cG9ydHMuY29kZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNvZGU7XG5leHBvcnRzLmNvbCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNvbDtcbmV4cG9ydHMuY29sZ3JvdXAgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5jb2xncm91cDtcbmV4cG9ydHMuZGQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kZDtcbmV4cG9ydHMuZGVsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGVsO1xuZXhwb3J0cy5kZm4gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kZm47XG5leHBvcnRzLmRpciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRpcjtcbmV4cG9ydHMuZGl2ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGl2O1xuZXhwb3J0cy5kbCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRsO1xuZXhwb3J0cy5kdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmR0O1xuZXhwb3J0cy5lbSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmVtO1xuZXhwb3J0cy5lbWJlZCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmVtYmVkO1xuZXhwb3J0cy5maWVsZHNldCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmZpZWxkc2V0O1xuZXhwb3J0cy5maWdjYXB0aW9uID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZmlnY2FwdGlvbjtcbmV4cG9ydHMuZmlndXJlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZmlndXJlO1xuZXhwb3J0cy5mb290ZXIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5mb290ZXI7XG5leHBvcnRzLmZvcm0gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5mb3JtO1xuZXhwb3J0cy5oMSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmgxO1xuZXhwb3J0cy5oMiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmgyO1xuZXhwb3J0cy5oMyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmgzO1xuZXhwb3J0cy5oNCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmg0O1xuZXhwb3J0cy5oNSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmg1O1xuZXhwb3J0cy5oNiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmg2O1xuZXhwb3J0cy5oZWFkID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaGVhZDtcbmV4cG9ydHMuaGVhZGVyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaGVhZGVyO1xuZXhwb3J0cy5oZ3JvdXAgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5oZ3JvdXA7XG5leHBvcnRzLmhyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaHI7XG5leHBvcnRzLmh0bWwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5odG1sO1xuZXhwb3J0cy5pID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaTtcbmV4cG9ydHMuaWZyYW1lID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaWZyYW1lO1xuZXhwb3J0cy5pbWcgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pbWc7XG5leHBvcnRzLmlucHV0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaW5wdXQ7XG5leHBvcnRzLmlucyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmlucztcbmV4cG9ydHMua2JkID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQua2JkO1xuZXhwb3J0cy5rZXlnZW4gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5rZXlnZW47XG5leHBvcnRzLmxhYmVsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubGFiZWw7XG5leHBvcnRzLmxlZ2VuZCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmxlZ2VuZDtcbmV4cG9ydHMubGkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5saTtcbmV4cG9ydHMubGluayA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmxpbms7XG5leHBvcnRzLm1haW4gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5tYWluO1xuZXhwb3J0cy5tYXAgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5tYXA7XG5leHBvcnRzLm1hcmsgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5tYXJrO1xuZXhwb3J0cy5tZW51ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubWVudTtcbmV4cG9ydHMubWV0YSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1ldGE7XG5leHBvcnRzLm5hdiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm5hdjtcbmV4cG9ydHMubm9zY3JpcHQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ub3NjcmlwdDtcbmV4cG9ydHMub2JqZWN0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQub2JqZWN0O1xuZXhwb3J0cy5vbCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm9sO1xuZXhwb3J0cy5vcHRncm91cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm9wdGdyb3VwO1xuZXhwb3J0cy5vcHRpb24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5vcHRpb247XG5leHBvcnRzLnAgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5wO1xuZXhwb3J0cy5wYXJhbSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnBhcmFtO1xuZXhwb3J0cy5wcmUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5wcmU7XG5leHBvcnRzLnByb2dyZXNzID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucHJvZ3Jlc3M7XG5leHBvcnRzLnEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5xO1xuZXhwb3J0cy5ycCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnJwO1xuZXhwb3J0cy5ydCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnJ0O1xuZXhwb3J0cy5ydWJ5ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucnVieTtcbmV4cG9ydHMucyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnM7XG5leHBvcnRzLnNhbXAgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zYW1wO1xuZXhwb3J0cy5zY3JpcHQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zY3JpcHQ7XG5leHBvcnRzLnNlY3Rpb24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zZWN0aW9uO1xuZXhwb3J0cy5zZWxlY3QgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zZWxlY3Q7XG5leHBvcnRzLnNtYWxsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc21hbGw7XG5leHBvcnRzLnNvdXJjZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNvdXJjZTtcbmV4cG9ydHMuc3BhbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNwYW47XG5leHBvcnRzLnN0cm9uZyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnN0cm9uZztcbmV4cG9ydHMuc3R5bGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdHlsZTtcbmV4cG9ydHMuc3ViID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3ViO1xuZXhwb3J0cy5zdXAgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdXA7XG5leHBvcnRzLnRhYmxlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGFibGU7XG5leHBvcnRzLnRib2R5ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGJvZHk7XG5leHBvcnRzLnRkID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGQ7XG5leHBvcnRzLnRleHRhcmVhID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGV4dGFyZWE7XG5leHBvcnRzLnRmb290ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGZvb3Q7XG5leHBvcnRzLnRoID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGg7XG5leHBvcnRzLnRoZWFkID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGhlYWQ7XG5leHBvcnRzLnRpdGxlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudGl0bGU7XG5leHBvcnRzLnRyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudHI7XG5leHBvcnRzLnUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC51O1xuZXhwb3J0cy51bCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnVsO1xuZXhwb3J0cy52aWRlbyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnZpZGVvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV3U2NvcGUoKSB7XG4gICAgcmV0dXJuIFwiY3ljbGVcIiArICsrY291bnRlcjtcbn1cbmZ1bmN0aW9uIGNoZWNrSXNvbGF0ZUFyZ3MoZGF0YWZsb3dDb21wb25lbnQsIHNjb3BlKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhZmxvd0NvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIGlzb2xhdGUoKSBtdXN0IGJlIGEgXCIgK1xuICAgICAgICAgICAgXCInZGF0YWZsb3dDb21wb25lbnQnIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAoc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IGdpdmVuIHRvIGlzb2xhdGUoKSBtdXN0IG5vdCBiZSBudWxsXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzb2xhdGVBbGxTb3VyY2VzKHNvdXJjZXMsIHNjb3BlKSB7XG4gICAgdmFyIHNjb3BlZFNvdXJjZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlcykge1xuICAgICAgICBpZiAoc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHNvdXJjZXNba2V5XVxuICAgICAgICAgICAgJiYgdHlwZW9mIHNvdXJjZXNba2V5XS5pc29sYXRlU291cmNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNjb3BlZFNvdXJjZXNba2V5XSA9IHNvdXJjZXNba2V5XS5pc29sYXRlU291cmNlKHNvdXJjZXNba2V5XSwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgc2NvcGVkU291cmNlc1trZXldID0gc291cmNlc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTb3VyY2VzO1xufVxuZnVuY3Rpb24gaXNvbGF0ZUFsbFNpbmtzKHNvdXJjZXMsIHNpbmtzLCBzY29wZSkge1xuICAgIHZhciBzY29wZWRTaW5rcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBzaW5rcykge1xuICAgICAgICBpZiAoc2lua3MuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgJiYgc291cmNlc1trZXldXG4gICAgICAgICAgICAmJiB0eXBlb2Ygc291cmNlc1trZXldLmlzb2xhdGVTaW5rID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNjb3BlZFNpbmtzW2tleV0gPSBzb3VyY2VzW2tleV0uaXNvbGF0ZVNpbmsoc2lua3Nba2V5XSwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpbmtzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHNjb3BlZFNpbmtzW2tleV0gPSBzaW5rc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTaW5rcztcbn1cbi8qKlxuICogVGFrZXMgYSBgZGF0YWZsb3dDb21wb25lbnRgIGZ1bmN0aW9uIGFuZCBhbiBvcHRpb25hbCBgc2NvcGVgIHN0cmluZywgYW5kXG4gKiByZXR1cm5zIGEgc2NvcGVkIHZlcnNpb24gb2YgdGhlIGBkYXRhZmxvd0NvbXBvbmVudGAgZnVuY3Rpb24uXG4gKlxuICogV2hlbiB0aGUgc2NvcGVkIGRhdGFmbG93IGNvbXBvbmVudCBpcyBpbnZva2VkLCBlYWNoIHNvdXJjZSBwcm92aWRlZCB0byB0aGVcbiAqIHNjb3BlZCBkYXRhZmxvd0NvbXBvbmVudCBpcyBpc29sYXRlZCB0byB0aGUgc2NvcGUgdXNpbmdcbiAqIGBzb3VyY2UuaXNvbGF0ZVNvdXJjZShzb3VyY2UsIHNjb3BlKWAsIGlmIHBvc3NpYmxlLiBMaWtld2lzZSwgdGhlIHNpbmtzXG4gKiByZXR1cm5lZCBmcm9tIHRoZSBzY29wZWQgZGF0YWZsb3cgY29tcG9uZW50IGFyZSBpc29sYXRlIHRvIHRoZSBzY29wZSB1c2luZ1xuICogYHNvdXJjZS5pc29sYXRlU2luayhzaW5rLCBzY29wZSlgLlxuICpcbiAqIElmIHRoZSBgc2NvcGVgIGlzIG5vdCBwcm92aWRlZCwgYSBuZXcgc2NvcGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQuXG4gKiBUaGlzIG1lYW5zIHRoYXQgd2hpbGUgKipgaXNvbGF0ZShkYXRhZmxvd0NvbXBvbmVudCwgc2NvcGUpYCBpcyBwdXJlKipcbiAqIChyZWZlcmVudGlhbGx5IHRyYW5zcGFyZW50KSwgKipgaXNvbGF0ZShkYXRhZmxvd0NvbXBvbmVudClgIGlzIGltcHVyZSoqXG4gKiAobm90IHJlZmVyZW50aWFsbHkgdHJhbnNwYXJlbnQpLiBUd28gY2FsbHMgdG8gYGlzb2xhdGUoRm9vLCBiYXIpYCB3aWxsXG4gKiBnZW5lcmF0ZSB0d28gaW5kaXN0aW5jdCBkYXRhZmxvdyBjb21wb25lbnRzLiBCdXQsIHR3byBjYWxscyB0byBgaXNvbGF0ZShGb28pYFxuICogd2lsbCBnZW5lcmF0ZSB0d28gZGlzdGluY3QgZGF0YWZsb3cgY29tcG9uZW50cy5cbiAqXG4gKiBOb3RlIHRoYXQgYm90aCBgaXNvbGF0ZVNvdXJjZSgpYCBhbmQgYGlzb2xhdGVTaW5rKClgIGFyZSBzdGF0aWMgbWVtYmVycyBvZlxuICogYHNvdXJjZWAuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBkcml2ZXJzIHByb2R1Y2UgYHNvdXJjZWAgd2hpbGUgdGhlXG4gKiBhcHBsaWNhdGlvbiBwcm9kdWNlcyBgc2lua2AsIGFuZCBpdCdzIHRoZSBkcml2ZXIncyByZXNwb25zaWJpbGl0eSB0b1xuICogaW1wbGVtZW50IGBpc29sYXRlU291cmNlKClgIGFuZCBgaXNvbGF0ZVNpbmsoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YWZsb3dDb21wb25lbnQgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGBzb3VyY2VzYCBhcyBpbnB1dFxuICogYW5kIG91dHB1dHMgYSBjb2xsZWN0aW9uIG9mIGBzaW5rc2AuXG4gKiBAcGFyYW0ge1N0cmluZ30gc2NvcGUgYW4gb3B0aW9uYWwgc3RyaW5nIHRoYXQgaXMgdXNlZCB0byBpc29sYXRlIGVhY2hcbiAqIGBzb3VyY2VzYCBhbmQgYHNpbmtzYCB3aGVuIHRoZSByZXR1cm5lZCBzY29wZWQgZGF0YWZsb3cgY29tcG9uZW50IGlzIGludm9rZWQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIHNjb3BlZCBkYXRhZmxvdyBjb21wb25lbnQgZnVuY3Rpb24gdGhhdCwgYXMgdGhlXG4gKiBvcmlnaW5hbCBgZGF0YWZsb3dDb21wb25lbnRgIGZ1bmN0aW9uLCB0YWtlcyBgc291cmNlc2AgYW5kIHJldHVybnMgYHNpbmtzYC5cbiAqIEBmdW5jdGlvbiBpc29sYXRlXG4gKi9cbmZ1bmN0aW9uIGlzb2xhdGUoY29tcG9uZW50LCBzY29wZSkge1xuICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7IHNjb3BlID0gbmV3U2NvcGUoKTsgfVxuICAgIGNoZWNrSXNvbGF0ZUFyZ3MoY29tcG9uZW50LCBzY29wZSk7XG4gICAgdmFyIGNvbnZlcnRlZFNjb3BlID0gdHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJyA/IHNjb3BlIDogc2NvcGUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2NvcGVkQ29tcG9uZW50KHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHJlc3RbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjb3BlZFNvdXJjZXMgPSBpc29sYXRlQWxsU291cmNlcyhzb3VyY2VzLCBjb252ZXJ0ZWRTY29wZSk7XG4gICAgICAgIHZhciBzaW5rcyA9IGNvbXBvbmVudC5hcHBseSh2b2lkIDAsIFtzY29wZWRTb3VyY2VzXS5jb25jYXQocmVzdCkpO1xuICAgICAgICB2YXIgc2NvcGVkU2lua3MgPSBpc29sYXRlQWxsU2lua3Moc291cmNlcywgc2lua3MsIGNvbnZlcnRlZFNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHNjb3BlZFNpbmtzO1xuICAgIH07XG59XG5pc29sYXRlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnRlciA9IDA7IH07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc29sYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9pc29sYXRlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgKiBmcm9tIFwiLi9pY29uVHlwZVwiO1xuXG5leHBvcnQgZW51bSBTaXplIHtcbiAgTWluaSwgVGlueSwgU21hbGwsIE1lZGl1bSwgTGFyZ2UsIEJpZywgSHVnZSwgTWFzc2l2ZSwgRmx1aWRcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTaXplIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKHNpemU6IFNpemUpIHtcbiAgICBzd2l0Y2goc2l6ZSkge1xuICAgICAgY2FzZSBTaXplLk1pbmk6IHJldHVybiBcIiBtaW5pXCI7XG4gICAgICBjYXNlIFNpemUuVGlueTogcmV0dXJuIFwiIHRpbnlcIjtcbiAgICAgIGNhc2UgU2l6ZS5TbWFsbDogcmV0dXJuIFwiIHNtYWxsXCI7XG4gICAgICBjYXNlIFNpemUuTWVkaXVtOiByZXR1cm4gXCIgbWVkaXVtXCI7XG4gICAgICBjYXNlIFNpemUuTGFyZ2U6IHJldHVybiBcIiBsYXJnZVwiO1xuICAgICAgY2FzZSBTaXplLkJpZzogcmV0dXJuIFwiIGJpZ1wiO1xuICAgICAgY2FzZSBTaXplLkh1Z2U6IHJldHVybiBcIiBodWdlXCI7XG4gICAgICBjYXNlIFNpemUuTWFzc2l2ZTogcmV0dXJuIFwiIG1hc3NpdmVcIjtcbiAgICAgIGNhc2UgU2l6ZS5GbHVpZDogcmV0dXJuIFwiIGZsdWlkXCI7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gVmVydGljYWxBbGlnbm1lbnQge1xuICBUb3AsIE1pZGRsZSwgQm90dG9tXG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmVydGljYWxBbGlnbm1lbnQge1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUoYWxpZ25tZW50OiBWZXJ0aWNhbEFsaWdubWVudCkge1xuICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XG4gICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LlRvcDogcmV0dXJuIFwiIHRvcCBhbGlnbmVkXCI7XG4gICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50Lk1pZGRsZTogcmV0dXJuIFwiIG1pZGRsZSBhbGlnbmVkXCI7XG4gICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTogcmV0dXJuIFwiIGJvdHRvbSBhbGlnbmVkXCI7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gVGV4dEFsaWdubWVudCB7XG4gIExlZnQsIFJpZ2h0LCBDZW50ZXIsIEp1c3RpZmllZFxufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRleHRBbGlnbm1lbnQge1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUoYWxpZ25tZW50OiBUZXh0QWxpZ25tZW50KSB7XG4gICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgIGNhc2UgVGV4dEFsaWdubWVudC5MZWZ0OiByZXR1cm4gXCIgbGVmdCBhbGlnbmVkLlwiO1xuICAgICAgY2FzZSBUZXh0QWxpZ25tZW50LlJpZ2h0OiByZXR1cm4gXCIgcmlnaHQgYWxpZ25lZC5cIjtcbiAgICAgIGNhc2UgVGV4dEFsaWdubWVudC5DZW50ZXI6IHJldHVybiBcIiBjZW50ZXIgYWxpZ25lZFwiO1xuICAgICAgY2FzZSBUZXh0QWxpZ25tZW50Lkp1c3RpZmllZDogcmV0dXJuIFwiIGp1c3RpZmllZFwiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBlbnVtIEZsb2F0IHtcbiAgTm9uZSwgUmlnaHQsIExlZnRcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGbG9hdCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShmbG9hdDogRmxvYXQpIHtcbiAgICBzd2l0Y2ggKGZsb2F0KVxuICAgIHtcbiAgICAgIGNhc2UgRmxvYXQuTGVmdDogcmV0dXJuIFwiIGxlZnQgZmxvYXRlZFwiO1xuICAgICAgY2FzZSBGbG9hdC5SaWdodDogcmV0dXJuIFwiIHJpZ2h0IGZsb2F0ZWRcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBBdHRhY2htZW50IHtcbk5vbmUsIFRvcCwgVG9wUmlnaHQsIFRvcExlZnQsIEJvdHRvbSwgQm90dG9tTGVmdCwgQm90dG9tUmlnaHQsIFJpZ2h0LCBMZWZ0XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXR0YWNobWVudCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShhdHRhY2htZW50OiBBdHRhY2htZW50KSB7XG4gICAgc3dpdGNoIChhdHRhY2htZW50KSB7XG4gICAgICBjYXNlIEF0dGFjaG1lbnQuTm9uZTogcmV0dXJuIFwiIGF0dGFjaGVkXCI7XG4gICAgICBjYXNlIEF0dGFjaG1lbnQuVG9wOiByZXR1cm4gXCIgdG9wIGF0dGFjaGVkXCI7XG4gICAgICBjYXNlIEF0dGFjaG1lbnQuQm90dG9tOiByZXR1cm4gXCIgYm90dG9tIGF0dGFjaGVkXCI7XG4gICAgICBjYXNlIEF0dGFjaG1lbnQuTGVmdDogcmV0dXJuIFwiIGxlZnQgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5SaWdodDogcmV0dXJuIFwiIHJpZ2h0IGF0dGFjaGVkXCI7XG4gICAgICBjYXNlIEF0dGFjaG1lbnQuVG9wUmlnaHQ6IHJldHVybiBcIiB0b3AgcmlnaHQgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Ub3BMZWZ0OiByZXR1cm4gXCIgdG9wIGxlZnQgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Cb3R0b21MZWZ0OiByZXR1cm4gXCIgYm90dG9tIGxlZnQgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Cb3R0b21SaWdodDogcmV0dXJuIFwiIGJvdHRvbSByaWdodCBhdHRhY2hlZFwiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBlbnVtIENvbG9yIHtcbiAgTm9uZSwgUHJpbWFyeSwgU2Vjb25kYXJ5LCBTdWNjZXNzLCBJbmZvLCBXYXJuaW5nLCBFcnJvclxufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbG9yIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGNvbG9yOiBDb2xvcikge1xuICAgIHN3aXRjaCAoY29sb3IpIHtcbiAgICAgIGNhc2UgQ29sb3IuUHJpbWFyeTogcmV0dXJuIFwiIHByaW1hcnlDb2xvcmVkXCI7XG4gICAgICBjYXNlIENvbG9yLlNlY29uZGFyeTogcmV0dXJuIFwiIHNlY29uZGFyeUNvbG9yZWRcIjtcbiAgICAgIGNhc2UgQ29sb3IuU3VjY2VzczogcmV0dXJuIFwiIHN1Y2Nlc3NDb2xvcmVkXCI7XG4gICAgICBjYXNlIENvbG9yLkluZm86IHJldHVybiBcIiBpbmZvQ29sb3JlZFwiO1xuICAgICAgY2FzZSBDb2xvci5XYXJuaW5nOiByZXR1cm4gXCIgd2FybmluZ0NvbG9yZWRcIjtcbiAgICAgIGNhc2UgQ29sb3IuRXJyb3I6IHJldHVybiBcIiBlcnJvckNvbG9yZWQgXCI7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gQW5pbWF0aW9uIHtcbiAgQnJvd3NlLCBEcm9wLCBGYWRlLCBGbGlwLCBTY2FsZSwgRmx5LCBTbGlkZSwgU3dpbmcsXG4gIEZsYXNoLCBTaGFrZSwgQm91bmNlLCBUYWRhLCBQdWxzZSwgSmlnZ2xlLFxuICBOb25lXG59XG5leHBvcnQgbmFtZXNwYWNlIEFuaW1hdGlvbiB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShhbmltOiBBbmltYXRpb24pIHtcbiAgICBzd2l0Y2ggKGFuaW0pXG4gICAge1xuICAgICAgY2FzZSBBbmltYXRpb24uQnJvd3NlOiByZXR1cm4gXCIgYnJvd3NlXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5Ecm9wOiByZXR1cm4gXCIgZHJvcFwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uRmFkZTogcmV0dXJuIFwiIGZhZGVcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkZsaXA6IHJldHVybiBcIiBmbGlwXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5TY2FsZTogcmV0dXJuIFwiIHNjYWxlXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5GbHk6IHJldHVybiBcIiBmbHlcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLlNsaWRlOiByZXR1cm4gXCIgc2xpZGVcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLlN3aW5nOiByZXR1cm4gXCIgc3dpbmdcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkZsYXNoOiByZXR1cm4gXCIgZmxhc2hcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLlNoYWtlOiByZXR1cm4gXCIgc2hha2VcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkJvdW5jZTogcmV0dXJuIFwiIGJvdW5jZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uVGFkYTogcmV0dXJuIFwiIHRhZGFcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLlB1bHNlOiByZXR1cm4gXCIgcHVsc2VcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkppZ2dsZTogcmV0dXJuIFwiIGppZ2dsZVwiO1xuICAgIH1cbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gaXNTdGF0aWMoYW5pbTogQW5pbWF0aW9uKTogQm9vbGVhbiB7XG4gICAgY29uc3Qgc3RhdGljQW5pbWF0aW9ucyA9IFtBbmltYXRpb24uRmxhc2gsIEFuaW1hdGlvbi5TaGFrZSxcbiAgICAgIEFuaW1hdGlvbi5Cb3VuY2UsIEFuaW1hdGlvbi5UYWRhLCBBbmltYXRpb24uUHVsc2UsIEFuaW1hdGlvbi5KaWdnbGVdO1xuICAgIHJldHVybiBzdGF0aWNBbmltYXRpb25zLmluZGV4T2YoYW5pbSkgIT09IC0xO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBpc0RpcmVjdGlvbmFsKGFuaW06IEFuaW1hdGlvbik6IEJvb2xlYW4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbkFuaW1hdGlvbnMgPSBbQW5pbWF0aW9uLkJyb3dzZSwgQW5pbWF0aW9uLkZhZGUsXG4gICAgICBBbmltYXRpb24uRmx5LCBBbmltYXRpb24uU2xpZGUsIEFuaW1hdGlvbi5Td2luZ107XG4gICAgcmV0dXJuIGRpcmVjdGlvbkFuaW1hdGlvbnMuaW5kZXhPZihhbmltKSAhPT0gLTE7XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gRGlyZWN0aW9uIHtcbiAgSW4sIE91dCwgTm9uZVxufVxuZXhwb3J0IG5hbWVzcGFjZSBEaXJlY3Rpb24ge1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUgKGRpcmVjdGlvbjogRGlyZWN0aW9uKXtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uSW4gPyBcIiBpblwiIDogXCIgb3V0XCI7XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gQW5pbWF0aW9uRGlyZWN0aW9uIHtcbiAgVXAsIERvd24sIExlZnQsIFJpZ2h0XG59XG5leHBvcnQgbmFtZXNwYWNlIEFuaW1hdGlvbkRpcmVjdGlvbiB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShkaXI6IEFuaW1hdGlvbkRpcmVjdGlvbikge1xuICAgIHN3aXRjaCAoZGlyKSB7XG4gICAgICBjYXNlIEFuaW1hdGlvbkRpcmVjdGlvbi5VcDogcmV0dXJuIFwiIHVwXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbkRpcmVjdGlvbi5Eb3duOiByZXR1cm4gXCIgZG93blwiO1xuICAgICAgY2FzZSBBbmltYXRpb25EaXJlY3Rpb24uTGVmdDogcmV0dXJuIFwiIGxlZnRcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uRGlyZWN0aW9uLlJpZ2h0OiByZXR1cm4gXCIgcmlnaHRcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VudW1zL2luZGV4LnRzIiwiaW1wb3J0IHtET01Tb3VyY2V9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5leHBvcnQge0RPTVNvdXJjZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7Vk5vZGV9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5leHBvcnQge1ZOb2RlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzLCB7U3RyZWFtfSBmcm9tIFwieHN0cmVhbVwiO1xuXG5leHBvcnQgdHlwZSBET01Db250ZW50ID0gU3RyaW5nIHwgVk5vZGVbXTtcbmV4cG9ydCB0eXBlIEV2ZW50U2VsZWN0b3IgPSAodHlwZTpzdHJpbmcpID0+IFN0cmVhbTxFdmVudD47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RPTUNvbnRlbnQoY29udGVudCkgOiBjb250ZW50IGlzIERPTUNvbnRlbnQge1xuICBpZiAoIWNvbnRlbnQpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mKGNvbnRlbnQpID09PSBcInN0cmluZ1wiKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mKEFycmF5KSkge1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gY29udGVudFswXS5zZWwgIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFAsQz4ge1xuICBET006IERPTVNvdXJjZTtcbiAgcHJvcHMkPzogeHM8UD47XG4gIGNvbnRlbnQkPzogeHM8Qz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFAsQyxFPiB7XG4gIERPTTogRE9NU291cmNlO1xuICBwcm9wcyQ/OiB4czxQPjtcbiAgY29udGVudCQ/OiB4czxDPjtcbiAgZXh0cmFzJD86IHhzPEU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlczxULEEsQz4ge1xuICBET006IERPTVNvdXJjZTtcbiAgdGFyZ2V0JDogeHM8VD47XG4gIGFyZ3MkPzogeHM8QT47XG4gIGNvbnRlbnQkPzogeHM8Qz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICBET006IHhzPFZOb2RlPjtcbiAgRXZlbnRzOiBFdmVudFNlbGVjdG9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElWYWx1ZUNvbXBvbmVudFNpbmtzPFY+IGV4dGVuZHMgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICB2YWx1ZSQ6IHhzPFY+O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2ludGVyZmFjZXMvaW5kZXgudHMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG52YXIgWFN0cmVhbUFkYXB0ZXIgPSB7XG4gICAgYWRhcHQ6IGZ1bmN0aW9uIChvcmlnaW5TdHJlYW0sIG9yaWdpblN0cmVhbVN1YnNjcmliZSkge1xuICAgICAgICBpZiAoWFN0cmVhbUFkYXB0ZXIuaXNWYWxpZFN0cmVhbShvcmlnaW5TdHJlYW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luU3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgdmFyIGRpc3Bvc2UgPSBudWxsO1xuICAgICAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQuY3JlYXRlKHtcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gb3V0O1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UgPSBvcmlnaW5TdHJlYW1TdWJzY3JpYmUob3JpZ2luU3RyZWFtLCBvYnNlcnZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBtYWtlU3ViamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyZWFtID0geHN0cmVhbV8xLmRlZmF1bHQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh4KSB7IHN0cmVhbS5zaGFtZWZ1bGx5U2VuZE5leHQoeCk7IH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyBzdHJlYW0uc2hhbWVmdWxseVNlbmRFcnJvcihlcnIpOyB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgc3RyZWFtLnNoYW1lZnVsbHlTZW5kQ29tcGxldGUoKTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgb2JzZXJ2ZXI6IG9ic2VydmVyLCBzdHJlYW06IHN0cmVhbSB9O1xuICAgIH0sXG4gICAgcmVtZW1iZXI6IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5yZW1lbWJlcigpO1xuICAgIH0sXG4gICAgaXNWYWxpZFN0cmVhbTogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHJlYW0uYWRkTGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzdHJlYW0uc2hhbWVmdWxseVNlbmROZXh0ID09PSAnZnVuY3Rpb24nKTtcbiAgICB9LFxuICAgIHN0cmVhbVN1YnNjcmliZTogZnVuY3Rpb24gKHN0cmVhbSwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgc3RyZWFtLmFkZExpc3RlbmVyKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcihvYnNlcnZlcik7IH07XG4gICAgfSxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBYU3RyZWFtQWRhcHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUveHN0cmVhbS1hZGFwdGVyL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSBudWxsIG9yIHVuZGVmaW5lZFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZVBhdGggPSBleHBvcnRzLnBhcnNlUGF0aCA9IGV4cG9ydHMuZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5zdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCA9IGV4cG9ydHMuaXNBYnNvbHV0ZVBhdGggPSB1bmRlZmluZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaXNBYnNvbHV0ZVBhdGggPSBleHBvcnRzLmlzQWJzb2x1dGVQYXRoID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgocGF0aCkge1xuICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG52YXIgYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCA9IGV4cG9ydHMuYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCA9IGZ1bmN0aW9uIGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwga2V5LCB2YWx1ZSkge1xuICB2YXIgX3BhcnNlUGF0aCA9IHBhcnNlUGF0aChwYXRoKTtcblxuICB2YXIgcGF0aG5hbWUgPSBfcGFyc2VQYXRoLnBhdGhuYW1lO1xuICB2YXIgc2VhcmNoID0gX3BhcnNlUGF0aC5zZWFyY2g7XG4gIHZhciBoYXNoID0gX3BhcnNlUGF0aC5oYXNoO1xuXG5cbiAgcmV0dXJuIGNyZWF0ZVBhdGgoe1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCArIChzZWFyY2guaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBrZXkgKyAnPScgKyB2YWx1ZSxcbiAgICBoYXNoOiBoYXNoXG4gIH0pO1xufTtcblxudmFyIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5zdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgX3BhcnNlUGF0aDIgPSBwYXJzZVBhdGgocGF0aCk7XG5cbiAgdmFyIHBhdGhuYW1lID0gX3BhcnNlUGF0aDIucGF0aG5hbWU7XG4gIHZhciBzZWFyY2ggPSBfcGFyc2VQYXRoMi5zZWFyY2g7XG4gIHZhciBoYXNoID0gX3BhcnNlUGF0aDIuaGFzaDtcblxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gucmVwbGFjZShuZXcgUmVnRXhwKCcoWz8mXSknICsga2V5ICsgJz1bYS16QS1aMC05XSsoJj8pJyksIGZ1bmN0aW9uIChtYXRjaCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBwcmVmaXggPT09ICc/JyA/IHByZWZpeCA6IHN1ZmZpeDtcbiAgICB9KSxcbiAgICBoYXNoOiBoYXNoXG4gIH0pO1xufTtcblxudmFyIGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZnVuY3Rpb24gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgX3BhcnNlUGF0aDMgPSBwYXJzZVBhdGgocGF0aCk7XG5cbiAgdmFyIHNlYXJjaCA9IF9wYXJzZVBhdGgzLnNlYXJjaDtcblxuICB2YXIgbWF0Y2ggPSBzZWFyY2gubWF0Y2gobmV3IFJlZ0V4cCgnWz8mXScgKyBrZXkgKyAnPShbYS16QS1aMC05XSspJykpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59O1xuXG52YXIgZXh0cmFjdFBhdGggPSBmdW5jdGlvbiBleHRyYWN0UGF0aChzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eKGh0dHBzPzopP1xcL1xcL1teXFwvXSovKTtcbiAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBzdHJpbmcgOiBzdHJpbmcuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG59O1xuXG52YXIgcGFyc2VQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBleHRyYWN0UGF0aChwYXRoKTtcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHBhdGggPT09IHBhdGhuYW1lLCAnQSBwYXRoIG11c3QgYmUgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoIG9ubHksIG5vdCBhIGZ1bGwgVVJMIGxpa2UgXCIlc1wiJywgcGF0aCkgOiB2b2lkIDA7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgaWYgKHBhdGhuYW1lID09PSAnJykgcGF0aG5hbWUgPSAnLyc7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaFxuICB9O1xufTtcblxudmFyIGNyZWF0ZVBhdGggPSBleHBvcnRzLmNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIGlmIChsb2NhdGlvbiA9PSBudWxsIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBsb2NhdGlvbjtcblxuICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZTtcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaDtcblxuICBpZiAoaGFzaCkgcGF0aCArPSBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7Vk5vZGV9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMsIHtTdHJlYW19IGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgZmxhdHRlbkNvbmN1cnJlbnRseSBmcm9tIFwieHN0cmVhbS9leHRyYS9mbGF0dGVuQ29uY3VycmVudGx5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENsYXNzTGlzdCh0YXJnZXQ6IFZOb2RlLCBjbGFzc2VzOiBzdHJpbmdbXSwgY2xhc3Nlc1RvQWRkOiBzdHJpbmcpIHtcbiAgbGV0IGNsYXNzTmFtZSA9IFwiXCI7XG4gIGlmICh0YXJnZXQuZGF0YSkge1xuICAgIGxldCBwcm9wcyA9IHRhcmdldC5kYXRhLnByb3BzID8gdGFyZ2V0LmRhdGEucHJvcHMgOiB7IGNsYXNzTmFtZTogdGFyZ2V0LnNlbC5zcGxpdChcIi5cIikuam9pbihcIiBcIil9O1xuICAgIGxldCBjbGFzc0xpc3QgPSBwcm9wcy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpIGFzIEFycmF5PHN0cmluZz47XG4gICAgY2xhc3NMaXN0LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICBjbGFzc05hbWUgKz0gaXRlbSArIFwiIFwiO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsYXNzTmFtZSArPSBjbGFzc2VzVG9BZGQ7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZGF0YSwge1xuICAgIFwicHJvcHNcIjoge1xuICAgICAgY2xhc3NOYW1lXG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBBZGRzIG9uZSBWTm9kZSB0byBhbm90aGVyIGFuZCBoYW5kbGVzIHVwZGF0ZXMgZm9yIHN0cmVhbSBieSByZXBsYWNpbmcgYmFzZWQgb24gdGhlIGlkZW50aWZpZXIgY2xhc3MuXG4gKiBAcGFyYW0gIHtWTm9kZX0gIGVsZW1lbnQgICAgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQuXG4gKiBAcGFyYW0gIHtWTm9kZX0gIHRhcmdldCAgICAgVGhlIHRhcmdldCBmb3IgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZnlpbmcgY2xhc3MgZm9yIHRoZSBlbGVtZW50IHRvIGJlIGFkZGVkLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSB0YXJnZXQgZWxlbWVudCdzIGNoaWxkcmVuIHdpdGggdGhlIGVsZW1lbnQgYWRkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFbGVtZW50KGVsZW1lbnQ6IFZOb2RlLCB0YXJnZXQ6IFZOb2RlLCBpZGVudGlmaWVyOiBzdHJpbmcpOiBBcnJheTxWTm9kZT4ge1xuICBsZXQgYyA9IFtdO1xuICBpZiAodGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgYyA9IHRhcmdldC5jaGlsZHJlbjtcbiAgfVxuICBpZiAodGFyZ2V0LnRleHQpIHtcbiAgICBjLnB1c2godGFyZ2V0LnRleHQpO1xuICB9XG4gIGZvcihsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoaWxkID0gY1tpXTtcbiAgICBsZXQgY1Byb3BzID0gY2hpbGQuZGF0YSA/IGNoaWxkLmRhdGEucHJvcHMgPyBjaGlsZC5kYXRhLnByb3BzIDoge30gOiB7fTtcbiAgICBpZiAodHlwZW9mKGNoaWxkKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YoY1Byb3BzLmNsYXNzTmFtZSkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAge1xuICAgICAgbGV0IGNsYXNzTGlzdCA9IGNoaWxkLmRhdGEucHJvcHMuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSBhcyBBcnJheTxzdHJpbmc+O1xuICAgICAgZm9yIChsZXQgcyBvZiBjbGFzc0xpc3QpIHtcbiAgICAgICAgaWYgKHMgPT09IGlkZW50aWZpZXIpXG4gICAgICAgIHtcbiAgICAgICAgICBjLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjLnB1c2goZWxlbWVudCk7XG4gIHJldHVybiBjO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFueXRoaW5nIHRvIGEgc3RyZWFtXG4gKiBAcGFyYW0gIHthbnl9IG9iaiAtIFRoZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtTdHJlYW08YW55Pn0gVGhlIG9iamVjdCBhcyBhIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyZWFtKG9iaik6IFN0cmVhbTxhbnk+IHtcbiAgaWYgKHR5cGVvZihvYmopICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZihvYmouYWRkTGlzdGVuZXIpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKXtcbiAgICAgICAgbGV0IGlzU3RyZWFtcyA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHN1Ym9iaiBvZiBvYmopIHtcbiAgICAgICAgICBpZiAodHlwZW9mKHN1Ym9iai5hZGRMaXN0ZW5lcikgIT09IFwiZnVuY3Rpb25cIil7XG4gICAgICAgICAgICBpc1N0cmVhbXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyZWFtcykge1xuICAgICAgICAgIHJldHVybiB4cy5jb21iaW5lLmFwcGx5KHRoaXMsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzLm9mKG9iaik7XG4gIH1cbiAgcmV0dXJuIHhzLm9mKFwiXCIpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9mIG9iamVjdHMgdG8gYSBzdHJlYW0gb2YgYW4gQXJyYXkuXG4gKiBAcGFyYW0gIHthbnl9IC4uLm9ianMgICBUaGUgb2JqZWN0cyB0byBpbmNsdWRlIGluIHRoZSBzdHJlYW1cbiAqIEByZXR1cm4ge1N0cmVhbTxhbnlbXT59IFRoZSBvYmplY3RzIGFzIGEgc3RyZWFtIG9mIGFuIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheVN0cmVhbSguLi5vYmpzKSA6IFN0cmVhbTxhbnlbXT4ge1xuICBsZXQgc3RyZWFtcyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgc3RyZWFtcyA9IHN0cmVhbXMubWFwKG9iaiA9PiBhc1N0cmVhbShvYmopKTtcbiAgcmV0dXJuIHhzLmNvbWJpbmUuYXBwbHkodGhpcywgc3RyZWFtcyk7XG59XG5cbi8qKlxuICogRmxhdHRlbnMgYSBzdHJlYW0gb2YgYW4gYXJyYXkgb2Ygc3RyZWFtcyBpbnRvIGEgc3RyZWFtIG9mIGFuIGFycmF5LlxuICogQHBhcmFtICB7U3RyZWFtPFN0cmVhbTxhbnk+W10+fSBzdHJlYW0gVGhlIHN0cmVhbSB0byBmbGF0dGVuXG4gKiBAcmV0dXJuIHtTdHJlYW08YW55W10+fSAgICAgICAgICAgICAgICBUaGUgZmxhdHRlbmVkIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5TdHJlYW1BcnJheShzdHJlYW06IFN0cmVhbTxTdHJlYW08YW55PltdPikgOiBTdHJlYW08YW55W10+IHtcbiAgcmV0dXJuIGZsYXR0ZW5Db25jdXJyZW50bHkoXG4gICAgc3RyZWFtLm1hcChjaGlsZHJlbiA9PiB4cy5jb21iaW5lLmFwcGx5KHRoaXMsIGNoaWxkcmVuKVxuICApXG4gICkgYXMgU3RyZWFtPGFueVtdPjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIG5hdHVyYWwgbnVtYmVyIGJldHdlZW4gMS0xNiB0byB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybiB7c3RyaW5nfSAgICAgVGhhdCBudW1iZXIgYXMgdGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bVRvVGV4dChudW06IG51bWJlcikgOiBzdHJpbmcge1xuICBzd2l0Y2gobnVtKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gXCIgb25lXCI7XG4gICAgY2FzZSAyOiByZXR1cm4gXCIgdHdvXCI7XG4gICAgY2FzZSAzOiByZXR1cm4gXCIgdGhyZWVcIjtcbiAgICBjYXNlIDQ6IHJldHVybiBcIiBmb3VyXCI7XG4gICAgY2FzZSA1OiByZXR1cm4gXCIgZml2ZVwiO1xuICAgIGNhc2UgNjogcmV0dXJuIFwiIHNpeFwiO1xuICAgIGNhc2UgNzogcmV0dXJuIFwiIHNldmVuXCI7XG4gICAgY2FzZSA4OiByZXR1cm4gXCIgZWlnaHRcIjtcbiAgICBjYXNlIDk6IHJldHVybiBcIiBuaW5lXCI7XG4gICAgY2FzZSAxMDogcmV0dXJuIFwiIHRlblwiO1xuICAgIGNhc2UgMTE6IHJldHVybiBcIiBlbGV2ZW5cIjtcbiAgICBjYXNlIDEyOiByZXR1cm4gXCIgdHdlbHZlXCI7XG4gICAgY2FzZSAxMzogcmV0dXJuIFwiIHRoaXJ0ZWVuXCI7XG4gICAgY2FzZSAxNDogcmV0dXJuIFwiIGZvdXJ0ZWVuXCI7XG4gICAgY2FzZSAxNTogcmV0dXJuIFwiIGZpZnRlZW5cIjtcbiAgICBjYXNlIDE2OiByZXR1cm4gXCIgc2l4dGVlblwiO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaW5kZXgudHMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBub3JtYWxpemVPcHRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGlzQ2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZScpXG4gICwgY29udGFpbnMgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuXG4gICwgZDtcblxuZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMikgfHwgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsICd3Jyk7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmIChnZXQgPT0gbnVsbCkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoc2V0ID09IG51bGwpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG5cdHJldHVybiBmbjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLnN0YXRlc0FyZUVxdWFsID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlUXVlcnkgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlUXVlcnkgPSBleHBvcnRzLmNyZWF0ZVF1ZXJ5ID0gZnVuY3Rpb24gY3JlYXRlUXVlcnkocHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKE9iamVjdC5jcmVhdGUobnVsbCksIHByb3BzKTtcbn07XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbigpIHtcbiAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJy8nIDogYXJndW1lbnRzWzBdO1xuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX0FjdGlvbnMuUE9QIDogYXJndW1lbnRzWzFdO1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICB2YXIgb2JqZWN0ID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkoaW5wdXQpIDogaW5wdXQ7XG5cbiAgdmFyIHBhdGhuYW1lID0gb2JqZWN0LnBhdGhuYW1lIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9IG9iamVjdC5zZWFyY2ggfHwgJyc7XG4gIHZhciBoYXNoID0gb2JqZWN0Lmhhc2ggfHwgJyc7XG4gIHZhciBzdGF0ZSA9IG9iamVjdC5zdGF0ZTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoLFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBrZXk6IGtleVxuICB9O1xufTtcblxudmFyIGlzRGF0ZSA9IGZ1bmN0aW9uIGlzRGF0ZShvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG52YXIgc3RhdGVzQXJlRXF1YWwgPSBleHBvcnRzLnN0YXRlc0FyZUVxdWFsID0gZnVuY3Rpb24gc3RhdGVzQXJlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHR5cGVvZkEgPSB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSk7XG4gIHZhciB0eXBlb2ZCID0gdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpO1xuXG4gIGlmICh0eXBlb2ZBICE9PSB0eXBlb2ZCKSByZXR1cm4gZmFsc2U7XG5cbiAgISh0eXBlb2ZBICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdZb3UgbXVzdCBub3Qgc3RvcmUgZnVuY3Rpb25zIGluIGxvY2F0aW9uIHN0YXRlJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIE5vdCB0aGUgc2FtZSBvYmplY3QsIGJ1dCBzYW1lIHR5cGUuXG4gIGlmICh0eXBlb2ZBID09PSAnb2JqZWN0Jykge1xuICAgICEhKGlzRGF0ZShhKSAmJiBpc0RhdGUoYikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBtdXN0IG5vdCBzdG9yZSBEYXRlIG9iamVjdHMgaW4gbG9jYXRpb24gc3RhdGUnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkpIHJldHVybiBPYmplY3Qua2V5cyhhKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gc3RhdGVzQXJlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gc3RhdGVzQXJlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWxsIG90aGVyIHNlcmlhbGl6YWJsZSB0eXBlcyAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4pXG4gIC8vIHNob3VsZCBiZSBzdHJpY3QgZXF1YWwuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLmtleSA9PT0gYi5rZXkgJiZcbiAgLy8gYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgc3RhdGVzQXJlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9Mb2NhdGlvblV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBWTm9kZSwgSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBBbmltYXRpb24sIEFuaW1hdGlvbkRpcmVjdGlvbiwgRGlyZWN0aW9uIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCB7IGggfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhbnNpdGlvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJhbnNpdGlvbiB7XG4gICAgYW5pbWF0aW9uOiBBbmltYXRpb247XG4gICAgZGlyZWN0aW9uPzogRGlyZWN0aW9uO1xuICAgIGFuaW1hdGlvbkRpcmVjdGlvbj86IEFuaW1hdGlvbkRpcmVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHRyYW5zaXRpb24gd3JhcHBlciBmb3IgYW5pbWF0aW5nIGRvbSBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdGFyZ2V0czogVk5vZGVcbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czoge30gb2ZcbiAgICogICBhbmltYXRpb246IEFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdG8gdXNlLlxuICAgKiAgIGRpcmVjdGlvbj86IERpcmVjdGlvbiAtIFdldGhlciB0byBhbmltYXRlIHRvIHZpc2libGUgb3IgaW52aXNpYmxlLlxuICAgKiAgIGFuaW1hdGlvbkRpcmVjdGlvbj86IEFuaW1hdGlvbkRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gZm9yIHRoZSBhbmltYXRpb24uXG4gICAqIERpc3JlZ2FyZHMgYW55IGNvbnRlbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlczxWTm9kZSwgVHJhbnNpdGlvbiwgYW55Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlczxWTm9kZSwgVHJhbnNpdGlvbiwgYW55Pikge1xuICAgICAgY29uc3QgZXZ0ID0gKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi50cmFuc2l0aW9uXCIpLmV2ZW50cyh0eXBlKTtcbiAgICAgIHNvdXJjZXMuYXJncyQgPSBzb3VyY2VzLmFyZ3MkID8gc291cmNlcy5hcmdzJCA6IHhzLm9mKHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uT3V0IH0pO1xuXG4gICAgICBsZXQgYW5pbWF0aW9uRW5kJCA9IGV2dChcImFuaW1hdGlvbmVuZFwiKS5tYXAoZXZ0ID0+ICh7XG4gICAgICAgIGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsXG4gICAgICAgIGRpcmVjdGlvbjogKGV2dC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoXCJvdXRcIikgPyBEaXJlY3Rpb24uT3V0IDogRGlyZWN0aW9uLkluXG4gICAgICB9KSkgYXMgU3RyZWFtPFRyYW5zaXRpb24+O1xuICAgICAgbGV0IGFuaW1hdGlvbiQgPSB4cy5tZXJnZShzb3VyY2VzLmFyZ3MkLCBhbmltYXRpb25FbmQkKTtcblxuICAgICAgbGV0IHZUcmVlJCA9IHhzLmNvbWJpbmUoYW5pbWF0aW9uJCwgc291cmNlcy50YXJnZXQkKS5tYXAoXG4gICAgICAgIChbdHJhbnNpdGlvbiwgdGFyZ2V0XSkgPT4gcmVuZGVyKHRhcmdldCwgdHJhbnNpdGlvbilcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnRyYW5zaXRpb25cIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSB0cmFuc2l0aW9uIHdyYXBwZXIgZm9yIGFuaW1hdGluZyBkb20gY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHRhcmdldHM6IFZOb2RlXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6IHt9IG9mXG4gICAqICAgYW5pbWF0aW9uOiBBbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRvIHVzZS5cbiAgICogICBkaXJlY3Rpb24/OiBEaXJlY3Rpb24gLSBXZXRoZXIgdG8gYW5pbWF0ZSB0byB2aXNpYmxlIG9yIGludmlzaWJsZS5cbiAgICogICBhbmltYXRpb25EaXJlY3Rpb24/OiBBbmltYXRpb25EaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGZvciB0aGUgYW5pbWF0aW9uLlxuICAgKiBEaXNyZWdhcmRzIGFueSBjb250ZW50LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih0YXJnZXQ6IFZOb2RlLCBhcmdzOiBUcmFuc2l0aW9uID0geyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lIH0pOiBWTm9kZSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwiXCIsIGM7XG4gICAgaWYgKHRhcmdldC5kYXRhKSB7XG4gICAgICBsZXQgY2xhc3NMaXN0ID0gdGFyZ2V0LmRhdGEucHJvcHMuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSBhcyBBcnJheTxzdHJpbmc+O1xuICAgICAgY2xhc3NMaXN0LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGlmIChbXCJoaWRkZW5cIiwgXCJ2aXNpYmxlXCIsIFwiYW5pbWF0aW5nXCIsIFwidHJhbnNpdGlvblwiXS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgIGNsYXNzTmFtZSArPSBpdGVtICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gZ2V0Q2xhc3NOYW1lKGFyZ3MpO1xuICAgIGNvbnN0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZGF0YSwge1xuICAgICAgXCJwcm9wc1wiOiB7XG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXJnZXQuY2hpbGRyZW4pIHtcbiAgICAgIGMgPSB0YXJnZXQuY2hpbGRyZW47XG4gICAgfVxuICAgIGlmICh0YXJnZXQudGV4dCkge1xuICAgICAgYyA9IHRhcmdldC50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gaCh0YXJnZXQuc2VsLCBkYXRhLCBjKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUodHJhbnNpdGlvbjogVHJhbnNpdGlvbik6IHN0cmluZyB7XG4gICAgaWYgKHRyYW5zaXRpb24uYW5pbWF0aW9uID09PSBBbmltYXRpb24uTm9uZSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb24uZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uT3V0ID8gXCJ0cmFuc2l0aW9uIGhpZGRlblwiIDogXCJ0cmFuc2l0aW9uIHZpc2libGVcIjtcbiAgICB9XG4gICAgbGV0IGFuaW1hdGlvbiA9IEFuaW1hdGlvbi5Ub0NsYXNzbmFtZSh0cmFuc2l0aW9uLmFuaW1hdGlvbik7XG4gICAgaWYgKEFuaW1hdGlvbi5pc1N0YXRpYyh0cmFuc2l0aW9uLmFuaW1hdGlvbikpIHtcbiAgICAgIHJldHVybiBcInZpc2libGUgYW5pbWF0aW5nIHRyYW5zaXRpb24gXCIgKyBhbmltYXRpb247XG4gICAgfVxuICAgIGxldCBkaXJlY3Rpb24gPSBEaXJlY3Rpb24uVG9DbGFzc25hbWUodHJhbnNpdGlvbi5kaXJlY3Rpb24pO1xuICAgIGlmIChBbmltYXRpb24uaXNEaXJlY3Rpb25hbCh0cmFuc2l0aW9uLmFuaW1hdGlvbikpIHtcbiAgICAgIGFuaW1hdGlvbiArPSBBbmltYXRpb25EaXJlY3Rpb24uVG9DbGFzc25hbWUodHJhbnNpdGlvbi5hbmltYXRpb25EaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gXCJ2aXNpYmxlIHRyYW5zaXRpb24gYW5pbWF0aW5nIFwiICsgZGlyZWN0aW9uICsgYW5pbWF0aW9uO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kdWxlcy90cmFuc2l0aW9uL2luZGV4LnRzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2FybmluZy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID9cbiAgICAgICAgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgb2JqIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCA6XG4gICAgICAgIG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKG9iai5ub2RlVHlwZSA9PT0gMSB8fCBvYmoubm9kZVR5cGUgPT09IDExKSAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydHMuU0NPUEVfUFJFRklYID0gXCIkJENZQ0xFRE9NJCQtXCI7XG5mdW5jdGlvbiBnZXRFbGVtZW50KHNlbGVjdG9ycykge1xuICAgIHZhciBkb21FbGVtZW50ID0gdHlwZW9mIHNlbGVjdG9ycyA9PT0gJ3N0cmluZycgP1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9ycykgOlxuICAgICAgICBzZWxlY3RvcnM7XG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvcnMgPT09ICdzdHJpbmcnICYmIGRvbUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbmRlciBpbnRvIHVua25vd24gZWxlbWVudCBgXCIgKyBzZWxlY3RvcnMgKyBcImBcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0VsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4gY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50IG5laXRoZXIgYSBcIiArXG4gICAgICAgICAgICBcInNlbGVjdG9yIHN0cmluZy5cIik7XG4gICAgfVxuICAgIHJldHVybiBkb21FbGVtZW50O1xufVxuZXhwb3J0cy5nZXRFbGVtZW50ID0gZ2V0RWxlbWVudDtcbmZ1bmN0aW9uIGdldFNjb3BlKG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBuYW1lc3BhY2VcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5pbmRleE9mKGV4cG9ydHMuU0NPUEVfUFJFRklYKSA+IC0xOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlcGxhY2UoZXhwb3J0cy5TQ09QRV9QUkVGSVgsICcnKTsgfSlcbiAgICAgICAgLmpvaW4oXCItXCIpO1xufVxuZXhwb3J0cy5nZXRTY29wZSA9IGdldFNjb3BlO1xuZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBuYW1lc3BhY2UuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmluZGV4T2YoZXhwb3J0cy5TQ09QRV9QUkVGSVgpID09PSAtMTsgfSkuam9pbihcIiBcIik7XG59XG5leHBvcnRzLmdldFNlbGVjdG9ycyA9IGdldFNlbGVjdG9ycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpID8gU3ltYm9sIDogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1zeW1ib2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBhZGRFdmVudExpc3RlbmVyID0gZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUuYWRkRXZlbnRMaXN0ZW5lciA/IG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IGV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xudmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ludmFyaWFudC9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3Quc2V0UHJvdG90eXBlT2Zcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5wdXNoLlxuICovXG52YXIgUFVTSCA9IGV4cG9ydHMuUFVTSCA9ICdQVVNIJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucmVwbGFjZS5cbiAqL1xudmFyIFJFUExBQ0UgPSBleHBvcnRzLlJFUExBQ0UgPSAnUkVQTEFDRSc7XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IHNvbWUgb3RoZXIgYWN0aW9uIHN1Y2hcbiAqIGFzIHVzaW5nIGEgYnJvd3NlcidzIGJhY2svZm9yd2FyZCBidXR0b25zIGFuZC9vciBtYW51YWxseSBtYW5pcHVsYXRpbmdcbiAqIHRoZSBVUkwgaW4gYSBicm93c2VyJ3MgbG9jYXRpb24gYmFyLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93RXZlbnRIYW5kbGVycy9vbnBvcHN0YXRlXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIFBPUCA9IGV4cG9ydHMuUE9QID0gJ1BPUCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheTogQXJyYXkuaXNBcnJheSxcbiAgcHJpbWl0aXZlOiBmdW5jdGlvbihzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHMgPT09ICdudW1iZXInOyB9LFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9pcy5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IENvbG9yLCBTaXplLCBJY29uVHlwZSB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGkgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEljb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBidXR0b24/OiBib29sZWFuO1xuICAgIGJvcmRlcmVkPzogYm9vbGVhbjtcbiAgICBjaXJjdWxhcj86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGxvYWRpbmc/OiBib29sZWFuO1xuICAgIGZpdHRlZD86IGJvb2xlYW47XG4gICAgbGluaz86IGJvb2xlYW47XG4gICAgZmxpcHBlZD86IGJvb2xlYW47XG4gICAgcm90YXRlZD86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGljb24gY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGljb25zLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICBidXR0b24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGRpc3BsYXkgd2VsbCBvbiBidXR0b25zXG4gICAqIFx0Ym9yZGVyZWQ/OiBib29sZWFuIC0gQWRkcyBhIGJvcmRlciBhcm91bmQgdGhlIGljb24uXG4gICAqIFx0Y2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBjaXJjdWxhci5cbiAgICogXHRkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiBcdGxvYWRpbmc/OiBib29sZWFuIC0gUm90YXRlcyB0aGUgaWNvbiB0byBhbGxvdyBpdCB0byBiZSB1c2VkIGZvciBsb2FkZXJzLlxuICAgKiBcdGZpdHRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gZm9yIHRpZ2h0IGZpdHMuXG4gICAqIFx0bGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIGNsaWNrYWJsZS5cbiAgICogXHRmbGlwcGVkPzogYm9vbGVhbiAtIEZsaXBzIHRoZSBpY29uLlxuICAgKiBcdHJvdGF0ZWQ/OiBib29sZWFuIC0gUm90YXRlcyB0aGUgaWNvbi5cbiAgICogXHRpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIG9uIGRhcmsgYmFja2dyb3VuZC5cbiAgICogXHRjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBpY29uLlxuICAgKiBcdHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGljb24uXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IEljb25UeXBlXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudFNvdXJjZXN9IHNvdXJjZXMgLSBUaGUgY29tcG9uZW50J3Mgc291cmNlcy5cbiAgICogQHJldHVybiB7Q29tcG9uZW50U2lua3N9IFRoZSBJY29uIGNvbXBvbmVudC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgSWNvblR5cGU+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgSWNvblR5cGU+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7IHR5cGU6IFwiXCIgfSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZigwKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKVxuICAgICAgICAgIC5tYXAoKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudCkpLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuaWNvblwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpY29uIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBpY29ucy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICBidXR0b24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGRpc3BsYXkgd2VsbCBvbiBidXR0b25zXG4gICAqIFx0Ym9yZGVyZWQ/OiBib29sZWFuIC0gQWRkcyBhIGJvcmRlciBhcm91bmQgdGhlIGljb24uXG4gICAqIFx0Y2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBjaXJjdWxhci5cbiAgICogXHRkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiBcdGxvYWRpbmc/OiBib29sZWFuIC0gUm90YXRlcyB0aGUgaWNvbiB0byBhbGxvdyBpdCB0byBiZSB1c2VkIGZvciBsb2FkZXJzLlxuICAgKiBcdGZpdHRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gZm9yIHRpZ2h0IGZpdHMuXG4gICAqIFx0bGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIGNsaWNrYWJsZS5cbiAgICogXHRmbGlwcGVkPzogYm9vbGVhbiAtIEZsaXBzIHRoZSBpY29uLlxuICAgKiBcdHJvdGF0ZWQ/OiBib29sZWFuIC0gUm90YXRlcyB0aGUgaWNvbi5cbiAgICogXHRpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGljb24gdG8gYXBwZWFyIG9uIGRhcmsgYmFja2dyb3VuZC5cbiAgICogXHRjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBpY29uLlxuICAgKiBcdHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGljb24uXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEljb25UeXBlXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudFNvdXJjZXN9IHNvdXJjZXMgLSBUaGUgY29tcG9uZW50J3Mgc291cmNlcy5cbiAgICogQHJldHVybiB7Q29tcG9uZW50U2lua3N9IFRoZSBJY29uIGNvbXBvbmVudC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBJY29uVHlwZSA9IHt9LCBjOiBJY29uVHlwZSA9IC0xKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzUHJvcHMocE9yQykgPyBwT3JDIDoge307XG4gICAgbGV0IGNvbnRlbnQgPSBpc1Byb3BzKHBPckMpID8gYyA6IHBPckM7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZ2V0Q2xhc3NuYW1lKHByb3BzLCBjb250ZW50KTtcbiAgICByZXR1cm4gY2xhc3NOYW1lICE9PSBcInVpIGljb25cIiA/IGkoeyBwcm9wczogeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9IH0pIDogXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzLCBjb250ZW50OiBJY29uVHlwZSk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuYnV0dG9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYnV0dG9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ib3JkZXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJvcmRlcmVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaXJjdWxhcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNpcmN1bGFyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sb2FkaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbG9hZGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZml0dGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZml0dGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5saW5rKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGlua1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmxpcHBlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsaXBwZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJvdGF0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByb3RhdGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gSWNvblR5cGUuVG9DbGFzc25hbWUoY29udGVudCk7XG4gICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIGljb25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJvcHMocHJvcHMpOiBwcm9wcyBpcyBQcm9wcyB7XG4gICAgcmV0dXJuIHR5cGVvZiAocHJvcHMpID09PSBcIm9iamVjdFwiO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvaWNvbi9pbmRleC50cyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbmZ1bmN0aW9uIGZyb21FdmVudChlbGVtZW50LCBldmVudE5hbWUsIHVzZUNhcHR1cmUpIHtcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdm9pZCAwKSB7IHVzZUNhcHR1cmUgPSBmYWxzZTsgfVxuICAgIHJldHVybiB4c3RyZWFtXzEuU3RyZWFtLmNyZWF0ZSh7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24gbmV4dChldmVudCkgeyBsaXN0ZW5lci5uZXh0KGV2ZW50KTsgfTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5uZXh0LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5uZXh0LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZnJvbUV2ZW50ID0gZnJvbUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9mcm9tRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzID0gcmVxdWlyZSgnc25hYmJkb20vaXMnKTtcbnZhciB2bm9kZSA9IHJlcXVpcmUoJ3NuYWJiZG9tL3Zub2RlJyk7XG5mdW5jdGlvbiBpc0dlbmVyaWNTdHJlYW0oeCkge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheSh4KSAmJiB0eXBlb2YgeC5tYXAgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIG11dGF0ZVN0cmVhbVdpdGhOUyh2Tm9kZSkge1xuICAgIGFkZE5TKHZOb2RlLmRhdGEsIHZOb2RlLmNoaWxkcmVuLCB2Tm9kZS5zZWwpO1xuICAgIHJldHVybiB2Tm9kZTtcbn1cbmZ1bmN0aW9uIGFkZE5TKGRhdGEsIGNoaWxkcmVuLCBzZWxlY3Rvcikge1xuICAgIGRhdGEubnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgaWYgKHNlbGVjdG9yICE9PSBcInRleHRcIiAmJiBzZWxlY3RvciAhPT0gXCJmb3JlaWduT2JqZWN0XCIgJiZcbiAgICAgICAgdHlwZW9mIGNoaWxkcmVuICE9PSAndW5kZWZpbmVkJyAmJiBpcy5hcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGlzR2VuZXJpY1N0cmVhbShjaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGNoaWxkcmVuW2ldLm1hcChtdXRhdGVTdHJlYW1XaXRoTlMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkTlMoY2hpbGRyZW5baV0uZGF0YSwgY2hpbGRyZW5baV0uY2hpbGRyZW4sIGNoaWxkcmVuW2ldLnNlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoKHNlbCwgYiwgYykge1xuICAgIHZhciBkYXRhID0ge307XG4gICAgdmFyIGNoaWxkcmVuO1xuICAgIHZhciB0ZXh0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGRhdGEgPSBiO1xuICAgICAgICBpZiAoaXMuYXJyYXkoYykpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYykpIHtcbiAgICAgICAgICAgIHRleHQgPSBjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKGlzLmFycmF5KGIpKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGIpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5hcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaXMucHJpbWl0aXZlKGNoaWxkcmVuW2ldKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gdm5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxbMF0gPT09ICdzJyAmJiBzZWxbMV0gPT09ICd2JyAmJiBzZWxbMl0gPT09ICdnJykge1xuICAgICAgICBhZGROUyhkYXRhLCBjaGlsZHJlbiwgc2VsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIHVuZGVmaW5lZCk7XG59XG5leHBvcnRzLmggPSBoO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHlwZXJzY3JpcHQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL2h5cGVyc2NyaXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuICAsIGlkID0gdG9TdHJpbmcuY2FsbCgoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHRvU3RyaW5nLmNhbGwoeCkgPT09IGlkKTsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gT2JqZWN0LmFzc2lnblxuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbiAgLCBpZCA9IHRvU3RyaW5nLmNhbGwoJycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB8fCAoeCAmJiAodHlwZW9mIHggPT09ICdvYmplY3QnKSAmJlxuXHRcdCgoeCBpbnN0YW5jZW9mIFN0cmluZykgfHwgKHRvU3RyaW5nLmNhbGwoeCkgPT09IGlkKSkpIHx8IGZhbHNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L3N0cmluZy9pcy1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsZWFyICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2NsZWFyJylcbiAgLCBhc3NpZ24gICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2Fzc2lnbicpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG4gICwgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBhdXRvQmluZCA9IHJlcXVpcmUoJ2QvYXV0by1iaW5kJylcbiAgLCBTeW1ib2wgICA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKVxuXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBJdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRvciA9IGZ1bmN0aW9uIChsaXN0LCBjb250ZXh0KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBJdGVyYXRvcikpIHJldHVybiBuZXcgSXRlcmF0b3IobGlzdCwgY29udGV4dCk7XG5cdGRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdF9fbGlzdF9fOiBkKCd3JywgdmFsdWUobGlzdCkpLFxuXHRcdF9fY29udGV4dF9fOiBkKCd3JywgY29udGV4dCksXG5cdFx0X19uZXh0SW5kZXhfXzogZCgndycsIDApXG5cdH0pO1xuXHRpZiAoIWNvbnRleHQpIHJldHVybjtcblx0Y2FsbGFibGUoY29udGV4dC5vbik7XG5cdGNvbnRleHQub24oJ19hZGQnLCB0aGlzLl9vbkFkZCk7XG5cdGNvbnRleHQub24oJ19kZWxldGUnLCB0aGlzLl9vbkRlbGV0ZSk7XG5cdGNvbnRleHQub24oJ19jbGVhcicsIHRoaXMuX29uQ2xlYXIpO1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhJdGVyYXRvci5wcm90b3R5cGUsIGFzc2lnbih7XG5cdGNvbnN0cnVjdG9yOiBkKEl0ZXJhdG9yKSxcblx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpO1xuXHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuO1xuXHRcdGlmICh0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRpID0gdGhpcy5fX3JlZG9fXy5zaGlmdCgpO1xuXHRcdFx0aWYgKGkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGlzdF9fLmxlbmd0aCkgcmV0dXJuIHRoaXMuX19uZXh0SW5kZXhfXysrO1xuXHRcdHRoaXMuX3VuQmluZCgpO1xuXHR9KSxcblx0bmV4dDogZChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jcmVhdGVSZXN1bHQodGhpcy5fbmV4dCgpKTsgfSksXG5cdF9jcmVhdGVSZXN1bHQ6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cdFx0cmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLl9yZXNvbHZlKGkpIH07XG5cdH0pLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTsgfSksXG5cdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX19saXN0X18gPSBudWxsO1xuXHRcdGRlbGV0ZSB0aGlzLl9fcmVkb19fO1xuXHRcdGlmICghdGhpcy5fX2NvbnRleHRfXykgcmV0dXJuO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfYWRkJywgdGhpcy5fb25BZGQpO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfZGVsZXRlJywgdGhpcy5fb25EZWxldGUpO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfY2xlYXInLCB0aGlzLl9vbkNsZWFyKTtcblx0XHR0aGlzLl9fY29udGV4dF9fID0gbnVsbDtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IEl0ZXJhdG9yXSc7IH0pXG59LCBhdXRvQmluZCh7XG5cdF9vbkFkZDogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0Kyt0aGlzLl9fbmV4dEluZGV4X187XG5cdFx0aWYgKCF0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19yZWRvX18nLCBkKCdjJywgW2luZGV4XSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGkpIHtcblx0XHRcdGlmIChyZWRvID49IGluZGV4KSB0aGlzLl9fcmVkb19fW2ldID0gKytyZWRvO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHRoaXMuX19yZWRvX18ucHVzaChpbmRleCk7XG5cdH0pLFxuXHRfb25EZWxldGU6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0dmFyIGk7XG5cdFx0aWYgKGluZGV4ID49IHRoaXMuX19uZXh0SW5kZXhfXykgcmV0dXJuO1xuXHRcdC0tdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdGlmICghdGhpcy5fX3JlZG9fXykgcmV0dXJuO1xuXHRcdGkgPSB0aGlzLl9fcmVkb19fLmluZGV4T2YoaW5kZXgpO1xuXHRcdGlmIChpICE9PSAtMSkgdGhpcy5fX3JlZG9fXy5zcGxpY2UoaSwgMSk7XG5cdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBpKSB7XG5cdFx0XHRpZiAocmVkbyA+IGluZGV4KSB0aGlzLl9fcmVkb19fW2ldID0gLS1yZWRvO1xuXHRcdH0sIHRoaXMpO1xuXHR9KSxcblx0X29uQ2xlYXI6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9fcmVkb19fKSBjbGVhci5jYWxsKHRoaXMuX19yZWRvX18pO1xuXHRcdHRoaXMuX19uZXh0SW5kZXhfXyA9IDA7XG5cdH0pXG59KSkpO1xuXG5kZWZpbmVQcm9wZXJ0eShJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgZChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzO1xufSkpO1xuZGVmaW5lUHJvcGVydHkoSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoJycsICdJdGVyYXRvcicpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtaXRlcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ28gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tYWxlcnQgKi9cblxuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBfY3JlYXRlTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gIHZhciBrZXkgPSBoaXN0b3J5U3RhdGUgJiYgaGlzdG9yeVN0YXRlLmtleTtcblxuICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKSh7XG4gICAgcGF0aG5hbWU6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICBzZWFyY2g6IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gsXG4gICAgaGFzaDogd2luZG93LmxvY2F0aW9uLmhhc2gsXG4gICAgc3RhdGU6IGtleSA/ICgwLCBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZSkoa2V5KSA6IHVuZGVmaW5lZFxuICB9LCB1bmRlZmluZWQsIGtleSk7XG59O1xuXG52YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gIHZhciBoaXN0b3J5U3RhdGUgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgaGlzdG9yeVN0YXRlID0gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWphY2tzb24vaGlzdG9yeS9wdWxsLzI4OVxuICAgIGhpc3RvcnlTdGF0ZSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbihoaXN0b3J5U3RhdGUpO1xufTtcblxudmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59O1xuXG52YXIgc3RhcnRMaXN0ZW5lciA9IGV4cG9ydHMuc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuc3RhdGUgIT09IHVuZGVmaW5lZCkgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdFxuICAgICAgbGlzdGVuZXIoX2NyZWF0ZUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuICB9O1xufTtcblxudmFyIHVwZGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHVwZGF0ZVN0YXRlKSB7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG5cbiAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpICgwLCBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZSkoa2V5LCBzdGF0ZSk7XG5cbiAgdXBkYXRlU3RhdGUoeyBrZXk6IGtleSB9LCAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpO1xufTtcblxudmFyIHB1c2hMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgbnVsbCwgcGF0aCk7XG4gIH0pO1xufTtcblxudmFyIHJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgbnVsbCwgcGF0aCk7XG4gIH0pO1xufTtcblxudmFyIGdvID0gZXhwb3J0cy5nbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvQnJvd3NlclByb3RvY29sLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gb3B0aW9ucy5nZXRDdXJyZW50TG9jYXRpb247XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gb3B0aW9ucy5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB2YXIgcHVzaExvY2F0aW9uID0gb3B0aW9ucy5wdXNoTG9jYXRpb247XG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBvcHRpb25zLnJlcGxhY2VMb2NhdGlvbjtcbiAgdmFyIGdvID0gb3B0aW9ucy5nbztcbiAgdmFyIGtleUxlbmd0aCA9IG9wdGlvbnMua2V5TGVuZ3RoO1xuXG5cbiAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IHZvaWQgMDtcbiAgdmFyIHBlbmRpbmdMb2NhdGlvbiA9IHZvaWQgMDtcbiAgdmFyIGJlZm9yZUxpc3RlbmVycyA9IFtdO1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBhbGxLZXlzID0gW107XG5cbiAgdmFyIGdldEN1cnJlbnRJbmRleCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRJbmRleCgpIHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uICYmIHBlbmRpbmdMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihwZW5kaW5nTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChjdXJyZW50TG9jYXRpb24pIHJldHVybiBhbGxLZXlzLmluZGV4T2YoY3VycmVudExvY2F0aW9uLmtleSk7XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKSB7XG4gICAgY3VycmVudExvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuXG4gICAgaWYgKGN1cnJlbnRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGFsbEtleXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsbEtleXMuc2xpY2UoMCwgY3VycmVudEluZGV4ICsgMSkpLCBbY3VycmVudExvY2F0aW9uLmtleV0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUkVQTEFDRSkge1xuICAgICAgYWxsS2V5c1tjdXJyZW50SW5kZXhdID0gY3VycmVudExvY2F0aW9uLmtleTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcihjdXJyZW50TG9jYXRpb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBiZWZvcmVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJlZm9yZUxpc3RlbmVycyA9IGJlZm9yZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKGJlZm9yZUxpc3RlbmVycy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgKDAsIF9ydW5UcmFuc2l0aW9uSG9vazIuZGVmYXVsdCkoYmVmb3JlTGlzdGVuZXJzW2luZGV4XSwgbG9jYXRpb24sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gZG9uZShyZXN1bHQpIDogbmV4dCgpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChnZXRVc2VyQ29uZmlybWF0aW9uICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChjdXJyZW50TG9jYXRpb24gJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShjdXJyZW50TG9jYXRpb24sIG5leHRMb2NhdGlvbikgfHwgcGVuZGluZ0xvY2F0aW9uICYmICgwLCBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbCkocGVuZGluZ0xvY2F0aW9uLCBuZXh0TG9jYXRpb24pKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cblxuICAgIHBlbmRpbmdMb2NhdGlvbiA9IG5leHRMb2NhdGlvbjtcblxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG8obmV4dExvY2F0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChwZW5kaW5nTG9jYXRpb24gIT09IG5leHRMb2NhdGlvbikgcmV0dXJuOyAvLyBUcmFuc2l0aW9uIHdhcyBpbnRlcnJ1cHRlZCBkdXJpbmcgY29uZmlybWF0aW9uXG5cbiAgICAgIHBlbmRpbmdMb2NhdGlvbiA9IG51bGw7XG5cbiAgICAgIGlmIChvaykge1xuICAgICAgICAvLyBUcmVhdCBQVVNIIHRvIHNhbWUgcGF0aCBsaWtlIFJFUExBQ0UgdG8gYmUgY29uc2lzdGVudCB3aXRoIGJyb3dzZXJzXG4gICAgICAgIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoY3VycmVudExvY2F0aW9uKTtcbiAgICAgICAgICB2YXIgbmV4dFBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShuZXh0TG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKG5leHRQYXRoID09PSBwcmV2UGF0aCAmJiAoMCwgX0xvY2F0aW9uVXRpbHMuc3RhdGVzQXJlRXF1YWwpKGN1cnJlbnRMb2NhdGlvbi5zdGF0ZSwgbmV4dExvY2F0aW9uLnN0YXRlKSkgbmV4dExvY2F0aW9uLmFjdGlvbiA9IF9BY3Rpb25zLlJFUExBQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgICAgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICAgICAgaWYgKHB1c2hMb2NhdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5SRVBMQUNFKSB7XG4gICAgICAgICAgaWYgKHJlcGxhY2VMb2NhdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoY3VycmVudExvY2F0aW9uLmtleSk7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobmV4dExvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEgJiYgbmV4dEluZGV4ICE9PSAtMSkgZ28ocHJldkluZGV4IC0gbmV4dEluZGV4KTsgLy8gUmVzdG9yZSB0aGUgVVJMXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGlucHV0KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihpbnB1dCwgX0FjdGlvbnMuUFVTSCkpO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShpbnB1dCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24oaW5wdXQsIF9BY3Rpb25zLlJFUExBQ0UpKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCB8fCA2KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBhY3Rpb24pIHtcbiAgICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gY3JlYXRlS2V5KCkgOiBhcmd1bWVudHNbMl07XG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikobG9jYXRpb24sIGFjdGlvbiwga2V5KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHRyYW5zaXRpb25UbzogdHJhbnNpdGlvblRvLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY3JlYXRlS2V5OiBjcmVhdGVLZXksXG4gICAgY3JlYXRlUGF0aDogX1BhdGhVdGlscy5jcmVhdGVQYXRoLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uXG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcnVuVHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGhvb2sobG9jYXRpb24sIGNhbGxiYWNrKTtcblxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XG4gICAgLy8gQXNzdW1lIHRoZSBob29rIHJ1bnMgc3luY2hyb25vdXNseSBhbmQgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHJldHVybiB2YWx1ZS5cbiAgICBjYWxsYmFjayhyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHJlc3VsdCA9PT0gdW5kZWZpbmVkLCAnWW91IHNob3VsZCBub3QgXCJyZXR1cm5cIiBpbiBhIHRyYW5zaXRpb24gaG9vayB3aXRoIGEgY2FsbGJhY2sgYXJndW1lbnQ7ICcgKyAnY2FsbCB0aGUgY2FsbGJhY2sgaW5zdGVhZCcpIDogdm9pZCAwO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBydW5UcmFuc2l0aW9uSG9vaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG52YXIgb2JqZWN0VHlwZXMgPSB7XG4gICdmdW5jdGlvbic6IHRydWUsXG4gICdvYmplY3QnOiB0cnVlXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKVxuICA/IGV4cG9ydHNcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKVxuICA/IG1vZHVsZVxuICA6IHVuZGVmaW5lZDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgd2luZG93YC4gKi9cbnZhciBmcmVlV2luZG93ID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcblxuLyoqIERldGVjdCBgdGhpc2AgYXMgdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgdGhpc0dsb2JhbCA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB0aGlzXSAmJiB0aGlzKTtcblxuLyoqXG4gKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICpcbiAqIFRoZSBgdGhpc2AgdmFsdWUgaXMgdXNlZCBpZiBpdCdzIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGF2b2lkIEdyZWFzZW1vbmtleSdzXG4gKiByZXN0cmljdGVkIGB3aW5kb3dgIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBgd2luZG93YCBvYmplY3QgaXMgdXNlZC5cbiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8XG4gICgoZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fFxuICAgIGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGdsb2JhbCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIGB2YWx1ZWAgaWYgaXQncyBhIGdsb2JhbCBvYmplY3QsIGVsc2UgYG51bGxgLlxuICovXG5mdW5jdGlvbiBjaGVja0dsb2JhbCh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLk9iamVjdCA9PT0gT2JqZWN0KSA/IHZhbHVlIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fcm9vdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbnZhciB2ZW5kb3IgPSBwcm90by5tYXRjaGVzXG4gIHx8IHByb3RvLm1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm9NYXRjaGVzU2VsZWN0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2g7XG5cbi8qKlxuICogTWF0Y2ggYGVsYCB0byBgc2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goZWwsIHNlbGVjdG9yKSB7XG4gIGlmICh2ZW5kb3IpIHJldHVybiB2ZW5kb3IuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB2YXIgbm9kZXMgPSBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldID09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21hdGNoZXMtc2VsZWN0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgZWxtKSB7XG4gIHZhciBrZXkgPSBkYXRhID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBkYXRhLmtleTtcbiAgcmV0dXJuIHtzZWw6IHNlbCwgZGF0YTogZGF0YSwgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgIHRleHQ6IHRleHQsIGVsbTogZWxtLCBrZXk6IGtleX07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL3Zub2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge0RPTUNvbnRlbnQsIElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIFZOb2RlLCBFdmVudFNlbGVjdG9yfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCB7QW5pbWF0aW9uLCBEaXJlY3Rpb259IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHtoLCBkaXZ9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCJtb2R1bGVzL3RyYW5zaXRpb25cIjtcbmltcG9ydCB7cGF0Y2hDbGFzc0xpc3QsIGFkZEVsZW1lbnR9IGZyb20gXCJ1dGlsc1wiO1xuO1xuXG5leHBvcnQgbmFtZXNwYWNlIERpbW1lciB7XG4gIC8qKlxuICAgKiBBIGRpbW1lciB3cmFwcGVyIHRvIHNob3cgZXh0cmEgaGlkZGVuIGNvbnRlbnQgb24gYW4gZWxlbWVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgdGFyZ2V0OlxuICAgKiAgIFZOb2RlIC0gVGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBkaW1tZXIgdG8uXG4gICAqICAgXCJQYWdlXCIgLSBDcmVhdGVzIGEgZGltbWVyIGZvciB0aGUgZW50aXJlIHBhZ2UuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGFyZ3M6IEJvb2xlYW5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKiBAcGFyYW0gIHtDb21wb25lbnRTb3VyY2VzfSBzb3VyY2VzIFRoZSBDb21wb25lbnQncyBzb3VyY2VzLlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnRTaW5rc30gVGhlIERpbW1lciBDb21wb25lbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlczxTdHJpbmd8Vk5vZGUsIGJvb2xlYW4sIERPTUNvbnRlbnQ+LCBpbnZlcnQkID0geHMub2YoZmFsc2UpKVxuICAgIDogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFN0cmluZ3xWTm9kZSwgYm9vbGVhbiwgRE9NQ29udGVudD4pIHtcbiAgICAgIGNvbnN0IGV2dCA9ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuZGltbWFibGVcIikuZXZlbnRzKHR5cGUpO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLmFyZ3MkID0gc291cmNlcy5hcmdzJCA/IHNvdXJjZXMuYXJncyQgOiBvbkhvdmVyKGV2dCk7XG5cbiAgICAgIGNvbnN0IHRhcmdldCQgPSBzb3VyY2VzLnRhcmdldCQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IGFjdGl2ZSQgPSBzb3VyY2VzLmFyZ3MkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uJCA9IGFjdGl2ZSRcbiAgICAgICAgLmZvbGQoKHByZXZBbmltLCBhY3RpdmUpID0+IHByZXZBbmltLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5vbmVcbiAgICAgICAgICA/ICh7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogYWN0aXZlID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dH0pXG4gICAgICAgICAgOiB7IGFuaW1hdGlvbjogQW5pbWF0aW9uLkZhZGUsIGRpcmVjdGlvbjogYWN0aXZlID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dFxuICAgICAgICAgIH1cbiAgICAgICAgLCAoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IERpcmVjdGlvbi5Ob25lIH0pKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQkID0geHMuY29tYmluZShzb3VyY2VzLmNvbnRlbnQkLCB0YXJnZXQkLCBpbnZlcnQkKVxuICAgICAgICAubWFwKChbY29udGVudCwgdGFyZ2V0LCBpbnZlcnRlZF0pID0+IHJlbmRlcihjb250ZW50LCB0YXJnZXQsIGludmVydGVkKSk7XG4gICAgICBjb25zdCBhbmltYXRlZENvbnRlbnQgPSBUcmFuc2l0aW9uLnJ1bih7RE9NOiBzb3VyY2VzLkRPTSwgYXJncyQ6IHRyYW5zaXRpb24kLCB0YXJnZXQkOiBjb250ZW50JH0pO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHRhcmdldCQsIGFuaW1hdGVkQ29udGVudC5ET00sIGFjdGl2ZSQpXG4gICAgICAgIC5tYXAoKFt0YXJnZXQsIGNvbnRlbnQsIGFjdGl2ZV0pID0+IGRpbUVsZW1lbnQodGFyZ2V0LCBjb250ZW50LCBhY3RpdmUpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6IGFuaW1hdGVkQ29udGVudC5FdmVudHMsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKGNvbnRlbnQ6IERPTUNvbnRlbnQgPSBcIlwiLCB0YXJnZXQ6IFN0cmluZ3xWTm9kZSA9IFwicGFnZVwiLCBpbnZlcnRlZCA9IGZhbHNlKSA6IFZOb2RlIHtcbiAgICByZXR1cm4gdGFyZ2V0ID09PSBcInBhZ2VcIlxuICAgICAgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidWkgXCIgKyAoaW52ZXJ0ZWQgPyBcImludmVydGVkIFwiIDogXCJcIikgKyAgXCJkaW1tZXIgbW9kYWxzIHBhZ2UgZGltbWVyXCJ9fSwgY29udGVudClcbiAgICAgIDogZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInVpIFwiICsgKGludmVydGVkID8gXCJpbnZlcnRlZCBcIiA6IFwiXCIpICsgXCJ0YXJnZXR0ZWQgZGltbWVyXCJ9fSwgW1xuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCJ9fSwgW1xuICAgICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImNlbnRlclwifX0sIFxuICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgXSlcbiAgICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ib3ZlcihldmVudHM6IEV2ZW50U2VsZWN0b3IpIHtcbiAgICByZXR1cm4geHMubWVyZ2UoZXZlbnRzKFwibW91c2VlbnRlclwiKSwgZXZlbnRzKFwibW91c2VsZWF2ZVwiKSlcbiAgICAgIC5tYXAoZXZ0ID0+IChldnQgYXMgTW91c2VFdmVudCkudHlwZSA9PT0gXCJtb3VzZWVudGVyXCIpLnN0YXJ0V2l0aChmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGltRWxlbWVudCh0YXJnZXRPclN0cmluZzogVk5vZGUgfCBzdHJpbmcsIGNvbnRlbnQ6IFZOb2RlLCBhY3RpdmU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBpc1BhZ2UgPSB0eXBlb2YodGFyZ2V0T3JTdHJpbmcpID09PSBcInN0cmluZ1wiO1xuICAgIGxldCB0YXJnZXQgPSBpc1BhZ2UgPyBjb250ZW50IDogdGFyZ2V0T3JTdHJpbmcgYXMgVk5vZGU7XG4gICAgbGV0IGNsYXNzTmFtZSA9IGlzUGFnZSA/IFwiXCIgOiBcImRpbW1hYmxlXCIsIGM7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IGlzUGFnZSA/IFwiYWN0aXZlXCI6IFwiIGRpbW1lZFwiO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gcGF0Y2hDbGFzc0xpc3QodGFyZ2V0LCBbXCJkaW1tYWJsZVwiLCBcImRpbW1lZFwiLCBcImludmVydGVkXCIsIFwiYWN0aXZlXCJdLCBjbGFzc05hbWUpO1xuICAgIGlmIChpc1BhZ2UpIHtcbiAgICAgIGlmICh0YXJnZXQuY2hpbGRyZW4pIHtcbiAgICAgICAgYyA9IHRhcmdldC5jaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRhcmdldC50ZXh0KSB7XG4gICAgICAgIGMgPSB0YXJnZXQudGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjID0gYWRkRWxlbWVudChjb250ZW50LCB0YXJnZXQsIFwidGFyZ2V0dGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaCh0YXJnZXQuc2VsLCBkYXRhLCBjKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvZGltbWVyL2luZGV4LnRzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTY29wZUNoZWNrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjb3BlQ2hlY2tlcihzY29wZSwgaXNvbGF0ZU1vZHVsZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuaXNvbGF0ZU1vZHVsZSA9IGlzb2xhdGVNb2R1bGU7XG4gICAgfVxuICAgIFNjb3BlQ2hlY2tlci5wcm90b3R5cGUuaXNTdHJpY3RseUluUm9vdFNjb3BlID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgZm9yICh2YXIgZWwgPSBsZWFmOyBlbDsgZWwgPSBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmlzb2xhdGVNb2R1bGUuaXNJc29sYXRlZEVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgaWYgKHNjb3BlICYmIHNjb3BlICE9PSB0aGlzLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gU2NvcGVDaGVja2VyO1xufSgpKTtcbmV4cG9ydHMuU2NvcGVDaGVja2VyID0gU2NvcGVDaGVja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NvcGVDaGVja2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9TY29wZUNoZWNrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbmZ1bmN0aW9uIGNyZWF0ZVZUcmVlKHZub2RlLCBjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlbDogdm5vZGUuc2VsLFxuICAgICAgICBkYXRhOiB2bm9kZS5kYXRhLFxuICAgICAgICB0ZXh0OiB2bm9kZS50ZXh0LFxuICAgICAgICBlbG06IHZub2RlLmVsbSxcbiAgICAgICAga2V5OiB2bm9kZS5rZXksXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFrZVRyYW5zcG9zZVZOb2RlKHJ1blN0cmVhbUFkYXB0ZXIpIHtcbiAgICBmdW5jdGlvbiBpbnRlcm5hbFRyYW5zcG9zZVZOb2RlKHZub2RlKSB7XG4gICAgICAgIGlmICghdm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZub2RlICYmIHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5zdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdC5vZih2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuU3RyZWFtQWRhcHRlci5pc1ZhbGlkU3RyZWFtKHZub2RlKSkge1xuICAgICAgICAgICAgdmFyIHhzU3RyZWFtID0geHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5hZGFwdCh2bm9kZSwgcnVuU3RyZWFtQWRhcHRlci5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICAgICAgcmV0dXJuIHhzU3RyZWFtLm1hcChpbnRlcm5hbFRyYW5zcG9zZVZOb2RlKS5mbGF0dGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZub2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoIXZub2RlLmNoaWxkcmVuIHx8IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdC5vZih2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdm5vZGVDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgLm1hcChpbnRlcm5hbFRyYW5zcG9zZVZOb2RlKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IG51bGw7IH0pO1xuICAgICAgICAgICAgaWYgKHZub2RlQ2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhzdHJlYW1fMS5kZWZhdWx0Lm9mKGNyZWF0ZVZUcmVlKHZub2RlLCBbXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhzdHJlYW1fMS5kZWZhdWx0LmNvbWJpbmUuYXBwbHkoeHN0cmVhbV8xLmRlZmF1bHQsIHZub2RlQ2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNoaWxkcmVuKSB7IHJldHVybiBjcmVhdGVWVHJlZSh2bm9kZSwgY2hpbGRyZW4uc2xpY2UoKSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5oYW5kbGVkIHZUcmVlIFZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHJhbnNwb3NlVk5vZGUodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFsVHJhbnNwb3NlVk5vZGUodm5vZGUpO1xuICAgIH07XG59XG5leHBvcnRzLm1ha2VUcmFuc3Bvc2VWTm9kZSA9IG1ha2VUcmFuc3Bvc2VWTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9zaXRpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL3RyYW5zcG9zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBIaXN0b3J5IGRyaXZlciBmYWN0b3J5XG4gKlxuICogVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoLCB3aGVuIGNhbGxlZCwgcmV0dXJucyBhIEhpc3RvcnkgRHJpdmVyIGZvciBDeWNsZS5qc1xuICogYXBwcy4gVGhlIGRyaXZlciBpcyBhbHNvIGEgZnVuY3Rpb24sIGFuZCBpdCB0YWtlcyBhIHN0cmVhbSBvZiBuZXcgbG9jYXRpb25zXG4gKiAoc3RyaW5ncyByZXByZXNlbnRpbmcgcGF0aG5hbWVzIG9yIGxvY2F0aW9uIG9iamVjdHMpIGFzIGlucHV0LCBhbmQgb3V0cHV0c1xuICogYW5vdGhlciBzdHJlYW0gb2YgbG9jYXRpb25zIHRoYXQgd2VyZSBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSB7SGlzdG9yeX0gaGlzdG9yeSB0aGUgSGlzdG9yeSBvYmplY3QgY3JlYXRlZCBieSB0aGUgaGlzdG9yeSBsaWJyYXJ5LlxuICogVGhpcyBvYmplY3QgaXMgdXN1YWxseSBjcmVhdGVkIHRocm91Z2ggYGNyZWF0ZUJyb3dzZXJIaXN0b3J5KClgIG9yXG4gKiBgY3JlYXRlSGFzaEhpc3RvcnkoKWAgb3IgYGNyZWF0ZU1lbW9yeUhpc3RvcnkoKWAgZnJvbSB0aGUgYGhpc3RvcnlgIGxpYnJhcnkuXG4gKiBBbHRlcm5hdGl2ZWx5LCB5b3UgbWF5IHVzZSBgY3JlYXRlU2VydmVySGlzdG9yeWAgZnJvbSB0aGlzIGxpYnJhcnkuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBhbiBvYmplY3Qgd2l0aCBzb21lIG9wdGlvbnMgc3BlY2lmaWMgdG8gdGhpcyBkcml2ZXIuXG4gKiBPcHRpb25zIG1heSBiZTogYGNhcHR1cmVgLCBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgZHJpdmVyIHNob3VsZFxuICogaW50ZXJjZXB0IGFuZCBoYW5kbGUgYW55IGNsaWNrIGV2ZW50IHRoYXQgbGVhZHMgdG8gYSBsaW5rLCBsaWtlIG9uIGFuIGA8YT5gXG4gKiBlbGVtZW50OyBgb25FcnJvcmAsIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlcnJvciBhcyBhcmd1bWVudCBhbmRcbiAqIGhhbmRsZXMgaXQsIHVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB3aGF0IHRvIGRvIHdpdGggZHJpdmVyIGVycm9ycy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgSGlzdG9yeSBEcml2ZXIgZnVuY3Rpb25cbiAqIEBmdW5jdGlvbiBtYWtlSGlzdG9yeURyaXZlclxuICovXG52YXIgbWFrZUhpc3RvcnlEcml2ZXJfMSA9IHJlcXVpcmUoJy4vbWFrZUhpc3RvcnlEcml2ZXInKTtcbmV4cG9ydHMubWFrZUhpc3RvcnlEcml2ZXIgPSBtYWtlSGlzdG9yeURyaXZlcl8xLm1ha2VIaXN0b3J5RHJpdmVyO1xuLyoqXG4gKiBDcmVhdGVzIGEgXCJTZXJ2ZXJIaXN0b3J5XCIgb2JqZWN0IHNpbWlsYXIgdG8gdGhlIEhpc3Rvcnkgb2JqZWN0cyB0aGF0IHRoZVxuICogYGhpc3RvcnlgIGxpYnJhcnkgY2FuIGNyZWF0ZS4gVXNlIHRoaXMgd2hlbiB5b3Ugd2FudCB0byBzdXBwb3J0IHNlcnZlci1zaWRlXG4gKiByZW5kZXJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBsb2NhdGlvbiB0aGlzIG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZVxuICogcGF0aG5hbWUsIG9yIGEgbG9jYXRpb24gb2JqZWN0IHdpdGggZmllbGRzIGxpa2UgYHBhdGhuYW1lYCwgYHNlYXJjaGAsXG4gKiBgcXVlcnlgLCBgc3RhdGVgLCBgYWN0aW9uYCwgYGtleWAsIGBoYXNoYCwgZXRjLlxuICogQHJldHVybiB7b2JqZWN0fSBhIEhpc3Rvcnkgb2JqZWN0LlxuICogQGZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhpc3RvcnlcbiAqL1xudmFyIHNlcnZlckhpc3RvcnlfMSA9IHJlcXVpcmUoJy4vc2VydmVySGlzdG9yeScpO1xuZXhwb3J0cy5jcmVhdGVTZXJ2ZXJIaXN0b3J5ID0gc2VydmVySGlzdG9yeV8xLmNyZWF0ZVNlcnZlckhpc3Rvcnk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XG5leHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IHV0aWxfMS5zdXBwb3J0c0hpc3Rvcnk7XG5leHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gdXRpbF8xLmNyZWF0ZUxvY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8XG4gICAgICAgIHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxuICAgICAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgICAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeTtcbnZhciBsb2NhdGlvbkRlZmF1bHRzID0ge1xuICAgIHBhdGhuYW1lOiAnLycsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBoYXNoOiAnJyxcbiAgICBzZWFyY2g6ICcnLFxuICAgIHN0YXRlOiB1bmRlZmluZWQsXG4gICAga2V5OiBudWxsLFxuICAgIHF1ZXJ5OiBudWxsLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdEFzc2lnbih7fSwgbG9jYXRpb25EZWZhdWx0cywgeyBwYXRobmFtZTogbG9jYXRpb24gfSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RBc3NpZ24oe30sIGxvY2F0aW9uRGVmYXVsdHMsIGxvY2F0aW9uKTtcbn1cbmV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIENyb3NzLUJyb3dzZXIgU3BsaXQgMS4xLjFcbiAqIENvcHlyaWdodCAyMDA3LTIwMTIgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBFQ01BU2NyaXB0IGNvbXBsaWFudCwgdW5pZm9ybSBjcm9zcy1icm93c2VyIHNwbGl0IG1ldGhvZFxuICovXG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhIHJlZ2V4IG9yIHN0cmluZyBzZXBhcmF0b3IuIE1hdGNoZXMgb2YgdGhlXG4gKiBzZXBhcmF0b3IgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LiBIb3dldmVyLCBpZiBgc2VwYXJhdG9yYCBpcyBhIHJlZ2V4IHRoYXQgY29udGFpbnNcbiAqIGNhcHR1cmluZyBncm91cHMsIGJhY2tyZWZlcmVuY2VzIGFyZSBzcGxpY2VkIGludG8gdGhlIHJlc3VsdCBlYWNoIHRpbWUgYHNlcGFyYXRvcmAgaXMgbWF0Y2hlZC5cbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHlcbiAqIGNyb3NzLWJyb3dzZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VwYXJhdG9yIFJlZ2V4IG9yIHN0cmluZyB0byB1c2UgZm9yIHNlcGFyYXRpbmcgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdCBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3Vic3RyaW5ncy5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNlXG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJyk7XG4gKiAvLyAtPiBbJ2EnLCAnYicsICdjJywgJ2QnXVxuICpcbiAqIC8vIFdpdGggbGltaXRcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnLCAyKTtcbiAqIC8vIC0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBCYWNrcmVmZXJlbmNlcyBpbiByZXN1bHQgYXJyYXlcbiAqIHNwbGl0KCcuLndvcmQxIHdvcmQyLi4nLCAvKFthLXpdKykoXFxkKykvaSk7XG4gKiAvLyAtPiBbJy4uJywgJ3dvcmQnLCAnMScsICcgJywgJ3dvcmQnLCAnMicsICcuLiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIHNwbGl0KHVuZGVmKSB7XG5cbiAgdmFyIG5hdGl2ZVNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdCxcbiAgICBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKFwiXCIpWzFdID09PSB1bmRlZixcbiAgICAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIHNlbGY7XG5cbiAgc2VsZiA9IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgYG5hdGl2ZVNwbGl0YFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gXCJbb2JqZWN0IFJlZ0V4cF1cIikge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyBcIm1cIiA6IFwiXCIpICsgKHNlcGFyYXRvci5leHRlbmRlZCA/IFwieFwiIDogXCJcIikgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAoc2VwYXJhdG9yLnN0aWNreSA/IFwieVwiIDogXCJcIiksXG4gICAgICAvLyBGaXJlZm94IDMrXG4gICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgXCJnXCIpLFxuICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICBzdHIgKz0gXCJcIjsgLy8gVHlwZS1jb252ZXJ0XG4gICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cChcIl5cIiArIHNlcGFyYXRvci5zb3VyY2UgKyBcIiQoPyFcXFxccylcIiwgZmxhZ3MpO1xuICAgIH1cbiAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICovXG4gICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWYgPyAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICBsaW1pdCA+Pj4gMDsgLy8gVG9VaW50MzIobGltaXQpXG4gICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyKSkge1xuICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHVuZGVmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KFwiXCIpKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3Nlci1zcGxpdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gSW5zcGlyZWQgYnkgR29vZ2xlIENsb3N1cmU6XG4vLyBodHRwOi8vY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL3N2bi9kb2NzL1xuLy8gY2xvc3VyZV9nb29nX2FycmF5X2FycmF5LmpzLmh0bWwjZ29vZy5hcnJheS5jbGVhclxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4uLy4uL29iamVjdC92YWxpZC12YWx1ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFsdWUodGhpcykubGVuZ3RoID0gMDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvYXJyYXkvIy9jbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgLCB4ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qY3VzdG9tQ3JlYXRlKi8pIHtcblx0dmFyIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mXG5cdCAgLCBjdXN0b21DcmVhdGUgPSBhcmd1bWVudHNbMF0gfHwgY3JlYXRlO1xuXHRpZiAodHlwZW9mIHNldFByb3RvdHlwZU9mICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBnZXRQcm90b3R5cGVPZihzZXRQcm90b3R5cGVPZihjdXN0b21DcmVhdGUobnVsbCksIHgpKSA9PT0geDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQmlnIHRoYW5rcyB0byBAV2ViUmVmbGVjdGlvbiBmb3Igc29ydGluZyB0aGlzIG91dFxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi81NTkzNTU0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuLi9pcy1vYmplY3QnKVxuICAsIHZhbHVlICAgICAgICAgPSByZXF1aXJlKCcuLi92YWxpZC12YWx1ZScpXG5cbiAgLCBpc1Byb3RvdHlwZU9mID0gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBudWxsRGVzYyA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsXG5cdFx0dmFsdWU6IHVuZGVmaW5lZCB9XG4gICwgdmFsaWRhdGU7XG5cbnZhbGlkYXRlID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdHZhbHVlKG9iaik7XG5cdGlmICgocHJvdG90eXBlID09PSBudWxsKSB8fCBpc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4gb2JqO1xuXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm90b3R5cGUgbXVzdCBiZSBudWxsIG9yIGFuIG9iamVjdCcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKHN0YXR1cykge1xuXHR2YXIgZm4sIHNldDtcblx0aWYgKCFzdGF0dXMpIHJldHVybiBudWxsO1xuXHRpZiAoc3RhdHVzLmxldmVsID09PSAyKSB7XG5cdFx0aWYgKHN0YXR1cy5zZXQpIHtcblx0XHRcdHNldCA9IHN0YXR1cy5zZXQ7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHRzZXQuY2FsbCh2YWxpZGF0ZShvYmosIHByb3RvdHlwZSksIHByb3RvdHlwZSk7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSkuX19wcm90b19fID0gcHJvdG90eXBlO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm4gPSBmdW5jdGlvbiBzZWxmKG9iaiwgcHJvdG90eXBlKSB7XG5cdFx0XHR2YXIgaXNOdWxsQmFzZTtcblx0XHRcdHZhbGlkYXRlKG9iaiwgcHJvdG90eXBlKTtcblx0XHRcdGlzTnVsbEJhc2UgPSBpc1Byb3RvdHlwZU9mLmNhbGwoc2VsZi5udWxsUG9seWZpbGwsIG9iaik7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVsZXRlIHNlbGYubnVsbFBvbHlmaWxsLl9fcHJvdG9fXztcblx0XHRcdGlmIChwcm90b3R5cGUgPT09IG51bGwpIHByb3RvdHlwZSA9IHNlbGYubnVsbFBvbHlmaWxsO1xuXHRcdFx0b2JqLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdGlmIChpc051bGxCYXNlKSBkZWZpbmVQcm9wZXJ0eShzZWxmLm51bGxQb2x5ZmlsbCwgJ19fcHJvdG9fXycsIG51bGxEZXNjKTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbGV2ZWwnLCB7IGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IHN0YXR1cy5sZXZlbCB9KTtcbn0oKGZ1bmN0aW9uICgpIHtcblx0dmFyIHggPSBPYmplY3QuY3JlYXRlKG51bGwpLCB5ID0ge30sIHNldFxuXHQgICwgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpO1xuXG5cdGlmIChkZXNjKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHNldCA9IGRlc2Muc2V0OyAvLyBPcGVyYSBjcmFzaGVzIGF0IHRoaXMgcG9pbnRcblx0XHRcdHNldC5jYWxsKHgsIHkpO1xuXHRcdH0gY2F0Y2ggKGlnbm9yZSkgeyB9XG5cdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0geSkgcmV0dXJuIHsgc2V0OiBzZXQsIGxldmVsOiAyIH07XG5cdH1cblxuXHR4Ll9fcHJvdG9fXyA9IHk7XG5cdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkgPT09IHkpIHJldHVybiB7IGxldmVsOiAyIH07XG5cblx0eCA9IHt9O1xuXHR4Ll9fcHJvdG9fXyA9IHk7XG5cdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkgPT09IHkpIHJldHVybiB7IGxldmVsOiAxIH07XG5cblx0cmV0dXJuIGZhbHNlO1xufSgpKSkpO1xuXG5yZXF1aXJlKCcuLi9jcmVhdGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0l0ZXJhYmxlID0gcmVxdWlyZSgnLi9pcy1pdGVyYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzSXRlcmFibGUodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpID8gTWFwIDogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1tYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVhZFN0YXRlID0gZXhwb3J0cy5zYXZlU3RhdGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUXVvdGFFeGNlZWRlZEVycm9ycyA9IFsnUXVvdGFFeGNlZWRlZEVycm9yJywgJ1FVT1RBX0VYQ0VFREVEX0VSUiddOyAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuXG5cbnZhciBTZWN1cml0eUVycm9yID0gJ1NlY3VyaXR5RXJyb3InO1xudmFyIEtleVByZWZpeCA9ICdAQEhpc3RvcnkvJztcblxudmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIEtleVByZWZpeCArIGtleTtcbn07XG5cbnZhciBzYXZlU3RhdGUgPSBleHBvcnRzLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gIGlmICghd2luZG93LnNlc3Npb25TdG9yYWdlKSB7XG4gICAgLy8gU2Vzc2lvbiBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgb3IgaGlkZGVuLlxuICAgIC8vIHNlc3Npb25TdG9yYWdlIGlzIHVuZGVmaW5lZCBpbiBJbnRlcm5ldCBFeHBsb3JlciB3aGVuIHNlcnZlZCB2aWEgZmlsZSBwcm90b2NvbC5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZScpIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlID09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oY3JlYXRlS2V5KGtleSksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFF1b3RhRXhjZWVkZWRFcnJvcnMuaW5kZXhPZihlcnJvci5uYW1lKSA+PSAwICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFNhZmFyaSBcInByaXZhdGUgbW9kZVwiIHRocm93cyBRdW90YUV4Y2VlZGVkRXJyb3IuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiBTYWZhcmkgcHJpdmF0ZSBtb2RlJykgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxudmFyIHJlYWRTdGF0ZSA9IGV4cG9ydHMucmVhZFN0YXRlID0gZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICB2YXIganNvbiA9IHZvaWQgMDtcbiAgdHJ5IHtcbiAgICBqc29uID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byByZWFkIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmIChqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgaW52YWxpZCBKU09OLlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuOS4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fZ2V0bmF0aXZlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjIuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgcm9vdCA9IHJlcXVpcmUoJ2xvZGFzaC5fcm9vdCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ2BdL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnLFxuICAnYCc6ICcmIzk2Oydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIoY2hyKSB7XG4gIHJldHVybiBodG1sRXNjYXBlc1tjaHJdO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gU3ltYm9sID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCdzIG5vdCBvbmUuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICogZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIFN5bWJvbCA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIFwiJ1wiLCBhbmQgXCJcXGBcIiBpbiBgc3RyaW5nYCB0b1xuICogdGhlaXIgY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICogU2VlIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIElFIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0IG9mXG4gKiBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuIFNlZSBbIzU5XShodHRwczovL2h0bWw1c2VjLm9yZy8jNTkpLFxuICogWyMxMDJdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDIpLCBbIzEwOF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwOCksIGFuZFxuICogWyMxMzNdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMzMpIG9mIHRoZSBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZylcbiAqIHRvIHJlZHVjZSBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLmVzY2FwZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlRm9yID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlZm9yJyksXG4gICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnbG9kYXNoLl9iaW5kY2FsbGJhY2snKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnbG9kYXNoLmtleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvck93bmAgb3IgYF8uZm9yT3duUmlnaHRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm9yT3duKG9iamVjdEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmcgYGl0ZXJhdGVlYFxuICogZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gbG9ncyAnYScgYW5kICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG52YXIgZm9yT3duID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvck93bjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guZm9yb3duL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guaXNhcmd1bWVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMC40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQXJyYXkgPSBnZXROYXRpdmUoQXJyYXksICdpc0FycmF5Jyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLmlzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gc2VsZWN0b3JQYXJzZXI7XG5cbnZhciBfYnJvd3NlclNwbGl0ID0gcmVxdWlyZSgnYnJvd3Nlci1zcGxpdCcpO1xuXG52YXIgX2Jyb3dzZXJTcGxpdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icm93c2VyU3BsaXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2xhc3NJZFNwbGl0ID0gLyhbXFwuI10/W2EtekEtWjAtOVxcdTAwN0YtXFx1RkZGRl86LV0rKS87XG52YXIgbm90Q2xhc3NJZCA9IC9eXFwufCMvO1xuXG5mdW5jdGlvbiBzZWxlY3RvclBhcnNlcigpIHtcbiAgdmFyIHNlbGVjdG9yID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcmd1bWVudHNbMF07XG5cbiAgdmFyIHRhZ05hbWUgPSB2b2lkIDA7XG4gIHZhciBpZCA9ICcnO1xuICB2YXIgY2xhc3NlcyA9IFtdO1xuXG4gIHZhciB0YWdQYXJ0cyA9ICgwLCBfYnJvd3NlclNwbGl0Mi5kZWZhdWx0KShzZWxlY3RvciwgY2xhc3NJZFNwbGl0KTtcblxuICBpZiAobm90Q2xhc3NJZC50ZXN0KHRhZ1BhcnRzWzFdKSB8fCBzZWxlY3RvciA9PT0gJycpIHtcbiAgICB0YWdOYW1lID0gJ2Rpdic7XG4gIH1cblxuICB2YXIgcGFydCA9IHZvaWQgMDtcbiAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gIHZhciBpID0gdm9pZCAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0YWdQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHBhcnQgPSB0YWdQYXJ0c1tpXTtcblxuICAgIGlmICghcGFydCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IHBhcnQuY2hhckF0KDApO1xuXG4gICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICB0YWdOYW1lID0gcGFydDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcuJykge1xuICAgICAgY2xhc3Nlcy5wdXNoKHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnIycpIHtcbiAgICAgIGlkID0gcGFydC5zdWJzdHJpbmcoMSwgcGFydC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICBpZDogaWQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oJyAnKVxuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS1zZWxlY3Rvci9saWIvc2VsZWN0b3JQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL01hdHQtRXNjaC92aXJ0dWFsLWRvbS9ibG9iL21hc3Rlci92aXJ0dWFsLWh5cGVyc2NyaXB0L3BhcnNlLXRhZy5qc1xuXG52YXIgc3BsaXQgPSByZXF1aXJlKCdicm93c2VyLXNwbGl0Jyk7XG5cbnZhciBjbGFzc0lkU3BsaXQgPSAvKFtcXC4jXT9bYS16QS1aMC05XFx1MDA3Ri1cXHVGRkZGXzotXSspLztcbnZhciBub3RDbGFzc0lkID0gL15cXC58Iy87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VTZWxlY3RvcihzZWxlY3RvciwgdXBwZXIpIHtcbiAgc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnJztcbiAgdmFyIHRhZ05hbWU7XG4gIHZhciBpZCA9ICcnO1xuICB2YXIgY2xhc3NlcyA9IFtdO1xuXG4gIHZhciB0YWdQYXJ0cyA9IHNwbGl0KHNlbGVjdG9yLCBjbGFzc0lkU3BsaXQpO1xuXG4gIGlmIChub3RDbGFzc0lkLnRlc3QodGFnUGFydHNbMV0pIHx8IHNlbGVjdG9yID09PSAnJykge1xuICAgIHRhZ05hbWUgPSAnZGl2JztcbiAgfVxuXG4gIHZhciBwYXJ0LCB0eXBlLCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0YWdQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHBhcnQgPSB0YWdQYXJ0c1tpXTtcblxuICAgIGlmICghcGFydCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IHBhcnQuY2hhckF0KDApO1xuXG4gICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICB0YWdOYW1lID0gcGFydDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcuJykge1xuICAgICAgY2xhc3Nlcy5wdXNoKHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnIycpIHtcbiAgICAgIGlkID0gcGFydC5zdWJzdHJpbmcoMSwgcGFydC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnTmFtZTogdXBwZXIgPT09IHRydWUgPyB0YWdOYW1lLnRvVXBwZXJDYXNlKCkgOiB0YWdOYW1lLFxuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMuam9pbignICcpXG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9wYXJzZS1zZWxlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0ICogZnJvbSBcIi4uL3NyY1wiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvdWkudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSVZhbHVlQ29tcG9uZW50U2lua3MgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgQ29sb3IsIFNpemUsIEF0dGFjaG1lbnQsIEZsb2F0IH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeyBudW1Ub1RleHQgfSBmcm9tIFwidXRpbHNcIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2LCBhIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1lbnUge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBzdWJtZW51PzogYm9vbGVhbjtcbiAgICBzZWNvbmRhcnk/OiBib29sZWFuO1xuICAgIHBvaW50aW5nPzogYm9vbGVhbjtcbiAgICB0YWJ1bGFyPzogYm9vbGVhbjtcbiAgICB0ZXh0PzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbD86IGJvb2xlYW47XG4gICAgcGFnaW5hdGlvbj86IGJvb2xlYW47XG4gICAgZml4ZWQ/OiBib29sZWFuO1xuICAgIHN0YWNrYWJsZT86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGxhYmVsbGVkPzogYm9vbGVhbjtcbiAgICBjb21wYWN0PzogYm9vbGVhbjtcbiAgICBldmVubHlEaXZpZGVkPzogYm9vbGVhbjtcbiAgICBib3JkZXJsZXNzPzogYm9vbGVhbjtcbiAgICBjb2xvcj86IENvbG9yO1xuICAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50O1xuICAgIHNpemU/OiBTaXplO1xuICB9XG4gIGV4cG9ydCB0eXBlIENvbnRlbnQgPSBBcnJheTxNZW51SXRlbT47XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVudUl0ZW0ge1xuICAgIGxpbms/OiBib29sZWFuO1xuICAgIGRvd24/OiBib29sZWFuO1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGhlYWRlcj86IGJvb2xlYW47XG4gICAgZml0dGVkPzogYm9vbGVhbjtcbiAgICBpY29uPzogYm9vbGVhbjtcbiAgICBjb2xvcj86IENvbG9yO1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gICAgaHJlZj86IHN0cmluZztcbiAgICBib2R5OiBET01Db250ZW50O1xuICB9XG4gIC8qKlxuICAgKiBBIG1lbnUgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGFuIGFzc29ydG1lbnQgb2YgaXRlbXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiBcdHNlY29uZGFyeT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gZGUtZW1waGFzaXplIGl0cyBjb250ZW50LlxuICAgKiBcdHBvaW50aW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBiZSBwb2ludGluZyB0byBuZWFyYnkgY29udGVudC5cbiAgICogXHR0YWJ1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBiZSBzdWl0ZWQgZm9yIHRhYnMuXG4gICAqIFx0dGV4dD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgZm9yIHRleHQgY29udGVudC5cbiAgICogXHR2ZXJ0aWNhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gZGlzcGxheSBpdHMgY29udGVudCB2ZXJ0aWNhbGx5LlxuICAgKiBcdHBhZ2luYXRpb24/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVudSBjb250ZW50IHRvIHByZXNlbnQgbGlua3MgdG8gcGFnZXMgb2YgY29udGVudC5cbiAgICogXHRmaXhlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gYXBwZWFyIGZpeGVkIHRvIGl0cyBjb250ZXh0LlxuICAgKiBcdHN0YWNrYWJsZT86IGJvb2xlYW4gLSBFbnN1cmVzIHRoZSBtZW51IGNvbnRlbnQgc3RhY2tzIG9uIG1vYmlsZSByZXNvbHV0aW9ucy5cbiAgICogXHRpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gaGF2ZSBpdHMgY29sb3JzIGludmVydGVkLlxuICAgKiBcdGljb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IGZvciBpY29uIGNvbnRlbnQuXG4gICAqIFx0bGFiZWxsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IGZvciBsYWJlbGxlZCBpY29uIGNvbnRlbnQuXG4gICAqIFx0Y29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCBpdCB0YWtlcyBvbmx5IHRoZSBhbW91bnQgb2Ygc3BhY2UgbmVjY2VzYXJ5LlxuICAgKiBcdGV2ZW5seURpdmlkZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHNvIHRoYXQgaXRzIGNvbnRlbnQgaXMgZXZlbmx5IGRpdmlkZWQuXG4gICAqIFx0Ym9yZGVybGVzcz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCB0aGVyZSBhcmUgbm8gYm9yZGVycyBiZXR3ZWVuIGl0cyBjb250ZW50LlxuICAgKiBcdGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIG1lbnUuXG4gICAqIFx0YXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBUaGUgYXR0YWNobWVudCBvZiB0aGUgbWVudS5cbiAgICogXHRzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBtZW51LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiBcdGxpbms/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGFwcGVhciBjbGlja2FibGUuXG4gICAqIFx0ZG93bj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYXBwZWFyIHByZXNzZWQuXG4gICAqIFx0YWN0aXZlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0byBiZSBtb3JlIHByb25vdW5jZWQuXG4gICAqIFx0ZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogXHRoZWFkZXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRleHQgdG8gYmUgbW9yZSBwcm9ub3VuY2VkLlxuICAgKiBcdGZpdHRlZD86IGJvb2xlYW4gLSBSZW1vdmVzIHRoZSBwYWRkaW5nIG9mIHRoZSBpdGVtLlxuICAgKiAgICAgICAgIGljb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIGZvciBpY29uIGNvbnRlbnQuXG4gICAqIFx0Y29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaXRlbS5cbiAgICogXHRmbG9hdD8gRmxvYXQgLSBUaGUgYWxpZ25tZW50IG9mIHRoZSBpdGVtLlxuICAgKiBcdGhyZWY/OiBzdHJpbmcgLSBUaGUgbGluayBmb3IgdGhlIGl0ZW0uXG4gICAqIFx0Ym9keTogRE9NQ29udGVudCAtIFRoZSBjb250ZW50IG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pik6IElWYWx1ZUNvbXBvbmVudFNpbmtzPENvbnRlbnQ+IHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG5cbiAgICAgIGNvbnN0IGNsaWNrJCA9IHNvdXJjZXMuRE9NLnNlbGVjdChcIi51aS5tZW51ID4gLml0ZW1cIikuZXZlbnRzKFwiY2xpY2tcIik7XG4gICAgICBjb25zdCBpdGVtcyQgPSBzb3VyY2VzLmNvbnRlbnQkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCBjbGlja2VkSWQkID0gY2xpY2skLm1hcChldiA9PiBwYXJzZUludCgoZXYgYXMgYW55KS5jdXJyZW50VGFyZ2V0LmlkKSlcbiAgICAgICAgLmZpbHRlcihuID0+ICFpc05hTihuKSAmJiB0eXBlb2YgKG4pICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICAgIGNvbnN0IGNsaWNrZWRJdGVtJCA9IGl0ZW1zJC5tYXAoaXRlbXMgPT4gY2xpY2tlZElkJC5tYXAoaWQgPT4gaXRlbXNbaWRdKSkuZmxhdHRlbigpXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiAhaXRlbS5kaXNhYmxlZCk7XG5cbiAgICAgIGNvbnN0IHZ0cmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIGl0ZW1zJCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdnRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIubWVudVwiKS5ldmVudHModHlwZSksXG4gICAgICAgIHZhbHVlJDogY2xpY2tlZEl0ZW0kXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBtZW51IGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBhbiBhc3NvcnRtZW50IG9mIGl0ZW1zLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogXHRzZWNvbmRhcnk/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGRlLWVtcGhhc2l6ZSBpdHMgY29udGVudC5cbiAgICogXHRwb2ludGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gYmUgcG9pbnRpbmcgdG8gbmVhcmJ5IGNvbnRlbnQuXG4gICAqIFx0dGFidWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gYmUgc3VpdGVkIGZvciB0YWJzLlxuICAgKiBcdHRleHQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IGZvciB0ZXh0IGNvbnRlbnQuXG4gICAqIFx0dmVydGljYWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGRpc3BsYXkgaXRzIGNvbnRlbnQgdmVydGljYWxseS5cbiAgICogXHRwYWdpbmF0aW9uPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIG1lbnUgY29udGVudCB0byBwcmVzZW50IGxpbmtzIHRvIHBhZ2VzIG9mIGNvbnRlbnQuXG4gICAqIFx0Zml4ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGFwcGVhciBmaXhlZCB0byBpdHMgY29udGV4dC5cbiAgICogXHRzdGFja2FibGU/OiBib29sZWFuIC0gRW5zdXJlcyB0aGUgbWVudSBjb250ZW50IHN0YWNrcyBvbiBtb2JpbGUgcmVzb2x1dGlvbnMuXG4gICAqIFx0aW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGhhdmUgaXRzIGNvbG9ycyBpbnZlcnRlZC5cbiAgICogXHRpY29uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBmb3IgaWNvbiBjb250ZW50LlxuICAgKiBcdGxhYmVsbGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBmb3IgbGFiZWxsZWQgaWNvbiBjb250ZW50LlxuICAgKiBcdGNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHNvIHRoYXQgaXQgdGFrZXMgb25seSB0aGUgYW1vdW50IG9mIHNwYWNlIG5lY2Nlc2FyeS5cbiAgICogXHRldmVubHlEaXZpZGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBzbyB0aGF0IGl0cyBjb250ZW50IGlzIGV2ZW5seSBkaXZpZGVkLlxuICAgKiBcdGJvcmRlcmxlc3M/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHNvIHRoYXQgdGhlcmUgYXJlIG5vIGJvcmRlcnMgYmV0d2VlbiBpdHMgY29udGVudC5cbiAgICogXHRjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBtZW51LlxuICAgKiBcdGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gVGhlIGF0dGFjaG1lbnQgb2YgdGhlIG1lbnUuXG4gICAqIFx0c2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgbWVudS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogQXJyYXkgb2Yge31cbiAgICogXHRsaW5rPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0byBhcHBlYXIgY2xpY2thYmxlLlxuICAgKiBcdGRvd24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGFwcGVhciBwcmVzc2VkLlxuICAgKiBcdGFjdGl2ZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYmUgbW9yZSBwcm9ub3VuY2VkLlxuICAgKiBcdGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqIFx0aGVhZGVyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0ZXh0IHRvIGJlIG1vcmUgcHJvbm91bmNlZC5cbiAgICogXHRmaXR0ZWQ/OiBib29sZWFuIC0gUmVtb3ZlcyB0aGUgcGFkZGluZyBvZiB0aGUgaXRlbS5cbiAgICogIGljb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIGZvciBpY29uIGNvbnRlbnQuXG4gICAqIFx0Y29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaXRlbS5cbiAgICogXHRmbG9hdD8gRmxvYXQgLSBUaGUgYWxpZ25tZW50IG9mIHRoZSBpdGVtLlxuICAgKiBcdGhyZWY/OiBzdHJpbmcgLSBUaGUgbGluayBmb3IgdGhlIGl0ZW0uXG4gICAqIFx0Ym9keTogRE9NQ29udGVudCAtIFRoZSBjb250ZW50IG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IENvbnRlbnQgPSB7fSwgYzogQ29udGVudCA9IFtdKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IChwT3JDIGluc3RhbmNlb2YgQXJyYXkpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gKHBPckMgaW5zdGFuY2VvZiBBcnJheSkgPyBwT3JDIDogYztcbiAgICBsZXQgaXRlbXMgPSBjb250ZW50Lm1hcChpdGVtID0+IGl0ZW0uaHJlZlxuICAgICAgPyBhKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRJdGVtQ2xhc3NuYW1lKGl0ZW0pLCBpZDogY29udGVudC5pbmRleE9mKGl0ZW0pLCBocmVmOiBpdGVtLmhyZWYgfSB9LCBpdGVtLmJvZHkpXG4gICAgICA6IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0SXRlbUNsYXNzbmFtZShpdGVtKSwgaWQ6IGNvbnRlbnQuaW5kZXhPZihpdGVtKSB9IH0sIGl0ZW0uYm9keSlcbiAgICApO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcywgY29udGVudC5sZW5ndGgpIH0gfSwgaXRlbXMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMsIGxlbmd0aDogbnVtYmVyKSB7XG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBpZiAoIXByb3BzLnN1Ym1lbnUpIHtcbiAgICAgIGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNlY29uZGFyeSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNlY29uZGFyeVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucG9pbnRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwb2ludGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGFidWxhcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRhYnVsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRleHQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB0ZXh0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ0aWNhbCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnRpY2FsXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wYWdpbmF0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcGFnaW5hdGlvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZml4ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmaXhlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc3RhY2thYmxlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3RhY2thYmxlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pY29uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaWNvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubGFiZWxsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsYWJlbGxlZCBpY29uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wYWN0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGFjdFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYm9yZGVybGVzcykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJvcmRlcmxlc3NcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmV2ZW5seURpdmlkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQobGVuZ3RoKSArIFwiIGl0ZW1cIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hdHRhY2htZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIG1lbnVcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG4gIGZ1bmN0aW9uIGdldEl0ZW1DbGFzc25hbWUoaXRlbTogTWVudUl0ZW0pIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJcIjtcbiAgICBpZiAoaXRlbS5kb3duKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZG93blwiO1xuICAgIH1cbiAgICBpZiAoaXRlbS5hY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uaGVhZGVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaGVhZGVyXCI7XG4gICAgfVxuICAgIGlmIChpdGVtLmZpdHRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnRpY2FsbHkgZml0dGVkXCI7XG4gICAgfVxuICAgIGlmIChpdGVtLmxpbmspIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsaW5rXCI7XG4gICAgfVxuICAgIGlmIChpdGVtLmljb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpY29uXCI7XG4gICAgfVxuICAgIGlmIChpdGVtLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoaXRlbS5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShpdGVtLmZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoaXRlbS5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShpdGVtLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGl0ZW1cIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvbWVudS9pbmRleC50cyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcbnZhciBEZWJvdW5jZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZU9wZXJhdG9yKGR0LCBpbnMpIHtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy50eXBlID0gJ2RlYm91bmNlJztcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB9XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIERlYm91bmNlT3BlcmF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB9O1xuICAgIERlYm91bmNlT3BlcmF0b3IucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgdGhpcy5pZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIHUuX24odCk7XG4gICAgICAgIH0sIHRoaXMuZHQpO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIERlYm91bmNlT3BlcmF0b3IucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIERlbGF5cyBldmVudHMgdW50aWwgYSBjZXJ0YWluIGFtb3VudCBvZiBzaWxlbmNlIGhhcyBwYXNzZWQuIElmIHRoYXQgdGltZXNwYW5cbiAqIG9mIHNpbGVuY2UgaXMgbm90IG1ldCB0aGUgZXZlbnQgaXMgZHJvcHBlZC5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLS0tMi0tMy0tNC0tLS01fFxuICogICAgIGRlYm91bmNlKDYwKVxuICogLS0tLS0xLS0tLS0tLS0tLTQtLXxcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBmcm9tRGlhZ3JhbSBmcm9tICd4c3RyZWFtL2V4dHJhL2Zyb21EaWFncmFtJ1xuICogaW1wb3J0IGRlYm91bmNlIGZyb20gJ3hzdHJlYW0vZXh0cmEvZGVib3VuY2UnXG4gKlxuICogY29uc3Qgc3RyZWFtID0gZnJvbURpYWdyYW0oJy0tMS0tLS0yLS0zLS00LS0tLTV8JylcbiAqICAuY29tcG9zZShkZWJvdW5jZSg2MCkpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IDFcbiAqID4gNFxuICogPiBjb21wbGV0ZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2QgVGhlIGFtb3VudCBvZiBzaWxlbmNlIHJlcXVpcmVkIGluIG1pbGxpc2Vjb25kcy5cbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UocGVyaW9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlYm91bmNlT3BlcmF0b3IoaW5zKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5TdHJlYW0obmV3IERlYm91bmNlT3BlcmF0b3IocGVyaW9kLCBpbnMpKTtcbiAgICB9O1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVib3VuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHN0cmVhbS9leHRyYS9kZWJvdW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcbnZhciBEZWxheU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheU9wZXJhdG9yKGR0LCBpbnMpIHtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy50eXBlID0gJ2RlbGF5JztcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgIH1cbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIERlbGF5T3BlcmF0b3IucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1Ll9uKHQpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgIH0sIHRoaXMuZHQpO1xuICAgIH07XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdS5fZShlcnIpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgIH0sIHRoaXMuZHQpO1xuICAgIH07XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdS5fYygpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgIH0sIHRoaXMuZHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBEZWxheXMgcGVyaW9kaWMgZXZlbnRzIGJ5IGEgZ2l2ZW4gdGltZSBwZXJpb2QuXG4gKlxuICogTWFyYmxlIGRpYWdyYW06XG4gKlxuICogYGBgdGV4dFxuICogMS0tLS0yLS0zLS00LS0tLTV8XG4gKiAgICAgZGVsYXkoNjApXG4gKiAtLS0xLS0tLTItLTMtLTQtLS0tNXxcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBmcm9tRGlhZ3JhbSBmcm9tICd4c3RyZWFtL2V4dHJhL2Zyb21EaWFncmFtJ1xuICogaW1wb3J0IGRlbGF5IGZyb20gJ3hzdHJlYW0vZXh0cmEvZGVsYXknXG4gKlxuICogY29uc3Qgc3RyZWFtID0gZnJvbURpYWdyYW0oJzEtLS0tMi0tMy0tNC0tLS01fCcpXG4gKiAgLmNvbXBvc2UoZGVsYXkoNjApKVxuICpcbiAqIHN0cmVhbS5hZGRMaXN0ZW5lcih7XG4gKiAgIG5leHQ6IGkgPT4gY29uc29sZS5sb2coaSksXG4gKiAgIGVycm9yOiBlcnIgPT4gY29uc29sZS5lcnJvcihlcnIpLFxuICogICBjb21wbGV0ZTogKCkgPT4gY29uc29sZS5sb2coJ2NvbXBsZXRlZCcpXG4gKiB9KVxuICogYGBgXG4gKlxuICogYGBgdGV4dFxuICogPiAxICAoYWZ0ZXIgNjAgbXMpXG4gKiA+IDIgIChhZnRlciAxNjAgbXMpXG4gKiA+IDMgIChhZnRlciAyMjAgbXMpXG4gKiA+IDQgIChhZnRlciAyODAgbXMpXG4gKiA+IDUgIChhZnRlciAzODAgbXMpXG4gKiA+IGNvbXBsZXRlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZCBUaGUgYW1vdW50IG9mIHNpbGVuY2UgcmVxdWlyZWQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5mdW5jdGlvbiBkZWxheShwZXJpb2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlPcGVyYXRvcihpbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlN0cmVhbShuZXcgRGVsYXlPcGVyYXRvcihwZXJpb2QsIGlucykpO1xuICAgIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2V4dHJhL2RlbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIGVtcHR5ID0ge307XG52YXIgRHJvcFJlcGVhdHNPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcFJlcGVhdHNPcGVyYXRvcihpbnMsIGZuKSB7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMudHlwZSA9ICdkcm9wUmVwZWF0cyc7XG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52ID0gZW1wdHk7XG4gICAgfVxuICAgIERyb3BSZXBlYXRzT3BlcmF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBEcm9wUmVwZWF0c09wZXJhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnYgPSBlbXB0eTtcbiAgICB9O1xuICAgIERyb3BSZXBlYXRzT3BlcmF0b3IucHJvdG90eXBlLmlzRXEgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbiA/IHRoaXMuZm4oeCwgeSkgOiB4ID09PSB5O1xuICAgIH07XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB2ID0gdGhpcy52O1xuICAgICAgICBpZiAodiAhPT0gZW1wdHkgJiYgdGhpcy5pc0VxKHQsIHYpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnYgPSBBcnJheS5pc0FycmF5KHQpID8gdC5zbGljZSgpIDogdDtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIERyb3BSZXBlYXRzT3BlcmF0b3IucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIERyb3BSZXBlYXRzT3BlcmF0b3IucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBEcm9wUmVwZWF0c09wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuRHJvcFJlcGVhdHNPcGVyYXRvciA9IERyb3BSZXBlYXRzT3BlcmF0b3I7XG4vKipcbiAqIERyb3BzIGNvbnNlY3V0aXZlIGR1cGxpY2F0ZSB2YWx1ZXMgaW4gYSBzdHJlYW0uXG4gKlxuICogTWFyYmxlIGRpYWdyYW06XG4gKlxuICogYGBgdGV4dFxuICogLS0xLS0yLS0xLS0xLS0xLS0yLS0zLS00LS0zLS0zfFxuICogICAgIGRyb3BSZXBlYXRzXG4gKiAtLTEtLTItLTEtLS0tLS0tLTItLTMtLTQtLTMtLS18XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgZHJvcFJlcGVhdHMgZnJvbSAneHN0cmVhbS9leHRyYS9kcm9wUmVwZWF0cydcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSB4cy5vZigxLCAyLCAxLCAxLCAxLCAyLCAzLCA0LCAzLCAzKVxuICogICAuY29tcG9zZShkcm9wUmVwZWF0cygpKVxuICpcbiAqIHN0cmVhbS5hZGRMaXN0ZW5lcih7XG4gKiAgIG5leHQ6IGkgPT4gY29uc29sZS5sb2coaSksXG4gKiAgIGVycm9yOiBlcnIgPT4gY29uc29sZS5lcnJvcihlcnIpLFxuICogICBjb21wbGV0ZTogKCkgPT4gY29uc29sZS5sb2coJ2NvbXBsZXRlZCcpXG4gKiB9KVxuICogYGBgXG4gKlxuICogYGBgdGV4dFxuICogPiAxXG4gKiA+IDJcbiAqID4gMVxuICogPiAyXG4gKiA+IDNcbiAqID4gNFxuICogPiAzXG4gKiA+IGNvbXBsZXRlZFxuICogYGBgXG4gKlxuICogRXhhbXBsZSB3aXRoIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb246XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBkcm9wUmVwZWF0cyBmcm9tICd4c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzJ1xuICpcbiAqIGNvbnN0IHN0cmVhbSA9IHhzLm9mKCdhJywgJ2InLCAnYScsICdBJywgJ0InLCAnYicpXG4gKiAgIC5jb21wb3NlKGRyb3BSZXBlYXRzKCh4LCB5KSA9PiB4LnRvTG93ZXJDYXNlKCkgPT09IHkudG9Mb3dlckNhc2UoKSkpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IGFcbiAqID4gYlxuICogPiBhXG4gKiA+IEJcbiAqID4gY29tcGxldGVkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpc0VxdWFsIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIG9mIHR5cGVcbiAqIGAoeDogVCwgeTogVCkgPT4gYm9vbGVhbmAgdGhhdCB0YWtlcyBhbiBldmVudCBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gYW5kXG4gKiBjaGVja3MgaWYgaXQgaXMgZXF1YWwgdG8gcHJldmlvdXMgZXZlbnQsIGJ5IHJldHVybmluZyBhIGJvb2xlYW4uXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGRyb3BSZXBlYXRzKGlzRXF1YWwpIHtcbiAgICBpZiAoaXNFcXVhbCA9PT0gdm9pZCAwKSB7IGlzRXF1YWwgPSB2b2lkIDA7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gZHJvcFJlcGVhdHNPcGVyYXRvcihpbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlN0cmVhbShuZXcgRHJvcFJlcGVhdHNPcGVyYXRvcihpbnMsIGlzRXF1YWwpKTtcbiAgICB9O1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZHJvcFJlcGVhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcm9wUmVwZWF0cy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHN0cmVhbS9leHRyYS9kcm9wUmVwZWF0cy5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RvY3Mtc3JjL2RvY3MubGVzc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgcnVuIH0gZnJvbSBcIkBjeWNsZS94c3RyZWFtLXJ1blwiO1xuaW1wb3J0IHsgbWFrZURPTURyaXZlciB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeyBtYWtlUm91dGVyRHJpdmVyLCBzdXBwb3J0c0hpc3RvcnkgfSBmcm9tIFwiY3ljbGljLXJvdXRlclwiO1xuaW1wb3J0IHsgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZUhpc3RvcnkgfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgc3dpdGNoUGF0aCBmcm9tIFwic3dpdGNoLXBhdGhcIjtcblxuaW1wb3J0IFJvdXRlciBmcm9tIFwiLi9yb3V0ZXJcIjtcbmltcG9ydCByb3V0ZXMgZnJvbSBcIi4vcm91dGVzXCI7XG5pbXBvcnQge0xheW91dH0gZnJvbSBcIi4vbGF5b3V0XCI7XG5cbmNvbnN0IGhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKVxuICA/IFtjcmVhdGVIaXN0b3J5KCksIHN3aXRjaFBhdGgsIHtjYXB0dXJlOiB0cnVlfV1cbiAgOiBbY3JlYXRlSGFzaEhpc3RvcnkoKSwgc3dpdGNoUGF0aCwge2NhcHR1cmU6IHRydWV9XTtcblxuZnVuY3Rpb24gYXBwKGRyaXZlcnMpIHtcbiAgY29uc3QgcGFnZSA9IFJvdXRlcihPYmplY3QuYXNzaWduKHt9LCBkcml2ZXJzLCB7cm91dGVzfSkpO1xuICBjb25zdCBsYXlvdXQgPSBMYXlvdXQucnVuKGRyaXZlcnMsIHBhZ2UpO1xuICBjb25zdCBzaW5rcyA9IHtcbiAgICBET006IGxheW91dC5ET00sXG4gICAgcm91dGVyOiB4cy5tZXJnZShwYWdlLnJvdXRlciwgbGF5b3V0LnJvdXRlciksXG4gIH07XG4gIHJldHVybiBzaW5rcztcbn1cblxucnVuKGFwcCwge1xuICBET006IG1ha2VET01Ecml2ZXIoXCIuYXBwXCIpLFxuICByb3V0ZXI6IG1ha2VSb3V0ZXJEcml2ZXIuYXBwbHkobnVsbCwgaGlzdG9yeSksXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL2FwcC50cyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciBmcm9tRXZlbnRfMSA9IHJlcXVpcmUoJy4vZnJvbUV2ZW50Jyk7XG52YXIgQm9keURPTVNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm9keURPTVNvdXJjZShfcnVuU3RyZWFtQWRhcHRlciwgX25hbWUpIHtcbiAgICAgICAgdGhpcy5fcnVuU3RyZWFtQWRhcHRlciA9IF9ydW5TdHJlYW1BZGFwdGVyO1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgfVxuICAgIEJvZHlET01Tb3VyY2UucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgc3RpbGwgdW5kZWZpbmVkL3VuZGVjaWRlZC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBCb2R5RE9NU291cmNlLnByb3RvdHlwZS5lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJ1blNBID0gdGhpcy5fcnVuU3RyZWFtQWRhcHRlcjtcbiAgICAgICAgdmFyIG91dCA9IHJ1blNBLnJlbWVtYmVyKHJ1blNBLmFkYXB0KHhzdHJlYW1fMS5kZWZhdWx0Lm9mKGRvY3VtZW50LmJvZHkpLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSkpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQm9keURPTVNvdXJjZS5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgc3RyZWFtO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy51c2VDYXB0dXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IGZyb21FdmVudF8xLmZyb21FdmVudChkb2N1bWVudC5ib2R5LCBldmVudFR5cGUsIG9wdGlvbnMudXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBmcm9tRXZlbnRfMS5mcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgZXZlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gdGhpcy5fcnVuU3RyZWFtQWRhcHRlci5hZGFwdChzdHJlYW0sIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBCb2R5RE9NU291cmNlO1xufSgpKTtcbmV4cG9ydHMuQm9keURPTVNvdXJjZSA9IEJvZHlET01Tb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb2R5RE9NU291cmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9Cb2R5RE9NU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKCcuL2Zyb21FdmVudCcpO1xudmFyIERvY3VtZW50RE9NU291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2N1bWVudERPTVNvdXJjZShfcnVuU3RyZWFtQWRhcHRlciwgX25hbWUpIHtcbiAgICAgICAgdGhpcy5fcnVuU3RyZWFtQWRhcHRlciA9IF9ydW5TdHJlYW1BZGFwdGVyO1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgfVxuICAgIERvY3VtZW50RE9NU291cmNlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbmFsaXR5IGlzIHN0aWxsIHVuZGVmaW5lZC91bmRlY2lkZWQuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRG9jdW1lbnRET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnVuU0EgPSB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyO1xuICAgICAgICB2YXIgb3V0ID0gcnVuU0EucmVtZW1iZXIocnVuU0EuYWRhcHQoeHN0cmVhbV8xLmRlZmF1bHQub2YoZG9jdW1lbnQpLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSkpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgRG9jdW1lbnRET01Tb3VyY2UucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHN0cmVhbTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMudXNlQ2FwdHVyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBmcm9tRXZlbnRfMS5mcm9tRXZlbnQoZG9jdW1lbnQsIGV2ZW50VHlwZSwgb3B0aW9ucy51c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IGZyb21FdmVudF8xLmZyb21FdmVudChkb2N1bWVudCwgZXZlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gdGhpcy5fcnVuU3RyZWFtQWRhcHRlci5hZGFwdChzdHJlYW0sIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBEb2N1bWVudERPTVNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLkRvY3VtZW50RE9NU291cmNlID0gRG9jdW1lbnRET01Tb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb2N1bWVudERPTVNvdXJjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvRG9jdW1lbnRET01Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFNjb3BlQ2hlY2tlcl8xID0gcmVxdWlyZSgnLi9TY29wZUNoZWNrZXInKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG1hdGNoZXNTZWxlY3RvcjtcbnRyeSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yID0gcmVxdWlyZShcIm1hdGNoZXMtc2VsZWN0b3JcIik7XG59XG5jYXRjaCAoZSkge1xuICAgIG1hdGNoZXNTZWxlY3RvciA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIHRvRWxBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbnB1dCk7XG59XG52YXIgRWxlbWVudEZpbmRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudEZpbmRlcihuYW1lc3BhY2UsIGlzb2xhdGVNb2R1bGUpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuaXNvbGF0ZU1vZHVsZSA9IGlzb2xhdGVNb2R1bGU7XG4gICAgfVxuICAgIEVsZW1lbnRGaW5kZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAocm9vdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlO1xuICAgICAgICBpZiAobmFtZXNwYWNlLmpvaW4oXCJcIikgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByb290RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcGUgPSB1dGlsc18xLmdldFNjb3BlKG5hbWVzcGFjZSk7XG4gICAgICAgIHZhciBzY29wZUNoZWNrZXIgPSBuZXcgU2NvcGVDaGVja2VyXzEuU2NvcGVDaGVja2VyKHNjb3BlLCB0aGlzLmlzb2xhdGVNb2R1bGUpO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB1dGlsc18xLmdldFNlbGVjdG9ycyhuYW1lc3BhY2UpO1xuICAgICAgICB2YXIgdG9wTm9kZSA9IHJvb3RFbGVtZW50O1xuICAgICAgICB2YXIgdG9wTm9kZU1hdGNoZXMgPSBbXTtcbiAgICAgICAgaWYgKHNjb3BlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRvcE5vZGUgPSB0aGlzLmlzb2xhdGVNb2R1bGUuZ2V0SXNvbGF0ZWRFbGVtZW50KHNjb3BlKSB8fCByb290RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzZWxlY3RvciAmJiBtYXRjaGVzU2VsZWN0b3IodG9wTm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgdG9wTm9kZU1hdGNoZXMucHVzaCh0b3BOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9FbEFycmF5KHRvcE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG4gICAgICAgICAgICAuZmlsdGVyKHNjb3BlQ2hlY2tlci5pc1N0cmljdGx5SW5Sb290U2NvcGUsIHNjb3BlQ2hlY2tlcilcbiAgICAgICAgICAgIC5jb25jYXQodG9wTm9kZU1hdGNoZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRGaW5kZXI7XG59KCkpO1xuZXhwb3J0cy5FbGVtZW50RmluZGVyID0gRWxlbWVudEZpbmRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsZW1lbnRGaW5kZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL0VsZW1lbnRGaW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFNjb3BlQ2hlY2tlcl8xID0gcmVxdWlyZSgnLi9TY29wZUNoZWNrZXInKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG1hdGNoZXNTZWxlY3RvcjtcbnRyeSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yID0gcmVxdWlyZShcIm1hdGNoZXMtc2VsZWN0b3JcIik7XG59XG5jYXRjaCAoZSkge1xuICAgIG1hdGNoZXNTZWxlY3RvciA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbn1cbnZhciBnRGVzdGluYXRpb25JZCA9IDA7XG5mdW5jdGlvbiBmaW5kRGVzdGluYXRpb25JZChhcnIsIHNlYXJjaElkKSB7XG4gICAgdmFyIG1pbkluZGV4ID0gMDtcbiAgICB2YXIgbWF4SW5kZXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB2YXIgY3VycmVudEluZGV4O1xuICAgIHZhciBjdXJyZW50RWxlbWVudDtcbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICBjdXJyZW50RWxlbWVudCA9IGFycltjdXJyZW50SW5kZXhdO1xuICAgICAgICB2YXIgY3VycmVudElkID0gY3VycmVudEVsZW1lbnQuZGVzdGluYXRpb25JZDtcbiAgICAgICAgaWYgKGN1cnJlbnRJZCA8IHNlYXJjaElkKSB7XG4gICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudElkID4gc2VhcmNoSWQpIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBBdHRhY2hlcyBhbiBhY3R1YWwgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIERPTSByb290IGVsZW1lbnQsXG4gKiBoYW5kbGVzIFwiZGVzdGluYXRpb25zXCIgKGludGVyZXN0ZWQgRE9NU291cmNlIG91dHB1dCBzdWJqZWN0cyksIGFuZCBidWJibGluZy5cbiAqL1xudmFyIEV2ZW50RGVsZWdhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudERlbGVnYXRvcih0b3BFbGVtZW50LCBldmVudFR5cGUsIHVzZUNhcHR1cmUsIGlzb2xhdGVNb2R1bGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50b3BFbGVtZW50ID0gdG9wRWxlbWVudDtcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gICAgICAgIHRoaXMudXNlQ2FwdHVyZSA9IHVzZUNhcHR1cmU7XG4gICAgICAgIHRoaXMuaXNvbGF0ZU1vZHVsZSA9IGlzb2xhdGVNb2R1bGU7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25zID0gW107XG4gICAgICAgIHRoaXMucm9vZiA9IHRvcEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHVzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmNhcHR1cmUoZXYpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb21MaXN0ZW5lciA9IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMuYnViYmxlKGV2KTsgfTtcbiAgICAgICAgfVxuICAgICAgICB0b3BFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB0aGlzLmRvbUxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICB9XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIChyYXdFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudG9wRWxlbWVudC5jb250YWlucyhyYXdFdmVudC5jdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldiA9IHRoaXMucGF0Y2hFdmVudChyYXdFdmVudCk7XG4gICAgICAgIGZvciAodmFyIGVsID0gZXYudGFyZ2V0OyBlbCAmJiBlbCAhPT0gdGhpcy5yb29mOyBlbCA9IGVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50b3BFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2LnByb3BhZ2F0aW9uSGFzQmVlblN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hdGNoRXZlbnRBZ2FpbnN0RGVzdGluYXRpb25zKGVsLCBldik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5tYXRjaEV2ZW50QWdhaW5zdERlc3RpbmF0aW9ucyA9IGZ1bmN0aW9uIChlbCwgZXYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLmRlc3RpbmF0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gdGhpcy5kZXN0aW5hdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoIWRlc3Quc2NvcGVDaGVja2VyLmlzU3RyaWN0bHlJblJvb3RTY29wZShlbCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVzU2VsZWN0b3IoZWwsIGRlc3Quc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGVFdmVudEN1cnJlbnRUYXJnZXQoZXYsIGVsKTtcbiAgICAgICAgICAgICAgICBkZXN0LnN1YmplY3QuX24oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuZGVzdGluYXRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlc3QgPSB0aGlzLmRlc3RpbmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzU2VsZWN0b3IoZXYudGFyZ2V0LCBkZXN0LnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGRlc3Quc3ViamVjdC5fbihldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5hZGREZXN0aW5hdGlvbiA9IGZ1bmN0aW9uIChzdWJqZWN0LCBuYW1lc3BhY2UsIGRlc3RpbmF0aW9uSWQpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdXRpbHNfMS5nZXRTY29wZShuYW1lc3BhY2UpO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB1dGlsc18xLmdldFNlbGVjdG9ycyhuYW1lc3BhY2UpO1xuICAgICAgICB2YXIgc2NvcGVDaGVja2VyID0gbmV3IFNjb3BlQ2hlY2tlcl8xLlNjb3BlQ2hlY2tlcihzY29wZSwgdGhpcy5pc29sYXRlTW9kdWxlKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbnMucHVzaCh7IHN1YmplY3Q6IHN1YmplY3QsIHNjb3BlQ2hlY2tlcjogc2NvcGVDaGVja2VyLCBzZWxlY3Rvcjogc2VsZWN0b3IsIGRlc3RpbmF0aW9uSWQ6IGRlc3RpbmF0aW9uSWQgfSk7XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUuY3JlYXRlRGVzdGluYXRpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdEZXN0aW5hdGlvbklkKys7XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUucmVtb3ZlRGVzdGluYXRpb25JZCA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbklkKSB7XG4gICAgICAgIHZhciBpID0gZmluZERlc3RpbmF0aW9uSWQodGhpcy5kZXN0aW5hdGlvbnMsIGRlc3RpbmF0aW9uSWQpO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5wYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBwRXZlbnQgPSBldmVudDtcbiAgICAgICAgcEV2ZW50LnByb3BhZ2F0aW9uSGFzQmVlblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9sZFN0b3BQcm9wYWdhdGlvbiA9IHBFdmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgIHBFdmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICBvbGRTdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRpb25IYXNCZWVuU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwRXZlbnQ7XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUubXV0YXRlRXZlbnRDdXJyZW50VGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50LCBjdXJyZW50VGFyZ2V0RWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50VGFyZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsZWFzZSB1c2UgZXZlbnQub3duZXJUYXJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQub3duZXJUYXJnZXQgPSBjdXJyZW50VGFyZ2V0RWxlbWVudDtcbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS51cGRhdGVUb3BFbGVtZW50ID0gZnVuY3Rpb24gKG5ld1RvcEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy50b3BFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudFR5cGUsIHRoaXMuZG9tTGlzdGVuZXIsIHRoaXMudXNlQ2FwdHVyZSk7XG4gICAgICAgIG5ld1RvcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50VHlwZSwgdGhpcy5kb21MaXN0ZW5lciwgdGhpcy51c2VDYXB0dXJlKTtcbiAgICAgICAgdGhpcy50b3BFbGVtZW50ID0gbmV3VG9wRWxlbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudERlbGVnYXRvcjtcbn0oKSk7XG5leHBvcnRzLkV2ZW50RGVsZWdhdG9yID0gRXZlbnREZWxlZ2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudERlbGVnYXRvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvRXZlbnREZWxlZ2F0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciBIVE1MU291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIVE1MU291cmNlKGh0bWwkLCBydW5TQSwgX25hbWUpIHtcbiAgICAgICAgdGhpcy5ydW5TQSA9IHJ1blNBO1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgICAgIHRoaXMuX2h0bWwkID0gaHRtbCQ7XG4gICAgICAgIHRoaXMuX2VtcHR5JCA9IHJ1blNBLmFkYXB0KHhzdHJlYW1fMS5kZWZhdWx0LmVtcHR5KCksIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICB9XG4gICAgSFRNTFNvdXJjZS5wcm90b3R5cGUuZWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnJ1blNBLmFkYXB0KHRoaXMuX2h0bWwkLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBIVE1MU291cmNlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIVE1MU291cmNlKHhzdHJlYW1fMS5kZWZhdWx0LmVtcHR5KCksIHRoaXMucnVuU0EsIHRoaXMuX25hbWUpO1xuICAgIH07XG4gICAgSFRNTFNvdXJjZS5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5fZW1wdHkkO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIEhUTUxTb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5IVE1MU291cmNlID0gSFRNTFNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxTb3VyY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL0hUTUxTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIERvY3VtZW50RE9NU291cmNlXzEgPSByZXF1aXJlKCcuL0RvY3VtZW50RE9NU291cmNlJyk7XG52YXIgQm9keURPTVNvdXJjZV8xID0gcmVxdWlyZSgnLi9Cb2R5RE9NU291cmNlJyk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xudmFyIEVsZW1lbnRGaW5kZXJfMSA9IHJlcXVpcmUoJy4vRWxlbWVudEZpbmRlcicpO1xudmFyIGZyb21FdmVudF8xID0gcmVxdWlyZSgnLi9mcm9tRXZlbnQnKTtcbnZhciBpc29sYXRlXzEgPSByZXF1aXJlKCcuL2lzb2xhdGUnKTtcbnZhciBFdmVudERlbGVnYXRvcl8xID0gcmVxdWlyZSgnLi9FdmVudERlbGVnYXRvcicpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbWF0Y2hlc1NlbGVjdG9yO1xudHJ5IHtcbiAgICBtYXRjaGVzU2VsZWN0b3IgPSByZXF1aXJlKFwibWF0Y2hlcy1zZWxlY3RvclwiKTtcbn1cbmNhdGNoIChlKSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yID0gRnVuY3Rpb24ucHJvdG90eXBlO1xufVxudmFyIGV2ZW50VHlwZXNUaGF0RG9udEJ1YmJsZSA9IFtcbiAgICBcImJsdXJcIixcbiAgICBcImNhbnBsYXlcIixcbiAgICBcImNhbnBsYXl0aHJvdWdoXCIsXG4gICAgXCJjaGFuZ2VcIixcbiAgICBcImR1cmF0aW9uY2hhbmdlXCIsXG4gICAgXCJlbXB0aWVkXCIsXG4gICAgXCJlbmRlZFwiLFxuICAgIFwiZm9jdXNcIixcbiAgICBcImxvYWRcIixcbiAgICBcImxvYWRlZGRhdGFcIixcbiAgICBcImxvYWRlZG1ldGFkYXRhXCIsXG4gICAgXCJtb3VzZWVudGVyXCIsXG4gICAgXCJtb3VzZWxlYXZlXCIsXG4gICAgXCJwYXVzZVwiLFxuICAgIFwicGxheVwiLFxuICAgIFwicGxheWluZ1wiLFxuICAgIFwicmF0ZWNoYW5nZVwiLFxuICAgIFwicmVzZXRcIixcbiAgICBcInNjcm9sbFwiLFxuICAgIFwic2Vla2VkXCIsXG4gICAgXCJzZWVraW5nXCIsXG4gICAgXCJzdGFsbGVkXCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInN1c3BlbmRcIixcbiAgICBcInRpbWV1cGRhdGVcIixcbiAgICBcInVubG9hZFwiLFxuICAgIFwidm9sdW1lY2hhbmdlXCIsXG4gICAgXCJ3YWl0aW5nXCIsXG5dO1xuZnVuY3Rpb24gZGV0ZXJtaW5lVXNlQ2FwdHVyZShldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnVzZUNhcHR1cmUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXN1bHQgPSBvcHRpb25zLnVzZUNhcHR1cmU7XG4gICAgfVxuICAgIGlmIChldmVudFR5cGVzVGhhdERvbnRCdWJibGUuaW5kZXhPZihldmVudFR5cGUpICE9PSAtMSkge1xuICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmlsdGVyQmFzZWRPbklzb2xhdGlvbihkb21Tb3VyY2UsIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpbHRlckJhc2VkT25Jc29sYXRpb25PcGVyYXRvcihyb290RWxlbWVudCQpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RFbGVtZW50JFxuICAgICAgICAgICAgLmZvbGQoZnVuY3Rpb24gc2hvdWxkUGFzcyhzdGF0ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGhhc0lzb2xhdGVkID0gISFkb21Tb3VyY2UuX2lzb2xhdGVNb2R1bGUuZ2V0SXNvbGF0ZWRFbGVtZW50KHNjb3BlKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRQYXNzID0gaGFzSXNvbGF0ZWQgJiYgIXN0YXRlLmhhZElzb2xhdGVkTXV0YWJsZTtcbiAgICAgICAgICAgIHJldHVybiB7IGhhZElzb2xhdGVkTXV0YWJsZTogaGFzSXNvbGF0ZWQsIHNob3VsZFBhc3M6IHNob3VsZFBhc3MsIGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgICAgfSwgeyBoYWRJc29sYXRlZE11dGFibGU6IGZhbHNlLCBzaG91bGRQYXNzOiBmYWxzZSwgZWxlbWVudDogbnVsbCB9KVxuICAgICAgICAgICAgLmRyb3AoMSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2hvdWxkUGFzczsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZWxlbWVudDsgfSk7XG4gICAgfTtcbn1cbnZhciBNYWluRE9NU291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluRE9NU291cmNlKF9yb290RWxlbWVudCQsIF9zYW5pdGF0aW9uJCwgX3J1blN0cmVhbUFkYXB0ZXIsIF9uYW1lc3BhY2UsIF9pc29sYXRlTW9kdWxlLCBfZGVsZWdhdG9ycywgX25hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKF9uYW1lc3BhY2UgPT09IHZvaWQgMCkgeyBfbmFtZXNwYWNlID0gW107IH1cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQkID0gX3Jvb3RFbGVtZW50JDtcbiAgICAgICAgdGhpcy5fc2FuaXRhdGlvbiQgPSBfc2FuaXRhdGlvbiQ7XG4gICAgICAgIHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIgPSBfcnVuU3RyZWFtQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gX25hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5faXNvbGF0ZU1vZHVsZSA9IF9pc29sYXRlTW9kdWxlO1xuICAgICAgICB0aGlzLl9kZWxlZ2F0b3JzID0gX2RlbGVnYXRvcnM7XG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICAgICAgdGhpcy5fX0pBTklfRVZBS0FMTElPX1dFX1dJTExfTUlTU19ZT1VfUExFQVNFX0NPTUVfQkFDS19FVkVOVFVBTExZID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19KQU5JX0VWQUtBTExJT19XRV9XSUxMX01JU1NfWU9VX1BMRUFTRV9DT01FX0JBQ0tfRVZFTlRVQUxMWSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNvbGF0ZVNvdXJjZSA9IGlzb2xhdGVfMS5pc29sYXRlU291cmNlO1xuICAgICAgICB0aGlzLmlzb2xhdGVTaW5rID0gZnVuY3Rpb24gKHNpbmssIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdTY29wZSA9IHV0aWxzXzEuZ2V0U2NvcGUoX3RoaXMuX25hbWVzcGFjZSk7XG4gICAgICAgICAgICB2YXIgZGVlcGVyU2NvcGUgPSBbZXhpc3RpbmdTY29wZSwgc2NvcGVdLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gISF4OyB9KS5qb2luKCctJyk7XG4gICAgICAgICAgICByZXR1cm4gaXNvbGF0ZV8xLmlzb2xhdGVTaW5rKHNpbmssIGRlZXBlclNjb3BlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRwdXQkO1xuICAgICAgICBpZiAodGhpcy5fbmFtZXNwYWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3V0cHV0JCA9IHRoaXMuX3Jvb3RFbGVtZW50JDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50RmluZGVyXzEgPSBuZXcgRWxlbWVudEZpbmRlcl8xLkVsZW1lbnRGaW5kZXIodGhpcy5fbmFtZXNwYWNlLCB0aGlzLl9pc29sYXRlTW9kdWxlKTtcbiAgICAgICAgICAgIG91dHB1dCQgPSB0aGlzLl9yb290RWxlbWVudCQubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWxlbWVudEZpbmRlcl8xLmNhbGwoZWwpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVuU0EgPSB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyO1xuICAgICAgICB2YXIgb3V0ID0gcnVuU0EucmVtZW1iZXIocnVuU0EuYWRhcHQob3V0cHV0JCwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYWluRE9NU291cmNlLnByb3RvdHlwZSwgXCJuYW1lc3BhY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lc3BhY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1haW5ET01Tb3VyY2UucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRE9NIGRyaXZlcidzIHNlbGVjdCgpIGV4cGVjdHMgdGhlIGFyZ3VtZW50IHRvIGJlIGEgXCIgK1xuICAgICAgICAgICAgICAgIFwic3RyaW5nIGFzIGEgQ1NTIHNlbGVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudERPTVNvdXJjZV8xLkRvY3VtZW50RE9NU291cmNlKHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIsIHRoaXMuX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvZHlET01Tb3VyY2VfMS5Cb2R5RE9NU291cmNlKHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIsIHRoaXMuX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmltbWVkU2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKCk7XG4gICAgICAgIHZhciBjaGlsZE5hbWVzcGFjZSA9IHRyaW1tZWRTZWxlY3RvciA9PT0gXCI6cm9vdFwiID9cbiAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZSA6XG4gICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2UuY29uY2F0KHRyaW1tZWRTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBuZXcgTWFpbkRPTVNvdXJjZSh0aGlzLl9yb290RWxlbWVudCQsIHRoaXMuX3Nhbml0YXRpb24kLCB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyLCBjaGlsZE5hbWVzcGFjZSwgdGhpcy5faXNvbGF0ZU1vZHVsZSwgdGhpcy5fZGVsZWdhdG9ycywgdGhpcy5fbmFtZSk7XG4gICAgfTtcbiAgICBNYWluRE9NU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJET00gZHJpdmVyJ3MgZXZlbnRzKCkgZXhwZWN0cyBhcmd1bWVudCB0byBiZSBhIFwiICtcbiAgICAgICAgICAgICAgICBcInN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZUNhcHR1cmUgPSBkZXRlcm1pbmVVc2VDYXB0dXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLl9uYW1lc3BhY2U7XG4gICAgICAgIHZhciBzY29wZSA9IHV0aWxzXzEuZ2V0U2NvcGUobmFtZXNwYWNlKTtcbiAgICAgICAgdmFyIGtleVBhcnRzID0gW2V2ZW50VHlwZSwgdXNlQ2FwdHVyZV07XG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAga2V5UGFydHMucHVzaChzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGtleVBhcnRzLmpvaW4oJ34nKTtcbiAgICAgICAgdmFyIGRvbVNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHZhciByb290RWxlbWVudCQ7XG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQkID0gdGhpcy5fcm9vdEVsZW1lbnQkXG4gICAgICAgICAgICAgICAgLmNvbXBvc2UoZmlsdGVyQmFzZWRPbklzb2xhdGlvbihkb21Tb3VyY2UsIHNjb3BlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb290RWxlbWVudCQgPSB0aGlzLl9yb290RWxlbWVudCQudGFrZSgyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQkID0gcm9vdEVsZW1lbnQkXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIHNldHVwRXZlbnREZWxlZ2F0b3JPblRvcEVsZW1lbnQocm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IGxpc3RlbmVyIGp1c3QgZm9yIHRoZSByb290IGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUV2ZW50XzEuZnJvbUV2ZW50KHJvb3RFbGVtZW50LCBldmVudFR5cGUsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXZlbnQgbGlzdGVuZXIgb24gdGhlIHRvcCBlbGVtZW50IGFzIGFuIEV2ZW50RGVsZWdhdG9yXG4gICAgICAgICAgICB2YXIgZGVsZWdhdG9ycyA9IGRvbVNvdXJjZS5fZGVsZWdhdG9ycztcbiAgICAgICAgICAgIHZhciB0b3AgPSBkb21Tb3VyY2UuX2lzb2xhdGVNb2R1bGUuZ2V0SXNvbGF0ZWRFbGVtZW50KHNjb3BlKSB8fCByb290RWxlbWVudDtcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0b3I7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdG9ycy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGRlbGVnYXRvciA9IGRlbGVnYXRvcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgZGVsZWdhdG9yLnVwZGF0ZVRvcEVsZW1lbnQodG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGVnYXRvciA9IG5ldyBFdmVudERlbGVnYXRvcl8xLkV2ZW50RGVsZWdhdG9yKHRvcCwgZXZlbnRUeXBlLCB1c2VDYXB0dXJlLCBkb21Tb3VyY2UuX2lzb2xhdGVNb2R1bGUpO1xuICAgICAgICAgICAgICAgIGRlbGVnYXRvcnMuc2V0KGtleSwgZGVsZWdhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgIGRvbVNvdXJjZS5faXNvbGF0ZU1vZHVsZS5hZGRFdmVudERlbGVnYXRvcihzY29wZSwgZGVsZWdhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbklkID0gZGVsZWdhdG9yLmNyZWF0ZURlc3RpbmF0aW9uSWQoKTtcbiAgICAgICAgICAgIHZhciBzdWJqZWN0ID0geHN0cmVhbV8xLmRlZmF1bHQuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdyZXF1ZXN0SWRsZUNhbGxiYWNrJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRvci5yZW1vdmVEZXN0aW5hdGlvbklkKGRlc3RpbmF0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0b3IucmVtb3ZlRGVzdGluYXRpb25JZChkZXN0aW5hdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGVnYXRvci5hZGREZXN0aW5hdGlvbihzdWJqZWN0LCBuYW1lc3BhY2UsIGRlc3RpbmF0aW9uSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmxhdHRlbigpO1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5fcnVuU3RyZWFtQWRhcHRlci5hZGFwdChldmVudCQsIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gZG9tU291cmNlLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2FuaXRhdGlvbiQuc2hhbWVmdWxseVNlbmROZXh0KCcnKTtcbiAgICAgICAgdGhpcy5faXNvbGF0ZU1vZHVsZS5yZXNldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1haW5ET01Tb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5NYWluRE9NU291cmNlID0gTWFpbkRPTVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1haW5ET01Tb3VyY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL01haW5ET01Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGh5cGVyc2NyaXB0XzEgPSByZXF1aXJlKCcuL2h5cGVyc2NyaXB0Jyk7XG52YXIgY2xhc3NOYW1lRnJvbVZOb2RlXzEgPSByZXF1aXJlKCdzbmFiYmRvbS1zZWxlY3Rvci9saWIvY2xhc3NOYW1lRnJvbVZOb2RlJyk7XG52YXIgc2VsZWN0b3JQYXJzZXJfMSA9IHJlcXVpcmUoJ3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9zZWxlY3RvclBhcnNlcicpO1xudmFyIFZOb2RlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVk5vZGVXcmFwcGVyKHJvb3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcbiAgICB9XG4gICAgVk5vZGVXcmFwcGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICAgIHZhciBfYSA9IHNlbGVjdG9yUGFyc2VyXzEuZGVmYXVsdCh2bm9kZS5zZWwpLCBzZWxlY3RvclRhZ05hbWUgPSBfYS50YWdOYW1lLCBzZWxlY3RvcklkID0gX2EuaWQ7XG4gICAgICAgIHZhciB2Tm9kZUNsYXNzTmFtZSA9IGNsYXNzTmFtZUZyb21WTm9kZV8xLmRlZmF1bHQodm5vZGUpO1xuICAgICAgICB2YXIgdk5vZGVEYXRhID0gdm5vZGUuZGF0YSB8fCB7fTtcbiAgICAgICAgdmFyIHZOb2RlRGF0YVByb3BzID0gdk5vZGVEYXRhLnByb3BzIHx8IHt9O1xuICAgICAgICB2YXIgX2IgPSB2Tm9kZURhdGFQcm9wcy5pZCwgdk5vZGVJZCA9IF9iID09PSB2b2lkIDAgPyBzZWxlY3RvcklkIDogX2I7XG4gICAgICAgIHZhciBpc1ZOb2RlQW5kUm9vdEVsZW1lbnRJZGVudGljYWwgPSB2Tm9kZUlkLnRvVXBwZXJDYXNlKCkgPT09IHRoaXMucm9vdEVsZW1lbnQuaWQudG9VcHBlckNhc2UoKSAmJlxuICAgICAgICAgICAgc2VsZWN0b3JUYWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHRoaXMucm9vdEVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpICYmXG4gICAgICAgICAgICB2Tm9kZUNsYXNzTmFtZS50b1VwcGVyQ2FzZSgpID09PSB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoaXNWTm9kZUFuZFJvb3RFbGVtZW50SWRlbnRpY2FsKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jID0gdGhpcy5yb290RWxlbWVudCwgdGFnTmFtZSA9IF9jLnRhZ05hbWUsIGlkID0gX2MuaWQsIGNsYXNzTmFtZSA9IF9jLmNsYXNzTmFtZTtcbiAgICAgICAgdmFyIGVsZW1lbnRJZCA9IGlkID8gXCIjXCIgKyBpZCA6IFwiXCI7XG4gICAgICAgIHZhciBlbGVtZW50Q2xhc3NOYW1lID0gY2xhc3NOYW1lID9cbiAgICAgICAgICAgIFwiLlwiICsgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwiLlwiKSA6IFwiXCI7XG4gICAgICAgIHJldHVybiBoeXBlcnNjcmlwdF8xLmgoXCJcIiArIHRhZ05hbWUudG9Mb3dlckNhc2UoKSArIGVsZW1lbnRJZCArIGVsZW1lbnRDbGFzc05hbWUsIHt9LCBbXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICByZXR1cm4gVk5vZGVXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuVk5vZGVXcmFwcGVyID0gVk5vZGVXcmFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vk5vZGVXcmFwcGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9WTm9kZVdyYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGh5cGVyc2NyaXB0XzEgPSByZXF1aXJlKCcuL2h5cGVyc2NyaXB0Jyk7XG5mdW5jdGlvbiBpc1ZhbGlkU3RyaW5nKHBhcmFtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgJiYgcGFyYW0ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0b3IocGFyYW0pIHtcbiAgICByZXR1cm4gaXNWYWxpZFN0cmluZyhwYXJhbSkgJiYgKHBhcmFtWzBdID09PSAnLicgfHwgcGFyYW1bMF0gPT09ICcjJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWdGdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh5cGVyc2NyaXB0KGZpcnN0LCBiLCBjKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdG9yKGZpcnN0KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHlwZXJzY3JpcHRfMS5oKHRhZ05hbWUgKyBmaXJzdCwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHlwZXJzY3JpcHRfMS5oKHRhZ05hbWUgKyBmaXJzdCwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHlwZXJzY3JpcHRfMS5oKHRhZ05hbWUgKyBmaXJzdCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEhYikge1xuICAgICAgICAgICAgcmV0dXJuIGh5cGVyc2NyaXB0XzEuaCh0YWdOYW1lLCBmaXJzdCwgYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoISFmaXJzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGh5cGVyc2NyaXB0XzEuaCh0YWdOYW1lLCBmaXJzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaHlwZXJzY3JpcHRfMS5oKHRhZ05hbWUsIHt9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG52YXIgU1ZHX1RBR19OQU1FUyA9IFtcbiAgICAnYScsICdhbHRHbHlwaCcsICdhbHRHbHlwaERlZicsICdhbHRHbHlwaEl0ZW0nLCAnYW5pbWF0ZScsICdhbmltYXRlQ29sb3InLFxuICAgICdhbmltYXRlTW90aW9uJywgJ2FuaW1hdGVUcmFuc2Zvcm0nLCAnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2NvbG9yUHJvZmlsZScsXG4gICAgJ2N1cnNvcicsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLFxuICAgICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLFxuICAgICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsXG4gICAgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZUltYWdlJywgJ2ZlTWVyZ2UnLCAnZmVNZXJnZU5vZGUnLFxuICAgICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsXG4gICAgJ2ZlU3BvdGxpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZm9udEZhY2UnLFxuICAgICdmb250RmFjZUZvcm1hdCcsICdmb250RmFjZU5hbWUnLCAnZm9udEZhY2VTcmMnLCAnZm9udEZhY2VVcmknLFxuICAgICdmb3JlaWduT2JqZWN0JywgJ2cnLCAnZ2x5cGgnLCAnZ2x5cGhSZWYnLCAnaGtlcm4nLCAnaW1hZ2UnLCAnbGluZScsXG4gICAgJ2xpbmVhckdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21pc3NpbmdHbHlwaCcsICdtcGF0aCcsXG4gICAgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc2NyaXB0JyxcbiAgICAnc2V0JywgJ3N0b3AnLCAnc3R5bGUnLCAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRQYXRoJywgJ3RpdGxlJyxcbiAgICAndHJlZicsICd0c3BhbicsICd1c2UnLCAndmlldycsICd2a2VybicsXG5dO1xudmFyIHN2ZyA9IGNyZWF0ZVRhZ0Z1bmN0aW9uKCdzdmcnKTtcblNWR19UQUdfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgc3ZnW3RhZ10gPSBjcmVhdGVUYWdGdW5jdGlvbih0YWcpO1xufSk7XG52YXIgVEFHX05BTUVTID0gW1xuICAgICdhJywgJ2FiYnInLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiYXNlJyxcbiAgICAnYmRpJywgJ2JkbycsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjYXB0aW9uJyxcbiAgICAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZWwnLCAnZGZuJywgJ2RpcicsICdkaXYnLCAnZGwnLFxuICAgICdkdCcsICdlbScsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsXG4gICAgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJyxcbiAgICAnaScsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ2xlZ2VuZCcsXG4gICAgJ2xpJywgJ2xpbmsnLCAnbWFpbicsICdtYXAnLCAnbWFyaycsICdtZW51JywgJ21ldGEnLCAnbmF2JywgJ25vc2NyaXB0JyxcbiAgICAnb2JqZWN0JywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdwJywgJ3BhcmFtJywgJ3ByZScsICdwcm9ncmVzcycsICdxJyxcbiAgICAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NtYWxsJyxcbiAgICAnc291cmNlJywgJ3NwYW4nLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLFxuICAgICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd1JywgJ3VsJywgJ3ZpZGVvJyxcbl07XG52YXIgZXhwb3J0ZWQgPSB7IFNWR19UQUdfTkFNRVM6IFNWR19UQUdfTkFNRVMsIFRBR19OQU1FUzogVEFHX05BTUVTLCBzdmc6IHN2ZywgaXNTZWxlY3RvcjogaXNTZWxlY3RvciwgY3JlYXRlVGFnRnVuY3Rpb246IGNyZWF0ZVRhZ0Z1bmN0aW9uIH07XG5UQUdfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgIGV4cG9ydGVkW25dID0gY3JlYXRlVGFnRnVuY3Rpb24obik7XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHlwZXJzY3JpcHQtaGVscGVycy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvaHlwZXJzY3JpcHQtaGVscGVycy5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmZ1bmN0aW9uIGlzb2xhdGVTb3VyY2Uoc291cmNlLCBzY29wZSkge1xuICAgIHJldHVybiBzb3VyY2Uuc2VsZWN0KHV0aWxzXzEuU0NPUEVfUFJFRklYICsgc2NvcGUpO1xufVxuZXhwb3J0cy5pc29sYXRlU291cmNlID0gaXNvbGF0ZVNvdXJjZTtcbmZ1bmN0aW9uIGlzb2xhdGVTaW5rKHNpbmssIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNpbmsubWFwKGZ1bmN0aW9uICh2VHJlZSkge1xuICAgICAgICBpZiAodlRyZWUuZGF0YSAmJiB2VHJlZS5kYXRhLmlzb2xhdGUpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1Njb3BlID0gdlRyZWUuZGF0YS5pc29sYXRlLnJlcGxhY2UoLyhjeWNsZXxcXC0pL2csICcnKTtcbiAgICAgICAgICAgIHZhciBfc2NvcGUgPSBzY29wZS5yZXBsYWNlKC8oY3ljbGV8XFwtKS9nLCAnJyk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VJbnQoZXhpc3RpbmdTY29wZSkpXG4gICAgICAgICAgICAgICAgfHwgaXNOYU4ocGFyc2VJbnQoX3Njb3BlKSlcbiAgICAgICAgICAgICAgICB8fCBleGlzdGluZ1Njb3BlID4gX3Njb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZUcmVlLmRhdGEgPSB2VHJlZS5kYXRhIHx8IHt9O1xuICAgICAgICB2VHJlZS5kYXRhLmlzb2xhdGUgPSBzY29wZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2VHJlZS5rZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2VHJlZS5rZXkgPSB1dGlsc18xLlNDT1BFX1BSRUZJWCArIHNjb3BlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2VHJlZTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuaXNvbGF0ZVNpbmsgPSBpc29sYXRlU2luaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzb2xhdGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL2lzb2xhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE1hcFBvbHlmaWxsID0gcmVxdWlyZSgnZXM2LW1hcCcpO1xudmFyIElzb2xhdGVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElzb2xhdGVNb2R1bGUoaXNvbGF0ZWRFbGVtZW50cykge1xuICAgICAgICB0aGlzLmlzb2xhdGVkRWxlbWVudHMgPSBpc29sYXRlZEVsZW1lbnRzO1xuICAgICAgICB0aGlzLmV2ZW50RGVsZWdhdG9ycyA9IG5ldyBNYXBQb2x5ZmlsbCgpO1xuICAgIH1cbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5zZXRTY29wZSA9IGZ1bmN0aW9uIChlbG0sIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuaXNvbGF0ZWRFbGVtZW50cy5zZXQoc2NvcGUsIGVsbSk7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5yZW1vdmVTY29wZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICB0aGlzLmlzb2xhdGVkRWxlbWVudHMuZGVsZXRlKHNjb3BlKTtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLmNsZWFudXBWTm9kZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIGVsbSA9IF9hLmVsbTtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIHZhciBzY29wZSA9IGRhdGEuaXNvbGF0ZSB8fCAnJztcbiAgICAgICAgdmFyIGlzQ3VycmVudEVsbSA9IHRoaXMuaXNvbGF0ZWRFbGVtZW50cy5nZXQoc2NvcGUpID09PSBlbG07XG4gICAgICAgIGlmIChzY29wZSAmJiBpc0N1cnJlbnRFbG0pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NvcGUoc2NvcGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnREZWxlZ2F0b3JzLmdldChzY29wZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGVsZWdhdG9ycy5zZXQoc2NvcGUsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuZ2V0SXNvbGF0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb2xhdGVkRWxlbWVudHMuZ2V0KHNjb3BlKTtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLmlzSXNvbGF0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKGVsbSkge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmlzb2xhdGVkRWxlbWVudHMuZW50cmllcygpO1xuICAgICAgICBmb3IgKHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7ICEhcmVzdWx0LnZhbHVlOyByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHJlc3VsdC52YWx1ZSwgc2NvcGUgPSBfYVswXSwgZWxlbWVudCA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKGVsbSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5hZGRFdmVudERlbGVnYXRvciA9IGZ1bmN0aW9uIChzY29wZSwgZXZlbnREZWxlZ2F0b3IpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRvcnMgPSB0aGlzLmV2ZW50RGVsZWdhdG9ycy5nZXQoc2NvcGUpO1xuICAgICAgICBpZiAoIWRlbGVnYXRvcnMpIHtcbiAgICAgICAgICAgIGRlbGVnYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREZWxlZ2F0b3JzLnNldChzY29wZSwgZGVsZWdhdG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZWdhdG9yc1tkZWxlZ2F0b3JzLmxlbmd0aF0gPSBldmVudERlbGVnYXRvcjtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzb2xhdGVkRWxlbWVudHMuY2xlYXIoKTtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLmNyZWF0ZU1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAob2xkVk5vZGUsIHZOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gb2xkVk5vZGUuZGF0YSwgb2xkRGF0YSA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hO1xuICAgICAgICAgICAgICAgIHZhciBlbG0gPSB2Tm9kZS5lbG0sIF9iID0gdk5vZGUuZGF0YSwgZGF0YSA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTY29wZSA9IG9sZERhdGEuaXNvbGF0ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBzY29wZSA9IGRhdGEuaXNvbGF0ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlU2NvcGUob2xkU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0U2NvcGUoZWxtLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxlZ2F0b3JzID0gc2VsZi5ldmVudERlbGVnYXRvcnMuZ2V0KHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWxlZ2F0b3JzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdG9yc1tpXS51cGRhdGVUb3BFbGVtZW50KGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVsZWdhdG9ycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV2ZW50RGVsZWdhdG9ycy5zZXQoc2NvcGUsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkU2NvcGUgJiYgIXNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlU2NvcGUoc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChvbGRWTm9kZSwgdk5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBvbGRWTm9kZS5kYXRhLCBvbGREYXRhID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2E7XG4gICAgICAgICAgICAgICAgdmFyIGVsbSA9IHZOb2RlLmVsbSwgX2IgPSB2Tm9kZS5kYXRhLCBkYXRhID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFNjb3BlID0gb2xkRGF0YS5pc29sYXRlIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIHNjb3BlID0gZGF0YS5pc29sYXRlIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlICYmIHNjb3BlICE9PSBvbGRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlU2NvcGUob2xkU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0U2NvcGUoZWxtLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbGRTY29wZSAmJiAhc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVTY29wZShzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKHZOb2RlLCBjYikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xlYW51cFZOb2RlKHZOb2RlKTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICh2Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xlYW51cFZOb2RlKHZOb2RlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSXNvbGF0ZU1vZHVsZTtcbn0oKSk7XG5leHBvcnRzLklzb2xhdGVNb2R1bGUgPSBJc29sYXRlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNvbGF0ZU1vZHVsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvaXNvbGF0ZU1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgc25hYmJkb21fMSA9IHJlcXVpcmUoJ3NuYWJiZG9tJyk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xudmFyIE1haW5ET01Tb3VyY2VfMSA9IHJlcXVpcmUoJy4vTWFpbkRPTVNvdXJjZScpO1xudmFyIFZOb2RlV3JhcHBlcl8xID0gcmVxdWlyZSgnLi9WTm9kZVdyYXBwZXInKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG1vZHVsZXNfMSA9IHJlcXVpcmUoJy4vbW9kdWxlcycpO1xudmFyIGlzb2xhdGVNb2R1bGVfMSA9IHJlcXVpcmUoJy4vaXNvbGF0ZU1vZHVsZScpO1xudmFyIHRyYW5zcG9zaXRpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNwb3NpdGlvbicpO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIE1hcFBvbHlmaWxsID0gcmVxdWlyZSgnZXM2LW1hcCcpO1xuZnVuY3Rpb24gbWFrZURPTURyaXZlcklucHV0R3VhcmQobW9kdWxlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb25hbCBtb2R1bGVzIG9wdGlvbiBtdXN0IGJlIFwiICtcbiAgICAgICAgICAgIFwiYW4gYXJyYXkgZm9yIHNuYWJiZG9tIG1vZHVsZXNcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9tRHJpdmVySW5wdXRHdWFyZCh2aWV3JCkge1xuICAgIGlmICghdmlldyRcbiAgICAgICAgfHwgdHlwZW9mIHZpZXckLmFkZExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgfHwgdHlwZW9mIHZpZXckLmZvbGQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRE9NIGRyaXZlciBmdW5jdGlvbiBleHBlY3RzIGFzIGlucHV0IGEgU3RyZWFtIG9mIFwiICtcbiAgICAgICAgICAgIFwidmlydHVhbCBET00gZWxlbWVudHNcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZURPTURyaXZlcihjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgdHJhbnNwb3NpdGlvbiA9IG9wdGlvbnMudHJhbnNwb3NpdGlvbiB8fCBmYWxzZTtcbiAgICB2YXIgbW9kdWxlcyA9IG9wdGlvbnMubW9kdWxlcyB8fCBtb2R1bGVzXzEuZGVmYXVsdDtcbiAgICB2YXIgaXNvbGF0ZU1vZHVsZSA9IG5ldyBpc29sYXRlTW9kdWxlXzEuSXNvbGF0ZU1vZHVsZSgobmV3IE1hcFBvbHlmaWxsKCkpKTtcbiAgICB2YXIgcGF0Y2ggPSBzbmFiYmRvbV8xLmluaXQoW2lzb2xhdGVNb2R1bGUuY3JlYXRlTW9kdWxlKCldLmNvbmNhdChtb2R1bGVzKSk7XG4gICAgdmFyIHJvb3RFbGVtZW50ID0gdXRpbHNfMS5nZXRFbGVtZW50KGNvbnRhaW5lcik7XG4gICAgdmFyIHZub2RlV3JhcHBlciA9IG5ldyBWTm9kZVdyYXBwZXJfMS5WTm9kZVdyYXBwZXIocm9vdEVsZW1lbnQpO1xuICAgIHZhciBkZWxlZ2F0b3JzID0gbmV3IE1hcFBvbHlmaWxsKCk7XG4gICAgbWFrZURPTURyaXZlcklucHV0R3VhcmQobW9kdWxlcyk7XG4gICAgZnVuY3Rpb24gRE9NRHJpdmVyKHZub2RlJCwgcnVuU3RyZWFtQWRhcHRlciwgbmFtZSkge1xuICAgICAgICBkb21Ecml2ZXJJbnB1dEd1YXJkKHZub2RlJCk7XG4gICAgICAgIHZhciB0cmFuc3Bvc2VWTm9kZSA9IHRyYW5zcG9zaXRpb25fMS5tYWtlVHJhbnNwb3NlVk5vZGUocnVuU3RyZWFtQWRhcHRlcik7XG4gICAgICAgIHZhciBwcmVwcm9jZXNzZWRWTm9kZSQgPSAodHJhbnNwb3NpdGlvbiA/IHZub2RlJC5tYXAodHJhbnNwb3NlVk5vZGUpLmZsYXR0ZW4oKSA6IHZub2RlJCk7XG4gICAgICAgIHZhciBzYW5pdGF0aW9uJCA9IHhzdHJlYW1fMS5kZWZhdWx0LmNyZWF0ZSgpO1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnQkID0geHN0cmVhbV8xLmRlZmF1bHQubWVyZ2UocHJlcHJvY2Vzc2VkVk5vZGUkLmVuZFdoZW4oc2FuaXRhdGlvbiQpLCBzYW5pdGF0aW9uJClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHZub2RlKSB7IHJldHVybiB2bm9kZVdyYXBwZXIuY2FsbCh2bm9kZSk7IH0pXG4gICAgICAgICAgICAuZm9sZChwYXRjaCwgcm9vdEVsZW1lbnQpXG4gICAgICAgICAgICAuZHJvcCgxKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiB1bndyYXBFbGVtZW50RnJvbVZOb2RlKHZub2RlKSB7IHJldHVybiB2bm9kZS5lbG07IH0pXG4gICAgICAgICAgICAuY29tcG9zZShmdW5jdGlvbiAoc3RyZWFtKSB7IHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdC5tZXJnZShzdHJlYW0sIHhzdHJlYW1fMS5kZWZhdWx0Lm5ldmVyKCkpOyB9KSAvLyBkb24ndCBjb21wbGV0ZSB0aGlzIHN0cmVhbVxuICAgICAgICAgICAgLnN0YXJ0V2l0aChyb290RWxlbWVudCk7XG4gICAgICAgIHJvb3RFbGVtZW50JC5hZGRMaXN0ZW5lcih7IG5leHQ6IGZ1bmN0aW9uICgpIHsgfSwgZXJyb3I6IGZ1bmN0aW9uICgpIHsgfSwgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfSB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYWluRE9NU291cmNlXzEuTWFpbkRPTVNvdXJjZShyb290RWxlbWVudCQsIHNhbml0YXRpb24kLCBydW5TdHJlYW1BZGFwdGVyLCBbXSwgaXNvbGF0ZU1vZHVsZSwgZGVsZWdhdG9ycywgbmFtZSk7XG4gICAgfVxuICAgIDtcbiAgICBET01Ecml2ZXIuc3RyZWFtQWRhcHRlciA9IHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIERPTURyaXZlcjtcbn1cbmV4cG9ydHMubWFrZURPTURyaXZlciA9IG1ha2VET01Ecml2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlRE9NRHJpdmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9tYWtlRE9NRHJpdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciB0cmFuc3Bvc2l0aW9uXzEgPSByZXF1aXJlKCcuL3RyYW5zcG9zaXRpb24nKTtcbnZhciBIVE1MU291cmNlXzEgPSByZXF1aXJlKCcuL0hUTUxTb3VyY2UnKTtcbnZhciB0b0hUTUwgPSByZXF1aXJlKCdzbmFiYmRvbS10by1odG1sJyk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbmZ1bmN0aW9uIG1ha2VIVE1MRHJpdmVyKGVmZmVjdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHZhciB0cmFuc3Bvc2l0aW9uID0gb3B0aW9ucy50cmFuc3Bvc2l0aW9uIHx8IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGh0bWxEcml2ZXIodm5vZGUkLCBydW5TdHJlYW1BZGFwdGVyLCBuYW1lKSB7XG4gICAgICAgIHZhciB0cmFuc3Bvc2VWTm9kZSA9IHRyYW5zcG9zaXRpb25fMS5tYWtlVHJhbnNwb3NlVk5vZGUocnVuU3RyZWFtQWRhcHRlcik7XG4gICAgICAgIHZhciBwcmVwcm9jZXNzZWRWTm9kZSQgPSAodHJhbnNwb3NpdGlvbiA/IHZub2RlJC5tYXAodHJhbnNwb3NlVk5vZGUpLmZsYXR0ZW4oKSA6IHZub2RlJCk7XG4gICAgICAgIHZhciBodG1sJCA9IHByZXByb2Nlc3NlZFZOb2RlJC5tYXAodG9IVE1MKTtcbiAgICAgICAgaHRtbCQuYWRkTGlzdGVuZXIoe1xuICAgICAgICAgICAgbmV4dDogZWZmZWN0IHx8IG5vb3AsXG4gICAgICAgICAgICBlcnJvcjogbm9vcCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBub29wLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBIVE1MU291cmNlXzEuSFRNTFNvdXJjZShodG1sJCwgcnVuU3RyZWFtQWRhcHRlciwgbmFtZSk7XG4gICAgfVxuICAgIDtcbiAgICBodG1sRHJpdmVyLnN0cmVhbUFkYXB0ZXIgPSB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0O1xuICAgIHJldHVybiBodG1sRHJpdmVyO1xufVxuZXhwb3J0cy5tYWtlSFRNTERyaXZlciA9IG1ha2VIVE1MRHJpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZUhUTUxEcml2ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL21ha2VIVE1MRHJpdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG52YXIgU0NPUEVfUFJFRklYID0gJ19fXyc7XG52YXIgTW9ja2VkRE9NU291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2NrZWRET01Tb3VyY2UoX3N0cmVhbUFkYXB0ZXIsIF9tb2NrQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbUFkYXB0ZXIgPSBfc3RyZWFtQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fbW9ja0NvbmZpZyA9IF9tb2NrQ29uZmlnO1xuICAgICAgICBpZiAoX21vY2tDb25maWcuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID0gX21vY2tDb25maWcuZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9zdHJlYW1BZGFwdGVyLmFkYXB0KHhzdHJlYW1fMS5kZWZhdWx0LmVtcHR5KCksIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5fZWxlbWVudHM7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9ICdNb2NrZWRET00nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTW9ja2VkRE9NU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtb2NrQ29uZmlnID0gdGhpcy5fbW9ja0NvbmZpZztcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtb2NrQ29uZmlnKTtcbiAgICAgICAgdmFyIGtleXNMZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dF8xID0gbW9ja0NvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgIG91dF8xLl9pc0N5Y2xlU291cmNlID0gJ01vY2tlZERPTSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9zdHJlYW1BZGFwdGVyLmFkYXB0KHhzdHJlYW1fMS5kZWZhdWx0LmVtcHR5KCksIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gJ01vY2tlZERPTSc7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgbW9ja0NvbmZpZyA9IHRoaXMuX21vY2tDb25maWc7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobW9ja0NvbmZpZyk7XG4gICAgICAgIHZhciBrZXlzTGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2NrZWRET01Tb3VyY2UodGhpcy5fc3RyZWFtQWRhcHRlciwgbW9ja0NvbmZpZ1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1vY2tlZERPTVNvdXJjZSh0aGlzLl9zdHJlYW1BZGFwdGVyLCB7fSk7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmlzb2xhdGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCBzY29wZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnNlbGVjdCgnLicgKyBTQ09QRV9QUkVGSVggKyBzY29wZSk7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmlzb2xhdGVTaW5rID0gZnVuY3Rpb24gKHNpbmssIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzaW5rLm1hcChmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5zZWwgJiYgdm5vZGUuc2VsLmluZGV4T2YoU0NPUEVfUFJFRklYICsgc2NvcGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlLnNlbCArPSBcIi5cIiArIFNDT1BFX1BSRUZJWCArIHNjb3BlO1xuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTW9ja2VkRE9NU291cmNlO1xufSgpKTtcbmV4cG9ydHMuTW9ja2VkRE9NU291cmNlID0gTW9ja2VkRE9NU291cmNlO1xuZnVuY3Rpb24gbW9ja0RPTVNvdXJjZShzdHJlYW1BZGFwdGVyLCBtb2NrQ29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrZWRET01Tb3VyY2Uoc3RyZWFtQWRhcHRlciwgbW9ja0NvbmZpZyk7XG59XG5leHBvcnRzLm1vY2tET01Tb3VyY2UgPSBtb2NrRE9NU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ja0RPTVNvdXJjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvbW9ja0RPTVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ2xhc3NNb2R1bGUgPSByZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2NsYXNzJyk7XG5leHBvcnRzLkNsYXNzTW9kdWxlID0gQ2xhc3NNb2R1bGU7XG52YXIgUHJvcHNNb2R1bGUgPSByZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL3Byb3BzJyk7XG5leHBvcnRzLlByb3BzTW9kdWxlID0gUHJvcHNNb2R1bGU7XG52YXIgQXR0cnNNb2R1bGUgPSByZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXMnKTtcbmV4cG9ydHMuQXR0cnNNb2R1bGUgPSBBdHRyc01vZHVsZTtcbnZhciBFdmVudHNNb2R1bGUgPSByZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2V2ZW50bGlzdGVuZXJzJyk7XG5leHBvcnRzLkV2ZW50c01vZHVsZSA9IEV2ZW50c01vZHVsZTtcbnZhciBTdHlsZU1vZHVsZSA9IHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvc3R5bGUnKTtcbmV4cG9ydHMuU3R5bGVNb2R1bGUgPSBTdHlsZU1vZHVsZTtcbnZhciBIZXJvTW9kdWxlID0gcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9oZXJvJyk7XG5leHBvcnRzLkhlcm9Nb2R1bGUgPSBIZXJvTW9kdWxlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gW1N0eWxlTW9kdWxlLCBDbGFzc01vZHVsZSwgUHJvcHNNb2R1bGUsIEF0dHJzTW9kdWxlXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL21vZHVsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNsaWNrRXZlbnQgPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGRvY3VtZW50ICYmIGRvY3VtZW50Lm9udG91Y2hzdGFydCA/XG4gICAgJ3RvdWNoc3RhcnQnIDogJ2NsaWNrJztcbmZ1bmN0aW9uIHdoaWNoKGV2KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGUgPSBldiB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgcmV0dXJuIGUud2hpY2ggPT09IG51bGwgPyBlLmJ1dHRvbiA6IGUud2hpY2g7XG59XG5mdW5jdGlvbiBzYW1lT3JpZ2luKGhyZWYpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZiAmJiBocmVmLmluZGV4T2Yod2luZG93LmxvY2F0aW9uLm9yaWdpbikgPT09IDA7XG59XG5mdW5jdGlvbiBtYWtlQ2xpY2tMaXN0ZW5lcihwdXNoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsaWNrTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKHdoaWNoKGV2ZW50KSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lICE9PSAnQScpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUgIT09ICdBJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZG93bmxvYWQnKSB8fFxuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnZXh0ZXJuYWwnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmsgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICBpZiAobGluayAmJiBsaW5rLmluZGV4T2YoJ21haWx0bzonKSA+IC0xIHx8IGxpbmsuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNhbWVPcmlnaW4oZWxlbWVudC5ocmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBwYXRobmFtZSA9IGVsZW1lbnQucGF0aG5hbWUsIHNlYXJjaCA9IGVsZW1lbnQuc2VhcmNoLCBfYSA9IGVsZW1lbnQuaGFzaCwgaGFzaCA9IF9hID09PSB2b2lkIDAgPyAnJyA6IF9hO1xuICAgICAgICBwdXNoKHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDbGlja3MocHVzaCkge1xuICAgIHZhciBsaXN0ZW5lciA9IG1ha2VDbGlja0xpc3RlbmVyKHB1c2gpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGNsaWNrRXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxufVxuZXhwb3J0cy5jYXB0dXJlQ2xpY2tzID0gY2FwdHVyZUNsaWNrcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcHR1cmVDbGlja3MuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi9jYXB0dXJlQ2xpY2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjYXB0dXJlQ2xpY2tzXzEgPSByZXF1aXJlKCcuL2NhcHR1cmVDbGlja3MnKTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGVIaXN0b3J5KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlSGlzdG9yeShsb2NhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBzdXBvcnQgdGhpbmdzIGxpa2UgaGlzdG9yeS5yZXBsYWNlKClcbiAgICAgICAgICAgIHZhciBfYSA9IGxvY2F0aW9uLnR5cGUsIHR5cGUgPSBfYSA9PT0gdm9pZCAwID8gJ3B1c2gnIDogX2E7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2dvJykge1xuICAgICAgICAgICAgICAgIGhpc3RvcnlbdHlwZV0obG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVt0eXBlXShsb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkgRHJpdmVyIGlucHV0IG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gJyArXG4gICAgICAgICAgICAgICAgJ29iamVjdCBidXQgcmVjZWl2ZWQgJHt0eXBlb2YgdXJsfScpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yRm4oZXJyKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlSGlzdG9yeURyaXZlcihoaXN0b3J5LCBvcHRpb25zKSB7XG4gICAgaWYgKCFoaXN0b3J5IHx8IHR5cGVvZiBoaXN0b3J5ICE9PSAnb2JqZWN0J1xuICAgICAgICB8fCB0eXBlb2YgaGlzdG9yeS5jcmVhdGVMb2NhdGlvbiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICB8fCB0eXBlb2YgaGlzdG9yeS5jcmVhdGVIcmVmICE9PSAnZnVuY3Rpb24nXG4gICAgICAgIHx8IHR5cGVvZiBoaXN0b3J5Lmxpc3RlbiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICB8fCB0eXBlb2YgaGlzdG9yeS5wdXNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21ha2VIaXN0b3J5RHJpdmVyIHJlcXVpcmVzIGFuIHZhbGlkIGhpc3Rvcnkgb2JqZWN0ICcgK1xuICAgICAgICAgICAgJ2NvbnRhaW5pbmcgY3JlYXRlTG9jYXRpb24oKSwgY3JlYXRlSHJlZigpLCBwdXNoKCksIGFuZCBsaXN0ZW4oKSBtZXRob2RzJyk7XG4gICAgfVxuICAgIHZhciBjYXB0dXJlID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhcHR1cmUgfHwgZmFsc2U7XG4gICAgdmFyIG9uRXJyb3IgPSBvcHRpb25zICYmIG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvckZuO1xuICAgIHJldHVybiBmdW5jdGlvbiBoaXN0b3J5RHJpdmVyKHNpbmskLCBydW5TQSkge1xuICAgICAgICB2YXIgX2EgPSBydW5TQS5tYWtlU3ViamVjdCgpLCBvYnNlcnZlciA9IF9hLm9ic2VydmVyLCBzdHJlYW0gPSBfYS5zdHJlYW07XG4gICAgICAgIHZhciBoaXN0b3J5JCA9IHJ1blNBLnJlbWVtYmVyKHN0cmVhbVxuICAgICAgICAgICAgLnN0YXJ0V2l0aChoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChsb2NhdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGhpc3RvcnkuYWRkQ29tcGxldGVDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIGhpc3RvcnkuY29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGhpc3RvcnkuYWRkQ29tcGxldGVDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1blNBLnN0cmVhbVN1YnNjcmliZShzaW5rJCwge1xuICAgICAgICAgICAgbmV4dDogbWFrZVVwZGF0ZUhpc3RvcnkoaGlzdG9yeSksXG4gICAgICAgICAgICBlcnJvcjogb25FcnJvcixcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ2xpY2tzXzEuY2FwdHVyZUNsaWNrcyhmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBoaXN0b3J5LnB1c2gobG9jYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlzdG9yeSQuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChocmVmKSB7IHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoaHJlZik7IH07XG4gICAgICAgIGhpc3RvcnkkLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7IHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTsgfTtcbiAgICAgICAgcmV0dXJuIGhpc3RvcnkkO1xuICAgIH07XG59XG5leHBvcnRzLm1ha2VIaXN0b3J5RHJpdmVyID0gbWFrZUhpc3RvcnlEcml2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlSGlzdG9yeURyaXZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2hpc3RvcnkvbGliL21ha2VIaXN0b3J5RHJpdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBTZXJ2ZXJIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJ2ZXJIaXN0b3J5KGN1cnJlbnRMb2NhdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbm9vcCgpIHsgcmV0dXJuIHZvaWQgMDsgfTtcbiAgICB9O1xuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGdpdmVuIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBiZWZvcmUgcHVzaGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2ldKHV0aWxfMS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMucHVzaChsb2NhdGlvbik7XG4gICAgfTtcbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudExvY2F0aW9uO1xuICAgIH07XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUuYWRkQ29tcGxldGVDYWxsYmFjayA9IGZ1bmN0aW9uIChjb21wbGV0ZSkge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZUNhbGxiYWNrID0gY29tcGxldGU7XG4gICAgfTtcbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVDYWxsYmFjaygpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZlckhpc3Rvcnk7XG59KCkpO1xuZnVuY3Rpb24gY3JlYXRlU2VydmVySGlzdG9yeShsb2MpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckhpc3RvcnkobG9jID8gdXRpbF8xLmNyZWF0ZUxvY2F0aW9uKGxvYykgOiBudWxsKTtcbn1cbmV4cG9ydHMuY3JlYXRlU2VydmVySGlzdG9yeSA9IGNyZWF0ZVNlcnZlckhpc3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXJIaXN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvaGlzdG9yeS9saWIvc2VydmVySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYmFzZV8xID0gcmVxdWlyZSgnQGN5Y2xlL2Jhc2UnKTtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbi8qKlxuICogVGFrZXMgYSBgbWFpbmAgZnVuY3Rpb24gYW5kIGNpcmN1bGFybHkgY29ubmVjdHMgaXQgdG8gdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqIG9mIGRyaXZlciBmdW5jdGlvbnMuXG4gKlxuICogKipFeGFtcGxlOioqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtydW59IGZyb20gJ0BjeWNsZS94c3RyZWFtLXJ1bic7XG4gKiBjb25zdCBkaXNwb3NlID0gcnVuKG1haW4sIGRyaXZlcnMpO1xuICogLy8gLi4uXG4gKiBkaXNwb3NlKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgYG1haW5gIGZ1bmN0aW9uIGV4cGVjdHMgYSBjb2xsZWN0aW9uIG9mIFwic291cmNlXCIgc3RyZWFtcyAocmV0dXJuZWQgZnJvbVxuICogZHJpdmVycykgYXMgaW5wdXQsIGFuZCBzaG91bGQgcmV0dXJuIGEgY29sbGVjdGlvbiBvZiBcInNpbmtcIiBzdHJlYW1zICh0byBiZVxuICogZ2l2ZW4gdG8gZHJpdmVycykuIEEgXCJjb2xsZWN0aW9uIG9mIHN0cmVhbXNcIiBpcyBhIEphdmFTY3JpcHQgb2JqZWN0IHdoZXJlXG4gKiBrZXlzIG1hdGNoIHRoZSBkcml2ZXIgbmFtZXMgcmVnaXN0ZXJlZCBieSB0aGUgYGRyaXZlcnNgIG9iamVjdCwgYW5kIHZhbHVlc1xuICogYXJlIHRoZSBzdHJlYW1zLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbiBvZiBlYWNoIGRyaXZlciB0byBzZWUgbW9yZVxuICogZGV0YWlscyBvbiB3aGF0IHR5cGVzIG9mIHNvdXJjZXMgaXQgb3V0cHV0cyBhbmQgc2lua3MgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWFpbiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYHNvdXJjZXNgIGFzIGlucHV0IGFuZCBvdXRwdXRzXG4gKiBgc2lua3NgLlxuICogQHBhcmFtIHtPYmplY3R9IGRyaXZlcnMgYW4gb2JqZWN0IHdoZXJlIGtleXMgYXJlIGRyaXZlciBuYW1lcyBhbmQgdmFsdWVzXG4gKiBhcmUgZHJpdmVyIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGRpc3Bvc2UgZnVuY3Rpb24sIHVzZWQgdG8gdGVybWluYXRlIHRoZSBleGVjdXRpb24gb2YgdGhlXG4gKiBDeWNsZS5qcyBwcm9ncmFtLCBjbGVhbmluZyB1cCByZXNvdXJjZXMgdXNlZC5cbiAqIEBmdW5jdGlvbiBydW5cbiAqL1xuZnVuY3Rpb24gcnVuKG1haW4sIGRyaXZlcnMpIHtcbiAgICB2YXIgX2EgPSBiYXNlXzEuZGVmYXVsdChtYWluLCBkcml2ZXJzLCB7IHN0cmVhbUFkYXB0ZXI6IHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQgfSksIHJ1biA9IF9hLnJ1biwgc2lua3MgPSBfYS5zaW5rcztcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93WydDeWNsZWpzRGV2VG9vbF9zdGFydEdyYXBoU2VyaWFsaXplciddKSB7XG4gICAgICAgIHdpbmRvd1snQ3ljbGVqc0RldlRvb2xfc3RhcnRHcmFwaFNlcmlhbGl6ZXInXShzaW5rcyk7XG4gICAgfVxuICAgIHJldHVybiBydW4oKTtcbn1cbmV4cG9ydHMucnVuID0gcnVuO1xuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcHJlcGFyZXMgdGhlIEN5Y2xlIGFwcGxpY2F0aW9uIHRvIGJlIGV4ZWN1dGVkLiBUYWtlcyBhIGBtYWluYFxuICogZnVuY3Rpb24gYW5kIHByZXBhcmVzIHRvIGNpcmN1bGFybHkgY29ubmVjdHMgaXQgdG8gdGhlIGdpdmVuIGNvbGxlY3Rpb24gb2ZcbiAqIGRyaXZlciBmdW5jdGlvbnMuIEFzIGFuIG91dHB1dCwgYEN5Y2xlKClgIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhyZWVcbiAqIHByb3BlcnRpZXM6IGBzb3VyY2VzYCwgYHNpbmtzYCBhbmQgYHJ1bmAuIE9ubHkgd2hlbiBgcnVuKClgIGlzIGNhbGxlZCB3aWxsXG4gKiB0aGUgYXBwbGljYXRpb24gYWN0dWFsbHkgZXhlY3V0ZS4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24gb2YgYHJ1bigpYCBmb3JcbiAqIG1vcmUgZGV0YWlscy5cbiAqXG4gKiAqKkV4YW1wbGU6KipcbiAqIGBgYGpzXG4gKiBpbXBvcnQgQ3ljbGUgZnJvbSAnQGN5Y2xlL3hzdHJlYW0tcnVuJztcbiAqIGNvbnN0IHtzb3VyY2VzLCBzaW5rcywgcnVufSA9IEN5Y2xlKG1haW4sIGRyaXZlcnMpO1xuICogLy8gLi4uXG4gKiBjb25zdCBkaXNwb3NlID0gcnVuKCk7IC8vIEV4ZWN1dGVzIHRoZSBhcHBsaWNhdGlvblxuICogLy8gLi4uXG4gKiBkaXNwb3NlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYWluIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBgc291cmNlc2AgYXMgaW5wdXQgYW5kIG91dHB1dHNcbiAqIGBzaW5rc2AuXG4gKiBAcGFyYW0ge09iamVjdH0gZHJpdmVycyBhbiBvYmplY3Qgd2hlcmUga2V5cyBhcmUgZHJpdmVyIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIGFyZSBkcml2ZXIgZnVuY3Rpb25zLlxuICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCB0aHJlZSBwcm9wZXJ0aWVzOiBgc291cmNlc2AsIGBzaW5rc2AgYW5kXG4gKiBgcnVuYC4gYHNvdXJjZXNgIGlzIHRoZSBjb2xsZWN0aW9uIG9mIGRyaXZlciBzb3VyY2VzLCBgc2lua3NgIGlzIHRoZVxuICogY29sbGVjdGlvbiBvZiBkcml2ZXIgc2lua3MsIHRoZXNlIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcgb3IgdGVzdGluZy4gYHJ1bmBcbiAqIGlzIHRoZSBmdW5jdGlvbiB0aGF0IG9uY2UgY2FsbGVkIHdpbGwgZXhlY3V0ZSB0aGUgYXBwbGljYXRpb24uXG4gKiBAZnVuY3Rpb24gQ3ljbGVcbiAqL1xudmFyIEN5Y2xlID0gZnVuY3Rpb24gKG1haW4sIGRyaXZlcnMpIHtcbiAgICB2YXIgb3V0ID0gYmFzZV8xLmRlZmF1bHQobWFpbiwgZHJpdmVycywgeyBzdHJlYW1BZGFwdGVyOiB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0IH0pO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbJ0N5Y2xlanNEZXZUb29sX3N0YXJ0R3JhcGhTZXJpYWxpemVyJ10pIHtcbiAgICAgICAgd2luZG93WydDeWNsZWpzRGV2VG9vbF9zdGFydEdyYXBoU2VyaWFsaXplciddKG91dC5zaW5rcyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuQ3ljbGUucnVuID0gcnVuO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ3ljbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL3hzdHJlYW0tcnVuL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBsb2dUb0NvbnNvbGVFcnJvcihlcnIpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXJyLnN0YWNrIHx8IGVycjtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IodGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuICAgICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VTaW5rUHJveGllcyhkcml2ZXJzLCBzdHJlYW1BZGFwdGVyKSB7XG4gICAgdmFyIHNpbmtQcm94aWVzID0ge307XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIGRyaXZlcnMpIHtcbiAgICAgICAgaWYgKGRyaXZlcnMuaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xuICAgICAgICAgICAgdmFyIHN1YmplY3QgPSBzdHJlYW1BZGFwdGVyLm1ha2VTdWJqZWN0KCk7XG4gICAgICAgICAgICB2YXIgZHJpdmVyU3RyZWFtQWRhcHRlciA9IGRyaXZlcnNbbmFtZV8xXS5zdHJlYW1BZGFwdGVyIHx8IHN0cmVhbUFkYXB0ZXI7XG4gICAgICAgICAgICB2YXIgc3RyZWFtID0gZHJpdmVyU3RyZWFtQWRhcHRlci5hZGFwdChzdWJqZWN0LnN0cmVhbSwgc3RyZWFtQWRhcHRlci5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICAgICAgc2lua1Byb3hpZXNbbmFtZV8xXSA9IHtcbiAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICBvYnNlcnZlcjogc3ViamVjdC5vYnNlcnZlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbmtQcm94aWVzO1xufVxuZnVuY3Rpb24gY2FsbERyaXZlcnMoZHJpdmVycywgc2lua1Byb3hpZXMsIHN0cmVhbUFkYXB0ZXIpIHtcbiAgICB2YXIgc291cmNlcyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWVfMiBpbiBkcml2ZXJzKSB7XG4gICAgICAgIGlmIChkcml2ZXJzLmhhc093blByb3BlcnR5KG5hbWVfMikpIHtcbiAgICAgICAgICAgIHZhciBkcml2ZXJPdXRwdXQgPSBkcml2ZXJzW25hbWVfMl0oc2lua1Byb3hpZXNbbmFtZV8yXS5zdHJlYW0sIHN0cmVhbUFkYXB0ZXIsIG5hbWVfMik7XG4gICAgICAgICAgICB2YXIgZHJpdmVyU3RyZWFtQWRhcHRlciA9IGRyaXZlcnNbbmFtZV8yXS5zdHJlYW1BZGFwdGVyO1xuICAgICAgICAgICAgaWYgKGRyaXZlclN0cmVhbUFkYXB0ZXIgJiYgZHJpdmVyU3RyZWFtQWRhcHRlci5pc1ZhbGlkU3RyZWFtKGRyaXZlck91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzW25hbWVfMl0gPSBzdHJlYW1BZGFwdGVyLmFkYXB0KGRyaXZlck91dHB1dCwgZHJpdmVyU3RyZWFtQWRhcHRlci5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc291cmNlc1tuYW1lXzJdID0gZHJpdmVyT3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZXNbbmFtZV8yXSAmJiB0eXBlb2Ygc291cmNlc1tuYW1lXzJdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHNvdXJjZXNbbmFtZV8yXS5faXNDeWNsZVNvdXJjZSA9IG5hbWVfMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbn1cbmZ1bmN0aW9uIHJlcGxpY2F0ZU1hbnkoc2lua3MsIHNpbmtQcm94aWVzLCBzdHJlYW1BZGFwdGVyKSB7XG4gICAgdmFyIHNpbmtOYW1lcyA9IE9iamVjdC5rZXlzKHNpbmtzKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICEhc2lua1Byb3hpZXNbbmFtZV07IH0pO1xuICAgIHZhciBidWZmZXJzID0ge307XG4gICAgdmFyIHJlcGxpY2F0b3JzID0ge307XG4gICAgc2lua05hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgYnVmZmVyc1tuYW1lXSA9IHsgbmV4dDogW10sIGVycm9yOiBbXSwgY29tcGxldGU6IFtdIH07XG4gICAgICAgIHJlcGxpY2F0b3JzW25hbWVdID0ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGJ1ZmZlcnNbbmFtZV0ubmV4dC5wdXNoKHgpOyB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBidWZmZXJzW25hbWVdLmVycm9yLnB1c2goeCk7IH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGJ1ZmZlcnNbbmFtZV0uY29tcGxldGUucHVzaCh4KTsgfSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHNpbmtOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbUFkYXB0ZXIuc3RyZWFtU3Vic2NyaWJlKHNpbmtzW25hbWVdLCB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJlcGxpY2F0b3JzW25hbWVdLm5leHQoeCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dUb0NvbnNvbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJlcGxpY2F0b3JzW25hbWVdLmVycm9yKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0uY29tcGxldGUoeCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgZGlzcG9zZUZ1bmN0aW9ucyA9IHN1YnNjcmlwdGlvbnNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJzsgfSk7XG4gICAgc2lua05hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gc2lua1Byb3hpZXNbbmFtZV0ub2JzZXJ2ZXI7XG4gICAgICAgIHZhciBuZXh0ID0gb2JzZXJ2ZXIubmV4dDtcbiAgICAgICAgdmFyIGVycm9yID0gb2JzZXJ2ZXIuZXJyb3I7XG4gICAgICAgIHZhciBjb21wbGV0ZSA9IG9ic2VydmVyLmNvbXBsZXRlO1xuICAgICAgICBidWZmZXJzW25hbWVdLm5leHQuZm9yRWFjaChuZXh0KTtcbiAgICAgICAgYnVmZmVyc1tuYW1lXS5lcnJvci5mb3JFYWNoKGVycm9yKTtcbiAgICAgICAgYnVmZmVyc1tuYW1lXS5jb21wbGV0ZS5mb3JFYWNoKGNvbXBsZXRlKTtcbiAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0ubmV4dCA9IG5leHQ7XG4gICAgICAgIHJlcGxpY2F0b3JzW25hbWVdLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJlcGxpY2F0b3JzW25hbWVdLmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGlzcG9zZUZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkaXNwb3NlKSB7IHJldHVybiBkaXNwb3NlKCk7IH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBkaXNwb3NlU291cmNlcyhzb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgayBpbiBzb3VyY2VzKSB7XG4gICAgICAgIGlmIChzb3VyY2VzLmhhc093blByb3BlcnR5KGspICYmIHNvdXJjZXNba11cbiAgICAgICAgICAgICYmIHR5cGVvZiBzb3VyY2VzW2tdLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNvdXJjZXNba10uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIGlzT2JqZWN0RW1wdHkgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDsgfTtcbmZ1bmN0aW9uIEN5Y2xlKG1haW4sIGRyaXZlcnMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG1haW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBnaXZlbiB0byBDeWNsZSBtdXN0IGJlIHRoZSAnbWFpbicgXCIgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHJpdmVycyAhPT0gXCJvYmplY3RcIiB8fCBkcml2ZXJzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBnaXZlbiB0byBDeWNsZSBtdXN0IGJlIGFuIG9iamVjdCBcIiArXG4gICAgICAgICAgICBcIndpdGggZHJpdmVyIGZ1bmN0aW9ucyBhcyBwcm9wZXJ0aWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0RW1wdHkoZHJpdmVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IGdpdmVuIHRvIEN5Y2xlIG11c3QgYmUgYW4gb2JqZWN0IFwiICtcbiAgICAgICAgICAgIFwid2l0aCBhdCBsZWFzdCBvbmUgZHJpdmVyIGZ1bmN0aW9uIGRlY2xhcmVkIGFzIGEgcHJvcGVydHkuXCIpO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtQWRhcHRlciA9IG9wdGlvbnMuc3RyZWFtQWRhcHRlcjtcbiAgICBpZiAoIXN0cmVhbUFkYXB0ZXIgfHwgaXNPYmplY3RFbXB0eShzdHJlYW1BZGFwdGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlyZCBhcmd1bWVudCBnaXZlbiB0byBDeWNsZSBtdXN0IGJlIGFuIG9wdGlvbnMgb2JqZWN0IFwiICtcbiAgICAgICAgICAgIFwid2l0aCB0aGUgc3RyZWFtQWRhcHRlciBrZXkgc3VwcGxpZWQgd2l0aCBhIHZhbGlkIHN0cmVhbSBhZGFwdGVyLlwiKTtcbiAgICB9XG4gICAgdmFyIHNpbmtQcm94aWVzID0gbWFrZVNpbmtQcm94aWVzKGRyaXZlcnMsIHN0cmVhbUFkYXB0ZXIpO1xuICAgIHZhciBzb3VyY2VzID0gY2FsbERyaXZlcnMoZHJpdmVycywgc2lua1Byb3hpZXMsIHN0cmVhbUFkYXB0ZXIpO1xuICAgIHZhciBzaW5rcyA9IG1haW4oc291cmNlcyk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5DeWNsZWpzID0geyBzaW5rczogc2lua3MgfTtcbiAgICB9XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpc3Bvc2VSZXBsaWNhdGlvbiA9IHJlcGxpY2F0ZU1hbnkoc2lua3MsIHNpbmtQcm94aWVzLCBzdHJlYW1BZGFwdGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpc3Bvc2VTb3VyY2VzKHNvdXJjZXMpO1xuICAgICAgICAgICAgZGlzcG9zZVJlcGxpY2F0aW9uKCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBzaW5rczogc2lua3MsIHNvdXJjZXM6IHNvdXJjZXMsIHJ1bjogcnVuIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDeWNsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUveHN0cmVhbS1ydW4vfi9AY3ljbGUvYmFzZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmZ1bmN0aW9uIGlzU3RyaWN0bHlJblNjb3BlKG5hbWVzcGFjZSwgcGF0aCkge1xuICAgIHZhciBwYXRoUGFydHMgPSB1dGlsLnNwbGl0UGF0aChwYXRoKTtcbiAgICByZXR1cm4gbmFtZXNwYWNlLmV2ZXJ5KGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgIHJldHVybiBwYXRoUGFydHNbaV0gPT09IHY7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRGaWx0ZXJlZFBhdGgobmFtZXNwYWNlLCBwYXRoKSB7XG4gICAgdmFyIHBhdGhQYXJ0cyA9IHV0aWwuc3BsaXRQYXRoKHBhdGgpO1xuICAgIHJldHVybiAnLycgKyB1dGlsLmZpbHRlclBhdGgocGF0aFBhcnRzLCBuYW1lc3BhY2UpO1xufVxudmFyIFJvdXRlclNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVyU291cmNlKGhpc3RvcnkkLCBfbmFtZXNwYWNlLCBfY3JlYXRlSHJlZiwgX3J1blNBLCBfcm91dGVNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeSQgPSBoaXN0b3J5JDtcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gX25hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlSHJlZiA9IF9jcmVhdGVIcmVmO1xuICAgICAgICB0aGlzLl9ydW5TQSA9IF9ydW5TQTtcbiAgICAgICAgdGhpcy5fcm91dGVNYXRjaGVyID0gX3JvdXRlTWF0Y2hlcjtcbiAgICB9XG4gICAgUm91dGVyU291cmNlLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgIHZhciBzY29wZWROYW1lc3BhY2UgPSB0aGlzLl9uYW1lc3BhY2UuY29uY2F0KHV0aWwuc3BsaXRQYXRoKHBhdGhuYW1lKSk7XG4gICAgICAgIHZhciBzY29wZWRIaXN0b3J5JCA9IHRoaXMuX3J1blNBLnJlbWVtYmVyKHRoaXMuaGlzdG9yeSRcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX3BhdGggPSBfYS5wYXRobmFtZTtcbiAgICAgICAgICAgIHJldHVybiBpc1N0cmljdGx5SW5TY29wZShzY29wZWROYW1lc3BhY2UsIF9wYXRoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgY3JlYXRlSHJlZiA9IHRoaXMuX2NyZWF0ZUhyZWY7XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyU291cmNlKHNjb3BlZEhpc3RvcnkkLCBzY29wZWROYW1lc3BhY2UsIGNyZWF0ZUhyZWYsIHRoaXMuX3J1blNBLCB0aGlzLl9yb3V0ZU1hdGNoZXIpO1xuICAgIH07XG4gICAgUm91dGVyU291cmNlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAocm91dGVzLCByb3V0ZU1hdGNoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMuX25hbWVzcGFjZTtcbiAgICAgICAgdmFyIF9jcmVhdGVIcmVmID0gdGhpcy5fY3JlYXRlSHJlZjtcbiAgICAgICAgdmFyIGNyZWF0ZUhyZWYgPSB1dGlsLm1ha2VDcmVhdGVIcmVmKG5hbWVzcGFjZSwgX2NyZWF0ZUhyZWYpO1xuICAgICAgICB2YXIgbWF0Y2gkID0gdGhpcy5fcnVuU0EucmVtZW1iZXIodGhpcy5oaXN0b3J5JFxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVyID0gcm91dGVNYXRjaGVyIHx8IF90aGlzLl9yb3V0ZU1hdGNoZXI7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRQYXRoID0gZ2V0RmlsdGVyZWRQYXRoKG5hbWVzcGFjZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgICAgdmFyIF9hID0gbWF0Y2hlcihmaWx0ZXJlZFBhdGgsIHJvdXRlcyksIHBhdGggPSBfYS5wYXRoLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlLCBsb2NhdGlvbjogbG9jYXRpb24sIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICBtYXRjaCQuY3JlYXRlSHJlZiA9IGNyZWF0ZUhyZWY7XG4gICAgICAgIHJldHVybiBtYXRjaCQ7XG4gICAgfTtcbiAgICBSb3V0ZXJTb3VyY2UucHJvdG90eXBlLmNyZWF0ZUhyZWYgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdXRpbC5tYWtlQ3JlYXRlSHJlZih0aGlzLl9uYW1lc3BhY2UsIHRoaXMuX2NyZWF0ZUhyZWYpKHBhdGgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJvdXRlclNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLlJvdXRlclNvdXJjZSA9IFJvdXRlclNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvdXRlclNvdXJjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3ljbGljLXJvdXRlci9saWIvUm91dGVyU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtYWtlUm91dGVyRHJpdmVyXzEgPSByZXF1aXJlKCcuL21ha2VSb3V0ZXJEcml2ZXInKTtcbmV4cG9ydHMubWFrZVJvdXRlckRyaXZlciA9IG1ha2VSb3V0ZXJEcml2ZXJfMS5tYWtlUm91dGVyRHJpdmVyO1xudmFyIGhpc3RvcnlfMSA9IHJlcXVpcmUoJ0BjeWNsZS9oaXN0b3J5Jyk7XG5leHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IGhpc3RvcnlfMS5zdXBwb3J0c0hpc3Rvcnk7XG5leHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gaGlzdG9yeV8xLmNyZWF0ZUxvY2F0aW9uO1xuZXhwb3J0cy5jcmVhdGVTZXJ2ZXJIaXN0b3J5ID0gaGlzdG9yeV8xLmNyZWF0ZVNlcnZlckhpc3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3ljbGljLXJvdXRlci9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGhpc3RvcnlfMSA9IHJlcXVpcmUoJ0BjeWNsZS9oaXN0b3J5Jyk7XG52YXIgUm91dGVyU291cmNlXzEgPSByZXF1aXJlKCcuL1JvdXRlclNvdXJjZScpO1xuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYW4gbmV3IHJvdXRlciBkcml2ZXIgZnVuY3Rpb24gdXNpbmcgdGhlIHNhbWUgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBieSBAY3ljbGUvaGlzdG9yeS5cbiAqIEBwdWJsaWNcbiAqIEBtZXRob2QgbWFrZVJvdXRlckRyaXZlclxuICogQHJldHVybiB7cm91dGVyRHJpdmVyfSBUaGUgcm91dGVyIGRyaXZlciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBtYWtlUm91dGVyRHJpdmVyKGhpc3RvcnksIHJvdXRlTWF0Y2hlciwgb3B0aW9ucykge1xuICAgIHZhciBoaXN0b3J5RHJpdmVyID0gaGlzdG9yeV8xLm1ha2VIaXN0b3J5RHJpdmVyKGhpc3RvcnksIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBhY3R1YWwgcm91dGVyIGRyaXZlci5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHR5cGVkZWYge3JvdXRlckRyaXZlcn1cbiAgICAgKiBAbmFtZSByb3V0ZXJEcml2ZXJcbiAgICAgKiBAbWV0aG9kIHJvdXRlckRyaXZlclxuICAgICAqIEBwYXJhbSAge1N0cmVhbTxzdHJpbmd8TG9jYXRpb24+fSBzaW5rJCAtIFRoaXMgaXMgdGhlIHNhbWUgaW5wdXQgdGhhdCB0aGVcbiAgICAgKiBoaXN0b3J5IGRyaXZlciB3b3VsZCBleHBlY3QuXG4gICAgICogQHJldHVybiB7cm91dGVyQVBJfVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiByb3V0ZXJEcml2ZXIoc2luayQsIHJ1blNBKSB7XG4gICAgICAgIHZhciBoaXN0b3J5JCA9IHJ1blNBLnJlbWVtYmVyKGhpc3RvcnlEcml2ZXIoc2luayQsIHJ1blNBKSk7XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyU291cmNlXzEuUm91dGVyU291cmNlKGhpc3RvcnkkLCBbXSwgaGlzdG9yeS5jcmVhdGVIcmVmLCBydW5TQSwgcm91dGVNYXRjaGVyKTtcbiAgICB9O1xufVxuZXhwb3J0cy5tYWtlUm91dGVyRHJpdmVyID0gbWFrZVJvdXRlckRyaXZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2VSb3V0ZXJEcml2ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2N5Y2xpYy1yb3V0ZXIvbGliL21ha2VSb3V0ZXJEcml2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3BsaXRQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdCgnLycpLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5sZW5ndGggPiAwOyB9KTtcbn1cbmV4cG9ydHMuc3BsaXRQYXRoID0gc3BsaXRQYXRoO1xuZnVuY3Rpb24gZmlsdGVyUGF0aChwYXRoUGFydHMsIG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBwYXRoUGFydHMuZmlsdGVyKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBuYW1lc3BhY2UuaW5kZXhPZihwYXJ0KSA8IDA7IH0pLmpvaW4oJy8nKTtcbn1cbmV4cG9ydHMuZmlsdGVyUGF0aCA9IGZpbHRlclBhdGg7XG52YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHsgcmV0dXJuIHBhcmFtWzBdID09PSB2YWx1ZTsgfTtcbnZhciBzdGFydHNXaXRoMiA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgICByZXR1cm4gcGFyYW1bMF0gPT09IHZhbHVlMSAmJiBwYXJhbVsxXSA9PT0gdmFsdWUyO1xufTtcbmZ1bmN0aW9uIG1ha2VDcmVhdGVIcmVmKG5hbWVzcGFjZSwgX2NyZWF0ZUhyZWYpIHtcbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBIUkVGcyB0aGF0IGFyZSBwcm9wZXJseSBuYW1lc3BhY2VkXG4gICAgICogQHR5cGVkZWYge2NyZWF0ZUhyZWZ9XG4gICAgICogQG5hbWUgY3JlYXRlSHJlZlxuICAgICAqIEBtZXRob2QgY3JlYXRlSHJlZlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCAtIHRoZSBIUkVGIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgY3VycmVudFxuICAgICAqIG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gYSBmdWxseSBxdWFsaWZpZWQgSFJFRiBjb21wb3NlZCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICogbmFtZXNwYWNlIGFuZCB0aGUgcGF0aCBwcm92aWRlZFxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICAgICAgdmFyIGZ1bGxQYXRoID0gXCJcIiArIG5hbWVzcGFjZS5qb2luKCcvJykgKyBwYXRoO1xuICAgICAgICByZXR1cm4gc3RhcnRzV2l0aChmdWxsUGF0aCwgJy8nKSB8fCBzdGFydHNXaXRoMihmdWxsUGF0aCwgJyMnLCAnLycpXG4gICAgICAgICAgICA/IF9jcmVhdGVIcmVmKGZ1bGxQYXRoKVxuICAgICAgICAgICAgOiBfY3JlYXRlSHJlZignLycgKyBmdWxsUGF0aCk7XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZUNyZWF0ZUhyZWYgPSBtYWtlQ3JlYXRlSHJlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2N5Y2xpYy1yb3V0ZXIvbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvcHkgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9jb3B5JylcbiAgLCBtYXAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvbWFwJylcbiAgLCBjYWxsYWJsZSAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbGlkVmFsdWUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG5cbiAgLCBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgZGVmaW5lO1xuXG5kZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVzYywgYmluZFRvKSB7XG5cdHZhciB2YWx1ZSA9IHZhbGlkVmFsdWUoZGVzYykgJiYgY2FsbGFibGUoZGVzYy52YWx1ZSksIGRncztcblx0ZGdzID0gY29weShkZXNjKTtcblx0ZGVsZXRlIGRncy53cml0YWJsZTtcblx0ZGVsZXRlIGRncy52YWx1ZTtcblx0ZGdzLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkgcmV0dXJuIHZhbHVlO1xuXHRcdGRlc2MudmFsdWUgPSBiaW5kLmNhbGwodmFsdWUsIChiaW5kVG8gPT0gbnVsbCkgPyB0aGlzIDogdGhpc1tiaW5kVG9dKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkZXNjKTtcblx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0fTtcblx0cmV0dXJuIGRncztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb3BzLyosIGJpbmRUbyovKSB7XG5cdHZhciBiaW5kVG8gPSBhcmd1bWVudHNbMV07XG5cdHJldHVybiBtYXAocHJvcHMsIGZ1bmN0aW9uIChkZXNjLCBuYW1lKSB7XG5cdFx0cmV0dXJuIGRlZmluZShuYW1lLCBkZXNjLCBiaW5kVG8pO1xuXHR9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZC9hdXRvLWJpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvUG9zSW50ID0gcmVxdWlyZSgnLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyJylcbiAgLCB2YWx1ZSAgICA9IHJlcXVpcmUoJy4uLy4uL29iamVjdC92YWxpZC12YWx1ZScpXG5cbiAgLCBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2ZcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCovKSB7XG5cdHZhciBpLCBsLCBmcm9tSW5kZXgsIHZhbDtcblx0aWYgKHNlYXJjaEVsZW1lbnQgPT09IHNlYXJjaEVsZW1lbnQpIHsgLy9qc2xpbnQ6IGlnbm9yZVxuXHRcdHJldHVybiBpbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHRsID0gdG9Qb3NJbnQodmFsdWUodGhpcykubGVuZ3RoKTtcblx0ZnJvbUluZGV4ID0gYXJndW1lbnRzWzFdO1xuXHRpZiAoaXNOYU4oZnJvbUluZGV4KSkgZnJvbUluZGV4ID0gMDtcblx0ZWxzZSBpZiAoZnJvbUluZGV4ID49IDApIGZyb21JbmRleCA9IGZsb29yKGZyb21JbmRleCk7XG5cdGVsc2UgZnJvbUluZGV4ID0gdG9Qb3NJbnQodGhpcy5sZW5ndGgpIC0gZmxvb3IoYWJzKGZyb21JbmRleCkpO1xuXG5cdGZvciAoaSA9IGZyb21JbmRleDsgaSA8IGw7ICsraSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpKSB7XG5cdFx0XHR2YWwgPSB0aGlzW2ldO1xuXHRcdFx0aWYgKHZhbCAhPT0gdmFsKSByZXR1cm4gaTsgLy9qc2xpbnQ6IGlnbm9yZVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBNYXRoLnNpZ25cblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L21hdGgvc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNpZ24gPSBNYXRoLnNpZ247XG5cdGlmICh0eXBlb2Ygc2lnbiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKChzaWduKDEwKSA9PT0gMSkgJiYgKHNpZ24oLTIwKSA9PT0gLTEpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9tYXRoL3NpZ24vaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAoaXNOYU4odmFsdWUpIHx8ICh2YWx1ZSA9PT0gMCkpIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuICh2YWx1ZSA+IDApID8gMSA6IC0xO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L21hdGgvc2lnbi9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaWduID0gcmVxdWlyZSgnLi4vbWF0aC9zaWduJylcblxuICAsIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmIChpc05hTih2YWx1ZSkpIHJldHVybiAwO1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmICgodmFsdWUgPT09IDApIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuIHNpZ24odmFsdWUpICogZmxvb3IoYWJzKHZhbHVlKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvbnVtYmVyL3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG8taW50ZWdlcicpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG1heCgwLCB0b0ludGVnZXIodmFsdWUpKTsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L251bWJlci90by1wb3MtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gSW50ZXJuYWwgbWV0aG9kLCB1c2VkIGJ5IGl0ZXJhdGlvbiBmdW5jdGlvbnMuXG4vLyBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyIGZvdW5kIGluIG9iamVjdFxuLy8gT3B0aW9uYWxseSB0YWtlcyBjb21wYXJlRm4gdG8gaXRlcmF0ZSBvYmplY3QgaW4gc3BlY2lmaWMgb3JkZXJcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbGFibGUgPSByZXF1aXJlKCcuL3ZhbGlkLWNhbGxhYmxlJylcbiAgLCB2YWx1ZSAgICA9IHJlcXVpcmUoJy4vdmFsaWQtdmFsdWUnKVxuXG4gICwgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsIGtleXMgPSBPYmplY3Qua2V5c1xuICAsIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBkZWZWYWwpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChvYmosIGNiLyosIHRoaXNBcmcsIGNvbXBhcmVGbiovKSB7XG5cdFx0dmFyIGxpc3QsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIGNvbXBhcmVGbiA9IGFyZ3VtZW50c1szXTtcblx0XHRvYmogPSBPYmplY3QodmFsdWUob2JqKSk7XG5cdFx0Y2FsbGFibGUoY2IpO1xuXG5cdFx0bGlzdCA9IGtleXMob2JqKTtcblx0XHRpZiAoY29tcGFyZUZuKSB7XG5cdFx0XHRsaXN0LnNvcnQoKHR5cGVvZiBjb21wYXJlRm4gPT09ICdmdW5jdGlvbicpID8gYmluZC5jYWxsKGNvbXBhcmVGbiwgb2JqKSA6IHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSBtZXRob2QgPSBsaXN0W21ldGhvZF07XG5cdFx0cmV0dXJuIGNhbGwuY2FsbChtZXRob2QsIGxpc3QsIGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG5cdFx0XHRpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpKSByZXR1cm4gZGVmVmFsO1xuXHRcdFx0cmV0dXJuIGNhbGwuY2FsbChjYiwgdGhpc0FyZywgb2JqW2tleV0sIGtleSwgb2JqLCBpbmRleCk7XG5cdFx0fSk7XG5cdH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L19pdGVyYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiwgb2JqO1xuXHRpZiAodHlwZW9mIGFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRvYmogPSB7IGZvbzogJ3JheicgfTtcblx0YXNzaWduKG9iaiwgeyBiYXI6ICdkd2EnIH0sIHsgdHJ6eTogJ3RyenknIH0pO1xuXHRyZXR1cm4gKG9iai5mb28gKyBvYmouYmFyICsgb2JqLnRyenkpID09PSAncmF6ZHdhdHJ6eSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyAgPSByZXF1aXJlKCcuLi9rZXlzJylcbiAgLCB2YWx1ZSA9IHJlcXVpcmUoJy4uL3ZhbGlkLXZhbHVlJylcblxuICAsIG1heCA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXN0LCBzcmMvKiwg4oCmc3JjbiovKSB7XG5cdHZhciBlcnJvciwgaSwgbCA9IG1heChhcmd1bWVudHMubGVuZ3RoLCAyKSwgYXNzaWduO1xuXHRkZXN0ID0gT2JqZWN0KHZhbHVlKGRlc3QpKTtcblx0YXNzaWduID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdHRyeSB7IGRlc3Rba2V5XSA9IHNyY1trZXldOyB9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGU7XG5cdFx0fVxuXHR9O1xuXHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSB7XG5cdFx0c3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdGtleXMoc3JjKS5mb3JFYWNoKGFzc2lnbik7XG5cdH1cblx0aWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHRocm93IGVycm9yO1xuXHRyZXR1cm4gZGVzdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vYXNzaWduJylcbiAgLCB2YWx1ZSAgPSByZXF1aXJlKCcuL3ZhbGlkLXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuXHR2YXIgY29weSA9IE9iamVjdCh2YWx1ZShvYmopKTtcblx0aWYgKGNvcHkgIT09IG9iaikgcmV0dXJuIGNvcHk7XG5cdHJldHVybiBhc3NpZ24oe30sIG9iaik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2NvcHkuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdvcmthcm91bmQgZm9yIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTI4MDRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgc2hpbTtcblxuaWYgKCFyZXF1aXJlKCcuL3NldC1wcm90b3R5cGUtb2YvaXMtaW1wbGVtZW50ZWQnKSgpKSB7XG5cdHNoaW0gPSByZXF1aXJlKCcuL3NldC1wcm90b3R5cGUtb2Yvc2hpbScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBudWxsT2JqZWN0LCBwcm9wcywgZGVzYztcblx0aWYgKCFzaGltKSByZXR1cm4gY3JlYXRlO1xuXHRpZiAoc2hpbS5sZXZlbCAhPT0gMSkgcmV0dXJuIGNyZWF0ZTtcblxuXHRudWxsT2JqZWN0ID0ge307XG5cdHByb3BzID0ge307XG5cdGRlc2MgPSB7IGNvbmZpZ3VyYWJsZTogZmFsc2UsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSxcblx0XHR2YWx1ZTogdW5kZWZpbmVkIH07XG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcblx0XHRcdHByb3BzW25hbWVdID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm9wc1tuYW1lXSA9IGRlc2M7XG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhudWxsT2JqZWN0LCBwcm9wcyk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNoaW0sICdudWxsUG9seWZpbGwnLCB7IGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IG51bGxPYmplY3QgfSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BzKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZSgocHJvdG90eXBlID09PSBudWxsKSA/IG51bGxPYmplY3QgOiBwcm90b3R5cGUsIHByb3BzKTtcblx0fTtcbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXJhdGUnKSgnZm9yRWFjaCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2Zvci1lYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gRGVwcmVjYXRlZFxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJzsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hcCA9IHsgZnVuY3Rpb246IHRydWUsIG9iamVjdDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiAoKHggIT0gbnVsbCkgJiYgbWFwW3R5cGVvZiB4XSkgfHwgZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2lzLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5rZXlzXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoJ3ByaW1pdGl2ZScpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0cmV0dXJuIGtleXMob2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBPYmplY3Qob2JqZWN0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxhYmxlID0gcmVxdWlyZSgnLi92YWxpZC1jYWxsYWJsZScpXG4gICwgZm9yRWFjaCAgPSByZXF1aXJlKCcuL2Zvci1lYWNoJylcblxuICAsIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBjYi8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIG8gPSB7fSwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcblx0Y2FsbGFibGUoY2IpO1xuXHRmb3JFYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIG9iaiwgaW5kZXgpIHtcblx0XHRvW2tleV0gPSBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBrZXksIG9iaiwgaW5kZXgpO1xuXHR9KTtcblx0cmV0dXJuIG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBvYmopIHtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gc3JjKSBvYmpba2V5XSA9IHNyY1trZXldO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucy8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyA9PSBudWxsKSByZXR1cm47XG5cdFx0cHJvY2VzcyhPYmplY3Qob3B0aW9ucyksIHJlc3VsdCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJnLyosIOKApmFyZ3MqLykge1xuXHR2YXIgc2V0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAobmFtZSkgeyBzZXRbbmFtZV0gPSB0cnVlOyB9KTtcblx0cmV0dXJuIHNldDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0ciA9ICdyYXpkd2F0cnp5JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoKHN0ci5jb250YWlucygnZHdhJykgPT09IHRydWUpICYmIChzdHIuY29udGFpbnMoJ2ZvbycpID09PSBmYWxzZSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5kZXhPZiA9IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLyosIHBvc2l0aW9uKi8pIHtcblx0cmV0dXJuIGluZGV4T2YuY2FsbCh0aGlzLCBzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSkgPiAtMTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBjb250YWlucyAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCcuLycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIEFycmF5SXRlcmF0b3I7XG5cbkFycmF5SXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEFycmF5SXRlcmF0b3IpKSByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3IoYXJyLCBraW5kKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBhcnIpO1xuXHRpZiAoIWtpbmQpIGtpbmQgPSAndmFsdWUnO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsICdrZXkrdmFsdWUnKSkga2luZCA9ICdrZXkrdmFsdWUnO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsICdrZXknKSkga2luZCA9ICdrZXknO1xuXHRlbHNlIGtpbmQgPSAndmFsdWUnO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19raW5kX18nLCBkKCcnLCBraW5kKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihBcnJheUl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbkFycmF5SXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoQXJyYXlJdGVyYXRvciksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICd2YWx1ZScpIHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAna2V5K3ZhbHVlJykgcmV0dXJuIFtpLCB0aGlzLl9fbGlzdF9fW2ldXTtcblx0XHRyZXR1cm4gaTtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IEFycmF5IEl0ZXJhdG9yXSc7IH0pXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtaXRlcmF0b3IvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2VzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzJylcbiAgLCBjYWxsYWJsZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCBpc1N0cmluZyAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nL2lzLXN0cmluZycpXG4gICwgZ2V0ICAgICAgICAgPSByZXF1aXJlKCcuL2dldCcpXG5cbiAgLCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY2IvKiwgdGhpc0FyZyovKSB7XG5cdHZhciBtb2RlLCB0aGlzQXJnID0gYXJndW1lbnRzWzJdLCByZXN1bHQsIGRvQnJlYWssIGJyb2tlbiwgaSwgbCwgY2hhciwgY29kZTtcblx0aWYgKGlzQXJyYXkoaXRlcmFibGUpIHx8IGlzQXJndW1lbnRzKGl0ZXJhYmxlKSkgbW9kZSA9ICdhcnJheSc7XG5cdGVsc2UgaWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkgbW9kZSA9ICdzdHJpbmcnO1xuXHRlbHNlIGl0ZXJhYmxlID0gZ2V0KGl0ZXJhYmxlKTtcblxuXHRjYWxsYWJsZShjYik7XG5cdGRvQnJlYWsgPSBmdW5jdGlvbiAoKSB7IGJyb2tlbiA9IHRydWU7IH07XG5cdGlmIChtb2RlID09PSAnYXJyYXknKSB7XG5cdFx0c29tZS5jYWxsKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdmFsdWUsIGRvQnJlYWspO1xuXHRcdFx0aWYgKGJyb2tlbikgcmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChtb2RlID09PSAnc3RyaW5nJykge1xuXHRcdGwgPSBpdGVyYWJsZS5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuXHRcdFx0Y2hhciA9IGl0ZXJhYmxlW2ldO1xuXHRcdFx0aWYgKChpICsgMSkgPCBsKSB7XG5cdFx0XHRcdGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdGlmICgoY29kZSA+PSAweEQ4MDApICYmIChjb2RlIDw9IDB4REJGRikpIGNoYXIgKz0gaXRlcmFibGVbKytpXTtcblx0XHRcdH1cblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgY2hhciwgZG9CcmVhayk7XG5cdFx0XHRpZiAoYnJva2VuKSBicmVhaztcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHJlc3VsdCA9IGl0ZXJhYmxlLm5leHQoKTtcblxuXHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCByZXN1bHQudmFsdWUsIGRvQnJlYWspO1xuXHRcdGlmIChicm9rZW4pIHJldHVybjtcblx0XHRyZXN1bHQgPSBpdGVyYWJsZS5uZXh0KCk7XG5cdH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LWl0ZXJhdG9yL2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZSgnZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMnKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nJylcbiAgLCBBcnJheUl0ZXJhdG9yICA9IHJlcXVpcmUoJy4vYXJyYXknKVxuICAsIFN0cmluZ0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9zdHJpbmcnKVxuICAsIGl0ZXJhYmxlICAgICAgID0gcmVxdWlyZSgnLi92YWxpZC1pdGVyYWJsZScpXG4gICwgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykuaXRlcmF0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAodHlwZW9mIGl0ZXJhYmxlKG9iailbaXRlcmF0b3JTeW1ib2xdID09PSAnZnVuY3Rpb24nKSByZXR1cm4gb2JqW2l0ZXJhdG9yU3ltYm9sXSgpO1xuXHRpZiAoaXNBcmd1bWVudHMob2JqKSkgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG5cdGlmIChpc1N0cmluZyhvYmopKSByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKG9iaik7XG5cdHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtaXRlcmF0b3IvZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHMgICAgPSByZXF1aXJlKCdlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50cycpXG4gICwgaXNTdHJpbmcgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy9pcy1zdHJpbmcnKVxuICAsIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpLml0ZXJhdG9yXG5cbiAgLCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWxzZTtcblx0aWYgKGlzQXJyYXkodmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdGlmIChpc0FyZ3VtZW50cyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gKHR5cGVvZiB2YWx1ZVtpdGVyYXRvclN5bWJvbF0gPT09ICdmdW5jdGlvbicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtaXRlcmF0b3IvaXMtaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFua3MgQG1hdGhpYXNieW5lbnNcbi8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSNpdGVyYXRpbmctb3Zlci1zeW1ib2xzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJy4vJylcblxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgU3RyaW5nSXRlcmF0b3I7XG5cblN0cmluZ0l0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmdJdGVyYXRvcikpIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Ioc3RyKTtcblx0c3RyID0gU3RyaW5nKHN0cik7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgc3RyKTtcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fbGVuZ3RoX18nLCBkKCcnLCBzdHIubGVuZ3RoKSk7XG5cbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFN0cmluZ0l0ZXJhdG9yLCBJdGVyYXRvcik7XG5cblN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKFN0cmluZ0l0ZXJhdG9yKSxcblx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGVuZ3RoX18pIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHR0aGlzLl91bkJpbmQoKTtcblx0fSksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0dmFyIGNoYXIgPSB0aGlzLl9fbGlzdF9fW2ldLCBjb2RlO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPT09IHRoaXMuX19sZW5ndGhfXykgcmV0dXJuIGNoYXI7XG5cdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRpZiAoKGNvZGUgPj0gMHhEODAwKSAmJiAoY29kZSA8PSAweERCRkYpKSByZXR1cm4gY2hhciArIHRoaXMuX19saXN0X19bdGhpcy5fX25leHRJbmRleF9fKytdO1xuXHRcdHJldHVybiBjaGFyO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgU3RyaW5nIEl0ZXJhdG9yXSc7IH0pXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtaXRlcmF0b3Ivc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG1hcCwgaXRlcmF0b3IsIHJlc3VsdDtcblx0aWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0dHJ5IHtcblx0XHQvLyBXZWJLaXQgZG9lc24ndCBzdXBwb3J0IGFyZ3VtZW50cyBhbmQgY3Jhc2hlc1xuXHRcdG1hcCA9IG5ldyBNYXAoW1sncmF6JywgJ29uZSddLCBbJ2R3YScsICd0d28nXSwgWyd0cnp5JywgJ3RocmVlJ11dKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoU3RyaW5nKG1hcCkgIT09ICdbb2JqZWN0IE1hcF0nKSByZXR1cm4gZmFsc2U7XG5cdGlmIChtYXAuc2l6ZSAhPT0gMykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5jbGVhciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5kZWxldGUgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZW50cmllcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmdldCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5oYXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAua2V5cyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5zZXQgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAudmFsdWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cblx0aXRlcmF0b3IgPSBtYXAuZW50cmllcygpO1xuXHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdGlmIChyZXN1bHQuZG9uZSAhPT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0aWYgKCFyZXN1bHQudmFsdWUpIHJldHVybiBmYWxzZTtcblx0aWYgKHJlc3VsdC52YWx1ZVswXSAhPT0gJ3JheicpIHJldHVybiBmYWxzZTtcblx0aWYgKHJlc3VsdC52YWx1ZVsxXSAhPT0gJ29uZScpIHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LW1hcC9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEV4cG9ydHMgdHJ1ZSBpZiBlbnZpcm9ubWVudCBwcm92aWRlcyBuYXRpdmUgYE1hcGAgaW1wbGVtZW50YXRpb24sXG4vLyB3aGF0ZXZlciB0aGF0IGlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBNYXAoKSkgPT09ICdbb2JqZWN0IE1hcF0nKTtcbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LW1hcC9pcy1uYXRpdmUtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldCcpKCdrZXknLFxuXHQndmFsdWUnLCAna2V5K3ZhbHVlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LW1hcC9saWIvaXRlcmF0b3Ita2luZHMuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZXRQcm90b3R5cGVPZiAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgSXRlcmF0b3IgICAgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3InKVxuICAsIHRvU3RyaW5nVGFnU3ltYm9sID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpLnRvU3RyaW5nVGFnXG4gICwga2luZHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2l0ZXJhdG9yLWtpbmRzJylcblxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIHVuQmluZCA9IEl0ZXJhdG9yLnByb3RvdHlwZS5fdW5CaW5kXG4gICwgTWFwSXRlcmF0b3I7XG5cbk1hcEl0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWFwLCBraW5kKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXBJdGVyYXRvcikpIHJldHVybiBuZXcgTWFwSXRlcmF0b3IobWFwLCBraW5kKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBtYXAuX19tYXBLZXlzRGF0YV9fLCBtYXApO1xuXHRpZiAoIWtpbmQgfHwgIWtpbmRzW2tpbmRdKSBraW5kID0gJ2tleSt2YWx1ZSc7XG5cdGRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdF9fa2luZF9fOiBkKCcnLCBraW5kKSxcblx0XHRfX3ZhbHVlc19fOiBkKCd3JywgbWFwLl9fbWFwVmFsdWVzRGF0YV9fKVxuXHR9KTtcbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKE1hcEl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbk1hcEl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKE1hcEl0ZXJhdG9yKSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gJ3ZhbHVlJykgcmV0dXJuIHRoaXMuX192YWx1ZXNfX1tpXTtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gJ2tleScpIHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdHJldHVybiBbdGhpcy5fX2xpc3RfX1tpXSwgdGhpcy5fX3ZhbHVlc19fW2ldXTtcblx0fSksXG5cdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX192YWx1ZXNfXyA9IG51bGw7XG5cdFx0dW5CaW5kLmNhbGwodGhpcyk7XG5cdH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBNYXAgSXRlcmF0b3JdJzsgfSlcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcEl0ZXJhdG9yLnByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsXG5cdGQoJ2MnLCAnTWFwIEl0ZXJhdG9yJykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1tYXAvbGliL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xlYXIgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L2FycmF5LyMvY2xlYXInKVxuICAsIGVJbmRleE9mICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgY2FsbGFibGUgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsaWRWYWx1ZSAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBlZSAgICAgICAgICAgICA9IHJlcXVpcmUoJ2V2ZW50LWVtaXR0ZXInKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpXG4gICwgaXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3IvdmFsaWQtaXRlcmFibGUnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL2Zvci1vZicpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCcuL2xpYi9pdGVyYXRvcicpXG4gICwgaXNOYXRpdmUgICAgICAgPSByZXF1aXJlKCcuL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZCcpXG5cbiAgLCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICwgTWFwUG9seTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBQb2x5ID0gZnVuY3Rpb24gKC8qaXRlcmFibGUqLykge1xuXHR2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF0sIGtleXMsIHZhbHVlcywgc2VsZjtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcFBvbHkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJ1Y3RvciByZXF1aXJlcyBcXCduZXdcXCcnKTtcblx0aWYgKGlzTmF0aXZlICYmIHNldFByb3RvdHlwZU9mICYmIChNYXAgIT09IE1hcFBvbHkpKSB7XG5cdFx0c2VsZiA9IHNldFByb3RvdHlwZU9mKG5ldyBNYXAoKSwgZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuXHR9IGVsc2Uge1xuXHRcdHNlbGYgPSB0aGlzO1xuXHR9XG5cdGlmIChpdGVyYWJsZSAhPSBudWxsKSBpdGVyYXRvcihpdGVyYWJsZSk7XG5cdGRlZmluZVByb3BlcnRpZXMoc2VsZiwge1xuXHRcdF9fbWFwS2V5c0RhdGFfXzogZCgnYycsIGtleXMgPSBbXSksXG5cdFx0X19tYXBWYWx1ZXNEYXRhX186IGQoJ2MnLCB2YWx1ZXMgPSBbXSlcblx0fSk7XG5cdGlmICghaXRlcmFibGUpIHJldHVybiBzZWxmO1xuXHRmb3JPZihpdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dmFyIGtleSA9IHZhbGlkVmFsdWUodmFsdWUpWzBdO1xuXHRcdHZhbHVlID0gdmFsdWVbMV07XG5cdFx0aWYgKGVJbmRleE9mLmNhbGwoa2V5cywga2V5KSAhPT0gLTEpIHJldHVybjtcblx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdH0sIHNlbGYpO1xuXHRyZXR1cm4gc2VsZjtcbn07XG5cbmlmIChpc05hdGl2ZSkge1xuXHRpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKE1hcFBvbHksIE1hcCk7XG5cdE1hcFBvbHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNYXAucHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGQoTWFwUG9seSlcblx0fSk7XG59XG5cbmVlKGRlZmluZVByb3BlcnRpZXMoTWFwUG9seS5wcm90b3R5cGUsIHtcblx0Y2xlYXI6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fX21hcEtleXNEYXRhX18ubGVuZ3RoKSByZXR1cm47XG5cdFx0Y2xlYXIuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXyk7XG5cdFx0Y2xlYXIuY2FsbCh0aGlzLl9fbWFwVmFsdWVzRGF0YV9fKTtcblx0XHR0aGlzLmVtaXQoJ19jbGVhcicpO1xuXHR9KSxcblx0ZGVsZXRlOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpO1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcblx0XHR0aGlzLl9fbWFwS2V5c0RhdGFfXy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMuX19tYXBWYWx1ZXNEYXRhX18uc3BsaWNlKGluZGV4LCAxKTtcblx0XHR0aGlzLmVtaXQoJ19kZWxldGUnLCBpbmRleCwga2V5KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSksXG5cdGVudHJpZXM6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKTsgfSksXG5cdGZvckVhY2g6IGQoZnVuY3Rpb24gKGNiLyosIHRoaXNBcmcqLykge1xuXHRcdHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdLCBpdGVyYXRvciwgcmVzdWx0O1xuXHRcdGNhbGxhYmxlKGNiKTtcblx0XHRpdGVyYXRvciA9IHRoaXMuZW50cmllcygpO1xuXHRcdHJlc3VsdCA9IGl0ZXJhdG9yLl9uZXh0KCk7XG5cdFx0d2hpbGUgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHRoaXMuX19tYXBWYWx1ZXNEYXRhX19bcmVzdWx0XSxcblx0XHRcdFx0dGhpcy5fX21hcEtleXNEYXRhX19bcmVzdWx0XSwgdGhpcyk7XG5cdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5fbmV4dCgpO1xuXHRcdH1cblx0fSksXG5cdGdldDogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KTtcblx0XHRpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG5cdFx0cmV0dXJuIHRoaXMuX19tYXBWYWx1ZXNEYXRhX19baW5kZXhdO1xuXHR9KSxcblx0aGFzOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gKGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSkgIT09IC0xKTtcblx0fSksXG5cdGtleXM6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsICdrZXknKTsgfSksXG5cdHNldDogZChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSksIGVtaXQ7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0aW5kZXggPSB0aGlzLl9fbWFwS2V5c0RhdGFfXy5wdXNoKGtleSkgLSAxO1xuXHRcdFx0ZW1pdCA9IHRydWU7XG5cdFx0fVxuXHRcdHRoaXMuX19tYXBWYWx1ZXNEYXRhX19baW5kZXhdID0gdmFsdWU7XG5cdFx0aWYgKGVtaXQpIHRoaXMuZW1pdCgnX2FkZCcsIGluZGV4LCBrZXkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9KSxcblx0c2l6ZTogZC5ncyhmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fbWFwS2V5c0RhdGFfXy5sZW5ndGg7IH0pLFxuXHR2YWx1ZXM6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsICd2YWx1ZScpOyB9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgTWFwXSc7IH0pXG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwUG9seS5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgZChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmVudHJpZXMoKTtcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBQb2x5LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkKCdjJywgJ01hcCcpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtbWFwL3BvbHlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRUeXBlcyA9IHsgb2JqZWN0OiB0cnVlLCBzeW1ib2w6IHRydWUgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHN5bWJvbCA9IFN5bWJvbCgndGVzdCBzeW1ib2wnKTtcblx0dHJ5IHsgU3RyaW5nKHN5bWJvbCk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gUmV0dXJuICd0cnVlJyBhbHNvIGZvciBwb2x5ZmlsbHNcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wuaXRlcmF0b3JdKSByZXR1cm4gZmFsc2U7XG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlXSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZ10pIHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXN5bWJvbC9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xuXHRpZiAoIXgpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiB4ID09PSAnc3ltYm9sJykgcmV0dXJuIHRydWU7XG5cdGlmICgheC5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnU3ltYm9sJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKHhbeC5jb25zdHJ1Y3Rvci50b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXN5bWJvbC9pcy1zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBFUzIwMTUgU3ltYm9sIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCAob3IgcGFydGlhbGx5IHN1cHBvcnQgaXQpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgdmFsaWRhdGVTeW1ib2wgPSByZXF1aXJlKCcuL3ZhbGlkYXRlLXN5bWJvbCcpXG5cbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgb2JqUHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZVxuICAsIE5hdGl2ZVN5bWJvbCwgU3ltYm9sUG9seWZpbGwsIEhpZGRlblN5bWJvbCwgZ2xvYmFsU3ltYm9scyA9IGNyZWF0ZShudWxsKVxuICAsIGlzTmF0aXZlU2FmZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0TmF0aXZlU3ltYm9sID0gU3ltYm9sO1xuXHR0cnkge1xuXHRcdFN0cmluZyhOYXRpdmVTeW1ib2woKSk7XG5cdFx0aXNOYXRpdmVTYWZlID0gdHJ1ZTtcblx0fSBjYXRjaCAoaWdub3JlKSB7fVxufVxuXG52YXIgZ2VuZXJhdGVOYW1lID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIGNyZWF0ZWQgPSBjcmVhdGUobnVsbCk7XG5cdHJldHVybiBmdW5jdGlvbiAoZGVzYykge1xuXHRcdHZhciBwb3N0Zml4ID0gMCwgbmFtZSwgaWUxMUJ1Z1dvcmthcm91bmQ7XG5cdFx0d2hpbGUgKGNyZWF0ZWRbZGVzYyArIChwb3N0Zml4IHx8ICcnKV0pICsrcG9zdGZpeDtcblx0XHRkZXNjICs9IChwb3N0Zml4IHx8ICcnKTtcblx0XHRjcmVhdGVkW2Rlc2NdID0gdHJ1ZTtcblx0XHRuYW1lID0gJ0BAJyArIGRlc2M7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqUHJvdG90eXBlLCBuYW1lLCBkLmdzKG51bGwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gRm9yIElFMTEgaXNzdWUgc2VlOlxuXHRcdFx0Ly8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2tkZXRhaWwvdmlldy8xOTI4NTA4L1xuXHRcdFx0Ly8gICAgaWUxMS1icm9rZW4tZ2V0dGVycy1vbi1kb20tb2JqZWN0c1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTJcblx0XHRcdGlmIChpZTExQnVnV29ya2Fyb3VuZCkgcmV0dXJuO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSB0cnVlO1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZCh2YWx1ZSkpO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSBmYWxzZTtcblx0XHR9KSk7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH07XG59KCkpO1xuXG4vLyBJbnRlcm5hbCBjb25zdHJ1Y3RvciAobm90IG9uZSBleHBvc2VkKSBmb3IgY3JlYXRpbmcgU3ltYm9sIGluc3RhbmNlcy5cbi8vIFRoaXMgb25lIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYHNvbWVTeW1ib2wgaW5zdGFuY2VvZiBTeW1ib2xgIGFsd2F5cyByZXR1cm4gZmFsc2VcbkhpZGRlblN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xuXHRpZiAodGhpcyBpbnN0YW5jZW9mIEhpZGRlblN5bWJvbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignVHlwZUVycm9yOiBTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcblx0cmV0dXJuIFN5bWJvbFBvbHlmaWxsKGRlc2NyaXB0aW9uKTtcbn07XG5cbi8vIEV4cG9zZWQgYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIChyZXR1cm5zIGluc3RhbmNlcyBvZiBIaWRkZW5TeW1ib2wpXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbFBvbHlmaWxsID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlRXJyb3I6IFN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuXHRpZiAoaXNOYXRpdmVTYWZlKSByZXR1cm4gTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcblx0c3ltYm9sID0gY3JlYXRlKEhpZGRlblN5bWJvbC5wcm90b3R5cGUpO1xuXHRkZXNjcmlwdGlvbiA9IChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcoZGVzY3JpcHRpb24pKTtcblx0cmV0dXJuIGRlZmluZVByb3BlcnRpZXMoc3ltYm9sLCB7XG5cdFx0X19kZXNjcmlwdGlvbl9fOiBkKCcnLCBkZXNjcmlwdGlvbiksXG5cdFx0X19uYW1lX186IGQoJycsIGdlbmVyYXRlTmFtZShkZXNjcmlwdGlvbikpXG5cdH0pO1xufTtcbmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwsIHtcblx0Zm9yOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRpZiAoZ2xvYmFsU3ltYm9sc1trZXldKSByZXR1cm4gZ2xvYmFsU3ltYm9sc1trZXldO1xuXHRcdHJldHVybiAoZ2xvYmFsU3ltYm9sc1trZXldID0gU3ltYm9sUG9seWZpbGwoU3RyaW5nKGtleSkpKTtcblx0fSksXG5cdGtleUZvcjogZChmdW5jdGlvbiAocykge1xuXHRcdHZhciBrZXk7XG5cdFx0dmFsaWRhdGVTeW1ib2wocyk7XG5cdFx0Zm9yIChrZXkgaW4gZ2xvYmFsU3ltYm9scykgaWYgKGdsb2JhbFN5bWJvbHNba2V5XSA9PT0gcykgcmV0dXJuIGtleTtcblx0fSksXG5cblx0Ly8gSWYgdGhlcmUncyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgZ2l2ZW4gc3ltYm9sLCBsZXQncyBmYWxsYmFjayB0byBpdFxuXHQvLyB0byBlbnN1cmUgcHJvcGVyIGludGVyb3BlcmFiaWxpdHkgd2l0aCBvdGhlciBuYXRpdmUgZnVuY3Rpb25zIGUuZy4gQXJyYXkuZnJvbVxuXHRoYXNJbnN0YW5jZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaGFzSW5zdGFuY2UpIHx8IFN5bWJvbFBvbHlmaWxsKCdoYXNJbnN0YW5jZScpKSxcblx0aXNDb25jYXRTcHJlYWRhYmxlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUpIHx8XG5cdFx0U3ltYm9sUG9seWZpbGwoJ2lzQ29uY2F0U3ByZWFkYWJsZScpKSxcblx0aXRlcmF0b3I6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLml0ZXJhdG9yKSB8fCBTeW1ib2xQb2x5ZmlsbCgnaXRlcmF0b3InKSksXG5cdG1hdGNoOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5tYXRjaCkgfHwgU3ltYm9sUG9seWZpbGwoJ21hdGNoJykpLFxuXHRyZXBsYWNlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5yZXBsYWNlKSB8fCBTeW1ib2xQb2x5ZmlsbCgncmVwbGFjZScpKSxcblx0c2VhcmNoOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zZWFyY2gpIHx8IFN5bWJvbFBvbHlmaWxsKCdzZWFyY2gnKSksXG5cdHNwZWNpZXM6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwZWNpZXMpIHx8IFN5bWJvbFBvbHlmaWxsKCdzcGVjaWVzJykpLFxuXHRzcGxpdDogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc3BsaXQpIHx8IFN5bWJvbFBvbHlmaWxsKCdzcGxpdCcpKSxcblx0dG9QcmltaXRpdmU6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvUHJpbWl0aXZlKSB8fCBTeW1ib2xQb2x5ZmlsbCgndG9QcmltaXRpdmUnKSksXG5cdHRvU3RyaW5nVGFnOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC50b1N0cmluZ1RhZykgfHwgU3ltYm9sUG9seWZpbGwoJ3RvU3RyaW5nVGFnJykpLFxuXHR1bnNjb3BhYmxlczogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudW5zY29wYWJsZXMpIHx8IFN5bWJvbFBvbHlmaWxsKCd1bnNjb3BhYmxlcycpKVxufSk7XG5cbi8vIEludGVybmFsIHR3ZWFrcyBmb3IgcmVhbCBzeW1ib2wgcHJvZHVjZXJcbmRlZmluZVByb3BlcnRpZXMoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChTeW1ib2xQb2x5ZmlsbCksXG5cdHRvU3RyaW5nOiBkKCcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fbmFtZV9fOyB9KVxufSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGV4cG9zZWQgb24gU3ltYm9sLnByb3RvdHlwZVxuLy8gVGhleSB3b24ndCBiZSBhY2Nlc3NpYmxlIG9uIHByb2R1Y2VkIHN5bWJvbCBpbnN0YW5jZXMgYXMgdGhleSBkZXJpdmUgZnJvbSBIaWRkZW5TeW1ib2wucHJvdG90eXBlXG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwge1xuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnU3ltYm9sICgnICsgdmFsaWRhdGVTeW1ib2wodGhpcykuX19kZXNjcmlwdGlvbl9fICsgJyknOyB9KSxcblx0dmFsdWVPZjogZChmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZVN5bWJvbCh0aGlzKTsgfSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSwgZCgnJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgc3ltYm9sID0gdmFsaWRhdGVTeW1ib2wodGhpcyk7XG5cdGlmICh0eXBlb2Ygc3ltYm9sID09PSAnc3ltYm9sJykgcmV0dXJuIHN5bWJvbDtcblx0cmV0dXJuIHN5bWJvbC50b1N0cmluZygpO1xufSkpO1xuZGVmaW5lUHJvcGVydHkoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywgZCgnYycsICdTeW1ib2wnKSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdG9uIG9mIHRvUHJpbWl0aXZlIGFuZCB0b1N0cmluZ1RhZyBmb3IgcmV0dXJuZWQgc3ltYm9sIGluc3RhbmNlc1xuZGVmaW5lUHJvcGVydHkoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsXG5cdGQoJ2MnLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWddKSk7XG5cbi8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRvIGRlZmluZSBgdG9QcmltaXRpdmVgIGFzIGxhc3Qgb25lLCBhcyBzb21lIGltcGxlbWVudGF0aW9uc1xuLy8gaW1wbGVtZW50IGB0b1ByaW1pdGl2ZWAgbmF0aXZlbHkgd2l0aG91dCBpbXBsZW1lbnRpbmcgYHRvU3RyaW5nVGFnYCAob3Igb3RoZXIgc3BlY2lmaWVkIHN5bWJvbHMpXG4vLyBBbmQgdGhhdCBtYXkgaW52b2tlIGVycm9yIGluIGRlZmluaXRpb24gZmxvdzpcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTE2NDE0NjE0OVxuZGVmaW5lUHJvcGVydHkoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmUsXG5cdGQoJ2MnLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmVdKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXN5bWJvbC9wb2x5ZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pcy1zeW1ib2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgYSBzeW1ib2xcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXN5bWJvbC92YWxpZGF0ZS1zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIGNhbGxhYmxlID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuXG4gICwgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHksIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgZGVzY3JpcHRvciA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfVxuXG4gICwgb24sIG9uY2UsIG9mZiwgZW1pdCwgbWV0aG9kcywgZGVzY3JpcHRvcnMsIGJhc2U7XG5cbm9uID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSB7XG5cdFx0ZGF0YSA9IGRlc2NyaXB0b3IudmFsdWUgPSBjcmVhdGUobnVsbCk7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fZWVfXycsIGRlc2NyaXB0b3IpO1xuXHRcdGRlc2NyaXB0b3IudmFsdWUgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0fVxuXHRpZiAoIWRhdGFbdHlwZV0pIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcjtcblx0ZWxzZSBpZiAodHlwZW9mIGRhdGFbdHlwZV0gPT09ICdvYmplY3QnKSBkYXRhW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRlbHNlIGRhdGFbdHlwZV0gPSBbZGF0YVt0eXBlXSwgbGlzdGVuZXJdO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxub25jZSA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgb25jZSwgc2VsZjtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cdHNlbGYgPSB0aGlzO1xuXHRvbi5jYWxsKHRoaXMsIHR5cGUsIG9uY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmLmNhbGwoc2VsZiwgdHlwZSwgb25jZSk7XG5cdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJndW1lbnRzKTtcblx0fSk7XG5cblx0b25jZS5fX2VlT25jZUxpc3RlbmVyX18gPSBsaXN0ZW5lcjtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vZmYgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGEsIGxpc3RlbmVycywgY2FuZGlkYXRlLCBpO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSByZXR1cm4gdGhpcztcblx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHRpZiAoIWRhdGFbdHlwZV0pIHJldHVybiB0aGlzO1xuXHRsaXN0ZW5lcnMgPSBkYXRhW3R5cGVdO1xuXG5cdGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAoaSA9IDA7IChjYW5kaWRhdGUgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGlmICgoY2FuZGlkYXRlID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0XHQoY2FuZGlkYXRlLl9fZWVPbmNlTGlzdGVuZXJfXyA9PT0gbGlzdGVuZXIpKSB7XG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAyKSBkYXRhW3R5cGVdID0gbGlzdGVuZXJzW2kgPyAwIDogMV07XG5cdFx0XHRcdGVsc2UgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKChsaXN0ZW5lcnMgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHQobGlzdGVuZXJzLl9fZWVPbmNlTGlzdGVuZXJfXyA9PT0gbGlzdGVuZXIpKSB7XG5cdFx0XHRkZWxldGUgZGF0YVt0eXBlXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHR2YXIgaSwgbCwgbGlzdGVuZXIsIGxpc3RlbmVycywgYXJncztcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSByZXR1cm47XG5cdGxpc3RlbmVycyA9IHRoaXMuX19lZV9fW3R5cGVdO1xuXHRpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuXG5cdGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnb2JqZWN0Jykge1xuXHRcdGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG5cdFx0bGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG5cdFx0Zm9yIChpID0gMDsgKGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fVxufTtcblxubWV0aG9kcyA9IHtcblx0b246IG9uLFxuXHRvbmNlOiBvbmNlLFxuXHRvZmY6IG9mZixcblx0ZW1pdDogZW1pdFxufTtcblxuZGVzY3JpcHRvcnMgPSB7XG5cdG9uOiBkKG9uKSxcblx0b25jZTogZChvbmNlKSxcblx0b2ZmOiBkKG9mZiksXG5cdGVtaXQ6IGQoZW1pdClcbn07XG5cbmJhc2UgPSBkZWZpbmVQcm9wZXJ0aWVzKHt9LCBkZXNjcmlwdG9ycyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uIChvKSB7XG5cdHJldHVybiAobyA9PSBudWxsKSA/IGNyZWF0ZShiYXNlKSA6IGRlZmluZVByb3BlcnRpZXMoT2JqZWN0KG8pLCBkZXNjcmlwdG9ycyk7XG59O1xuZXhwb3J0cy5tZXRob2RzID0gbWV0aG9kcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ldmVudC1lbWl0dGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgbG9vcEFzeW5jID0gZXhwb3J0cy5sb29wQXN5bmMgPSBmdW5jdGlvbiBsb29wQXN5bmModHVybnMsIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50VHVybiA9IDAsXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgdmFyIGlzU3luYyA9IGZhbHNlLFxuICAgICAgaGFzTmV4dCA9IGZhbHNlLFxuICAgICAgZG9uZUFyZ3MgPSB2b2lkIDA7XG5cbiAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlzRG9uZSA9IHRydWU7XG5cbiAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgZG9uZUFyZ3MgPSBhcmdzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH07XG5cbiAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGhhc05leHQgPSB0cnVlO1xuXG4gICAgaWYgKGlzU3luYykgcmV0dXJuOyAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuXG4gICAgaXNTeW5jID0gdHJ1ZTtcblxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgd29yayhjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBpc1N5bmMgPSBmYWxzZTtcblxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxvb3AgZmluaXNoZWQgc3luY2hyb25vdXNseS5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgX3RvQ29uc3VtYWJsZUFycmF5KGRvbmVBcmdzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBuZXh0KCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGV4cG9ydHMuc3RhcnRMaXN0ZW5lciA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dldFVzZXJDb25maXJtYXRpb24nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ287XG4gIH1cbn0pO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBpID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xuXG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGkgPj0gMCA/IGkgOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGVuc3VyZVNsYXNoID0gZnVuY3Rpb24gZW5zdXJlU2xhc2goKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcblxuICBpZiAoKDAsIF9QYXRoVXRpbHMuaXNBYnNvbHV0ZVBhdGgpKHBhdGgpKSByZXR1cm4gdHJ1ZTtcblxuICByZXBsYWNlSGFzaFBhdGgoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKHF1ZXJ5S2V5KSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGtleSA9ICgwLCBfUGF0aFV0aWxzLmdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCkocGF0aCwgcXVlcnlLZXkpO1xuXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKGtleSkge1xuICAgIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCkocGF0aCwgcXVlcnlLZXkpO1xuICAgIHN0YXRlID0gKDAsIF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKShrZXkpO1xuICB9XG5cbiAgdmFyIGluaXQgPSAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKHBhdGgpO1xuICBpbml0LnN0YXRlID0gc3RhdGU7XG5cbiAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoaW5pdCwgdW5kZWZpbmVkLCBrZXkpO1xufTtcblxudmFyIHByZXZMb2NhdGlvbiA9IHZvaWQgMDtcblxudmFyIHN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBxdWVyeUtleSkge1xuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaWYgKCFlbnN1cmVTbGFzaCgpKSByZXR1cm47IC8vIEhhc2ggcGF0aCBtdXN0IGFsd2F5cyBiZWdpbiB3aXRoIGEgL1xuXG4gICAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbihxdWVyeUtleSk7XG5cbiAgICBpZiAocHJldkxvY2F0aW9uICYmIGN1cnJlbnRMb2NhdGlvbi5rZXkgJiYgcHJldkxvY2F0aW9uLmtleSA9PT0gY3VycmVudExvY2F0aW9uLmtleSkgcmV0dXJuOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBoYXNoY2hhbmdlIGV2ZW50c1xuXG4gICAgcHJldkxvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuXG4gICAgbGlzdGVuZXIoY3VycmVudExvY2F0aW9uKTtcbiAgfTtcblxuICBlbnN1cmVTbGFzaCgpO1xuICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgfTtcbn07XG5cbnZhciB1cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBxdWVyeUtleSwgdXBkYXRlSGFzaCkge1xuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcblxuICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhdGggPSAoMCwgX1BhdGhVdGlscy5hZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKShwYXRoLCBxdWVyeUtleSwga2V5KTtcbiAgICAoMCwgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUpKGtleSwgc3RhdGUpO1xuICB9XG5cbiAgcHJldkxvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgdXBkYXRlSGFzaChwYXRoKTtcbn07XG5cbnZhciBwdXNoTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbiwgcXVlcnlLZXkpIHtcbiAgcmV0dXJuIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBxdWVyeUtleSwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoZ2V0SGFzaFBhdGgoKSAhPT0gcGF0aCkge1xuICAgICAgcHVzaEhhc2hQYXRoKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoIHVzaW5nIGhhc2ggaGlzdG9yeScpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgcmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24sIHF1ZXJ5S2V5KSB7XG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgcXVlcnlLZXksIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKGdldEhhc2hQYXRoKCkgIT09IHBhdGgpIHJlcGxhY2VIYXNoUGF0aChwYXRoKTtcbiAgfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9IYXNoUHJvdG9jb2wuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdvID0gZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX0Jyb3dzZXJQcm90b2NvbCA9IHJlcXVpcmUoJy4vQnJvd3NlclByb3RvY29sJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2V0VXNlckNvbmZpcm1hdGlvbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dvJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Jyb3dzZXJQcm90b2NvbC5nbztcbiAgfVxufSk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikod2luZG93LmxvY2F0aW9uKTtcbn07XG5cbnZhciBwdXNoTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xuICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgcmV0dXJuIGZhbHNlOyAvLyBEb24ndCB1cGRhdGUgbG9jYXRpb25cbn07XG5cbnZhciByZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpO1xuICByZXR1cm4gZmFsc2U7IC8vIERvbid0IHVwZGF0ZSBsb2NhdGlvblxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvUmVmcmVzaFByb3RvY29sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0Jyb3dzZXJQcm90b2NvbCA9IHJlcXVpcmUoJy4vQnJvd3NlclByb3RvY29sJyk7XG5cbnZhciBCcm93c2VyUHJvdG9jb2wgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfQnJvd3NlclByb3RvY29sKTtcblxudmFyIF9SZWZyZXNoUHJvdG9jb2wgPSByZXF1aXJlKCcuL1JlZnJlc2hQcm90b2NvbCcpO1xuXG52YXIgUmVmcmVzaFByb3RvY29sID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1JlZnJlc2hQcm90b2NvbCk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyBIVE1MNSdzIGhpc3RvcnkgQVBJXG4gKiAocHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQpIHRvIG1hbmFnZSBoaXN0b3J5LlxuICogVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgbWV0aG9kIG9mIG1hbmFnaW5nIGhpc3RvcnkgaW4gYnJvd3NlcnMgYmVjYXVzZVxuICogaXQgcHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKlxuICogTm90ZTogSW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgZnVsbFxuICogcGFnZSByZWxvYWRzIHdpbGwgYmUgdXNlZCB0byBwcmVzZXJ2ZSBjbGVhbiBVUkxzLiBZb3UgY2FuIGZvcmNlIHRoaXNcbiAqIGJlaGF2aW9yIHVzaW5nIHsgZm9yY2VSZWZyZXNoOiB0cnVlIH0gaW4gb3B0aW9ucy5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHZhciB1c2VSZWZyZXNoID0gb3B0aW9ucy5mb3JjZVJlZnJlc2ggfHwgISgwLCBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KSgpO1xuICB2YXIgUHJvdG9jb2wgPSB1c2VSZWZyZXNoID8gUmVmcmVzaFByb3RvY29sIDogQnJvd3NlclByb3RvY29sO1xuXG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gUHJvdG9jb2wuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IFByb3RvY29sLmdldEN1cnJlbnRMb2NhdGlvbjtcbiAgdmFyIHB1c2hMb2NhdGlvbiA9IFByb3RvY29sLnB1c2hMb2NhdGlvbjtcbiAgdmFyIHJlcGxhY2VMb2NhdGlvbiA9IFByb3RvY29sLnJlcGxhY2VMb2NhdGlvbjtcbiAgdmFyIGdvID0gUHJvdG9jb2wuZ287XG5cblxuICB2YXIgaGlzdG9yeSA9ICgwLCBfY3JlYXRlSGlzdG9yeTIuZGVmYXVsdCkoX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IGdldFVzZXJDb25maXJtYXRpb24gfSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIHB1c2hMb2NhdGlvbjogcHVzaExvY2F0aW9uLFxuICAgIHJlcGxhY2VMb2NhdGlvbjogcmVwbGFjZUxvY2F0aW9uLFxuICAgIGdvOiBnb1xuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcExpc3RlbmVyID0gdm9pZCAwO1xuXG4gIHZhciBzdGFydExpc3RlbmVyID0gZnVuY3Rpb24gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgYmVmb3JlKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcExpc3RlbmVyID0gQnJvd3NlclByb3RvY29sLnN0YXJ0TGlzdGVuZXIoaGlzdG9yeS50cmFuc2l0aW9uVG8pO1xuXG4gICAgdmFyIHVubGlzdGVuID0gYmVmb3JlID8gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpIDogaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BMaXN0ZW5lcigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCB0cnVlKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9KTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfSGFzaFByb3RvY29sID0gcmVxdWlyZSgnLi9IYXNoUHJvdG9jb2wnKTtcblxudmFyIEhhc2hQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9IYXNoUHJvdG9jb2wpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgRGVmYXVsdFF1ZXJ5S2V5ID0gJ19rJztcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHZhciBxdWVyeUtleSA9IG9wdGlvbnMucXVlcnlLZXk7XG5cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShxdWVyeUtleSAhPT0gZmFsc2UsICdVc2luZyB7IHF1ZXJ5S2V5OiBmYWxzZSB9IG5vIGxvbmdlciB3b3Jrcy4gSW5zdGVhZCwganVzdCBkb25cXCd0ICcgKyAndXNlIGxvY2F0aW9uIHN0YXRlIGlmIHlvdSBkb25cXCd0IHdhbnQgYSBrZXkgaW4geW91ciBVUkwgcXVlcnkgc3RyaW5nJykgOiB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBxdWVyeUtleSAhPT0gJ3N0cmluZycpIHF1ZXJ5S2V5ID0gRGVmYXVsdFF1ZXJ5S2V5O1xuXG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gSGFzaFByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG5cblxuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBIYXNoUHJvdG9jb2wuZ2V0Q3VycmVudExvY2F0aW9uKHF1ZXJ5S2V5KTtcbiAgfTtcblxuICB2YXIgcHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIEhhc2hQcm90b2NvbC5wdXNoTG9jYXRpb24obG9jYXRpb24sIHF1ZXJ5S2V5KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIEhhc2hQcm90b2NvbC5yZXBsYWNlTG9jYXRpb24obG9jYXRpb24sIHF1ZXJ5S2V5KTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9ICgwLCBfY3JlYXRlSGlzdG9yeTIuZGVmYXVsdCkoX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IGdldFVzZXJDb25maXJtYXRpb24gfSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIHB1c2hMb2NhdGlvbjogcHVzaExvY2F0aW9uLFxuICAgIHJlcGxhY2VMb2NhdGlvbjogcmVwbGFjZUxvY2F0aW9uLFxuICAgIGdvOiBIYXNoUHJvdG9jb2wuZ29cbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BMaXN0ZW5lciA9IHZvaWQgMDtcblxuICB2YXIgc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGJlZm9yZSkge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BMaXN0ZW5lciA9IEhhc2hQcm90b2NvbC5zdGFydExpc3RlbmVyKGhpc3RvcnkudHJhbnNpdGlvblRvLCBxdWVyeUtleSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBiZWZvcmUgPyBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcikgOiBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcExpc3RlbmVyKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIHRydWUpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UpO1xuICB9O1xuXG4gIHZhciBnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2gpKCk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJykgOiB2b2lkIDA7XG5cbiAgICBoaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihwYXRoKSB7XG4gICAgcmV0dXJuICcjJyArIGhpc3RvcnkuY3JlYXRlSHJlZihwYXRoKTtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICBnbzogZ28sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZlxuICB9KTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlU3RhdGVTdG9yYWdlID0gZnVuY3Rpb24gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpIHtcbiAgcmV0dXJuIGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5zdGF0ZTtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBlbnRyeSkge1xuICAgIG1lbW9bZW50cnkua2V5XSA9IGVudHJ5LnN0YXRlO1xuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG59O1xuXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBvcHRpb25zIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogW29wdGlvbnNdIH07XG4gIH1cblxuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbY3VycmVudF07XG4gICAgdmFyIHBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShlbnRyeSk7XG5cbiAgICB2YXIga2V5ID0gdm9pZCAwLFxuICAgICAgICBzdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAoZW50cnkua2V5KSB7XG4gICAgICBrZXkgPSBlbnRyeS5rZXk7XG4gICAgICBzdGF0ZSA9IHJlYWRTdGF0ZShrZXkpO1xuICAgIH1cblxuICAgIHZhciBpbml0ID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcblxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKF9leHRlbmRzKHt9LCBpbml0LCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgaW5kZXggPSBjdXJyZW50ICsgbjtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBpZiAoIW4pIHJldHVybjtcblxuICAgIGlmICghY2FuR28obikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQ2Fubm90IGdvKCVzKSB0aGVyZSBpcyBub3QgZW5vdWdoIGhpc3RvcnknLCBuKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnQgKz0gbjtcbiAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG5cbiAgICAvLyBDaGFuZ2UgYWN0aW9uIHRvIFBPUFxuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHsgYWN0aW9uOiBfQWN0aW9ucy5QT1AgfSkpO1xuICB9O1xuXG4gIHZhciBwdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICBjdXJyZW50ICs9IDE7XG5cbiAgICBpZiAoY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSBlbnRyaWVzLnNwbGljZShjdXJyZW50KTtcblxuICAgIGVudHJpZXMucHVzaChsb2NhdGlvbik7XG5cbiAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIGVudHJpZXNbY3VycmVudF0gPSBsb2NhdGlvbjtcbiAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSAoMCwgX2NyZWF0ZUhpc3RvcnkyLmRlZmF1bHQpKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgcHVzaExvY2F0aW9uOiBwdXNoTG9jYXRpb24sXG4gICAgcmVwbGFjZUxvY2F0aW9uOiByZXBsYWNlTG9jYXRpb24sXG4gICAgZ286IGdvXG4gIH0pKTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zO1xuICB2YXIgZW50cmllcyA9IF9vcHRpb25zLmVudHJpZXM7XG4gIHZhciBjdXJyZW50ID0gX29wdGlvbnMuY3VycmVudDtcblxuXG4gIGlmICh0eXBlb2YgZW50cmllcyA9PT0gJ3N0cmluZycpIHtcbiAgICBlbnRyaWVzID0gW2VudHJpZXNdO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJpZXMpKSB7XG4gICAgZW50cmllcyA9IFsnLyddO1xuICB9XG5cbiAgZW50cmllcyA9IGVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5KTtcbiAgfSk7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGN1cnJlbnQgPSBlbnRyaWVzLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSB7XG4gICAgIShjdXJyZW50ID49IDAgJiYgY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdDdXJyZW50IGluZGV4IG11c3QgYmUgPj0gMCBhbmQgPCAlcywgd2FzICVzJywgZW50cmllcy5sZW5ndGgsIGN1cnJlbnQpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBzdG9yYWdlID0gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpO1xuXG4gIHZhciBzYXZlU3RhdGUgPSBmdW5jdGlvbiBzYXZlU3RhdGUoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzdG9yYWdlW2tleV0gPSBzdGF0ZTtcbiAgfTtcblxuICB2YXIgcmVhZFN0YXRlID0gZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICAgIHJldHVybiBzdG9yYWdlW2tleV07XG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMuQWN0aW9ucyA9IGV4cG9ydHMudXNlUXVlcmllcyA9IGV4cG9ydHMudXNlQmVmb3JlVW5sb2FkID0gZXhwb3J0cy51c2VCYXNlbmFtZSA9IGV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGV4cG9ydHMuY3JlYXRlSGFzaEhpc3RvcnkgPSBleHBvcnRzLmNyZWF0ZUhpc3RvcnkgPSB1bmRlZmluZWQ7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2xvY2F0aW9uc0FyZUVxdWFsJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWw7XG4gIH1cbn0pO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVCcm93c2VySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUJyb3dzZXJIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSByZXF1aXJlKCcuL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkyKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeTIpO1xuXG52YXIgX3VzZUJhc2VuYW1lMiA9IHJlcXVpcmUoJy4vdXNlQmFzZW5hbWUnKTtcblxudmFyIF91c2VCYXNlbmFtZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZTIpO1xuXG52YXIgX3VzZUJlZm9yZVVubG9hZDIgPSByZXF1aXJlKCcuL3VzZUJlZm9yZVVubG9hZCcpO1xuXG52YXIgX3VzZUJlZm9yZVVubG9hZDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCZWZvcmVVbmxvYWQyKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IHJlcXVpcmUoJy4vdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllczIpO1xuXG52YXIgX0FjdGlvbnMyID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfQWN0aW9uczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BY3Rpb25zMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuY3JlYXRlSGlzdG9yeSA9IF9jcmVhdGVCcm93c2VySGlzdG9yeTIuZGVmYXVsdDtcbmV4cG9ydHMuY3JlYXRlSGFzaEhpc3RvcnkgPSBfY3JlYXRlSGFzaEhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBfY3JlYXRlTWVtb3J5SGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMudXNlQmFzZW5hbWUgPSBfdXNlQmFzZW5hbWUzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZUJlZm9yZVVubG9hZCA9IF91c2VCZWZvcmVVbmxvYWQzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZVF1ZXJpZXMgPSBfdXNlUXVlcmllczMuZGVmYXVsdDtcbmV4cG9ydHMuQWN0aW9ucyA9IF9BY3Rpb25zMy5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHVzZUJhc2VuYW1lID0gZnVuY3Rpb24gdXNlQmFzZW5hbWUoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG4gICAgdmFyIGJhc2VuYW1lID0gb3B0aW9ucy5iYXNlbmFtZTtcblxuXG4gICAgdmFyIGFkZEJhc2VuYW1lID0gZnVuY3Rpb24gYWRkQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGlmICghbG9jYXRpb24pIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgaWYgKGJhc2VuYW1lICYmIGxvY2F0aW9uLmJhc2VuYW1lID09IG51bGwpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZW5hbWUpID09PSAwKSB7XG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHJpbmcoYmFzZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9IGJhc2VuYW1lO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSAnJykgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfTtcblxuICAgIHZhciBwcmVwZW5kQmFzZW5hbWUgPSBmdW5jdGlvbiBwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgdmFyIG9iamVjdCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKGxvY2F0aW9uKSA6IGxvY2F0aW9uO1xuICAgICAgdmFyIHBuYW1lID0gb2JqZWN0LnBhdGhuYW1lO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRCYXNlbmFtZSA9IGJhc2VuYW1lLnNsaWNlKC0xKSA9PT0gJy8nID8gYmFzZW5hbWUgOiBiYXNlbmFtZSArICcvJztcbiAgICAgIHZhciBub3JtYWxpemVkUGF0aG5hbWUgPSBwbmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IHBuYW1lLnNsaWNlKDEpIDogcG5hbWU7XG4gICAgICB2YXIgcGF0aG5hbWUgPSBub3JtYWxpemVkQmFzZW5hbWUgKyBub3JtYWxpemVkUGF0aG5hbWU7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gYWRkQmFzZW5hbWUoaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGhvb2ssIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGFkZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LnB1c2gocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucmVwbGFjZShwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRCYXNlbmFtZShoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFtwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pXS5jb25jYXQoYXJncykpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uXG4gICAgfSk7XG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VCYXNlbmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdGFydExpc3RlbmVyID0gZnVuY3Rpb24gc3RhcnRMaXN0ZW5lcihnZXRQcm9tcHRNZXNzYWdlKSB7XG4gIHZhciBoYW5kbGVCZWZvcmVVbmxvYWQgPSBmdW5jdGlvbiBoYW5kbGVCZWZvcmVVbmxvYWQoZXZlbnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGdldFByb21wdE1lc3NhZ2UoKTtcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIChldmVudCB8fCB3aW5kb3cuZXZlbnQpLnJldHVyblZhbHVlID0gbWVzc2FnZTtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csICdiZWZvcmV1bmxvYWQnLCBoYW5kbGVCZWZvcmVVbmxvYWQpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCAnYmVmb3JldW5sb2FkJywgaGFuZGxlQmVmb3JlVW5sb2FkKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byB1c2UgdGhlIGJlZm9yZXVubG9hZCBldmVudCBpbiB3ZWJcbiAqIGJyb3dzZXJzIHRvIGNhbmNlbCBuYXZpZ2F0aW9uLlxuICovXG52YXIgdXNlQmVmb3JlVW5sb2FkID0gZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNyZWF0ZUhpc3RvcnkpIHtcbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAndXNlQmVmb3JlVW5sb2FkIG9ubHkgd29ya3MgaW4gRE9NIGVudmlyb25tZW50cycpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgdmFyIHN0b3BMaXN0ZW5lciA9IHZvaWQgMDtcblxuICAgIHZhciBnZXRQcm9tcHRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0UHJvbXB0TWVzc2FnZSgpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IG1lc3NhZ2UgPT0gbnVsbCAmJiBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgbWVzc2FnZSA9IGxpc3RlbmVyc1tpXS5jYWxsKCk7XG4gICAgICB9cmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW5CZWZvcmVVbmxvYWQgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmVVbmxvYWQobGlzdGVuZXIpIHtcbiAgICAgIGlmIChsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcikgPT09IDEpIHN0b3BMaXN0ZW5lciA9IHN0YXJ0TGlzdGVuZXIoZ2V0UHJvbXB0TWVzc2FnZSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwICYmIHN0b3BMaXN0ZW5lcikge1xuICAgICAgICAgIHN0b3BMaXN0ZW5lcigpO1xuICAgICAgICAgIHN0b3BMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgbGlzdGVuQmVmb3JlVW5sb2FkOiBsaXN0ZW5CZWZvcmVVbmxvYWRcbiAgICB9KTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZUJlZm9yZVVubG9hZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvdXNlQmVmb3JlVW5sb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3F1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnktc3RyaW5nJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5ID0gZnVuY3Rpb24gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XG4gIHJldHVybiAoMCwgX3F1ZXJ5U3RyaW5nLnN0cmluZ2lmeSkocXVlcnkpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufTtcblxudmFyIGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLnBhcnNlO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBob3cgdG8gaGFuZGxlIFVSTCBxdWVyaWVzLlxuICovXG52YXIgdXNlUXVlcmllcyA9IGZ1bmN0aW9uIHVzZVF1ZXJpZXMoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gb3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IG9wdGlvbnMucGFyc2VRdWVyeVN0cmluZztcblxuXG4gICAgaWYgKHR5cGVvZiBzdHJpbmdpZnlRdWVyeSAhPT0gJ2Z1bmN0aW9uJykgc3RyaW5naWZ5UXVlcnkgPSBkZWZhdWx0U3RyaW5naWZ5UXVlcnk7XG5cbiAgICBpZiAodHlwZW9mIHBhcnNlUXVlcnlTdHJpbmcgIT09ICdmdW5jdGlvbicpIHBhcnNlUXVlcnlTdHJpbmcgPSBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZztcblxuICAgIHZhciBkZWNvZGVRdWVyeSA9IGZ1bmN0aW9uIGRlY29kZVF1ZXJ5KGxvY2F0aW9uKSB7XG4gICAgICBpZiAoIWxvY2F0aW9uKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIGlmIChsb2NhdGlvbi5xdWVyeSA9PSBudWxsKSBsb2NhdGlvbi5xdWVyeSA9IHBhcnNlUXVlcnlTdHJpbmcobG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZVF1ZXJ5ID0gZnVuY3Rpb24gZW5jb2RlUXVlcnkobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICBpZiAocXVlcnkgPT0gbnVsbCkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICB2YXIgb2JqZWN0ID0gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkobG9jYXRpb24pIDogbG9jYXRpb247XG4gICAgICB2YXIgcXVlcnlTdHJpbmcgPSBzdHJpbmdpZnlRdWVyeShxdWVyeSk7XG4gICAgICB2YXIgc2VhcmNoID0gcXVlcnlTdHJpbmcgPyAnPycgKyBxdWVyeVN0cmluZyA6ICcnO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG9iamVjdCwge1xuICAgICAgICBzZWFyY2g6IHNlYXJjaFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlY29kZVF1ZXJ5KGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3J1blRyYW5zaXRpb25Ib29rMi5kZWZhdWx0KShob29rLCBkZWNvZGVRdWVyeShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcihkZWNvZGVRdWVyeShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5wdXNoKGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH07XG5cbiAgICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LnJlcGxhY2UoZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3TG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFtlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpXS5jb25jYXQoYXJncykpO1xuXG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkpIG5ld0xvY2F0aW9uLnF1ZXJ5ID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZVF1ZXJ5KShsb2NhdGlvbi5xdWVyeSk7XG5cbiAgICAgIHJldHVybiBkZWNvZGVRdWVyeShuZXdMb2NhdGlvbik7XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvblxuICAgIH0pO1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUXVlcmllcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMS40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdsb2Rhc2guaXNhcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJyYXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIGFkZGVkIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nXG4gKiBmbGF0dGVuaW5nIGFuZCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMtbGlrZSBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAoaXNTdHJpY3QgfHwgaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2Jhc2VmbGF0dGVuL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjMgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9ySW5gIGFuZCBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXNcbiAqIG92ZXIgYG9iamVjdGAgcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGludm9raW5nIGBpdGVyYXRlZWAgZm9yXG4gKiBlYWNoIHByb3BlcnR5LiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAqIHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2Jhc2Vmb3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjEuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgpO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYE5hTmAgaXMgZm91bmQgaW4gYGFycmF5YC5cbiAqIElmIGBmcm9tUmlnaHRgIGlzIHByb3ZpZGVkIGVsZW1lbnRzIG9mIGBhcnJheWAgYXJlIGl0ZXJhdGVkIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCBgTmFOYCwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMCA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAob3RoZXIgIT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2Jhc2VpbmRleG9mL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjMgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWluZGV4b2YnKSxcbiAgICBjYWNoZUluZGV4T2YgPSByZXF1aXJlKCdsb2Rhc2guX2NhY2hlaW5kZXhvZicpLFxuICAgIGNyZWF0ZUNhY2hlID0gcmVxdWlyZSgnbG9kYXNoLl9jcmVhdGVjYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmRleE9mID0gYmFzZUluZGV4T2YsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICBpc0xhcmdlID0gaXNDb21tb24gJiYgbGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUsXG4gICAgICBzZWVuID0gaXNMYXJnZSA/IGNyZWF0ZUNhY2hlKCkgOiBudWxsLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgaWYgKHNlZW4pIHtcbiAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICBpZiAoaXNDb21tb24gJiYgdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIDApIDwgMCkge1xuICAgICAgaWYgKGl0ZXJhdGVlIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2Jhc2V1bmlxL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxuICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmRDYWxsYmFjaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2JpbmRjYWxsYmFjay9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMC4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNhY2hlYCBtaW1pY2tpbmcgdGhlIHJldHVybiBzaWduYXR1cmUgb2ZcbiAqIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGNhY2hlLmRhdGEsXG4gICAgICByZXN1bHQgPSAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkgPyBkYXRhLnNldC5oYXModmFsdWUpIDogZGF0YS5oYXNoW3ZhbHVlXTtcblxuICByZXR1cm4gcmVzdWx0ID8gMCA6IC0xO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2NhY2hlaW5kZXhvZi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9nZXRuYXRpdmUnKTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUoZ2xvYmFsLCAnU2V0Jyk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5kYXRhID0geyAnaGFzaCc6IG5hdGl2ZUNyZWF0ZShudWxsKSwgJ3NldCc6IG5ldyBTZXQgfTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdGhpcy5wdXNoKHZhbHVlc1tsZW5ndGhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHB1c2hcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBkYXRhLnNldC5hZGQodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGRhdGEuaGFzaFt2YWx1ZV0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBTZXRgIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgY2FjaGUgb2JqZWN0IGlmIGBTZXRgIGlzIHN1cHBvcnRlZCwgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKHZhbHVlcykge1xuICByZXR1cm4gKG5hdGl2ZUNyZWF0ZSAmJiBTZXQpID8gbmV3IFNldENhY2hlKHZhbHVlcykgOiBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgU2V0YCBjYWNoZS5cblNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gY2FjaGVQdXNoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fY3JlYXRlY2FjaGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjIuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgcm9vdCA9IHJlcXVpcmUoJ2xvZGFzaC5fcm9vdCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbjEgPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZGVcXHhkZi1cXHhmNlxceGY4LVxceGZmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1ZmUyMC1cXFxcdWZlMjMnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmMCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgJ10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4vKiogVXNlZCB0byBtYXAgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjQyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlQyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJ1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIGRlYnVyckxldHRlcihsZXR0ZXIpIHtcbiAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1tsZXR0ZXJdO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gU3ltYm9sID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCdzIG5vdCBvbmUuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICogZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIFN5bWJvbCA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZyBbbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogdG8gYmFzaWMgbGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmcgW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4xLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1cnI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLmRlYnVyci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMS4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBkZWJ1cnIgPSByZXF1aXJlKCdsb2Rhc2guZGVidXJyJyksXG4gICAgd29yZHMgPSByZXF1aXJlKCdsb2Rhc2gud29yZHMnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqL1xudmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2ViYWJDYXNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5rZWJhYmNhc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjEuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fZ2V0bmF0aXZlJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdsb2Rhc2guaXNhcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJyYXknKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL15cXGQrJC87XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBnZXROYXRpdmUoT2JqZWN0LCAna2V5cycpO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpID8gK3ZhbHVlIDogLTE7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICogb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIHNoaW1LZXlzKG9iamVjdCkge1xuICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcbiAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gcHJvcHNMZW5ndGggJiYgb2JqZWN0Lmxlbmd0aDtcblxuICB2YXIgYWxsb3dJbmRleGVzID0gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbnZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgQ3RvciA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICBza2lwSW5kZXhlcyA9IGxlbmd0aCA+IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gKGluZGV4ICsgJycpO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5rZXlzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy42LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiAoK3N0YXJ0IHx8IDApLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIHJlc3QpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0UGFyYW07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLnJlc3RwYXJhbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMS4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2VmbGF0dGVuJyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2V1bmlxJyksXG4gICAgcmVzdFBhcmFtID0gcmVxdWlyZSgnbG9kYXNoLnJlc3RwYXJhbScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAqIGBTYW1lVmFsdWVaZXJvYCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gKiAvLyA9PiBbMSwgMiwgNF1cbiAqL1xudmFyIHVuaW9uID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCBmYWxzZSwgdHJ1ZSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLnVuaW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4yLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIHJvb3QgPSByZXF1aXJlKCdsb2Rhc2guX3Jvb3QnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyMycsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGYwJyxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNRdW90ZVJhbmdlID0gJ1xcXFx1MjAxOFxcXFx1MjAxOVxcXFx1MjAxY1xcXFx1MjAxZCcsXG4gICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNRdW90ZVJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgJ10nLFxuICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNMb3dlck1pc2MgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNVcHBlck1pc2MgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIG5vbi1jb21wb3VuZCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUJhc2ljV29yZCA9IC9bYS16QS1aMC05XSsvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZUNvbXBsZXhXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXJNaXNjICsgJysoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc0xvd2VyTWlzYywgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyTWlzYyArICcrJyxcbiAgcnNVcHBlciArICcrJyxcbiAgcnNEaWdpdHMsXG4gIHJzRW1vamlcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG52YXIgcmVIYXNDb21wbGV4V29yZCA9IC9bYS16XVtBLVpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IFN5bWJvbCA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAqIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBTeW1ib2wgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICBwYXR0ZXJuID0gcmVIYXNDb21wbGV4V29yZC50ZXN0KHN0cmluZykgPyByZUNvbXBsZXhXb3JkIDogcmVCYXNpY1dvcmQ7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3b3JkcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gud29yZHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmZ1bmN0aW9uIGVuY29kZXJGb3JBcnJheUZvcm1hdChvcHRzKSB7XG5cdHN3aXRjaCAob3B0cy5hcnJheUZvcm1hdCkge1xuXHRcdGNhc2UgJ2luZGV4Jzpcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gW1xuXHRcdFx0XHRcdGVuY29kZShrZXksIG9wdHMpLFxuXHRcdFx0XHRcdCdbJyxcblx0XHRcdFx0XHRpbmRleCxcblx0XHRcdFx0XHQnXSdcblx0XHRcdFx0XS5qb2luKCcnKSA6IFtcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcblx0XHRcdFx0XHQnWycsXG5cdFx0XHRcdFx0ZW5jb2RlKGluZGV4LCBvcHRzKSxcblx0XHRcdFx0XHQnXT0nLFxuXHRcdFx0XHRcdGVuY29kZSh2YWx1ZSwgb3B0cylcblx0XHRcdFx0XS5qb2luKCcnKTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdicmFja2V0Jzpcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgPyBlbmNvZGUoa2V5LCBvcHRzKSA6IFtcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcblx0XHRcdFx0XHQnW109Jyxcblx0XHRcdFx0XHRlbmNvZGUodmFsdWUsIG9wdHMpXG5cdFx0XHRcdF0uam9pbignJyk7XG5cdFx0XHR9O1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgPyBlbmNvZGUoa2V5LCBvcHRzKSA6IFtcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcblx0XHRcdFx0XHQnPScsXG5cdFx0XHRcdFx0ZW5jb2RlKHZhbHVlLCBvcHRzKVxuXHRcdFx0XHRdLmpvaW4oJycpO1xuXHRcdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBwYXJzZXJGb3JBcnJheUZvcm1hdChvcHRzKSB7XG5cdHZhciByZXN1bHQ7XG5cblx0c3dpdGNoIChvcHRzLmFycmF5Rm9ybWF0KSB7XG5cdFx0Y2FzZSAnaW5kZXgnOlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikge1xuXHRcdFx0XHRyZXN1bHQgPSAvXFxbKFxcZCopXSQvLmV4ZWMoa2V5KTtcblxuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvXFxbXFxkKl0kLywgJycpO1xuXG5cdFx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldW3Jlc3VsdFsxXV0gPSB2YWx1ZTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdicmFja2V0Jzpcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpIHtcblx0XHRcdFx0cmVzdWx0ID0gLyhcXFtdKSQvLmV4ZWMoa2V5KTtcblxuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvXFxbXSQvLCAnJyk7XG5cblx0XHRcdFx0aWYgKCFyZXN1bHQgfHwgYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbXS5jb25jYXQoYWNjdW11bGF0b3Jba2V5XSwgdmFsdWUpO1xuXHRcdFx0fTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSB7XG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgb3B0cykge1xuXHRpZiAob3B0cy5lbmNvZGUpIHtcblx0XHRyZXR1cm4gb3B0cy5zdHJpY3QgPyBzdHJpY3RVcmlFbmNvZGUodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24ga2V5c1NvcnRlcihpbnB1dCkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQuc29ydCgpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4ga2V5c1NvcnRlcihPYmplY3Qua2V5cyhpbnB1dCkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBOdW1iZXIoYSkgLSBOdW1iZXIoYik7XG5cdFx0fSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBpbnB1dFtrZXldO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIGlucHV0O1xufVxuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJz8nKVsxXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG5cdG9wdHMgPSBvYmplY3RBc3NpZ24oe2FycmF5Rm9ybWF0OiAnbm9uZSd9LCBvcHRzKTtcblxuXHR2YXIgZm9ybWF0dGVyID0gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0cyk7XG5cblx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZVxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9pc3N1ZXMvNDdcblx0dmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuXHRpZiAoIXN0cikge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRzdHIuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuXHRcdHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG5cdFx0Ly8gRmlyZWZveCAocHJlIDQwKSBkZWNvZGVzIGAlM0RgIHRvIGA9YFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nL3B1bGwvMzdcblx0XHR2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzLmpvaW4oJz0nKSA6IHVuZGVmaW5lZDtcblxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG5cdFx0Zm9ybWF0dGVyKGRlY29kZVVSSUNvbXBvbmVudChrZXkpLCB2YWwsIHJldCk7XG5cdH0pO1xuXG5cdHJldHVybiBPYmplY3Qua2V5cyhyZXQpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG5cdFx0dmFyIHZhbCA9IHJldFtrZXldO1xuXHRcdGlmIChCb29sZWFuKHZhbCkgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0Ly8gU29ydCBvYmplY3Qga2V5cywgbm90IHZhbHVlc1xuXHRcdFx0cmVzdWx0W2tleV0gPSBrZXlzU29ydGVyKHZhbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdFtrZXldID0gdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlLFxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZSdcblx0fTtcblxuXHRvcHRzID0gb2JqZWN0QXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcblxuXHR2YXIgZm9ybWF0dGVyID0gZW5jb2RlckZvckFycmF5Rm9ybWF0KG9wdHMpO1xuXG5cdHJldHVybiBvYmogPyBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRzKTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdHZhbC5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcblx0XHRcdFx0aWYgKHZhbDIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGZvcm1hdHRlcihrZXksIHZhbDIsIHJlc3VsdC5sZW5ndGgpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0cykgKyAnPScgKyBlbmNvZGUodmFsLCBvcHRzKTtcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHgubGVuZ3RoID4gMDtcblx0fSkuam9pbignJicpIDogJyc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsYXNzTmFtZUZyb21WTm9kZTtcblxudmFyIF9zZWxlY3RvclBhcnNlcjIgPSByZXF1aXJlKCcuL3NlbGVjdG9yUGFyc2VyJyk7XG5cbnZhciBfc2VsZWN0b3JQYXJzZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2VsZWN0b3JQYXJzZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY2xhc3NOYW1lRnJvbVZOb2RlKHZOb2RlKSB7XG4gIHZhciBfc2VsZWN0b3JQYXJzZXIgPSAoMCwgX3NlbGVjdG9yUGFyc2VyMy5kZWZhdWx0KSh2Tm9kZS5zZWwpO1xuXG4gIHZhciBjbiA9IF9zZWxlY3RvclBhcnNlci5jbGFzc05hbWU7XG5cblxuICBpZiAoIXZOb2RlLmRhdGEpIHtcbiAgICByZXR1cm4gY247XG4gIH1cblxuICB2YXIgX3ZOb2RlJGRhdGEgPSB2Tm9kZS5kYXRhO1xuICB2YXIgZGF0YUNsYXNzID0gX3ZOb2RlJGRhdGEuY2xhc3M7XG4gIHZhciBwcm9wcyA9IF92Tm9kZSRkYXRhLnByb3BzO1xuXG5cbiAgaWYgKGRhdGFDbGFzcykge1xuICAgIHZhciBjID0gT2JqZWN0LmtleXModk5vZGUuZGF0YS5jbGFzcykuZmlsdGVyKGZ1bmN0aW9uIChjbCkge1xuICAgICAgcmV0dXJuIHZOb2RlLmRhdGEuY2xhc3NbY2xdO1xuICAgIH0pO1xuICAgIGNuICs9ICcgJyArIGMuam9pbignICcpO1xuICB9XG5cbiAgaWYgKHByb3BzICYmIHByb3BzLmNsYXNzTmFtZSkge1xuICAgIGNuICs9ICcgJyArIHByb3BzLmNsYXNzTmFtZTtcbiAgfVxuXG4gIHJldHVybiBjbi50cmltKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9jbGFzc05hbWVGcm9tVk5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8vIEFsbCBTVkcgY2hpbGRyZW4gZWxlbWVudHMsIG5vdCBpbiB0aGlzIGxpc3QsIHNob3VsZCBzZWxmLWNsb3NlXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvaW50cm8uaHRtbCNUZXJtQ29udGFpbmVyRWxlbWVudFxuICAnYSc6IHRydWUsXG4gICdkZWZzJzogdHJ1ZSxcbiAgJ2dseXBoJzogdHJ1ZSxcbiAgJ2cnOiB0cnVlLFxuICAnbWFya2VyJzogdHJ1ZSxcbiAgJ21hc2snOiB0cnVlLFxuICAnbWlzc2luZy1nbHlwaCc6IHRydWUsXG4gICdwYXR0ZXJuJzogdHJ1ZSxcbiAgJ3N2Zyc6IHRydWUsXG4gICdzd2l0Y2gnOiB0cnVlLFxuICAnc3ltYm9sJzogdHJ1ZSxcblxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvaW50cm8uaHRtbCNUZXJtRGVzY3JpcHRpdmVFbGVtZW50XG4gICdkZXNjJzogdHJ1ZSxcbiAgJ21ldGFkYXRhJzogdHJ1ZSxcbiAgJ3RpdGxlJzogdHJ1ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tdG8taHRtbC9saWIvY29udGFpbmVyLWVsZW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgaW5pdCA9IHJlcXVpcmUoJy4vaW5pdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoW3JlcXVpcmUoJy4vbW9kdWxlcy9hdHRyaWJ1dGVzJyksIHJlcXVpcmUoJy4vbW9kdWxlcy9zdHlsZScpXSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgcGFyc2VTZWxlY3RvciA9IHJlcXVpcmUoJy4vcGFyc2Utc2VsZWN0b3InKTtcbnZhciBWT0lEX0VMRU1FTlRTID0gcmVxdWlyZSgnLi92b2lkLWVsZW1lbnRzJyk7XG52YXIgQ09OVEFJTkVSX0VMRU1FTlRTID0gcmVxdWlyZSgnLi9jb250YWluZXItZWxlbWVudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbml0KG1vZHVsZXMpIHtcbiAgZnVuY3Rpb24gcGFyc2UoZGF0YSkge1xuICAgIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgYXJyLnB1c2goZm4oZGF0YSkpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQgIT09ICcnO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5zZWwgJiYgdm5vZGUudGV4dCkge1xuICAgICAgcmV0dXJuIHZub2RlLnRleHQ7XG4gICAgfVxuXG4gICAgdm5vZGUuZGF0YSA9IHZub2RlLmRhdGEgfHwge307XG5cbiAgICAvLyBTdXBwb3J0IHRodW5rc1xuICAgIGlmICh0eXBlb2Ygdm5vZGUuc2VsID09PSAnc3RyaW5nJyAmJiB2bm9kZS5zZWwuc2xpY2UoMCwgNSkgPT09ICd0aHVuaycpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuZGF0YS5mbi5hcHBseShudWxsLCB2bm9kZS5kYXRhLmFyZ3MpO1xuICAgIH1cblxuICAgIHZhciB0YWdOYW1lID0gcGFyc2VTZWxlY3Rvcih2bm9kZS5zZWwpLnRhZ05hbWU7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBwYXJzZSh2bm9kZSk7XG4gICAgdmFyIHN2ZyA9IHZub2RlLmRhdGEubnMgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgdmFyIHRhZyA9IFtdO1xuXG4gICAgLy8gT3BlbiB0YWdcbiAgICB0YWcucHVzaCgnPCcgKyB0YWdOYW1lKTtcbiAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIHRhZy5wdXNoKCcgJyArIGF0dHJpYnV0ZXMuam9pbignICcpKTtcbiAgICB9XG4gICAgaWYgKHN2ZyAmJiBDT05UQUlORVJfRUxFTUVOVFNbdGFnTmFtZV0gIT09IHRydWUpIHtcbiAgICAgIHRhZy5wdXNoKCcgLycpO1xuICAgIH1cbiAgICB0YWcucHVzaCgnPicpO1xuXG4gICAgLy8gQ2xvc2UgdGFnLCBpZiBuZWVkZWRcbiAgICBpZiAoVk9JRF9FTEVNRU5UU1t0YWdOYW1lXSAhPT0gdHJ1ZSAmJiAhc3ZnIHx8IHN2ZyAmJiBDT05UQUlORVJfRUxFTUVOVFNbdGFnTmFtZV0gPT09IHRydWUpIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLnByb3BzICYmIHZub2RlLmRhdGEucHJvcHMuaW5uZXJIVE1MKSB7XG4gICAgICAgIHRhZy5wdXNoKHZub2RlLmRhdGEucHJvcHMuaW5uZXJIVE1MKTtcbiAgICAgIH0gZWxzZSBpZiAodm5vZGUudGV4dCkge1xuICAgICAgICB0YWcucHVzaCh2bm9kZS50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICB0YWcucHVzaChyZW5kZXJUb1N0cmluZyhjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRhZy5wdXNoKCc8LycgKyB0YWdOYW1lICsgJz4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnLmpvaW4oJycpO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tdG8taHRtbC9saWIvaW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIGZvck93biA9IHJlcXVpcmUoJ2xvZGFzaC5mb3Jvd24nKTtcbnZhciBlc2NhcGUgPSByZXF1aXJlKCdsb2Rhc2guZXNjYXBlJyk7XG52YXIgdW5pb24gPSByZXF1aXJlKCdsb2Rhc2gudW5pb24nKTtcblxudmFyIHBhcnNlU2VsZWN0b3IgPSByZXF1aXJlKCcuLi9wYXJzZS1zZWxlY3RvcicpO1xuXG4vLyBkYXRhLmF0dHJzLCBkYXRhLnByb3BzLCBkYXRhLmNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXR0cmlidXRlcyh2bm9kZSkge1xuICB2YXIgc2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKHZub2RlLnNlbCk7XG4gIHZhciBwYXJzZWRDbGFzc2VzID0gc2VsZWN0b3IuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgdmFyIHZhbHVlcyA9IHt9O1xuXG4gIGlmIChzZWxlY3Rvci5pZCkge1xuICAgIHZhbHVlcy5pZCA9IHNlbGVjdG9yLmlkO1xuICB9XG5cbiAgc2V0QXR0cmlidXRlcyh2bm9kZS5kYXRhLnByb3BzLCB2YWx1ZXMpO1xuICBzZXRBdHRyaWJ1dGVzKHZub2RlLmRhdGEuYXR0cnMsIHZhbHVlcyk7IC8vIGBhdHRyc2Agb3ZlcnJpZGUgYHByb3BzYCwgbm90IHN1cmUgaWYgdGhpcyBpcyBnb29kIHNvXG5cbiAgaWYgKHZub2RlLmRhdGEuY2xhc3MpIHtcbiAgICAvLyBPbWl0IGBjbGFzc05hbWVgIGF0dHJpYnV0ZSBpZiBgY2xhc3NgIGlzIHNldCBvbiB2bm9kZVxuICAgIHZhbHVlcy5jbGFzcyA9IHVuZGVmaW5lZDtcbiAgfVxuICBmb3JPd24odm5vZGUuZGF0YS5jbGFzcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIGNsYXNzZXMucHVzaChrZXkpO1xuICAgIH1cbiAgfSk7XG4gIGNsYXNzZXMgPSB1bmlvbihjbGFzc2VzLCB2YWx1ZXMuY2xhc3MsIHBhcnNlZENsYXNzZXMpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICE9PSAnJztcbiAgfSk7XG5cbiAgaWYgKGNsYXNzZXMubGVuZ3RoKSB7XG4gICAgdmFsdWVzLmNsYXNzID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gIH1cblxuICBmb3JPd24odmFsdWVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGF0dHJpYnV0ZXMucHVzaCh2YWx1ZSA9PT0gdHJ1ZSA/IGtleSA6IGtleSArICc9XCInICsgZXNjYXBlKHZhbHVlKSArICdcIicpO1xuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlcy5sZW5ndGggPyBhdHRyaWJ1dGVzLmpvaW4oJyAnKSA6ICcnO1xufTtcblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyh2YWx1ZXMsIHRhcmdldCkge1xuICBmb3JPd24odmFsdWVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGlmIChrZXkgPT09ICdodG1sRm9yJykge1xuICAgICAgdGFyZ2V0Wydmb3InXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnY2xhc3NOYW1lJykge1xuICAgICAgdGFyZ2V0WydjbGFzcyddID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL21vZHVsZXMvYXR0cmlidXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBmb3JPd24gPSByZXF1aXJlKCdsb2Rhc2guZm9yb3duJyk7XG52YXIgZXNjYXBlID0gcmVxdWlyZSgnbG9kYXNoLmVzY2FwZScpO1xudmFyIGtlYmFiQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC5rZWJhYmNhc2UnKTtcblxuLy8gZGF0YS5zdHlsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0eWxlKHZub2RlKSB7XG4gIHZhciBzdHlsZXMgPSBbXTtcbiAgdmFyIHN0eWxlID0gdm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBtZXJnZSBpbiBgZGVsYXllZGAgcHJvcGVydGllc1xuICBpZiAoc3R5bGUuZGVsYXllZCkge1xuICAgIF9leHRlbmRzKHN0eWxlLCBzdHlsZS5kZWxheWVkKTtcbiAgfVxuXG4gIGZvck93bihzdHlsZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAvLyBvbWl0IGhvb2sgb2JqZWN0c1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHlsZXMucHVzaChrZWJhYkNhc2Uoa2V5KSArICc6ICcgKyBlc2NhcGUodmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdHlsZXMubGVuZ3RoID8gJ3N0eWxlPVwiJyArIHN0eWxlcy5qb2luKCc7ICcpICsgJ1wiJyA6ICcnO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tdG8taHRtbC9saWIvbW9kdWxlcy9zdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc3ludGF4Lmh0bWwjdm9pZC1lbGVtZW50c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWVcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL3ZvaWQtZWxlbWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVk5vZGUgPSByZXF1aXJlKCcuL3Zub2RlJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbmZ1bmN0aW9uIGFkZE5TKGRhdGEsIGNoaWxkcmVuKSB7XG4gIGRhdGEubnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFkZE5TKGNoaWxkcmVuW2ldLmRhdGEsIGNoaWxkcmVuW2ldLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoKHNlbCwgYiwgYykge1xuICB2YXIgZGF0YSA9IHt9LCBjaGlsZHJlbiwgdGV4dCwgaTtcbiAgaWYgKGMgIT09IHVuZGVmaW5lZCkge1xuICAgIGRhdGEgPSBiO1xuICAgIGlmIChpcy5hcnJheShjKSkgeyBjaGlsZHJlbiA9IGM7IH1cbiAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYykpIHsgdGV4dCA9IGM7IH1cbiAgfSBlbHNlIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXMuYXJyYXkoYikpIHsgY2hpbGRyZW4gPSBiOyB9XG4gICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGIpKSB7IHRleHQgPSBiOyB9XG4gICAgZWxzZSB7IGRhdGEgPSBiOyB9XG4gIH1cbiAgaWYgKGlzLmFycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGlzLnByaW1pdGl2ZShjaGlsZHJlbltpXSkpIGNoaWxkcmVuW2ldID0gVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VsWzBdID09PSAncycgJiYgc2VsWzFdID09PSAndicgJiYgc2VsWzJdID09PSAnZycpIHtcbiAgICBhZGROUyhkYXRhLCBjaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIFZOb2RlKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIHVuZGVmaW5lZCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL2guanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUpe1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSl7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCl7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSl7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKG5vZGUsIGNoaWxkKXtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKG5vZGUsIGNoaWxkKXtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSl7XG4gIHJldHVybiBub2RlLnBhcmVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nKG5vZGUpe1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbn1cblxuZnVuY3Rpb24gdGFnTmFtZShub2RlKXtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZTtcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCl7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9odG1sZG9tYXBpLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJvb2xlYW5BdHRycyA9IFtcImFsbG93ZnVsbHNjcmVlblwiLCBcImFzeW5jXCIsIFwiYXV0b2ZvY3VzXCIsIFwiYXV0b3BsYXlcIiwgXCJjaGVja2VkXCIsIFwiY29tcGFjdFwiLCBcImNvbnRyb2xzXCIsIFwiZGVjbGFyZVwiLCBcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiwgXCJkZWZhdWx0Y2hlY2tlZFwiLCBcImRlZmF1bHRtdXRlZFwiLCBcImRlZmF1bHRzZWxlY3RlZFwiLCBcImRlZmVyXCIsIFwiZGlzYWJsZWRcIiwgXCJkcmFnZ2FibGVcIiwgXG4gICAgICAgICAgICAgICAgXCJlbmFibGVkXCIsIFwiZm9ybW5vdmFsaWRhdGVcIiwgXCJoaWRkZW5cIiwgXCJpbmRldGVybWluYXRlXCIsIFwiaW5lcnRcIiwgXCJpc21hcFwiLCBcIml0ZW1zY29wZVwiLCBcImxvb3BcIiwgXCJtdWx0aXBsZVwiLCBcbiAgICAgICAgICAgICAgICBcIm11dGVkXCIsIFwibm9ocmVmXCIsIFwibm9yZXNpemVcIiwgXCJub3NoYWRlXCIsIFwibm92YWxpZGF0ZVwiLCBcIm5vd3JhcFwiLCBcIm9wZW5cIiwgXCJwYXVzZW9uZXhpdFwiLCBcInJlYWRvbmx5XCIsIFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIiwgXCJyZXZlcnNlZFwiLCBcInNjb3BlZFwiLCBcInNlYW1sZXNzXCIsIFwic2VsZWN0ZWRcIiwgXCJzb3J0YWJsZVwiLCBcInNwZWxsY2hlY2tcIiwgXCJ0cmFuc2xhdGVcIiwgXG4gICAgICAgICAgICAgICAgXCJ0cnVlc3BlZWRcIiwgXCJ0eXBlbXVzdG1hdGNoXCIsIFwidmlzaWJsZVwiXTtcbiAgICBcbnZhciBib29sZWFuQXR0cnNEaWN0ID0ge307XG5mb3IodmFyIGk9MCwgbGVuID0gYm9vbGVhbkF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIGJvb2xlYW5BdHRyc0RpY3RbYm9vbGVhbkF0dHJzW2ldXSA9IHRydWU7XG59XG4gICAgXG5mdW5jdGlvbiB1cGRhdGVBdHRycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGtleSwgY3VyLCBvbGQsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fSwgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICBcbiAgLy8gdXBkYXRlIG1vZGlmaWVkIGF0dHJpYnV0ZXMsIGFkZCBuZXcgYXR0cmlidXRlc1xuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IHRvIG5hbWVzcGFjZWQgYXR0cmlidXRlcyAoc2V0QXR0cmlidXRlTlMpXG4gICAgICBpZighY3VyICYmIGJvb2xlYW5BdHRyc0RpY3Rba2V5XSlcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgZWxzZVxuICAgICAgICBlbG0uc2V0QXR0cmlidXRlKGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy9yZW1vdmUgcmVtb3ZlZCBhdHRyaWJ1dGVzXG4gIC8vIHVzZSBgaW5gIG9wZXJhdG9yIHNpbmNlIHRoZSBwcmV2aW91cyBgZm9yYCBpdGVyYXRpb24gdXNlcyBpdCAoLmkuZS4gYWRkIGV2ZW4gYXR0cmlidXRlcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZSlcbiAgLy8gdGhlIG90aGVyIG9wdGlvbiBpcyB0byByZW1vdmUgYWxsIGF0dHJpYnV0ZXMgd2l0aCB2YWx1ZSA9PSB1bmRlZmluZWRcbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoIShrZXkgaW4gYXR0cnMpKSB7XG4gICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlQXR0cnMsIHVwZGF0ZTogdXBkYXRlQXR0cnN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL21vZHVsZXMvYXR0cmlidXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIHVwZGF0ZUNsYXNzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgY3VyLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRDbGFzcyA9IG9sZFZub2RlLmRhdGEuY2xhc3MgfHwge30sXG4gICAgICBrbGFzcyA9IHZub2RlLmRhdGEuY2xhc3MgfHwge307XG4gIGZvciAobmFtZSBpbiBvbGRDbGFzcykge1xuICAgIGlmICgha2xhc3NbbmFtZV0pIHtcbiAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4ga2xhc3MpIHtcbiAgICBjdXIgPSBrbGFzc1tuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRDbGFzc1tuYW1lXSkge1xuICAgICAgZWxtLmNsYXNzTGlzdFtjdXIgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVDbGFzcywgdXBkYXRlOiB1cGRhdGVDbGFzc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vbW9kdWxlcy9jbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG5cbmZ1bmN0aW9uIGFyckludm9rZXIoYXJyKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHJldHVybjtcbiAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBsZW5ndGggaXMgdHdvLCBmb3IgcGVyZm9ybWFuY2VcbiAgICBhcnIubGVuZ3RoID09PSAyID8gYXJyWzBdKGFyclsxXSkgOiBhcnJbMF0uYXBwbHkodW5kZWZpbmVkLCBhcnIuc2xpY2UoMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbkludm9rZXIobykge1xuICByZXR1cm4gZnVuY3Rpb24oZXYpIHsgXG4gICAgaWYgKG8uZm4gPT09IG51bGwpIHJldHVybjtcbiAgICBvLmZuKGV2KTsgXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUV2ZW50TGlzdGVuZXJzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fSwgb24gPSB2bm9kZS5kYXRhLm9uO1xuICBpZiAoIW9uKSByZXR1cm47XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGlzLmFycmF5KGN1cikpIHtcbiAgICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgYXJySW52b2tlcihjdXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ciA9IHtmbjogY3VyfTtcbiAgICAgICAgb25bbmFtZV0gPSBjdXI7XG4gICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZuSW52b2tlcihjdXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzLmFycmF5KG9sZCkpIHtcbiAgICAgIC8vIERlbGliZXJhdGVseSBtb2RpZnkgb2xkIGFycmF5IHNpbmNlIGl0J3MgY2FwdHVyZWQgaW4gY2xvc3VyZSBjcmVhdGVkIHdpdGggYGFyckludm9rZXJgXG4gICAgICBvbGQubGVuZ3RoID0gY3VyLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSBvbGRbaV0gPSBjdXJbaV07XG4gICAgICBvbltuYW1lXSAgPSBvbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZC5mbiA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBpZiAob2xkT24pIHtcbiAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgIGlmIChvbltuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICAgICAgaWYgKGlzLmFycmF5KG9sZCkpIHtcbiAgICAgICAgICBvbGQubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvbGQuZm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnMsIHVwZGF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnN9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmFmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IHNldFRpbWVvdXQ7XG52YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24oZm4pIHsgcmFmKGZ1bmN0aW9uKCkgeyByYWYoZm4pOyB9KTsgfTtcblxuZnVuY3Rpb24gc2V0TmV4dEZyYW1lKG9iaiwgcHJvcCwgdmFsKSB7XG4gIG5leHRGcmFtZShmdW5jdGlvbigpIHsgb2JqW3Byb3BdID0gdmFsOyB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dE5vZGVSZWN0KHRleHROb2RlKSB7XG4gIHZhciByZWN0O1xuICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXh0Tm9kZSk7XG4gICAgaWYgKHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICByZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBjYWxjVHJhbnNmb3JtT3JpZ2luKGlzVGV4dE5vZGUsIHRleHRSZWN0LCBib3VuZGluZ1JlY3QpIHtcbiAgaWYgKGlzVGV4dE5vZGUpIHtcbiAgICBpZiAodGV4dFJlY3QpIHtcbiAgICAgIC8vY2FsY3VsYXRlIHBpeGVscyB0byBjZW50ZXIgb2YgdGV4dCBmcm9tIGxlZnQgZWRnZSBvZiBib3VuZGluZyBib3hcbiAgICAgIHZhciByZWxhdGl2ZUNlbnRlclggPSB0ZXh0UmVjdC5sZWZ0ICsgdGV4dFJlY3Qud2lkdGgvMiAtIGJvdW5kaW5nUmVjdC5sZWZ0O1xuICAgICAgdmFyIHJlbGF0aXZlQ2VudGVyWSA9IHRleHRSZWN0LnRvcCArIHRleHRSZWN0LmhlaWdodC8yIC0gYm91bmRpbmdSZWN0LnRvcDtcbiAgICAgIHJldHVybiByZWxhdGl2ZUNlbnRlclggKyAncHggJyArIHJlbGF0aXZlQ2VudGVyWSArICdweCc7XG4gICAgfVxuICB9XG4gIHJldHVybiAnMCAwJzsgLy90b3AgbGVmdFxufVxuXG5mdW5jdGlvbiBnZXRUZXh0RHgob2xkVGV4dFJlY3QsIG5ld1RleHRSZWN0KSB7XG4gIGlmIChvbGRUZXh0UmVjdCAmJiBuZXdUZXh0UmVjdCkge1xuICAgIHJldHVybiAoKG9sZFRleHRSZWN0LmxlZnQgKyBvbGRUZXh0UmVjdC53aWR0aC8yKSAtIChuZXdUZXh0UmVjdC5sZWZ0ICsgbmV3VGV4dFJlY3Qud2lkdGgvMikpO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZ2V0VGV4dER5KG9sZFRleHRSZWN0LCBuZXdUZXh0UmVjdCkge1xuICBpZiAob2xkVGV4dFJlY3QgJiYgbmV3VGV4dFJlY3QpIHtcbiAgICByZXR1cm4gKChvbGRUZXh0UmVjdC50b3AgKyBvbGRUZXh0UmVjdC5oZWlnaHQvMikgLSAobmV3VGV4dFJlY3QudG9wICsgbmV3VGV4dFJlY3QuaGVpZ2h0LzIpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaXNUZXh0RWxlbWVudChlbG0pIHtcbiAgcmV0dXJuIGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBlbG0uY2hpbGROb2Rlc1swXS5ub2RlVHlwZSA9PT0gMztcbn1cblxudmFyIHJlbW92ZWQsIGNyZWF0ZWQ7XG5cbmZ1bmN0aW9uIHByZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgcmVtb3ZlZCA9IHt9O1xuICBjcmVhdGVkID0gW107XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGhlcm8gPSB2bm9kZS5kYXRhLmhlcm87XG4gIGlmIChoZXJvICYmIGhlcm8uaWQpIHtcbiAgICBjcmVhdGVkLnB1c2goaGVyby5pZCk7XG4gICAgY3JlYXRlZC5wdXNoKHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXN0cm95KHZub2RlKSB7XG4gIHZhciBoZXJvID0gdm5vZGUuZGF0YS5oZXJvO1xuICBpZiAoaGVybyAmJiBoZXJvLmlkKSB7XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgICB2bm9kZS5pc1RleHROb2RlID0gaXNUZXh0RWxlbWVudChlbG0pOyAvL2lzIHRoaXMgYSB0ZXh0IG5vZGU/XG4gICAgdm5vZGUuYm91bmRpbmdSZWN0ID0gZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvL3NhdmUgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSB0byBhIG5ldyBwcm9wZXJ0eSBvbiB0aGUgdm5vZGVcbiAgICB2bm9kZS50ZXh0UmVjdCA9IHZub2RlLmlzVGV4dE5vZGUgPyBnZXRUZXh0Tm9kZVJlY3QoZWxtLmNoaWxkTm9kZXNbMF0pIDogbnVsbDsgLy9zYXZlIGJvdW5kaW5nIHJlY3Qgb2YgaW5uZXIgdGV4dCBub2RlXG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbG0sIG51bGwpOyAvL2dldCBjdXJyZW50IHN0eWxlcyAoaW5jbHVkZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMpXG4gICAgdm5vZGUuc2F2ZWRTdHlsZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29tcHV0ZWRTdHlsZSkpOyAvL3NhdmUgYSBjb3B5IG9mIGNvbXB1dGVkIHN0eWxlIHZhbHVlc1xuICAgIHJlbW92ZWRbaGVyby5pZF0gPSB2bm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0KCkge1xuICB2YXIgaSwgaWQsIG5ld0VsbSwgb2xkVm5vZGUsIG9sZEVsbSwgaFJhdGlvLCB3UmF0aW8sXG4gICAgICBvbGRSZWN0LCBuZXdSZWN0LCBkeCwgZHksIG9yaWdUcmFuc2Zvcm0sIG9yaWdUcmFuc2l0aW9uLFxuICAgICAgbmV3U3R5bGUsIG9sZFN0eWxlLCBuZXdDb21wdXRlZFN0eWxlLCBpc1RleHROb2RlLFxuICAgICAgbmV3VGV4dFJlY3QsIG9sZFRleHRSZWN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlkID0gY3JlYXRlZFtpXTtcbiAgICBuZXdFbG0gPSBjcmVhdGVkW2krMV0uZWxtO1xuICAgIG9sZFZub2RlID0gcmVtb3ZlZFtpZF07XG4gICAgaWYgKG9sZFZub2RlKSB7XG4gICAgICBpc1RleHROb2RlID0gb2xkVm5vZGUuaXNUZXh0Tm9kZSAmJiBpc1RleHRFbGVtZW50KG5ld0VsbSk7IC8vQXJlIG9sZCAmIG5ldyBib3RoIHRleHQ/XG4gICAgICBuZXdTdHlsZSA9IG5ld0VsbS5zdHlsZTtcbiAgICAgIG5ld0NvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuZXdFbG0sIG51bGwpOyAvL2dldCBmdWxsIGNvbXB1dGVkIHN0eWxlIGZvciBuZXcgZWxlbWVudFxuICAgICAgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgb2xkU3R5bGUgPSBvbGRFbG0uc3R5bGU7XG4gICAgICAvL092ZXJhbGwgZWxlbWVudCBib3VuZGluZyBib3hlc1xuICAgICAgbmV3UmVjdCA9IG5ld0VsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG9sZFJlY3QgPSBvbGRWbm9kZS5ib3VuZGluZ1JlY3Q7IC8vcHJldmlvdXNseSBzYXZlZCBib3VuZGluZyByZWN0XG4gICAgICAvL1RleHQgbm9kZSBib3VuZGluZyBib3hlcyAmIGRpc3RhbmNlc1xuICAgICAgaWYgKGlzVGV4dE5vZGUpIHtcbiAgICAgICAgbmV3VGV4dFJlY3QgPSBnZXRUZXh0Tm9kZVJlY3QobmV3RWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICBvbGRUZXh0UmVjdCA9IG9sZFZub2RlLnRleHRSZWN0O1xuICAgICAgICBkeCA9IGdldFRleHREeChvbGRUZXh0UmVjdCwgbmV3VGV4dFJlY3QpO1xuICAgICAgICBkeSA9IGdldFRleHREeShvbGRUZXh0UmVjdCwgbmV3VGV4dFJlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9DYWxjdWxhdGUgZGlzdGFuY2VzIGJldHdlZW4gb2xkICYgbmV3IHBvc2l0aW9uc1xuICAgICAgICBkeCA9IG9sZFJlY3QubGVmdCAtIG5ld1JlY3QubGVmdDtcbiAgICAgICAgZHkgPSBvbGRSZWN0LnRvcCAtIG5ld1JlY3QudG9wO1xuICAgICAgfVxuICAgICAgaFJhdGlvID0gbmV3UmVjdC5oZWlnaHQgLyAoTWF0aC5tYXgob2xkUmVjdC5oZWlnaHQsIDEpKTtcbiAgICAgIHdSYXRpbyA9IGlzVGV4dE5vZGUgPyBoUmF0aW8gOiBuZXdSZWN0LndpZHRoIC8gKE1hdGgubWF4KG9sZFJlY3Qud2lkdGgsIDEpKTsgLy90ZXh0IHNjYWxlcyBiYXNlZCBvbiBoUmF0aW9cbiAgICAgIC8vIEFuaW1hdGUgbmV3IGVsZW1lbnRcbiAgICAgIG9yaWdUcmFuc2Zvcm0gPSBuZXdTdHlsZS50cmFuc2Zvcm07XG4gICAgICBvcmlnVHJhbnNpdGlvbiA9IG5ld1N0eWxlLnRyYW5zaXRpb247XG4gICAgICBpZiAobmV3Q29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09PSAnaW5saW5lJykgLy9pbmxpbmUgZWxlbWVudHMgY2Fubm90IGJlIHRyYW5zZm9ybWVkXG4gICAgICAgIG5ld1N0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJzsgICAgICAgIC8vdGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gaGF2ZSBhbnkgbmVnYXRpdmUgc2lkZSBlZmZlY3RzXG4gICAgICBuZXdTdHlsZS50cmFuc2l0aW9uID0gb3JpZ1RyYW5zaXRpb24gKyAndHJhbnNmb3JtIDBzJztcbiAgICAgIG5ld1N0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNhbGNUcmFuc2Zvcm1PcmlnaW4oaXNUZXh0Tm9kZSwgbmV3VGV4dFJlY3QsIG5ld1JlY3QpO1xuICAgICAgbmV3U3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgIG5ld1N0eWxlLnRyYW5zZm9ybSA9IG9yaWdUcmFuc2Zvcm0gKyAndHJhbnNsYXRlKCcrZHgrJ3B4LCAnK2R5KydweCkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NjYWxlKCcrMS93UmF0aW8rJywgJysxL2hSYXRpbysnKSc7XG4gICAgICBzZXROZXh0RnJhbWUobmV3U3R5bGUsICd0cmFuc2l0aW9uJywgb3JpZ1RyYW5zaXRpb24pO1xuICAgICAgc2V0TmV4dEZyYW1lKG5ld1N0eWxlLCAndHJhbnNmb3JtJywgb3JpZ1RyYW5zZm9ybSk7XG4gICAgICBzZXROZXh0RnJhbWUobmV3U3R5bGUsICdvcGFjaXR5JywgJzEnKTtcbiAgICAgIC8vIEFuaW1hdGUgb2xkIGVsZW1lbnRcbiAgICAgIGZvciAodmFyIGtleSBpbiBvbGRWbm9kZS5zYXZlZFN0eWxlKSB7IC8vcmUtYXBwbHkgc2F2ZWQgaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHBhcnNlSW50KGtleSkgIT0ga2V5KSB7XG4gICAgICAgICAgdmFyIG1zID0ga2V5LnN1YnN0cmluZygwLDIpID09PSAnbXMnO1xuICAgICAgICAgIHZhciBtb3ogPSBrZXkuc3Vic3RyaW5nKDAsMykgPT09ICdtb3onO1xuICAgICAgICAgIHZhciB3ZWJraXQgPSBrZXkuc3Vic3RyaW5nKDAsNikgPT09ICd3ZWJraXQnO1xuICAgICAgXHQgIGlmICghbXMgJiYgIW1veiAmJiAhd2Via2l0KSAvL2lnbm9yZSBwcmVmaXhlZCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIFx0ICBvbGRTdHlsZVtrZXldID0gb2xkVm5vZGUuc2F2ZWRTdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbGRTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBvbGRTdHlsZS50b3AgPSBvbGRSZWN0LnRvcCArICdweCc7IC8vc3RhcnQgYXQgZXhpc3RpbmcgcG9zaXRpb25cbiAgICAgIG9sZFN0eWxlLmxlZnQgPSBvbGRSZWN0LmxlZnQgKyAncHgnO1xuICAgICAgb2xkU3R5bGUud2lkdGggPSBvbGRSZWN0LndpZHRoICsgJ3B4JzsgLy9OZWVkZWQgZm9yIGVsZW1lbnRzIHdobyB3ZXJlIHNpemVkIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudHNcbiAgICAgIG9sZFN0eWxlLmhlaWdodCA9IG9sZFJlY3QuaGVpZ2h0ICsgJ3B4JzsgLy9OZWVkZWQgZm9yIGVsZW1lbnRzIHdobyB3ZXJlIHNpemVkIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudHNcbiAgICAgIG9sZFN0eWxlLm1hcmdpbiA9IDA7IC8vTWFyZ2luIG9uIGhlcm8gZWxlbWVudCBsZWFkcyB0byBpbmNvcnJlY3QgcG9zaXRpb25pbmdcbiAgICAgIG9sZFN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNhbGNUcmFuc2Zvcm1PcmlnaW4oaXNUZXh0Tm9kZSwgb2xkVGV4dFJlY3QsIG9sZFJlY3QpO1xuICAgICAgb2xkU3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICBvbGRTdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvbGRFbG0pO1xuICAgICAgc2V0TmV4dEZyYW1lKG9sZFN0eWxlLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnKyAtZHggKydweCwgJysgLWR5ICsncHgpIHNjYWxlKCcrd1JhdGlvKycsICcraFJhdGlvKycpJyk7IC8vc2NhbGUgbXVzdCBiZSBvbiBmYXIgcmlnaHQgZm9yIHRyYW5zbGF0ZSB0byBiZSBjb3JyZWN0XG4gICAgICBzZXROZXh0RnJhbWUob2xkU3R5bGUsICdvcGFjaXR5JywgJzAnKTtcbiAgICAgIG9sZEVsbS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGV2LnByb3BlcnR5TmFtZSA9PT0gJ3RyYW5zZm9ybScpXG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChldi50YXJnZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZWQgPSBjcmVhdGVkID0gdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtwcmU6IHByZSwgY3JlYXRlOiBjcmVhdGUsIGRlc3Ryb3k6IGRlc3Ryb3ksIHBvc3Q6IHBvc3R9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL21vZHVsZXMvaGVyby5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIHVwZGF0ZVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIga2V5LCBjdXIsIG9sZCwgZWxtID0gdm5vZGUuZWxtLFxuICAgICAgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLnByb3BzIHx8IHt9LCBwcm9wcyA9IHZub2RlLmRhdGEucHJvcHMgfHwge307XG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCFwcm9wc1trZXldKSB7XG4gICAgICBkZWxldGUgZWxtW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICBvbGQgPSBvbGRQcm9wc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1ciAmJiAoa2V5ICE9PSAndmFsdWUnIHx8IGVsbVtrZXldICE9PSBjdXIpKSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVQcm9wcywgdXBkYXRlOiB1cGRhdGVQcm9wc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vbW9kdWxlcy9wcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByYWYgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgc2V0VGltZW91dDtcbnZhciBuZXh0RnJhbWUgPSBmdW5jdGlvbihmbikgeyByYWYoZnVuY3Rpb24oKSB7IHJhZihmbik7IH0pOyB9O1xuXG5mdW5jdGlvbiBzZXROZXh0RnJhbWUob2JqLCBwcm9wLCB2YWwpIHtcbiAgbmV4dEZyYW1lKGZ1bmN0aW9uKCkgeyBvYmpbcHJvcF0gPSB2YWw7IH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGN1ciwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLFxuICAgICAgb2xkU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9LFxuICAgICAgc3R5bGUgPSB2bm9kZS5kYXRhLnN0eWxlIHx8IHt9LFxuICAgICAgb2xkSGFzRGVsID0gJ2RlbGF5ZWQnIGluIG9sZFN0eWxlO1xuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoIXN0eWxlW25hbWVdKSB7XG4gICAgICBlbG0uc3R5bGVbbmFtZV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgY3VyID0gc3R5bGVbbmFtZV07XG4gICAgaWYgKG5hbWUgPT09ICdkZWxheWVkJykge1xuICAgICAgZm9yIChuYW1lIGluIHN0eWxlLmRlbGF5ZWQpIHtcbiAgICAgICAgY3VyID0gc3R5bGUuZGVsYXllZFtuYW1lXTtcbiAgICAgICAgaWYgKCFvbGRIYXNEZWwgfHwgY3VyICE9PSBvbGRTdHlsZS5kZWxheWVkW25hbWVdKSB7XG4gICAgICAgICAgc2V0TmV4dEZyYW1lKGVsbS5zdHlsZSwgbmFtZSwgY3VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gJ3JlbW92ZScgJiYgY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgZWxtLnN0eWxlW25hbWVdID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseURlc3Ryb3lTdHlsZSh2bm9kZSkge1xuICB2YXIgc3R5bGUsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgcyA9IHZub2RlLmRhdGEuc3R5bGU7XG4gIGlmICghcyB8fCAhKHN0eWxlID0gcy5kZXN0cm95KSkgcmV0dXJuO1xuICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICBlbG0uc3R5bGVbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVJlbW92ZVN0eWxlKHZub2RlLCBybSkge1xuICB2YXIgcyA9IHZub2RlLmRhdGEuc3R5bGU7XG4gIGlmICghcyB8fCAhcy5yZW1vdmUpIHtcbiAgICBybSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBpZHgsIGkgPSAwLCBtYXhEdXIgPSAwLFxuICAgICAgY29tcFN0eWxlLCBzdHlsZSA9IHMucmVtb3ZlLCBhbW91bnQgPSAwLCBhcHBsaWVkID0gW107XG4gIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgIGFwcGxpZWQucHVzaChuYW1lKTtcbiAgICBlbG0uc3R5bGVbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgfVxuICBjb21wU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsbSk7XG4gIHZhciBwcm9wcyA9IGNvbXBTdHlsZVsndHJhbnNpdGlvbi1wcm9wZXJ0eSddLnNwbGl0KCcsICcpO1xuICBmb3IgKDsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYoYXBwbGllZC5pbmRleE9mKHByb3BzW2ldKSAhPT0gLTEpIGFtb3VudCsrO1xuICB9XG4gIGVsbS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAoZXYudGFyZ2V0ID09PSBlbG0pIC0tYW1vdW50O1xuICAgIGlmIChhbW91bnQgPT09IDApIHJtKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtjcmVhdGU6IHVwZGF0ZVN0eWxlLCB1cGRhdGU6IHVwZGF0ZVN0eWxlLCBkZXN0cm95OiBhcHBseURlc3Ryb3lTdHlsZSwgcmVtb3ZlOiBhcHBseVJlbW92ZVN0eWxlfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9tb2R1bGVzL3N0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8ganNoaW50IG5ld2NhcDogZmFsc2Vcbi8qIGdsb2JhbCByZXF1aXJlLCBtb2R1bGUsIGRvY3VtZW50LCBOb2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWTm9kZSA9IHJlcXVpcmUoJy4vdm5vZGUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciBkb21BcGkgPSByZXF1aXJlKCcuL2h0bWxkb21hcGknKTtcblxuZnVuY3Rpb24gaXNVbmRlZihzKSB7IHJldHVybiBzID09PSB1bmRlZmluZWQ7IH1cbmZ1bmN0aW9uIGlzRGVmKHMpIHsgcmV0dXJuIHMgIT09IHVuZGVmaW5lZDsgfVxuXG52YXIgZW1wdHlOb2RlID0gVk5vZGUoJycsIHt9LCBbXSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUodm5vZGUxLCB2bm9kZTIpIHtcbiAgcmV0dXJuIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiYgdm5vZGUxLnNlbCA9PT0gdm5vZGUyLnNlbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIG1hcCA9IHt9LCBrZXk7XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSBtYXBba2V5XSA9IGk7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95JywgJ3ByZScsICdwb3N0J107XG5cbmZ1bmN0aW9uIGluaXQobW9kdWxlcywgYXBpKSB7XG4gIHZhciBpLCBqLCBjYnMgPSB7fTtcblxuICBpZiAoaXNVbmRlZihhcGkpKSBhcGkgPSBkb21BcGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAobW9kdWxlc1tqXVtob29rc1tpXV0gIT09IHVuZGVmaW5lZCkgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdChlbG0pIHtcbiAgICByZXR1cm4gVk5vZGUoYXBpLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLWxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gYXBpLnBhcmVudE5vZGUoY2hpbGRFbG0pO1xuICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgdmFyIGksIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUpO1xuICAgICAgICBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGVsbSwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbiwgc2VsID0gdm5vZGUuc2VsO1xuICAgIGlmIChpc0RlZihzZWwpKSB7XG4gICAgICAvLyBQYXJzZSBzZWxlY3RvclxuICAgICAgdmFyIGhhc2hJZHggPSBzZWwuaW5kZXhPZignIycpO1xuICAgICAgdmFyIGRvdElkeCA9IHNlbC5pbmRleE9mKCcuJywgaGFzaElkeCk7XG4gICAgICB2YXIgaGFzaCA9IGhhc2hJZHggPiAwID8gaGFzaElkeCA6IHNlbC5sZW5ndGg7XG4gICAgICB2YXIgZG90ID0gZG90SWR4ID4gMCA/IGRvdElkeCA6IHNlbC5sZW5ndGg7XG4gICAgICB2YXIgdGFnID0gaGFzaElkeCAhPT0gLTEgfHwgZG90SWR4ICE9PSAtMSA/IHNlbC5zbGljZSgwLCBNYXRoLm1pbihoYXNoLCBkb3QpKSA6IHNlbDtcbiAgICAgIGVsbSA9IHZub2RlLmVsbSA9IGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLm5zKSA/IGFwaS5jcmVhdGVFbGVtZW50TlMoaSwgdGFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXBpLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgIGlmIChoYXNoIDwgZG90KSBlbG0uaWQgPSBzZWwuc2xpY2UoaGFzaCArIDEsIGRvdCk7XG4gICAgICBpZiAoZG90SWR4ID4gMCkgZWxtLmNsYXNzTmFtZSA9IHNlbC5zbGljZShkb3QrMSkucmVwbGFjZSgvXFwuL2csICcgJyk7XG4gICAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGFwaS5hcHBlbmRDaGlsZChlbG0sIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXMucHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICAgIGFwaS5hcHBlbmRDaGlsZChlbG0sIGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgaWYgKGkuY3JlYXRlKSBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgaWYgKGkuaW5zZXJ0KSBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbSA9IHZub2RlLmVsbSA9IGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlLmVsbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSksIGJlZm9yZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sodm5vZGUpIHtcbiAgICB2YXIgaSwgaiwgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIGkodm5vZGUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgaSwgbGlzdGVuZXJzLCBybSwgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2guc2VsKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKGNoLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkgY2JzLnJlbW92ZVtpXShjaCwgcm0pO1xuICAgICAgICAgIGlmIChpc0RlZihpID0gY2guZGF0YSkgJiYgaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgICAgaShjaCwgcm0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgYXBpLnJlbW92ZUNoaWxkKHBhcmVudEVsbSwgY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwLCBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIGJlZm9yZTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgYXBpLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWR4SW5PbGQgPSBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV07XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBlbG1Ub01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgYmVmb3JlID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHgrMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCsxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgdmFyIGksIGhvb2s7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhKSAmJiBpc0RlZihob29rID0gaS5ob29rKSAmJiBpc0RlZihpID0gaG9vay5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbSwgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbiwgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSByZXR1cm47XG4gICAgaWYgKCFzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgdmFyIHBhcmVudEVsbSA9IGFwaS5wYXJlbnROb2RlKG9sZFZub2RlLmVsbSk7XG4gICAgICBlbG0gPSBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtLCBvbGRWbm9kZS5lbG0pO1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7XG4gICAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIGFwaS5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIGFwaS5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGFwaS5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucG9zdHBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgaSwgZWxtLCBwYXJlbnQ7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucHJlLmxlbmd0aDsgKytpKSBjYnMucHJlW2ldKCk7XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5zZWwpKSB7XG4gICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICBwYXJlbnQgPSBhcGkucGFyZW50Tm9kZShlbG0pO1xuXG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cbiAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnQsIHZub2RlLmVsbSwgYXBpLm5leHRTaWJsaW5nKGVsbSkpO1xuICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50LCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWVbaV0uZGF0YS5ob29rLmluc2VydChpbnNlcnRlZFZub2RlUXVldWVbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnBvc3QubGVuZ3RoOyArK2kpIGNicy5wb3N0W2ldKCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtpbml0OiBpbml0fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9zbmFiYmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoID0gcmVxdWlyZSgnLi9oJyk7XG5cbmZ1bmN0aW9uIGNvcHlUb1RodW5rKHZub2RlLCB0aHVuaykge1xuICB0aHVuay5lbG0gPSB2bm9kZS5lbG07XG4gIHZub2RlLmRhdGEuZm4gPSB0aHVuay5kYXRhLmZuO1xuICB2bm9kZS5kYXRhLmFyZ3MgPSB0aHVuay5kYXRhLmFyZ3M7XG4gIHRodW5rLmRhdGEgPSB2bm9kZS5kYXRhO1xuICB0aHVuay5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICB0aHVuay50ZXh0ID0gdm5vZGUudGV4dDtcbiAgdGh1bmsuZWxtID0gdm5vZGUuZWxtO1xufVxuXG5mdW5jdGlvbiBpbml0KHRodW5rKSB7XG4gIHZhciBpLCBjdXIgPSB0aHVuay5kYXRhO1xuICB2YXIgdm5vZGUgPSBjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBjdXIuYXJncyk7XG4gIGNvcHlUb1RodW5rKHZub2RlLCB0aHVuayk7XG59XG5cbmZ1bmN0aW9uIHByZXBhdGNoKG9sZFZub2RlLCB0aHVuaykge1xuICB2YXIgaSwgb2xkID0gb2xkVm5vZGUuZGF0YSwgY3VyID0gdGh1bmsuZGF0YSwgdm5vZGU7XG4gIHZhciBvbGRBcmdzID0gb2xkLmFyZ3MsIGFyZ3MgPSBjdXIuYXJncztcbiAgaWYgKG9sZC5mbiAhPT0gY3VyLmZuIHx8IG9sZEFyZ3MubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVuayk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAob2xkQXJnc1tpXSAhPT0gYXJnc1tpXSkge1xuICAgICAgY29weVRvVGh1bmsoY3VyLmZuLmFwcGx5KHVuZGVmaW5lZCwgYXJncyksIHRodW5rKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29weVRvVGh1bmsob2xkVm5vZGUsIHRodW5rKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWwsIGtleSwgZm4sIGFyZ3MpIHtcbiAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgIGFyZ3MgPSBmbjtcbiAgICBmbiA9IGtleTtcbiAgICBrZXkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGgoc2VsLCB7XG4gICAga2V5OiBrZXksXG4gICAgaG9vazoge2luaXQ6IGluaXQsIHByZXBhdGNoOiBwcmVwYXRjaH0sXG4gICAgZm46IGZuLFxuICAgIGFyZ3M6IGFyZ3NcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL3RodW5rLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0fSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgaXNQYXR0ZXJuLCBpc1JvdXRlRGVmaW5pdGlvbiwgdHJhdmVyc2VSb3V0ZXMsIGlzTm90TnVsbCwgc3BsaXRQYXRoLCBpc1BhcmFtLCBleHRyYWN0UGFydGlhbCwgdW5wcmVmaXhlZCwgfSBmcm9tICcuL3V0aWwnO1xuZnVuY3Rpb24gc3dpdGNoUGF0aElucHV0R3VhcmQocGF0aCwgcm91dGVzKSB7XG4gICAgaWYgKCFpc1BhdHRlcm4ocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgcGFyYW1ldGVyIHRvIHN3aXRjaFBhdGggbXVzdCBiZSBhIHJvdXRlIHBhdGguXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzUm91dGVEZWZpbml0aW9uKHJvdXRlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIHBhcmFtZXRlciB0byBzd2l0Y2hQYXRoIG11c3QgYmUgYW4gb2JqZWN0IFwiICtcbiAgICAgICAgICAgIFwiY29udGFpbmluZyByb3V0ZSBwYXR0ZXJucy5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQYXRoKHNvdXJjZVBhdGgsIG1hdGNoZWRQYXRoKSB7XG4gICAgdmFyIHNvdXJjZVBhcnRzID0gc3BsaXRQYXRoKHNvdXJjZVBhdGgpO1xuICAgIHZhciBtYXRjaGVkUGFydHMgPSBzcGxpdFBhdGgobWF0Y2hlZFBhdGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlZFBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtYXRjaGVkUGFydHNbaV0gIT09IHNvdXJjZVBhcnRzW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIvXCIgKyBleHRyYWN0UGFydGlhbChzb3VyY2VQYXRoLCBtYXRjaGVkUGF0aCk7XG59XG5mdW5jdGlvbiBiZXR0ZXJNYXRjaChjYW5kaWRhdGUsIHJlZmVyZW5jZSkge1xuICAgIGlmICghaXNOb3ROdWxsKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzTm90TnVsbChyZWZlcmVuY2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlUGF0aChjYW5kaWRhdGUsIHJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlLmxlbmd0aCA+PSByZWZlcmVuY2UubGVuZ3RoO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1dpdGhQYXJhbXMoc291cmNlUGF0aCwgcGF0dGVybikge1xuICAgIHZhciBzb3VyY2VQYXJ0cyA9IHNwbGl0UGF0aChzb3VyY2VQYXRoKTtcbiAgICB2YXIgcGF0dGVyblBhcnRzID0gc3BsaXRQYXRoKHBhdHRlcm4pO1xuICAgIHZhciBwYXJhbXMgPSBwYXR0ZXJuUGFydHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocGFydCwgaSkgeyByZXR1cm4gaXNQYXJhbShwYXJ0KSA/IHNvdXJjZVBhcnRzW2ldIDogbnVsbDsgfSlcbiAgICAgICAgLmZpbHRlcihpc05vdE51bGwpO1xuICAgIHZhciBtYXRjaGVkID0gcGF0dGVyblBhcnRzXG4gICAgICAgIC5ldmVyeShmdW5jdGlvbiAocGFydCwgaSkgeyByZXR1cm4gaXNQYXJhbShwYXJ0KSB8fCBwYXJ0ID09PSBzb3VyY2VQYXJ0c1tpXTsgfSk7XG4gICAgcmV0dXJuIG1hdGNoZWQgPyBwYXJhbXMgOiBbXTtcbn1cbmZ1bmN0aW9uIGdldFBhcmFtRm5WYWx1ZShwYXJhbUZuLCBwYXJhbXMpIHtcbiAgICB2YXIgX3BhcmFtRm4gPSBpc1JvdXRlRGVmaW5pdGlvbihwYXJhbUZuKSA/IHBhcmFtRm5bXCIvXCJdIDogcGFyYW1GbjtcbiAgICByZXR1cm4gdHlwZW9mIF9wYXJhbUZuID09PSBcImZ1bmN0aW9uXCIgPyBfcGFyYW1Gbi5hcHBseSh2b2lkIDAsIHBhcmFtcykgOiBfcGFyYW1Gbjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKF9hKSB7XG4gICAgdmFyIHNvdXJjZVBhdGggPSBfYS5zb3VyY2VQYXRoLCBtYXRjaGVkUGF0aCA9IF9hLm1hdGNoZWRQYXRoLCBtYXRjaGVkVmFsdWUgPSBfYS5tYXRjaGVkVmFsdWUsIHJvdXRlcyA9IF9hLnJvdXRlcztcbiAgICB2YXIgcGF0aCA9IG1hdGNoZWRQYXRoID8gdmFsaWRhdGVQYXRoKHNvdXJjZVBhdGgsIG1hdGNoZWRQYXRoKSA6IG51bGw7XG4gICAgdmFyIHZhbHVlID0gbWF0Y2hlZFZhbHVlO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICBwYXRoID0gcm91dGVzW1wiKlwiXSA/IHNvdXJjZVBhdGggOiBudWxsO1xuICAgICAgICB2YWx1ZSA9IHBhdGggPyByb3V0ZXNbXCIqXCJdIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH07XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzd2l0Y2hQYXRoKHNvdXJjZVBhdGgsIHJvdXRlcykge1xuICAgIHN3aXRjaFBhdGhJbnB1dEd1YXJkKHNvdXJjZVBhdGgsIHJvdXRlcyk7XG4gICAgdmFyIG1hdGNoZWRQYXRoID0gbnVsbDtcbiAgICB2YXIgbWF0Y2hlZFZhbHVlID0gbnVsbDtcbiAgICB0cmF2ZXJzZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChzb3VyY2VQYXRoLnNlYXJjaChwYXR0ZXJuKSA9PT0gMCAmJiBiZXR0ZXJNYXRjaChwYXR0ZXJuLCBtYXRjaGVkUGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoZWRQYXRoID0gcGF0dGVybjtcbiAgICAgICAgICAgIG1hdGNoZWRWYWx1ZSA9IHJvdXRlc1twYXR0ZXJuXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1zID0gbWF0Y2hlc1dpdGhQYXJhbXMoc291cmNlUGF0aCwgcGF0dGVybikuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgYmV0dGVyTWF0Y2goc291cmNlUGF0aCwgbWF0Y2hlZFBhdGgpKSB7XG4gICAgICAgICAgICBtYXRjaGVkUGF0aCA9IGV4dHJhY3RQYXJ0aWFsKHNvdXJjZVBhdGgsIHBhdHRlcm4pO1xuICAgICAgICAgICAgbWF0Y2hlZFZhbHVlID0gZ2V0UGFyYW1GblZhbHVlKHJvdXRlc1twYXR0ZXJuXSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSb3V0ZURlZmluaXRpb24ocm91dGVzW3BhdHRlcm5dKSAmJiBwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlUGF0aCAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBzd2l0Y2hQYXRoKHVucHJlZml4ZWQoc291cmNlUGF0aCwgcGF0dGVybikgfHwgXCIvXCIsIHJvdXRlc1twYXR0ZXJuXSk7XG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZFBhdGggPSBwYXR0ZXJuICsgY2hpbGQucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQucGF0aCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBiZXR0ZXJNYXRjaChuZXN0ZWRQYXRoLCBtYXRjaGVkUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFBhdGggPSBuZXN0ZWRQYXRoO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmFsdWUgPSBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsaWRhdGUoeyBzb3VyY2VQYXRoOiBzb3VyY2VQYXRoLCBtYXRjaGVkUGF0aDogbWF0Y2hlZFBhdGgsIG1hdGNoZWRWYWx1ZTogbWF0Y2hlZFZhbHVlLCByb3V0ZXM6IHJvdXRlcyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zd2l0Y2gtcGF0aC9saWIvZXMyMDE1L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybihjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlLmNoYXJBdCgwKSA9PT0gXCIvXCIgfHwgY2FuZGlkYXRlID09PSBcIipcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1JvdXRlRGVmaW5pdGlvbihjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gIWNhbmRpZGF0ZSB8fCB0eXBlb2YgY2FuZGlkYXRlICE9PSBcIm9iamVjdFwiID9cbiAgICAgICAgZmFsc2UgOiBpc1BhdHRlcm4oT2JqZWN0LmtleXMoY2FuZGlkYXRlKVswXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VSb3V0ZXMocm91dGVzLCBjYWxsYmFjaykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocm91dGVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBrZXlzW2ldO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gXCIqXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FsbGJhY2socGF0dGVybik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTm90TnVsbChjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlICE9PSBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0UGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gISFzOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1BhcmFtKGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiBjYW5kaWRhdGUubWF0Y2goLzpcXHcrLykgIT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcnRpYWwoc291cmNlUGF0aCwgcGF0dGVybikge1xuICAgIHZhciBwYXR0ZXJuUGFydHMgPSBzcGxpdFBhdGgocGF0dGVybik7XG4gICAgdmFyIHNvdXJjZVBhcnRzID0gc3BsaXRQYXRoKHNvdXJjZVBhdGgpO1xuICAgIHZhciBtYXRjaGVkUGFydHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5QYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtYXRjaGVkUGFydHMucHVzaChzb3VyY2VQYXJ0c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVkUGFydHMuZmlsdGVyKGlzTm90TnVsbCkuam9pbihcIi9cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5wcmVmaXhlZChmdWxsU3RyaW5nLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVsbFN0cmluZy5zcGxpdChwcmVmaXgpWzFdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3dpdGNoLXBhdGgvbGliL2VzMjAxNS91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BvbnlmaWxsID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpO1xuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbnlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgcm9vdDsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9ICgwLCBfcG9ueWZpbGwyWydkZWZhdWx0J10pKHJvb3QpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVzdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGw7XG5mdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgX1N5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChfU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0X1N5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyBVSSBmcm9tIFwiLi4vdWlcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuaW1wb3J0IHtkaXYsIFZOb2RlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEluZGV4IHtcbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzKSB7XG4gICAgY29uc3QgdlRyZWUkID0geHMub2YoXG4gICAgICBkaXYoXCIuY2VudGVyZWRcIiwgW1xuICAgICAgICBVSS5Db250YWluZXIucmVuZGVyKFtcbiAgICAgICAgICBVSS5HcmlkLnJlbmRlcih7Y2VudGVyZWQ6IHRydWV9LCBbXG4gICAgICAgICAgICBVSS5Sb3cucmVuZGVyKFtcbiAgICAgICAgICAgICAgVUkuSGVhZGVyLnJlbmRlcih7c2l6ZTogVUkuU2l6ZS5IdWdlfSwgXCJXZWxjb21lLlwiLCB7XG4gICAgICAgICAgICAgICAgc3VidGV4dDogXCJBdCB0aGUgbW9tZW50IHRoZSBkb2NzIGFyZSBhIFdJUC4gUGxhbm5lZCBwYWdlcyBhcmUgc2NhZmZvbGRlZCBpbiB0aGUgc2lkZW1lbnUuXCJcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIERPTTogdlRyZWUkLFxuICAgICAgcm91dGVyOiB4cy5uZXZlcigpXG4gICAgfTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvaW5kZXgvaW5kZXgudHMiLCIvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbmltcG9ydCB7IGRpdiwgVk5vZGUgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHsgU2lkZWJhciB9IGZyb20gXCIuL3NpZGViYXJcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBMYXlvdXQge1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IGFueSwgcGFnZTogYW55KSB7XG5cbiAgICAvKioqIENyZWF0ZSBjb21wb25lbnRzICoqKi9cbiAgICBsZXQgc2lkZWJhciA9IFNpZGViYXIucnVuKHNvdXJjZXMpO1xuICAgIC8qKiogQ29tcG9zZSB2aWV3ICoqKi9cbiAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNpZGViYXIuRE9NLCBwYWdlLkRPTSwpXG4gICAgICAubWFwKChbc2lkZWJhciwgcGFnZV0pID0+XG4gICAgICAgIGRpdihcIi5mdWxsLmhlaWdodFwiLCBbXG4gICAgICAgICAgZGl2KFwiLmNvbnRlbnQucHVzaGVyXCIsIFtcbiAgICAgICAgICAgIHNpZGViYXIsXG4gICAgICAgICAgICBwYWdlXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBET006IHZUcmVlJCxcbiAgICAgIHJvdXRlcjogcGFnZS5yb3V0ZXJcbiAgICB9O1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy9sYXlvdXQvaW5kZXgudHMiLCJpbXBvcnQgKiBhcyBVSSBmcm9tIFwiLi4vLi4vdWlcIjtcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuaW1wb3J0IHsgZGl2LCBWTm9kZSB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2lkZWJhciB7XG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlcykge1xuICAgIGxldCBjdXJyZW50UGFnZSQgPSBzb3VyY2VzLnJvdXRlci5oaXN0b3J5JC5tYXAoeCA9PiB4LnBhdGhuYW1lKSBhcyBTdHJlYW08c3RyaW5nPjtcbiAgICBsZXQgcHJlZml4ID0gXCIvY3ljbGUtc2VtYW50aWMtdWlcIjtcbiAgICBjb25zdCB2VHJlZSQgPSBjdXJyZW50UGFnZSQubWFwKHBhZ2UgPT5cbiAgICAgIGRpdihcIi5sZWZ0Lm1lbnVcIiwgW1xuICAgICAgICBkaXYoXCIuZml4ZWRcIiwgW1xuICAgICAgICAgIFVJLk1lbnUucmVuZGVyKHtcbiAgICAgICAgICAgIHZlcnRpY2FsOiB0cnVlLCBpbnZlcnRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGF0dGFjaG1lbnQ6IFVJLkF0dGFjaG1lbnQuTm9uZSwgc2l6ZTogVUkuU2l6ZS5GbHVpZFxuICAgICAgICAgIH0sIFt7XG4gICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBbXCJJbnRyb2R1Y3Rpb25cIiwgVUkuTWVudS5yZW5kZXIoXG4gICAgICAgICAgICAgIHsgc3VibWVudTogdHJ1ZSwgfSwgW3tcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9cIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9cIiB8fCBwYWdlID09PSBwcmVmaXggKyBcIi9ob21lXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJBYm91dFwiXG4gICAgICAgICAgICAgIH1dKV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IFtcIkVsZW1lbnRzXCIsIFVJLk1lbnUucmVuZGVyKFxuICAgICAgICAgICAgICB7IHN1Ym1lbnU6IHRydWUsIH0sIFt7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvYnV0dG9uXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJCdXR0b25cIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvY29udGFpbmVyXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvY29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJDb250YWluZXJcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvZGl2aWRlclwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL2RpdmlkZXJcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkRpdmlkZXJcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvaGVhZGVyXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvaGVhZGVyXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJIZWFkZXJcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvaWNvblwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL2ljb25cIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkljb25cIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvaW1hZ2VcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9lbGVtZW50cy9pbWFnZVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiSW1hZ2VcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvbGFiZWxcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9lbGVtZW50cy9sYWJlbFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiTGFiZWxcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvbGlzdFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL2xpc3RcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkxpc3RcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvbG9hZGVyXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvbG9hZGVyXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJMb2FkZXJcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvc2VnbWVudFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL3NlZ21lbnRcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlNlZ21lbnRcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvc3RlcFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL3N0ZXBcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlN0ZXBcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvZWxlbWVudHMvdGV4dGJveFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL3RleHRib3hcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlRleHRib3hcIlxuICAgICAgICAgICAgICB9XSldXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBbXCJDb2xsZWN0aW9uc1wiLCBVSS5NZW51LnJlbmRlcihcbiAgICAgICAgICAgICAgeyBzdWJtZW51OiB0cnVlLCB9LCBbe1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL2JyZWFkY3J1bWJcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9jb2xsZWN0aW9ucy9icmVhZGNydW1iXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJCcmVhZGNydW1iXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL2Zvcm1cIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9jb2xsZWN0aW9ucy9mb3JtXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJGb3JtXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL2dyaWRcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9jb2xsZWN0aW9ucy9ncmlkXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJHcmlkXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL21lbnVcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9jb2xsZWN0aW9ucy9tZW51XCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJNZW51XCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL21lc3NhZ2VcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9jb2xsZWN0aW9ucy9tZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJNZXNzYWdlXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL3RhYmxlXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvY29sbGVjdGlvbnMvdGFibGVcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlRhYmxlXCJcbiAgICAgICAgICAgICAgfV0pXVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogW1wiTW9kdWxlc1wiLCBVSS5NZW51LnJlbmRlcihcbiAgICAgICAgICAgICAgeyBzdWJtZW51OiB0cnVlLCB9LCBbe1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL21vZHVsZXMvY2hlY2tib3hcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9tb2R1bGVzL2NoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJDaGVja2JveFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9tb2R1bGVzL2RpbW1lclwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL21vZHVsZXMvZGltbWVyXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJEaW1tZXJcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvbW9kdWxlcy9kcm9wZG93blwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL21vZHVsZXMvZHJvcGRvd25cIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkRyb3Bkb3duXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL21vZHVsZXMvbW9kYWxcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9tb2R1bGVzL21vZGFsXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJNb2RhbFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9tb2R1bGVzL3BvcHVwXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvbW9kdWxlcy9wb3B1cFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiUG9wdXBcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvbW9kdWxlcy9wcm9ncmVzc1wiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL21vZHVsZXMvcHJvZ3Jlc3NcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlByb2dyZXNzXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL21vZHVsZXMvdHJhbnNpdGlvblwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL21vZHVsZXMvdHJhbnNpdGlvblwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiVHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgIH1dKV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IFtcIlZpZXdzXCIsIFVJLk1lbnUucmVuZGVyKFxuICAgICAgICAgICAgICB7IHN1Ym1lbnU6IHRydWUsIH0sIFt7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvdmlld3Mvc3RhdGlzdGljXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvdmlld3Mvc3RhdGlzdGljXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJTdGF0aXN0aWNcIlxuICAgICAgICAgICAgICB9XSldXG4gICAgICAgICAgfV0pXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIERPTTogdlRyZWUkLFxuICAgICAgcm91dGVyOiB4cy5uZXZlcigpXG4gICAgfTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvbGF5b3V0L3NpZGViYXIvaW5kZXgudHMiLCJpbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB4cywge1N0cmVhbX0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCB7RE9NU291cmNlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5pbnRlcmZhY2UgQ29tcG9uZW50Um91dGVyU291cmNlcyB7XG4gIHJvdXRlczogYW55O1xuICByb3V0ZXI6IGFueTtcbiAgRE9NOiBET01Tb3VyY2U7XG59XG5cbmNvbnN0IGNhbGxQYWdlID0gZnVuY3Rpb24gKHNvdXJjZXM6IENvbXBvbmVudFJvdXRlclNvdXJjZXMpIHtcbiAgcmV0dXJuICh7cGF0aCwgdmFsdWV9KSA9PiB7XG4gICAgY29uc3QgcFNvdXJjZXMgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VzLCB7cm91dGVyOiBzb3VyY2VzLnJvdXRlci5wYXRoKHBhdGgpfSk7XG4gICAgY29uc3QgaXNvbGF0ZWRQYWdlID0gaXNvbGF0ZSh2YWx1ZSkocFNvdXJjZXMpIGFzIGFueTtcbiAgICByZXR1cm4gaXNvbGF0ZWRQYWdlO1xuICB9O1xufTtcblxuZnVuY3Rpb24gcHJvcE9yTmV2ZXIoa2V5OiBzdHJpbmcsIHg6IE9iamVjdCkge1xuICBpZiAoeC5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICByZXR1cm4geFtrZXldO1xuICB9XG4gIHJldHVybiB4cy5uZXZlcigpO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQnlLZXkoa2V5OiBzdHJpbmcsIHN0cmVhbTogU3RyZWFtPGFueT4pIHtcbiAgICByZXR1cm4gc3RyZWFtLm1hcCh4ID0+IHByb3BPck5ldmVyKGtleSwgeCkpLmZsYXR0ZW4oKTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50Um91dGVyIChzb3VyY2VzOiBDb21wb25lbnRSb3V0ZXJTb3VyY2VzKSB7XG4gIGNvbnN0IGNvbXBvbmVudCQgPSBzb3VyY2VzLnJvdXRlci5kZWZpbmUoc291cmNlcy5yb3V0ZXMpXG4gICAgLm1hcChyb3V0ZSA9PiBjYWxsUGFnZShzb3VyY2VzKShyb3V0ZSkpXG4gICAgLnJlbWVtYmVyKClcbiAgICAuZGVidWcoKCkgPT4ge30pOyAvL1N0YXRlJCBkb2VzIG5vdCB3b3JrIHdpdGhvdXQgdGhpcyBsaW5lLiBVbmFibGUgdG8gcmVwcm9kdWNlIGluIHdlYnBhY2tiaW4uXG4gIGNvbnN0IHBsdWNrID0ga2V5ID0+IGZsYXR0ZW5CeUtleShrZXksIGNvbXBvbmVudCQpO1xuICBjb25zdCBzaW5rcyA9IHtcbiAgICBwbHVjazogcGx1Y2ssXG4gICAgRE9NOiBwbHVjayhcIkRPTVwiKSxcbiAgICByb3V0ZXI6IHBsdWNrKFwicm91dGVyXCIpLFxuICB9O1xuICByZXR1cm4gc2lua3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNvdXJjZXMgPT4gaXNvbGF0ZShDb21wb25lbnRSb3V0ZXIpKHNvdXJjZXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvcm91dGVyLnRzIiwiLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuaW1wb3J0IHtWTm9kZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7U3RyZWFtfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IHsgSW5kZXh9IGZyb20gXCIuL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgXCIvXCI6IEluZGV4LnJ1blxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL3JvdXRlcy50cyIsImltcG9ydCB7IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHtkaXYsIGEsIHNwYW4sIGksIFZOb2RlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBCcmVhZGNydW1iIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgYXJyb3c/OiBib29sZWFuO1xuICAgIGNoZXZyb24/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCB0eXBlIENvbnRlbnQgPSBBcnJheTxCcmVhZENydW1iSXRlbT47XG4gIGV4cG9ydCBpbnRlcmZhY2UgQnJlYWRDcnVtYkl0ZW17XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICB0ZXh0Pzogc3RyaW5nO1xuICAgIGhyZWY/OiBzdHJpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGludGVyYWN0aXZlIEJyZWFkY3J1bWIgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGEgaGlzdG9yeSBvZiBsaW5rcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgYXJyb3c/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBicmVhZGNydW1iIHRvIHVzZSBhcnJvdyBpY29ucy5cbiAgICogIGNoZWN2cm9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnJlYWRjcnVtYiB0byB1c2UgY2hldnJvbiBpY29ucy5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogQXJyYXkgb2Yge31cbiAgICogICBhY3RpdmU/OiBib29sZWFuIC0gSGlnaGxpZ2h0cyB0aGUgc2VjdGlvbiBhcyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogICB0ZXh0Pzogc3RyaW5nIC0gVGhlIHRleHQgZm9yIHRoZSBzZWN0aW9uLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBUaGUgbG9jYXRpb24gZm9yIHRoZSBzZWN0aW9uIHRvIHBvaW50IHRvd2FyZHMuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSA6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG4gICAgICBjb25zdCBicmVhZGNydW1iJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IGJyZWFkY3J1bWIkLFxuICAgICAgICBFdmVudHM6IHR5cGUgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmJyZWFkY3J1bWJcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3RhdGljIEJyZWFkY3J1bWIgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGEgaGlzdG9yeSBvZiBsaW5rcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcbiAgICogIGFycm93PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnJlYWRjcnVtYiB0byB1c2UgYXJyb3cgaWNvbnMuXG4gICAqICBjaGVjdnJvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJyZWFkY3J1bWIgdG8gdXNlIGNoZXZyb24gaWNvbnMuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEFycmF5IG9mIHt9XG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIEhpZ2hsaWdodHMgdGhlIHNlY3Rpb24gYXMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqICAgdGV4dD86IHN0cmluZyAtIFRoZSB0ZXh0IGZvciB0aGUgc2VjdGlvbi5cbiAgICogICBocmVmPzogc3RyaW5nIC0gVGhlIGxvY2F0aW9uIGZvciB0aGUgc2VjdGlvbiB0byBwb2ludCB0b3dhcmRzLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wc3xDb250ZW50ID0ge30sIGM6IENvbnRlbnQgPSBbXSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0NvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0NvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgY2hpbGRyZW4gPSBjb250ZW50Lm1hcChjID0+IFtcbiAgICAgIHNlY3Rpb24oYyksIGRpdmlkZXIocHJvcHMpXG4gICAgXSkucmVkdWNlKChhLCBuKSA9PiBhLmNvbmNhdChuKSk7XG4gICAgY2hpbGRyZW4uc3BsaWNlKC0xLCAxKTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInVpIGJyZWFkY3J1bWJcIn19LCBjaGlsZHJlbik7XG4gIH1cbiAgZnVuY3Rpb24gc2VjdGlvbihzZWN0aW9uOiBCcmVhZENydW1iSXRlbSkgOiBWTm9kZSB7XG4gICAgcmV0dXJuIHNlY3Rpb24uYWN0aXZlXG4gICAgICA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJhY3RpdmUgc2VjdGlvblwifX0sIHNlY3Rpb24udGV4dClcbiAgICAgIDogYSh7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJzZWN0aW9uXCIsIGhyZWY6IHNlY3Rpb24uaHJlZn19LCBzZWN0aW9uLnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIGRpdmlkZXIocHJvcHM6IFByb3BzKSA6IFZOb2RlIHtcbiAgICByZXR1cm4gc3Bhbih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkaXZpZGVyXCJ9fSwgZGl2aWRlckljb24ocHJvcHMpKTtcbiAgfVxuICBmdW5jdGlvbiBkaXZpZGVySWNvbihwcm9wczogUHJvcHMpIDogVk5vZGUge1xuICAgIGlmIChwcm9wcy5hcnJvdykge1xuICAgICAgcmV0dXJuIGkoeyBwcm9wczogeyBjbGFzc05hbWU6IFwicmlnaHQgYXJyb3cgaWNvbiBkaXZpZGVyXCJ9fSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaGV2cm9uKSB7XG4gICAgICByZXR1cm4gaSh7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJyaWdodCBjaGV2cm9uIGljb24gZGl2aWRlclwifX0pO1xuICAgIH1cbiAgICByZXR1cm4gKFwiIC8gXCIpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBpc0NvbnRlbnQocHJvcHNPckNvbnRlbnQ6IFByb3BzIHwgQ29udGVudCk6IHByb3BzT3JDb250ZW50IGlzIENvbnRlbnQge1xuICAgIHJldHVybiBwcm9wc09yQ29udGVudCAhPT0gdW5kZWZpbmVkICYmICg8Q29udGVudD5wcm9wc09yQ29udGVudCkucHVzaCAhPT0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvYnJlYWRjcnVtYi9pbmRleC50cyIsImltcG9ydCB7XG4gIERPTUNvbnRlbnQsIElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlcyxcbiAgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudFxufSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgbnVtVG9UZXh0IH0gZnJvbSBcInV0aWxzXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2LCBsYWJlbCwgVk5vZGUgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEZpZWxkIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgaW5saW5lPzogYm9vbGVhbjtcbiAgICBjZW50ZXJlZD86IGJvb2xlYW47XG4gICAgcmVxdWlyZWQ/OiBib29sZWFuO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBjb250ZW50IGluIGEgRmllbGQgc3VpdGFibGUgZm9yIHRoZSBGb3JtIGNvbXBvbmVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIHdpZHRoPzogbnVtYmVyIC0gVGhlIHdpZHRoIG9mIHRoZSBmaWVsZCBpbiBncmlkIGNvbHVtbnMuXG4gICAqICAgaW5saW5lPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgbmV4dCB0byB0aGUgZmllbGQgaW5zdGVhZCBvZiBhYm92ZSBpdC5cbiAgICogICBjZW50ZXJlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGZpZWxkIHRvIGJlIGNlbnRlcmVkLlxuICAgKiAgIHJlcXVpcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZmllbGQgdG8gc2hvdyBpdCBpcyBtYW5kYXRvcnkuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IHt9IG9mXG4gICAqICAgbGFiZWw/OiBET01Db250ZW50IC0gVGhlIGxhYmVsIGZvciB0aGUgZmllbGQuXG4gICAqICAgYm9keTogRE9NQ29udGVudCAtIFRoZSBmaWVsZCBpbnB1dC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuICAgICAgc291cmNlcy5leHRyYXMkID0gc291cmNlcy5leHRyYXMkID8gc291cmNlcy5leHRyYXMkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQsIHNvdXJjZXMuZXh0cmFzJCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50LCBleHRyYV0pID0+IHJlbmRlcihwcm9wcywgY29udGVudCwgZXh0cmEpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5maWVsZFwiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29udGVudCBpbiBhIEZpZWxkIHN1aXRhYmxlIGZvciB0aGUgRm9ybSBjb21wb25lbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIHdpZHRoPzogbnVtYmVyIC0gVGhlIHdpZHRoIG9mIHRoZSBmaWVsZCBpbiBncmlkIGNvbHVtbnMuXG4gICAqICAgaW5saW5lPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgbmV4dCB0byB0aGUgZmllbGQgaW5zdGVhZCBvZiBhYm92ZSBpdC5cbiAgICogICBjZW50ZXJlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGZpZWxkIHRvIGJlIGNlbnRlcmVkLlxuICAgKiAgIHJlcXVpcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZmllbGQgdG8gc2hvdyBpdCBpcyBtYW5kYXRvcnkuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IHt9IG9mXG4gICAqICAgbGFiZWw/OiBET01Db250ZW50IC0gVGhlIGxhYmVsIGZvciB0aGUgZmllbGQuXG4gICAqICAgYm9keTogRE9NQ29udGVudCAtIFRoZSBmaWVsZCBpbnB1dC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiLCBlOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgZXh0cmEgPSBpc0RPTUNvbnRlbnQocE9yQykgPyAoYyA9PT0gXCJcIikgPyBlIDogYyA6IGU7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIFtdLmNvbmNhdChleHRyYSA/IGxhYmVsKGV4dHJhKSA6IFwiXCIsIGNvbnRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy53aWR0aCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChwcm9wcy53aWR0aCkgKyBcIiB3aWRlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbmxpbmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbmxpbmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbnRlcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2VudGVyZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJlcXVpcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmVxdWlyZWRcIjtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGZpZWxkXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2Zvcm0vZmllbGQudHMiLCJpbXBvcnQge1xuICBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcyxcbiAgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudFxufSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgbnVtVG9UZXh0IH0gZnJvbSBcInV0aWxzXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2LCBsYWJlbCB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmllbGRzIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgbGFiZWw/OiBET01Db250ZW50O1xuICAgIGVxdWFsV2lkdGg/OiBib29sZWFuO1xuICAgIGdyb3VwZWQ/OiBib29sZWFuO1xuICAgIGlubGluZT86IGJvb2xlYW47XG4gICAgcmVxdWlyZWQ/OiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIG11bHRpcGxlIHJlbGF0ZWQgRmllbGQgY29tcG9uZW50cyB0b2dldGhlci5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGxhYmVsPzogRE9NQ29udGVudCAtIEEgbGFiZWwgZm9yIHRoZSBmaWVsZHMuXG4gICAqICAgZXF1YWxXaWR0aD86IGJvb2xlYW4gLSBEaXZpZGVzIGZpZWxkcyBpbiBlcXVhbCB3aWR0aC5cbiAgICogICBncm91cGVkPzogYm9vbGVhbiAtIEdyb3VwcyBmaWVsZHMgdG9nZXRoZXIgZm9yIHJlbGF0ZWQgY2hvaWNlcy5cbiAgICogICBpbmxpbmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbHMgdG8gYmUgbmV4dCB0byB0aGUgZmllbGRzIGluc3RlYWQgb2YgYWJvdmUgdGhlbS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuZmllbGRzXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgICAgdmFsdWUkOiB4cy5uZXZlcigpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgbXVsdGlwbGUgcmVsYXRlZCBGaWVsZCBjb21wb25lbnRzIHRvZ2V0aGVyLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBsYWJlbD86IERPTUNvbnRlbnQgLSBBIGxhYmVsIGZvciB0aGUgZmllbGRzLlxuICAgKiAgIGVxdWFsV2lkdGg/OiBib29sZWFuIC0gRGl2aWRlcyBmaWVsZHMgaW4gZXF1YWwgd2lkdGguXG4gICAqICAgZ3JvdXBlZD86IGJvb2xlYW4gLSBHcm91cHMgZmllbGRzIHRvZ2V0aGVyIGZvciByZWxhdGVkIGNob2ljZXMuXG4gICAqICAgaW5saW5lPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWxzIHRvIGJlIG5leHQgdG8gdGhlIGZpZWxkcyBpbnN0ZWFkIG9mIGFib3ZlIHRoZW0uXG4gICAqICAgcmVxdWlyZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0aGUgZmllbGRzIHRvIG1ha2UgdGhlbSBhcHBlYXIgbWFuZGV0b3J5LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgbGJsID0gcHJvcHMubGFiZWwgPyBsYWJlbChwcm9wcy5sYWJlbCkgOiBcIlwiO1xuICAgIGxldCBjaGlsZHJlbiA9ICg8QXJyYXk8YW55Pj5jb250ZW50KS5sZW5ndGggPyBbbGJsXS5jb25jYXQoY29udGVudCkgOiBbbGJsLCBjb250ZW50XTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMsIGNvbnRlbnQpIH0gfSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcywgY29udGVudCkge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmVxdWFsV2lkdGggJiYgY29udGVudC5sZW5ndGgpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQoY29udGVudC5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW5saW5lKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW5saW5lXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ncm91cGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZ3JvdXBlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmVxdWlyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByZXF1aXJlZFwiO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgZmllbGRzXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2Zvcm0vZmllbGRzLnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEZvcm0ge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgICBlcXVhbFdpZHRoPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cblxuICAvKipcbiAgICogQSBmb3JtIGNvbXBvbmVudCBmb3IgY2FwdHVyaW5nIGdyb3VwcyBvZiB1c2VyIGlucHV0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZvcm0gd2l0aCBhIGxvYWRlci5cbiAgICogICBlcXVhbFdpZHRoPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZm9ybSBjb250ZW50IHRvIGhhdmUgZXF1YWwgd2lkdGhzIHBlciByb3cuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmb3JtIGZvciBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGZvcm0ncyBjb250ZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKVxuICAgICAgICAubWFwKChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmZvcm1cIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBmb3JtIGNvbXBvbmVudCBmb3IgY2FwdHVyaW5nIGdyb3VwcyBvZiB1c2VyIGlucHV0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBsb2FkaW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZm9ybSB3aXRoIGEgbG9hZGVyLlxuICAgKiAgIGVxdWFsV2lkdGg/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmb3JtIGNvbnRlbnQgdG8gaGF2ZSBlcXVhbCB3aWR0aHMgcGVyIHJvdy5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZvcm0gZm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgZm9ybSdzIGNvbnRlbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBjb250ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMubG9hZGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxvYWRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmVxdWFsV2lkdGgpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBlcXVhbCB3aWR0aFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBmb3JtXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2Zvcm0vZm9ybS50cyIsImV4cG9ydCAqIGZyb20gXCIuL2Zvcm1cIlxuZXhwb3J0ICogZnJvbSBcIi4vZmllbGRcIlxuZXhwb3J0ICogZnJvbSBcIi4vZmllbGRzXCJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9mb3JtL2luZGV4LnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFZlcnRpY2FsQWxpZ25tZW50LCBUZXh0QWxpZ25tZW50LCBTaXplLCBGbG9hdCB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHsgbnVtVG9UZXh0IH0gZnJvbSBcInV0aWxzXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBDb2x1bW4ge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBtb2JpbGU/OiBudW1iZXI7XG4gICAgdGFibGV0PzogbnVtYmVyO1xuICAgIGNvbXB1dGVyPzogbnVtYmVyO1xuICAgIGxhcmdlc2NyZWVuPzogbnVtYmVyO1xuICAgIHNpemU/OiBTaXplO1xuICAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50O1xuICAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50O1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGNvbnRlbnQgaW4gYSBjb2x1bW4gc3VpdGFibGUgZm9yIHRoZSBHcmlkIGNvbXBvbmVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBXZXRoZXIgdGhlIGNvbHVtbiBzaG91bGQgYmUgbGVmdCBvciByaWdodCBmbG9hdGVkLlxuICAgKiAgIHdpZHRoPzogaW50IC0gVGhlIGRlZmF1bHQgd2lkdGggb2YgdGhlIGNvbHVtbi5cbiAgICogICBtb2JpbGU/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogICB0YWJsZXQ/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiB0YWJsZXQgZGV2aWNlcy5cbiAgICogICBjb21wdXRlcj86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIGNvbXB1dGVyIGRldmljZXMuXG4gICAqICAgbGFyZ2VzY3JlZW4/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiBsYXJnZSBzY3JlZW4gZGV2aWNlcy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBjb2x1bW4uXG4gICAqICAgYWxpZ25tZW50PzogVmVydGljYWxBbGlnbm1lbnQgLSBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQgLSBUaGUgdGV4dCBhbGlnbm1lbnQgb2YgdGhlIGNvbHVtbi5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBDb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuY29sdW1uXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBjb250ZW50IGluIGEgY29sdW1uIHN1aXRhYmxlIGZvciB0aGUgR3JpZCBjb21wb25lbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBXZXRoZXIgdGhlIGNvbHVtbiBzaG91bGQgYmUgbGVmdCBvciByaWdodCBmbG9hdGVkLlxuICAgKiAgIHdpZHRoPzogaW50IC0gVGhlIGRlZmF1bHQgd2lkdGggb2YgdGhlIGNvbHVtbi5cbiAgICogICBtb2JpbGU/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogICB0YWJsZXQ/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiB0YWJsZXQgZGV2aWNlcy5cbiAgICogICBjb21wdXRlcj86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIGNvbXB1dGVyIGRldmljZXMuXG4gICAqICAgbGFyZ2VzY3JlZW4/OiBpbnQgLSBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiBvbiBsYXJnZSBzY3JlZW4gZGV2aWNlcy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBjb2x1bW4uXG4gICAqICAgYWxpZ25tZW50PzogVmVydGljYWxBbGlnbm1lbnQgLSBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQgLSBUaGUgdGV4dCBhbGlnbm1lbnQgb2YgdGhlIGNvbHVtbi5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNvbnRlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmZsb2F0ICYmIHByb3BzLmZsb2F0ID09PSBGbG9hdC5SaWdodCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJpZ2h0IGZsb2F0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZsb2F0ICYmIHByb3BzLmZsb2F0ID09PSBGbG9hdC5MZWZ0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGVmdCBmbG9hdGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5tb2JpbGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQocHJvcHMubW9iaWxlKSArIFwiIHdpZGUgbW9iaWxlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWJsZXQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQocHJvcHMudGFibGV0KSArIFwiIHdpZGUgdGFibGV0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wdXRlcikge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChwcm9wcy5jb21wdXRlcikgKyBcIiB3aWRlIGNvbXB1dGVyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sYXJnZXNjcmVlbikge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChwcm9wcy5sYXJnZXNjcmVlbikgKyBcIiB3aWRlIGxhcmdlc2NyZWVuXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYWxpZ25tZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFZlcnRpY2FsQWxpZ25tZW50LlRvQ2xhc3NuYW1lKHByb3BzLmFsaWdubWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnRleHRBbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVGV4dEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy50ZXh0QWxpZ25tZW50KTtcbiAgICB9XG4gICAgaWYgKHByb3BzLndpZHRoKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KHByb3BzLndpZHRoKSArIFwiIHdpZGVcIjtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGNvbHVtblwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9ncmlkL2NvbHVtbi50cyIsImltcG9ydCB7XG4gIERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLFxuICBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50XG59IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBWZXJ0aWNhbEFsaWdubWVudCwgVGV4dEFsaWdubWVudCB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHsgbnVtVG9UZXh0IH0gZnJvbSBcInV0aWxzXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBHcmlkIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgZXF1YWxseURpdmlkZWQ/OiBib29sZWFuO1xuICAgIGRpdmlkZWQ/OiBib29sZWFuO1xuICAgIGNvbnRhaW5lcj86IGJvb2xlYW47XG4gICAgY2VsbGVkPzogYm9vbGVhbjtcbiAgICBpbnRDZWxsZWQ/OiBib29sZWFuO1xuICAgIHBhZGRlZD86IGJvb2xlYW47XG4gICAgcmVsYXhlZD86IGJvb2xlYW47XG4gICAgY2VudGVyZWQ/OiBib29sZWFuO1xuICAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50O1xuICAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGNvbnRlbnQgaW4gYSBjb2x1bW4gc3VpdGFibGUgZm9yIHRoZSBHcmlkIGNvbXBvbmVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGVxdWFsbHlEaXZpZGVkPzogYm9vbGVhbiAtIFN0eWxlcyBncmlkIGNvbnRlbnQgdG8gdGFrZSB1cCBlcXVhbCBhbW91bnRzIG9mIHNwYWNlLlxuICAgKiAgIGRpdmlkZWQ/OiBib29sZWFuIC0gVXNlIGRpdmlkZXJzIHRvIHNlcGVyYXRlIGNvbnRlbnQgaW4gdGhlIEdyaWQuXG4gICAqICAgY29udGFpbmVyPyA6IGJvb2xlYW4gLSBXcmFwcyB0aGUgZ3JpZCBpbiBhIGNvbnRhaW5lci5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gRGl2aWRlcyB0aGUgZ3JpZCBpbnRvIGNlbGxzLlxuICAgKiAgIGludENlbGxlZD86IGJvb2xlYW4gLSBEaXZpZGVzIHRoZSBncmlkIGludG8gY2VsbHMgd2l0aCBvbmx5IGludGVybmFsIGRpdmlkZXJzLlxuICAgKiAgIHBhZGRlZD86IGJvb2xlYW4gLSBBZGRzIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGd1dHRlcnMgdG8gdGhlIGdyaWQuXG4gICAqICAgcmVsYXhlZD86IGJvb2xlYW4gLSBJbmNyZWFzZXMgdGhlIGFtb3VudCBvZiBuZWdhdGl2ZSBzcGFjZS5cbiAgICogICBjZW50ZXJlZD86IGJvb2xlYW4gLSBDZW50ZXJzIHRoZSBjb250ZW50IG9mIHRoZSBHcmlkLlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50OiBEZXRlcm1pbmVzIHRoZSBhbGlnbm1lbnQgb2YgY29udGVudCBpbiB0aGUgR3JpZC5cbiAgICogICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudDogRGV0ZXJtaW5lcyB0aGUgdGV4dCBhbGlnbm1lbnQgb2YgY29udGVudCBpbiB0aGUgR3JpZC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JClcbiAgICAgICAgLm1hcCgoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5ncmlkXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBjb250ZW50IGluIGEgY29sdW1uIHN1aXRhYmxlIGZvciB0aGUgR3JpZCBjb21wb25lbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGVxdWFsbHlEaXZpZGVkPzogYm9vbGVhbiAtIFN0eWxlcyBncmlkIGNvbnRlbnQgdG8gdGFrZSB1cCBlcXVhbCBhbW91bnRzIG9mIHNwYWNlLlxuICAgKiAgIGRpdmlkZWQ/OiBib29sZWFuIC0gVXNlIGRpdmlkZXJzIHRvIHNlcGVyYXRlIGNvbnRlbnQgaW4gdGhlIEdyaWQuXG4gICAqICAgY29udGFpbmVyPyA6IGJvb2xlYW4gLSBXcmFwcyB0aGUgZ3JpZCBpbiBhIGNvbnRhaW5lci5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gRGl2aWRlcyB0aGUgZ3JpZCBpbnRvIGNlbGxzLlxuICAgKiAgIGludENlbGxlZD86IGJvb2xlYW4gLSBEaXZpZGVzIHRoZSBncmlkIGludG8gY2VsbHMgd2l0aCBvbmx5IGludGVybmFsIGRpdmlkZXJzLlxuICAgKiAgIHBhZGRlZD86IGJvb2xlYW4gLSBBZGRzIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGd1dHRlcnMgdG8gdGhlIGdyaWQuXG4gICAqICAgcmVsYXhlZD86IGJvb2xlYW4gLSBJbmNyZWFzZXMgdGhlIGFtb3VudCBvZiBuZWdhdGl2ZSBzcGFjZS5cbiAgICogICBjZW50ZXJlZD86IGJvb2xlYW4gLSBDZW50ZXJzIHRoZSBjb250ZW50IG9mIHRoZSBHcmlkLlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50OiBEZXRlcm1pbmVzIHRoZSBhbGlnbm1lbnQgb2YgY29udGVudCBpbiB0aGUgR3JpZC5cbiAgICogICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudDogRGV0ZXJtaW5lcyB0aGUgdGV4dCBhbGlnbm1lbnQgb2YgY29udGVudCBpbiB0aGUgR3JpZC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzLCBjb250ZW50KSB9IH0sIGNvbnRlbnQpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzLCBjb250ZW50KTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5lcXVhbGx5RGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQubGVuZ3RoIDogMSkgKyBcIiBjb2x1bW5cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpdmlkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXZpZGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb250YWluZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb250YWluZXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbGxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNlbGxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW50Q2VsbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW50ZXJuYWxseSBjZWxsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBhZGRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHBhZGRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmVsYXhlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJlbGF4ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbnRlcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2VudGVyZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYWxpZ25tZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFZlcnRpY2FsQWxpZ25tZW50LlRvQ2xhc3NuYW1lKHByb3BzLmFsaWdubWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnRleHRBbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVGV4dEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy50ZXh0QWxpZ25tZW50KTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGdyaWRcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9ncmlkLnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vZ3JpZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcm93XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb2x1bW5cIjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9ncmlkL2luZGV4LnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCJ1dGlsc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUm93IHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgc3RyZXRjaGVkPzogYm9vbGVhbjtcbiAgICBtb2JpbGU/OiBib29sZWFuO1xuICAgIHRhYmxldD86IGJvb2xlYW47XG4gICAgY29tcHV0ZXI/OiBib29sZWFuO1xuICAgIGxhcmdlc2NyZWVuPzogYm9vbGVhbjtcbiAgICBlcXVhbGx5RGl2aWRlZD86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJvdyBjb21wb25lbnQgdGhhdCB3cmFwcyBDb2x1bW4gY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIHN0cmV0Y2hlZD86IGJvb2xlYW4gLSBFbnN1cmVzIHRoZSBjb2x1bW5zIGFyZSBzdHJldGNoZWQgdG8gZXF1YWwgaGVpZ2h0LlxuICAgKiAgIG1vYmlsZT86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogICB0YWJsZXQ/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gdGFibGV0IGRldmljZXMuXG4gICAqICAgY29tcHV0ZXI/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gY29tcHV0ZXIgZGV2aWNlcy5cbiAgICogICBsYXJnZXNjcmVlbj86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiBsYXJnZXNjcmVlbiBkZXZpY2VzLlxuICAgKiAgIGVxdWFsbHlEaXZpZGVkPzogYm9vbGVhbiAtIE1ha2VzIGVhY2ggY29sdW1uIG9mIHRoZSByb3cgZXF1YWwgaW4gd2lkdGguXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnJvd1wiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJvdyBjb21wb25lbnQgdGhhdCB3cmFwcyBDb2x1bW4gY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgc3RyZXRjaGVkPzogYm9vbGVhbiAtIEVuc3VyZXMgdGhlIGNvbHVtbnMgYXJlIHN0cmV0Y2hlZCB0byBlcXVhbCBoZWlnaHQuXG4gICAqICAgbW9iaWxlPzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiAgIHRhYmxldD86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiB0YWJsZXQgZGV2aWNlcy5cbiAgICogICBjb21wdXRlcj86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiBjb21wdXRlciBkZXZpY2VzLlxuICAgKiAgIGxhcmdlc2NyZWVuPzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIGxhcmdlc2NyZWVuIGRldmljZXMuXG4gICAqICAgZXF1YWxseURpdmlkZWQ/OiBib29sZWFuIC0gTWFrZXMgZWFjaCBjb2x1bW4gb2YgdGhlIHJvdyBlcXVhbCBpbiB3aWR0aC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wc3xET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcywgY29udGVudCkgfSB9LCBjb250ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzLCBjb250ZW50KTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5zdHJldGNoZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzdHJldGNoZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm1vYmlsZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIG1vYmlsZSBvbmx5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWJsZXQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB0YWJsZXQgb25seVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcHV0ZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb21wdXRlciBvbmx5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sYXJnZXNjcmVlbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxhcmdlc2NyZWVuIG9ubHlcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmVxdWFsbHlEaXZpZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KGNvbnRlbnQubGVuZ3RoID8gY29udGVudC5sZW5ndGggOiAxKSArIFwiIGNvbHVtblwiO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgcm93XCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2dyaWQvcm93LnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vYnJlYWRjcnVtYlwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZm9ybVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZ3JpZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWVudVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWVzc2FnZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdGFibGVcIjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBJY29uVHlwZSwgU2l6ZSwgQ29sb3IsIEFuaW1hdGlvbiwgRGlyZWN0aW9uIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7IEljb24gfSBmcm9tIFwiZWxlbWVudHMvaWNvblwiO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCJtb2R1bGVzL3RyYW5zaXRpb25cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgb24kPzogU3RyZWFtPGJvb2xlYW4+O1xuICAgIGNsb3NlYWJsZT86IGJvb2xlYW47XG4gICAgaWNvbj86IGJvb2xlYW47XG4gICAgZmxvYXRpbmc/OiBib29sZWFuO1xuICAgIGNvbXBhY3Q/OiBib29sZWFuO1xuICAgIGF0dGFjaGVkPzogYm9vbGVhbjtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBjb2xvcj86IENvbG9yO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29udGVudCB7XG4gICAgaWNvbj86IEljb25UeXBlO1xuICAgIGhlYWRlcj86IERPTUNvbnRlbnQ7XG4gICAgYm9keT86IERPTUNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBjb21wb25lbnQgdG8gcHJlc2VudCBtZXNzYWdlcyB0byB1c2Vycy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIG9uJD86IFN0cmVhbTxib29sZWFuPiAtIFdoZW4gdG8gc2hvdy9oaWRlIHRoZSBtZXNzYWdlLlxuICAgKiAgIGNsb3NlYWJsZT86IGJvb2xlYW4gLSBQcm92aWRlcyBhIGNsb3NlIGljb24gZm9yIHRoZSBtZXNzYWdlIGZvciBkaXNtaXNzYWwuXG4gICAqICAgaWNvbj86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZXNzYWdlIHRvIHN1cHBvcnQgYW4gaWNvbi5cbiAgICogICBmbG9hdGluZz86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZXNzYWdlIHRvIGZsb2F0IGFib3ZlIHJlbGF0ZWQgY29udGVudC5cbiAgICogICBjb21wYWN0PzogYm9vbGVhbiAtIEZvcm1hdHMgYSBtZXNzYWdlIHRvIG9ubHkgb2NjdXB5IHdpZHRoIG5lZWRlZCBieSBpdHMgY29udGVudC5cbiAgICogICBhdHRhY2hlZD86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZXNzYWdlIHRvIGFwcGVhciBhdHRhY2hlZCB0byBvdGhlciBjb250ZW50LlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIG1lc3NhZ2UuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbWVzc2FnZS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge31cbiAgICogICBpY29uPzogU3RyaW5nfFZOb2RlIC0gQSBtZXNzYWdlIGNhbiBoYXZlIGFuIGljb24gc2lnbmlmeWluZyB0aGUgdHlwZSBvZiBtZXNzYWdlLlxuICAgKiAgIGhlYWRlcj86IFN0cmluZ3xWTm9kZSAtIEEgbWVzc2FnZSBjYW4gaGF2ZSBhIGhlYWRlciB0ZXh0LlxuICAgKiAgIGJvZHk/OiBTdHJpbmd8Vk5vZGUgLSBBIG1lc3NhZ2UgY2FuIGhhdmUgYWRkaXRpb25hbHkgYm9keSBjb250ZW50LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgaWNvbiA9IEljb24ucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgcHJvcHMkOiB4cy5vZih7IHR5cGU6IFwiY2xvc2VcIiB9KSB9KTtcbiAgICAgIGNvbnN0IGNsb3NlJCA9IGljb24uRXZlbnRzKFwiY2xpY2tcIikubWFwVG8oZmFsc2UpO1xuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCwgaWNvbi5ET00pXG4gICAgICAgIC5tYXAoKFtwcm9wcywgY29udGVudCwgY2xvc2VJY29uXSkgPT5cbiAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICAgICAgICBjb250ZW50Lmljb24sXG4gICAgICAgICAgICBwcm9wcy5jbG9zZWFibGUgPyBjbG9zZUljb24gOiBcIlwiLFxuICAgICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImNvbnRlbnRcIiB9IH0sIFtdLmNvbmNhdChcbiAgICAgICAgICAgICAgY29udGVudC5oZWFkZXIgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiaGVhZGVyXCIgfSB9LCBjb250ZW50LmhlYWRlcikgOiBcIlwiLFxuICAgICAgICAgICAgICBjb250ZW50LmJvZHlcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICAgIGNvbnN0IG9uJCA9IHNvdXJjZXMucHJvcHMkLm1hcChwcm9wcyA9PiBwcm9wcy5vbiQgPyBwcm9wcy5vbiQgOiB4cy5vZih0cnVlKSkuZmxhdHRlbigpO1xuICAgICAgY29uc3QgYWN0aXZlJCA9IHhzLm1lcmdlKG9uJCwgY2xvc2UkKTtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0gYWN0aXZlJC5mb2xkKChwcmV2QW5pbSwgYWN0aXZlKSA9PiBwcmV2QW5pbS5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5Ob25lXG4gICAgICAgID8geyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IGFjdGl2ZSA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXQgfVxuICAgICAgICA6IHsgYW5pbWF0aW9uOiBBbmltYXRpb24uRmFkZSwgZGlyZWN0aW9uOiBhY3RpdmUgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0IH1cbiAgICAgICAgLCB7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogRGlyZWN0aW9uLk5vbmUgfSk7XG4gICAgICBjb25zdCBhbmltYXRlZFZUcmVlJCA9IFRyYW5zaXRpb24ucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgdGFyZ2V0JDogdlRyZWUkLCBhcmdzJDogdHJhbnNpdGlvbiQgfSkuRE9NO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiBhbmltYXRlZFZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLm1lc3NhZ2VcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXNzYWdlIGNvbXBvbmVudCB0byBwcmVzZW50IG1lc3NhZ2VzIHRvIHVzZXJzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBvbiQ/OiBTdHJlYW08Ym9vbGVhbj4gLSBXaGVuIHRvIHNob3cvaGlkZSB0aGUgbWVzc2FnZS5cbiAgICogICBjbG9zZWFibGU/OiBib29sZWFuIC0gUHJvdmlkZXMgYSBjbG9zZSBpY29uIGZvciB0aGUgbWVzc2FnZSBmb3IgZGlzbWlzc2FsLlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVzc2FnZSB0byBzdXBwb3J0IGFuIGljb24uXG4gICAqICAgZmxvYXRpbmc/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVzc2FnZSB0byBmbG9hdCBhYm92ZSByZWxhdGVkIGNvbnRlbnQuXG4gICAqICAgY29tcGFjdD86IGJvb2xlYW4gLSBGb3JtYXRzIGEgbWVzc2FnZSB0byBvbmx5IG9jY3VweSB3aWR0aCBuZWVkZWQgYnkgaXRzIGNvbnRlbnQuXG4gICAqICAgYXR0YWNoZWQ/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVzc2FnZSB0byBhcHBlYXIgYXR0YWNoZWQgdG8gb3RoZXIgY29udGVudC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBtZXNzYWdlLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IHt9XG4gICAqICAgaWNvbj86IFN0cmluZ3xWTm9kZSAtIEEgbWVzc2FnZSBjYW4gaGF2ZSBhbiBpY29uIHNpZ25pZnlpbmcgdGhlIHR5cGUgb2YgbWVzc2FnZS5cbiAgICogICBoZWFkZXI/OiBTdHJpbmd8Vk5vZGUgLSBBIG1lc3NhZ2UgY2FuIGhhdmUgYSBoZWFkZXIgdGV4dC5cbiAgICogICBib2R5PzogU3RyaW5nfFZOb2RlIC0gQSBtZXNzYWdlIGNhbiBoYXZlIGFkZGl0aW9uYWx5IGJvZHkgY29udGVudC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBDb250ZW50ID0ge30sIGM6IENvbnRlbnQgPSB7fSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0NvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0NvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBjb25zdCBjbG9zZUljb24gPSBJY29uLnJlbmRlcih7fSwgSWNvblR5cGUuQ2xvc2UpO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICBjb250ZW50Lmljb24gPyBJY29uLnJlbmRlcihjb250ZW50Lmljb24pIDogXCJcIixcbiAgICAgIHByb3BzLmNsb3NlYWJsZSA/IGNsb3NlSWNvbiA6IFwiXCIsXG4gICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY29udGVudFwiIH0gfSwgW10uY29uY2F0KFxuICAgICAgICBjb250ZW50LmhlYWRlciA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJoZWFkZXJcIiB9IH0sIGNvbnRlbnQuaGVhZGVyKSA6IFwiXCIsXG4gICAgICAgIGNvbnRlbnQuYm9keVxuICAgICAgKSlcbiAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmljb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpY29uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbG9hdGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsb2F0aW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wYWN0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGFjdFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYXR0YWNoZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhdHRhY2hlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIG1lc3NhZ2VcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb250ZW50KGNvbnRlbnQpOiBjb250ZW50IGlzIENvbnRlbnQge1xuICAgIHJldHVybiBjb250ZW50ICE9PSB1bmRlZmluZWQgJiYgKGlzRE9NQ29udGVudChjb250ZW50Lmljb24pIHx8IGlzRE9NQ29udGVudChjb250ZW50LmhlYWRlcikgfHwgaXNET01Db250ZW50KGNvbnRlbnQuYm9keSkpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvbWVzc2FnZS9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50IH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIENvbG9yIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgdGFibGUsIHRyLCB0aCwgdGQsIHRoZWFkLCB0Ym9keSwgdGZvb3QgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFRhYmxlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgc2luZ2xlbGluZT86IGJvb2xlYW47XG4gICAgZml4ZWQ/OiBib29sZWFuO1xuICAgIHNlbGVjdGFibGU/OiBib29sZWFuO1xuICAgIHN0cmlwZWQ/OiBib29sZWFuO1xuICAgIGNlbGxlZD86IGJvb2xlYW47XG4gICAgYmFzaWM/OiBib29sZWFuO1xuICAgIHZlcnliYXNpYz86IGJvb2xlYW47XG4gICAgY29sbGFwc2luZz86IGJvb2xlYW47XG4gICAgcGFkZGVkPzogYm9vbGVhbjtcbiAgICB2ZXJ5cGFkZGVkPzogYm9vbGVhbjtcbiAgICBjb21wYWN0PzogYm9vbGVhbjtcbiAgICB2ZXJ5Y29tcGFjdD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENvbnRlbnQge1xuICAgIGhlYWRlcj86IEFycmF5PERPTUNvbnRlbnQ+O1xuICAgIGJvZHk6IEFycmF5PEFycmF5PERPTUNvbnRlbnQ+PjtcbiAgICBmb290ZXI/OiBBcnJheTxET01Db250ZW50PiB8IERPTUNvbnRlbnQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBIHRhYmxlIGNvbXBvbmVudCB0byBzaG93IGNvbnRlbnQgaW4gYSB0YWJsZS5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIHNpbmdsZWxpbmU/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgY29udGVudCBvZiB0aGUgdGFibGUgdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUuXG4gICAqICAgZml4ZWQ/OiBib29sZWFuIC0gU3RvcHMgcmVzaXppbmcgb2YgdGFibGUgY2VsbHMgYmFzZWQgb24gY29udGVudC5cbiAgICogICBzZWxlY3RhYmxlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcm93cyBvZiB0aGUgdGFibGUgdG8gYmUgc2VsZWN0YWJsZS5cbiAgICogICBzdHJpcGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcm93cyBvZiB0aGUgdGFibGUgdG8gYWx0ZXJuYXRlIGNvbG9ycy5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gRGl2aWRlcyBlYWNoIHJvdyBpbnRvIHNlcGVyYXRlIGNlbGxzLlxuICAgKiAgIGJhc2ljPzogYm9vbGVhbiAtIFJlZHVjZXMgdGhlIGNvbXBsZXhpdHkgb2YgdGhlIHRhYmxlLlxuICAgKiAgIHZlcnliYXNpYz86IGJvb2xlYW4gLSBSZWR1Y2VzIHRoZSBjb21wbGV4aXR5IG9mIHRoZSB0YWJsZSBieSBhIGxvdC5cbiAgICogICBjb2xsYXBzaW5nPzogYm9vbGVhbiAtIE1ha2VzIHRoZSB0YWJsZSBvbmx5IHRha2UgdXAgYXMgbXVjaCBzcGFjZSBhcyBuZWVkZWQuXG4gICAqICAgcGFkZGVkPzogYm9vbGVhbiAtIEFkZHMgZXh0cmEgcGFkZGluZyB0byB0aGUgdGFibGUgY29udGVudC5cbiAgICogICB2ZXJ5cGFkZGVkPzogYm9vbGVhbiAtIEFkZHMgYSBsb3Qgb2YgZXh0cmEgcGFkZGluZyB0byB0aGUgdGFibGUgY29udGVudC5cbiAgICogICBjb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGFibGUgY29udGVudCB0byBiZSBtb3JlIGNvbXBhY3QsIHRvIGFsbG93IGZvciBtb3JlIHJvd3MuXG4gICAqICAgdmVyeWNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0YWJsZSBjb250ZW50IHRvIGJlIGdyZWF0bHkgY29tcGFjdGVkLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHRhYmxlIGNvbnRlbnQuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvdXIgb2YgdGhlIHRhYmxlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiB7fSBvZlxuICAgKiBcdGhlYWRlcnM6IFtET01Db250ZW50XVxuICAgKiBcdGJvZHk6IFtbRG9tQ29udGVudF1dXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKHsgYm9keTogW10gfSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnRhYmxlXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdGFibGUgY29tcG9uZW50IHRvIHNob3cgY29udGVudCBpbiBhIHRhYmxlLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgc2luZ2xlbGluZT86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBjb250ZW50IG9mIHRoZSB0YWJsZSB0byBmaXQgb24gYSBzaW5nbGUgbGluZS5cbiAgICogICBmaXhlZD86IGJvb2xlYW4gLSBTdG9wcyByZXNpemluZyBvZiB0YWJsZSBjZWxscyBiYXNlZCBvbiBjb250ZW50LlxuICAgKiAgIHNlbGVjdGFibGU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSByb3dzIG9mIHRoZSB0YWJsZSB0byBiZSBzZWxlY3RhYmxlLlxuICAgKiAgIHN0cmlwZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSByb3dzIG9mIHRoZSB0YWJsZSB0byBhbHRlcm5hdGUgY29sb3JzLlxuICAgKiAgIGNlbGxlZD86IGJvb2xlYW4gLSBEaXZpZGVzIGVhY2ggcm93IGludG8gc2VwZXJhdGUgY2VsbHMuXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gUmVkdWNlcyB0aGUgY29tcGxleGl0eSBvZiB0aGUgdGFibGUuXG4gICAqICAgdmVyeWJhc2ljPzogYm9vbGVhbiAtIFJlZHVjZXMgdGhlIGNvbXBsZXhpdHkgb2YgdGhlIHRhYmxlIGJ5IGEgbG90LlxuICAgKiAgIGNvbGxhcHNpbmc/OiBib29sZWFuIC0gTWFrZXMgdGhlIHRhYmxlIG9ubHkgdGFrZSB1cCBhcyBtdWNoIHNwYWNlIGFzIG5lZWRlZC5cbiAgICogICBwYWRkZWQ/OiBib29sZWFuIC0gQWRkcyBleHRyYSBwYWRkaW5nIHRvIHRoZSB0YWJsZSBjb250ZW50LlxuICAgKiAgIHZlcnlwYWRkZWQ/OiBib29sZWFuIC0gQWRkcyBhIGxvdCBvZiBleHRyYSBwYWRkaW5nIHRvIHRoZSB0YWJsZSBjb250ZW50LlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0YWJsZSBjb250ZW50IHRvIGJlIG1vcmUgY29tcGFjdCwgdG8gYWxsb3cgZm9yIG1vcmUgcm93cy5cbiAgICogICB2ZXJ5Y29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRhYmxlIGNvbnRlbnQgdG8gYmUgZ3JlYXRseSBjb21wYWN0ZWQuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGFibGUgY29udGVudC5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG91ciBvZiB0aGUgdGFibGUuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IHt9IG9mXG4gICAqIFx0aGVhZGVyczogW0RPTUNvbnRlbnRdXG4gICAqIFx0Ym9keTogW1tEb21Db250ZW50XV1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBDb250ZW50ID0ge30sIGM6IENvbnRlbnQgPSB7IGJvZHk6IFtdIH0pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNDb250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNDb250ZW50KHBPckMpID8gcE9yQyA6IGM7XG5cbiAgICBsZXQgaGVhZGVyID0gY29udGVudC5oZWFkZXIgPyB0aGVhZChbdHIoY29udGVudC5oZWFkZXIubWFwKGggPT4gdGgoaCkpKV0pIDogXCJcIjtcbiAgICBsZXQgZm9vdGVyO1xuICAgIGlmIChpc0RPTUNvbnRlbnQoY29udGVudC5mb290ZXIpKSB7XG4gICAgICBmb290ZXIgPSB0Zm9vdChjb250ZW50LmZvb3Rlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9vdGVyID0gY29udGVudC5mb290ZXIgPyB0Zm9vdChbdHIoY29udGVudC5mb290ZXIubWFwKGYgPT4gdGgoZikpKV0pIDogXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGUoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICBoZWFkZXIsXG4gICAgICB0Ym9keShjb250ZW50LmJvZHkubWFwKHIgPT4gdHIoci5tYXAoYyA9PiB0ZChjKSkpKSksXG4gICAgICBmb290ZXJcbiAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5zaW5nbGVsaW5lKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2luZ2xlIGxpbmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZpeGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZml4ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNlbGVjdGFibGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzZWxlY3RhYmxlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zdHJpcGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3RyaXBlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2VsbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2VsbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5iYXNpYykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJhc2ljXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ5YmFzaWMpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ5IGJhc2ljXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb2xsYXBzaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29sbGFwc2luZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucGFkZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcGFkZGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ5cGFkZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVyeSBwYWRkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXBhY3QpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb21wYWN0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ5Y29tcGFjdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnkgY29tcGFjdFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIHRhYmxlXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29udGVudChjb250ZW50KTogY29udGVudCBpcyBDb250ZW50IHtcbiAgICByZXR1cm4gY29udGVudCAhPT0gdW5kZWZpbmVkICYmIChcbiAgICAgICg8Q29udGVudD5jb250ZW50KS5ib2R5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICgoPENvbnRlbnQ+Y29udGVudCkuaGVhZGVyICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKDxDb250ZW50PmNvbnRlbnQpLmZvb3RlciAhPT0gdW5kZWZpbmVkKSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy90YWJsZS9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXMsIGlzRE9NQ29udGVudCB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgU2l6ZSwgQXR0YWNobWVudCwgRmxvYXQgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYsIGEgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEJ1dHRvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGFuaW1hdGVkPzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbEFuaW1hdGVkPzogYm9vbGVhbjtcbiAgICBsYWJlbGVkPzogYm9vbGVhbjtcbiAgICByaWdodGxhYmVsZWQ/OiBib29sZWFuO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGJhc2ljPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgY29tcGFjdD86IGJvb2xlYW47XG4gICAgY2lyY3VsYXI/OiBib29sZWFuO1xuICAgIGZsdWlkPzogYm9vbGVhbjtcbiAgICBocmVmPzogc3RyaW5nO1xuICAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50O1xuICAgIHNpemU/OiBTaXplO1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgfVxuICAvKipcbiAgICogQW4gaW50ZXJhY3RpdmUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdXNlciBpbnRlcmFjdGlvbiB0aHJvdWdoIGNsaWNraW5nLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBhbmltYXRlZD8gOiBib29sZWFuIC0gQWxsb3dzIGZvciBhbiBhbmltYXRpb24gaW4gdGhlIGJ1dHRvbiB0byBzaG93IGhpZGRlbiBjb250ZW50LlxuICAgKiAgIHZlcnRpY2FsQW5pbWF0ZWQ/OiBib29sZWFuIC0gU2VlIGFuaW1hdGVkLiBUaGlzIGFuaW1hdGlvbiBpcyB2ZXJ0aWNhbC5cbiAgICogICBsYWJlbGVkPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgbGFiZWxlZCBidXR0b25zLlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBidXR0b25zIHdpdGggYW4gaWNvbi5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgc2ltcGxlci5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgb24gZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBhY3RpdmU/OiBib29sZWFuIC0gU2V0cyB0aGUgYnV0dG9uIHRvIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGxvYWRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gc2hvdyB0aGF0IGl0IGlzIGxvYWRpbmcgLyB3b3JraW5nLlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gZm9yIGEgdGlnaHQgZml0LlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGFwcGVhciBjaXJjdWxhci5cbiAgICogICBmbHVpZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBiZSBhcyB3aWRlIGFzIHBvc3NpYmxlLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBPdXRwdXRzIHRoZSBidXR0b24gYXMgYSBsaW5rIHRvIHRvIHRoZSBocmVmLlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gV2hlcmUgdGhlIGJ1dHRvbiBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYnV0dG9uLlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBUaGUgbGVmdCBvciByaWdodCBmbG9hdCBvZiB0aGUgYnV0dG9uLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGJ1dHRvbi5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge30gb2ZcbiAgICogICBib2R5PzogRE9NQ29udGVudCAtIFRoZSBib2R5IGNvbnRlbnQgdG8gZGlzcGxheSBvbiB0aGUgYnV0dG9uLlxuICAgKiAgIGhpZGRlbj86IERPTUNvbnRlbnQgLSBUaGUgaGlkZGVuIGNvbnRlbnQgdG8gZGlzcGxheSBmb3IgYW5pbWF0ZWQgYnV0dG9ucy5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50Pikge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLmV4dHJhcyQgPSBzb3VyY2VzLmV4dHJhcyQgPyBzb3VyY2VzLmV4dHJhcyQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdnRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCwgc291cmNlcy5leHRyYXMkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnQsIGV4dHJhc10pID0+IHJlbmRlcihwcm9wcywgY29udGVudCwgZXh0cmFzKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdnRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIudWkuYnV0dG9uXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3RhdGljIGJ1dHRvbiBjb21wb25lbnQgZm9yIHVzZXIgaW50ZXJhY3Rpb24gdGhyb3VnaCBjbGlja2luZy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgcHJvcGVydGllczpcbiAgICogICBhbmltYXRlZD8gOiBib29sZWFuIC0gQWxsb3dzIGZvciBhbiBhbmltYXRpb24gaW4gdGhlIGJ1dHRvbiB0byBzaG93IGhpZGRlbiBjb250ZW50LlxuICAgKiAgIHZlcnRpY2FsQW5pbWF0ZWQ/OiBib29sZWFuIC0gU2VlIGFuaW1hdGVkLiBUaGlzIGFuaW1hdGlvbiBpcyB2ZXJ0aWNhbC5cbiAgICogICBsYWJlbGVkPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgbGFiZWxlZCBidXR0b25zLlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBidXR0b25zIHdpdGggYW4gaWNvbi5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgc2ltcGxlci5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgb24gZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBhY3RpdmU/OiBib29sZWFuIC0gU2V0cyB0aGUgYnV0dG9uIHRvIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGxvYWRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gc2hvdyB0aGF0IGl0IGlzIGxvYWRpbmcgLyB3b3JraW5nLlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gZm9yIGEgdGlnaHQgZml0LlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGFwcGVhciBjaXJjdWxhci5cbiAgICogICBmbHVpZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBiZSBhcyB3aWRlIGFzIHBvc3NpYmxlLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBPdXRwdXRzIHRoZSBidXR0b24gYXMgYSBsaW5rIHRvIHRvIHRoZSBocmVmLlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gV2hlcmUgdGhlIGJ1dHRvbiBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYnV0dG9uLlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBUaGUgbGVmdCBvciByaWdodCBmbG9hdCBvZiB0aGUgYnV0dG9uLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGJ1dHRvbi5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDoge30gb2ZcbiAgICogICBib2R5PzogRE9NQ29udGVudCAtIFRoZSBib2R5IGNvbnRlbnQgdG8gZGlzcGxheSBvbiB0aGUgYnV0dG9uLlxuICAgKiAgIGhpZGRlbj86IERPTUNvbnRlbnQgLSBUaGUgaGlkZGVuIGNvbnRlbnQgdG8gZGlzcGxheSBmb3IgYW5pbWF0ZWQgYnV0dG9ucy5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiLCBlOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgZXh0cmEgPSBpc0RPTUNvbnRlbnQocE9yQykgPyAoYyAhPT0gXCJcIikgPyBjIDogZSA6IGU7XG4gICAgbGV0IGNoaWxkcmVuID0gZXh0cmFcbiAgICAgID8gW2Rpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ2aXNpYmxlIGNvbnRlbnRcIiB9IH0sIGNvbnRlbnQpLFxuICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImhpZGRlbiBjb250ZW50XCIgfSB9LCBleHRyYSldXG4gICAgICA6IGNvbnRlbnQ7XG4gICAgcmV0dXJuIHByb3BzLmhyZWZcbiAgICAgID8gYSh7IHByb3BzOiB7IGhyZWY6IHByb3BzLmhyZWYsIGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNoaWxkcmVuKVxuICAgICAgOiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBjaGlsZHJlbik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5hbmltYXRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFuaW1hdGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ0aWNhbEFuaW1hdGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWwuYW5pbWF0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxhYmVsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsYWJlbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yaWdodGxhYmVsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodCBsYWJlbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pY29uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaWNvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYmFzaWMpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBiYXNpY1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYWN0aXZlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYWN0aXZlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sb2FkaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbG9hZGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcGFjdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXBhY3RcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZsdWlkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZmx1aWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKHByb3BzLmZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgYnV0dG9uXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2J1dHRvbi9pbmRleC50cyIsImltcG9ydCB7RE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnR9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHtkaXZ9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29udGFpbmVyIHtcbiAgLyoqXG4gICogQSByZXNwb25zaXZlIGNvbnRhaW5lciBjb21wb25lbnQgdG8gaG9zdCBvdGhlciBjb250ZW50LlxuICAqIERvZXMgbm90IGFjY2VwdCBhbnkgcHJvcGVydGllcyBpbiBwcm9wcyQuXG4gICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8YW55LCBET01Db250ZW50PikgOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPGFueSwgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSBzb3VyY2VzLmNvbnRlbnQkLm1hcChjb250ZW50ID0+IHJlbmRlcihjb250ZW50KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmNvbnRhaW5lclwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAqIEEgcmVzcG9uc2l2ZSBjb250YWluZXIgY29tcG9uZW50IHRvIGhvc3Qgb3RoZXIgY29udGVudC5cbiAgKiBEb2VzIG5vdCBhY2NlcHQgYW55IHByb3BlcnRpZXMuXG4gICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IE9iamVjdHxET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKSA6IFZOb2RlIHtcbiAgICAvLyBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidWkgY29udGFpbmVyXCJ9fSwgY29udGVudCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9jb250YWluZXIvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcyxJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50fSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7ZGl2fSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIERpdmlkZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBob3Jpem9udGFsPzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbD86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIGZpdHRlZD86IGJvb2xlYW47XG4gICAgaGlkZGVuPzogYm9vbGVhbjtcbiAgICBzZWN0aW9uPzogYm9vbGVhbjtcbiAgICBjbGVhcmluZz86IGJvb2xlYW47XG4gICAgaGVhZGVyPzogYm9vbGVhbjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRpdmlkZXIgZWxlbWVudCB0byBzZXBlcmF0ZSBjb250ZW50IG9uIHBhZ2UuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogXHRjb250ZW50PzogVk5vZGUgLSBUaGUgY29udGVudCB0byBhZGQgdG8gdGhlIGRpdmlkZXIuXG4gICAqIFx0aG9yaXpvbnRhbD86IGJvb2xlYW4gLSBOZWVkZWQgdG8gcmVuZGVyIHRleHQgaG9yaXpvbnRhbGx5IGluIHRoZSBkaXZpZGVyLlxuICAgKiBcdHZlcnRpY2FsPzogYm9vbGVhbiAtIERldGVybWluZXMgdmVydGljYWwvaG9yaXpvbnRhbCBvcmllbnRhdGlvbiBvZiB0aGUgZGl2aWRlci5cbiAgICogXHRpbnZlcnRlZD86IGJvb2xlYW4gLSBGb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogXHRmaXR0ZWQ/OiBib29sZWFuIC0gTWluaW1pemVzIHRoZSBzcGFjZSBiZXR3ZWVuIGRpdmlkZWQgY29udGVudC5cbiAgICogXHRoaWRkZW4/OiBib29sZWFuIC0gQ3JlYXRlcyBhbiBpbnZpc2libGUgZGl2aWRlciB0aGF0IGRpdmlkZXMgdGhlIGNvbnRlbnQuXG4gICAqIFx0c2VjdGlvbj86IGJvb2xlYW4gLSBQcm92aWRlcyBncmVhdGVyIG1hcmdpbnMgZm9yIGJldHdlZW4gZGl2aWRlZCBjb250ZW50LlxuICAgKiBcdGNsZWFyaW5nPzogYm9vbGVhbiAtIENsZWFycyBmbG9hdGVkIGNvbnRlbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIDogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmRpdmlkZXJcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRpdmlkZXIgZWxlbWVudCB0byBzZXBlcmF0ZSBjb250ZW50IG9uIHBhZ2UuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiBcdGNvbnRlbnQ/OiBWTm9kZSAtIFRoZSBjb250ZW50IHRvIGFkZCB0byB0aGUgZGl2aWRlci5cbiAgICogXHRob3Jpem9udGFsPzogYm9vbGVhbiAtIE5lZWRlZCB0byByZW5kZXIgdGV4dCBob3Jpem9udGFsbHkgaW4gdGhlIGRpdmlkZXIuXG4gICAqIFx0dmVydGljYWw/OiBib29sZWFuIC0gRGV0ZXJtaW5lcyB2ZXJ0aWNhbC9ob3Jpem9udGFsIG9yaWVudGF0aW9uIG9mIHRoZSBkaXZpZGVyLlxuICAgKiBcdGludmVydGVkPzogYm9vbGVhbiAtIEZvciBkYXJrIGJhY2tncm91bmRzLlxuICAgKiBcdGZpdHRlZD86IGJvb2xlYW4gLSBNaW5pbWl6ZXMgdGhlIHNwYWNlIGJldHdlZW4gZGl2aWRlZCBjb250ZW50LlxuICAgKiBcdGhpZGRlbj86IGJvb2xlYW4gLSBDcmVhdGVzIGFuIGludmlzaWJsZSBkaXZpZGVyIHRoYXQgZGl2aWRlcyB0aGUgY29udGVudC5cbiAgICogXHRzZWN0aW9uPzogYm9vbGVhbiAtIFByb3ZpZGVzIGdyZWF0ZXIgbWFyZ2lucyBmb3IgYmV0d2VlbiBkaXZpZGVkIGNvbnRlbnQuXG4gICAqIFx0Y2xlYXJpbmc/OiBib29sZWFuIC0gQ2xlYXJzIGZsb2F0ZWQgY29udGVudC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wc3xET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczoge2NsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKHByb3BzLCBjb250ZW50KSB9fSwgY29udGVudCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BzOiBQcm9wcywgY29udGVudD8pIDogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy52ZXJ0aWNhbCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnRpY2FsXCI7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZml0dGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZml0dGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5oaWRkZW4pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBoaWRkZW5cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNlY3Rpb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzZWN0aW9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jbGVhcmluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNsZWFyaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5oZWFkZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBoZWFkZXJcIjtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGRpdmlkZXJcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvZGl2aWRlci9pbmRleC50cyIsImltcG9ydCB7RE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlcyxJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50fSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgQXR0YWNobWVudCwgRmxvYXQsIFRleHRBbGlnbm1lbnQsIENvbG9yIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBIZWFkZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBpY29uPzogYm9vbGVhbjtcbiAgICBkaXZpZGVyPzogYm9vbGVhbjtcbiAgICBibG9jaz86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgICBmbG9hdD86IEZsb2F0O1xuICAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50O1xuICAgIHNpemU/OiBTaXplO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBFeHRyYXMge1xuICAgIHN1YnRleHQ/OiBET01Db250ZW50O1xuICAgIGljb24/OiBET01Db250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoZWFkZXIgZm9yIGltcG9ydGFudCB0ZXh0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgaWNvbj86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGljb24gaGVhZGVycy5cbiAgICogICBkaXZpZGVyPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgaGVhZGVycyB0byBzZXBlcmF0ZSBjb250ZW50LlxuICAgKiAgIGJsb2NrPzogYm9vbGVhbiAtIFdyYXBzIGhlYWRlciBpbiBhIGJsb2NrLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGRpc2FibGVkIGNvbnRlbnQuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGluZyBmb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFN0eWxpbmcgZm9yIGhlYWRlcnMgYXR0YWNoZWQgdG8gb3RoZXIgY29udGVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gRmxvYXRzIHRoZSBoZWFkZXIgdG8gdGhlIGxlZnQgb3IgcmlnaHQuXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQgLSBUZXh0IGFsaWdubWVudCBvZiB0aGUgaGVhZGVyIHRleHQuXG4gICAqICAgc2l6ZT86IFNpemUgLSBEZXRlcm1pbmVzIHRoZSBzaXplIG9mIHRoZSBoZWFkZXIuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaGVhZGVyLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiB7fSBvZlxuICAgKiAgIHRleHQ6IERPTUNvbnRlbnQgLSBUaGUgaGVhZGVyIHRleHQuXG4gICAqICAgc3VidGV4dD86IERPTUNvbnRlbnQtIEFuIG9wdGlvbmFsIHN1Yi1oZWFkZXIgdG8gYWNjb21wYW55IHRoZSBoZWFkZXIuXG4gICAqICAgaWNvbj86IERPTUNvbnRlbnQgLSBPcHRpb25hbCBpbWFnZS9pY29uIGNvbnRlbnQgZm9yIHRoZSBoZWFkZXIuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRXh0cmFzPik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRXh0cmFzPikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLmV4dHJhcyQgPSBzb3VyY2VzLmV4dHJhcyQgPyBzb3VyY2VzLmV4dHJhcyQgOiB4cy5vZih7fSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQsIHNvdXJjZXMuZXh0cmFzJCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50LCBleHRyYXNdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQsIGV4dHJhcylcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmhlYWRlclwiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGhlYWRlciBmb3IgaW1wb3J0YW50IHRleHQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBpY29uIGhlYWRlcnMuXG4gICAqICAgZGl2aWRlcj86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGhlYWRlcnMgdG8gc2VwZXJhdGUgY29udGVudC5cbiAgICogICBibG9jaz86IGJvb2xlYW4gLSBXcmFwcyBoZWFkZXIgaW4gYSBibG9jay5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBkaXNhYmxlZCBjb250ZW50LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBTdHlsaW5nIGZvciBoZWFkZXJzIGF0dGFjaGVkIHRvIG90aGVyIGNvbnRlbnQuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIEZsb2F0cyB0aGUgaGVhZGVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGV4dCBhbGlnbm1lbnQgb2YgdGhlIGhlYWRlciB0ZXh0LlxuICAgKiAgIHNpemU/OiBTaXplIC0gRGV0ZXJtaW5lcyB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGhlYWRlci5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDoge30gb2ZcbiAgICogICB0ZXh0OiBET01Db250ZW50IC0gVGhlIGhlYWRlciB0ZXh0LlxuICAgKiAgIHN1YnRleHQ/OiBET01Db250ZW50LSBBbiBvcHRpb25hbCBzdWItaGVhZGVyIHRvIGFjY29tcGFueSB0aGUgaGVhZGVyLlxuICAgKiAgIGljb24/OiBET01Db250ZW50IC0gT3B0aW9uYWwgaW1hZ2UvaWNvbiBjb250ZW50IGZvciB0aGUgaGVhZGVyLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDb3JFOiBQcm9wcyB8IERPTUNvbnRlbnQgfCBFeHRyYXMgPSB7fSwgY09yRTogRE9NQ29udGVudCB8IEV4dHJhcyA9IHt9LCBlOiBFeHRyYXMgPSB7fSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQ29yRSkgPyB7fSA6IGlzRXh0cmFzKHBPckNvckUpID8ge30gOiBwT3JDb3JFO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckNvckUpID8gcE9yQ29yRSA6IGlzRE9NQ29udGVudChjT3JFKSA/IGNPckUgOiBcIlwiO1xuICAgIGxldCBleHRyYXMgPSBpc0V4dHJhcyhwT3JDb3JFKSA/IHBPckNvckUgOiBpc0V4dHJhcyhjT3JFKSA/IGNPckUgOiBlO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICBleHRyYXMuaWNvbiA/IGV4dHJhcy5pY29uIDogXCJcIixcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBbXS5jb25jYXQoXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGV4dHJhcy5zdWJ0ZXh0ID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInN1YiBoZWFkZXJcIiB9IH0sIGV4dHJhcy5zdWJ0ZXh0KSA6IFwiXCJcbiAgICAgICkpXG4gICAgXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpdmlkZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXZpZGVyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ibG9jaykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJsb2NrXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnRleHRBbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVGV4dEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy50ZXh0QWxpZ25tZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgaGVhZGVyXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXh0cmFzKGV4dHJhKTogZXh0cmEgaXMgRXh0cmFzIHtcbiAgICByZXR1cm4gZXh0cmEgIT09IHVuZGVmaW5lZCAmJiAoKDxFeHRyYXM+ZXh0cmEpLnN1YnRleHQgIT09IHVuZGVmaW5lZFxuICAgICAgfHwgKCg8RXh0cmFzPmV4dHJhKS5pY29uICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICgoPEV4dHJhcz5leHRyYSkuaWNvbikgIT09IFwiYm9vbGVhblwiKSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9oZWFkZXIvaW5kZXgudHMiLCJpbXBvcnQgeyBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgVmVydGljYWxBbGlnbm1lbnQsIEZsb2F0IH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGEsIGltZyB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBJbWFnZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGhyZWY/OiBzdHJpbmc7XG4gICAgaGlkZGVuPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgYXZhdGFyPzogYm9vbGVhbjtcbiAgICBib3JkZXJlZD86IGJvb2xlYW47XG4gICAgc3BhY2VkPzogYm9vbGVhbjtcbiAgICBjaXJjdWxhcj86IGJvb2xlYW47XG4gICAgcm91bmRlZD86IGJvb2xlYW47XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgICBzaXplPzogU2l6ZTtcbiAgICB2ZXJ0aWNhbEFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltYWdlIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBpbWFnZXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBocmVmPzogc3RyaW5nIC0gU3R5bGVzIHRoZSBpbWFnZSBhcyBhIGxpbmsgdG93YXJkcyB0aGUgbG9jYXRpb24uXG4gICAqICAgaGlkZGVuPzogYm9vbGVhbiAtIEhpZGVzIHRoZSBpbWFnZS5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBhdmF0YXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSBmb3IgdXNhZ2UgYXMgYW4gYXZhdGFyLlxuICAgKiAgIGJvcmRlcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2Ugd2l0aCBhIGJvcmRlci5cbiAgICogICBzcGFjZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB3aXRoIGV4dHJhIHNwYWNpbmcgdG8gc2VwZXJhdGUgaXQgZnJvbSBuZWFyYnkgY29udGVudC5cbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIHJvdW5kZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB0byBoYXZlIHJvdW5kZWQgZWRnZXMuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFRoZSBmbG9hdCBvcmllbnRhdGlvbiBvZiB0aGUgaW1hZ2UuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgaW1hZ2UuXG4gICAqICAgdmVydGljYWxBbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudCAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGV4dCBuZWFyYnkgdGhlIGltYWdlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBzdHJpbmcgLSBUaGUgc3JjIHVybC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgc3RyaW5nPik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIHN0cmluZz4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5pbWFnZVwiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1hZ2UgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGltYWdlcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgbGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIGFzIGEgbGluay5cbiAgICogICBoaWRkZW4/OiBib29sZWFuIC0gSGlkZXMgdGhlIGltYWdlLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2UgdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGF2YXRhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIGZvciB1c2FnZSBhcyBhbiBhdmF0YXIuXG4gICAqICAgYm9yZGVyZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB3aXRoIGEgYm9yZGVyLlxuICAgKiAgIHNwYWNlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHdpdGggZXh0cmEgc3BhY2luZyB0byBzZXBlcmF0ZSBpdCBmcm9tIG5lYXJieSBjb250ZW50LlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2UgdG8gYmUgY2lyY3VsYXIuXG4gICAqICAgcm91bmRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGhhdmUgcm91bmRlZCBlZGdlcy5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gVGhlIGZsb2F0IG9yaWVudGF0aW9uIG9mIHRoZSBpbWFnZS5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBpbWFnZS5cbiAgICogICB2ZXJ0aWNhbEFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0ZXh0IG5lYXJieSB0aGUgaW1hZ2UuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IHN0cmluZyAtIFRoZSBzcmMgdXJsLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IHN0cmluZyA9IHt9LCBjOiBzdHJpbmcgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IHR5cGVvZiAocE9yQykgPT09IFwic3RyaW5nXCIgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSB0eXBlb2YgKHBPckMpID09PSBcInN0cmluZ1wiID8gcE9yQyA6IGM7XG4gICAgbGV0IGltYWdlID0gaW1nKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpLCBzcmM6IGNvbnRlbnQgfSB9KTtcbiAgICByZXR1cm4gcHJvcHMuaHJlZiA/IGEoeyBwcm9wczogeyBocmVmOiBwcm9wcy5ocmVmIH0gfSwgaW1hZ2UpIDogaW1hZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuaHJlZikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxpbmtcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhpZGRlbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGhpZGRlblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYXZhdGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYXZhdGFyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ib3JkZXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJvcmRlcmVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zcGFjZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzcGFjZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJvdW5kZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByb3VuZGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKHByb3BzLmZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy52ZXJ0aWNhbEFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBWZXJ0aWNhbEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy52ZXJ0aWNhbEFsaWdubWVudCk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWUgKyBcIiBpbWFnZVwiO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvaW1hZ2UvaW5kZXgudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9idXR0b25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbnRhaW5lclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZGl2aWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVhZGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pY29uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbWFnZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGFiZWxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpc3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xvYWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2VnbWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RlcFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdGV4dGJveFwiO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnQgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgQXR0YWNobWVudCwgQ29sb3IgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIExhYmVsIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgY2lyY3VsYXI/OiBib29sZWFuO1xuICAgIGVtcHR5PzogYm9vbGVhbjtcbiAgICBwb2ludGluZz86IGJvb2xlYW47XG4gICAgYmFzaWM/OiBib29sZWFuO1xuICAgIGxlZnRDb3JuZXI/OiBib29sZWFuO1xuICAgIHJpZ2h0Q29ybmVyPzogYm9vbGVhbjtcbiAgICB0YWc/OiBib29sZWFuO1xuICAgIHJpYmJvbj86IGJvb2xlYW47XG4gICAgaW52UmliYm9uPzogYm9vbGVhbjtcbiAgICBob3Jpem9udGFsPzogYm9vbGVhbjtcbiAgICBmbG9hdGluZz86IGJvb2xlYW47XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gICAgc2l6ZT86IFNpemU7XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTGFiZWwgY29tcG9uZW50IHRvIGFkZCBpbmZvcm1hdGlvbiB0byBjZXJ0YWluIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIGVtcHR5PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgZm9yIGVtcHR5IGNvbnRlbnQuXG4gICAqICAgcG9pbnRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBwb2ludGluZyB0b3dhcmRzIG5lYXJieSBjb250ZW50LlxuICAgKiAgIGJhc2ljPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgbWluaW1hbGlzdGljLlxuICAgKiAgIGxlZnRDb3JuZXI/OiBib29sZWFuIC0gQXR0YWNoZXMgdGhlIGxhYmVsIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgcmlnaHRDb3JuZXI/OiBib29sZWFuIC0gQXR0YWNoZXMgdGhlIGxhYmVsIHRvIHRoZSB0b3AtcmlnaHQgY29ybmVyIG9mIG5lYXJieSBjb250ZW50LlxuICAgKiAgIHRhZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGxvb2sgbGlrZSBhIHRhZy5cbiAgICogICByaWJib24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBsb29rIGxpa2UgYSByaWJib24gb3ZlciB0aGUgbGVmdCBzaWRlIG9mIGNvbnRlbnQuXG4gICAqICAgaW52UmliYm9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gbG9vayBsaWtlIGEgcmliYm9uIG92ZXIgdGhlIHJpZ2h0IHNpZGUgb2YgY29udGVudC5cbiAgICogICBob3Jpem9udGFsPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgZm9yIGhvcml6b250YWwgY29udGVudC5cbiAgICogICBmbG9hdGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIGZsb2F0aW5nIG92ZXIgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBXaGVyZSB0aGUgbGFiZWwgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxhYmVsLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGxhYmVsLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGFuZCBleHRyYXM6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcbiAgICAgIHNvdXJjZXMuZXh0cmFzJCA9IHNvdXJjZXMuZXh0cmFzJCA/IHNvdXJjZXMuZXh0cmFzJCA6IHhzLm9mKFtdKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCwgc291cmNlcy5leHRyYXMkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnQsIGV4dHJhc10pID0+IHJlbmRlcihwcm9wcywgY29udGVudCwgZXh0cmFzKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIubGFiZWxcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIExhYmVsIGNvbXBvbmVudCB0byBhZGQgaW5mb3JtYXRpb24gdG8gY2VydGFpbiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIGVtcHR5PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgZm9yIGVtcHR5IGNvbnRlbnQuXG4gICAqICAgcG9pbnRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBwb2ludGluZyB0b3dhcmRzIG5lYXJieSBjb250ZW50LlxuICAgKiAgIGJhc2ljPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgbWluaW1hbGlzdGljLlxuICAgKiAgIGxlZnRDb3JuZXI/OiBib29sZWFuIC0gQXR0YWNoZXMgdGhlIGxhYmVsIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgcmlnaHRDb3JuZXI/OiBib29sZWFuIC0gQXR0YWNoZXMgdGhlIGxhYmVsIHRvIHRoZSB0b3AtcmlnaHQgY29ybmVyIG9mIG5lYXJieSBjb250ZW50LlxuICAgKiAgIHRhZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGxvb2sgbGlrZSBhIHRhZy5cbiAgICogICByaWJib24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBsb29rIGxpa2UgYSByaWJib24gb3ZlciB0aGUgbGVmdCBzaWRlIG9mIGNvbnRlbnQuXG4gICAqICAgaW52UmliYm9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gbG9vayBsaWtlIGEgcmliYm9uIG92ZXIgdGhlIHJpZ2h0IHNpZGUgb2YgY29udGVudC5cbiAgICogICBob3Jpem9udGFsPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgZm9yIGhvcml6b250YWwgY29udGVudC5cbiAgICogICBmbG9hdGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIGZsb2F0aW5nIG92ZXIgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBXaGVyZSB0aGUgbGFiZWwgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxhYmVsLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGxhYmVsLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGFuZCBleHRyYXM6IERPTUNvbnRlbnRcbiAgICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIiwgZTogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgbGV0IGRldGFpbCA9IGlzRE9NQ29udGVudChwT3JDKSA/IGMgOiBlO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICBjb250ZW50LFxuICAgICAgZGV0YWlsID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImRldGFpbFwiIH0gfSwgZGV0YWlsKSA6IFwiXCJcbiAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmVtcHR5KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZW1wdHlcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBvaW50aW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcG9pbnRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmJhc2ljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYmFzaWNcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxlZnRDb3JuZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsZWZ0IGNvcm5lclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmlnaHRDb3JuZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodCBjb3JuZXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRhZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRhZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmliYm9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmliYm9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZSaWJib24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodCByaWJib25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhvcml6b250YWwpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBob3Jpem9udGFsXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbG9hdGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsb2F0aW5nIFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hdHRhY2htZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgbGFiZWxcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvbGFiZWwvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MgfSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgVmVydGljYWxBbGlnbm1lbnQsIEZsb2F0IH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgYSwgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBMaXN0IHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgYnVsbGV0ZWQ/OiBib29sZWFuO1xuICAgIG9yZGVyZWQ/OiBib29sZWFuO1xuICAgIGhvcml6b250YWw/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBzZWxlY3Rpb24/OiBib29sZWFuO1xuICAgIGFuaW1hdGVkPzogYm9vbGVhbjtcbiAgICByZWxheGVkPzogYm9vbGVhbjtcbiAgICBkaXZpZGVkPzogYm9vbGVhbjtcbiAgICBjZWxsZWQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50O1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gIH1cbiAgZXhwb3J0IHR5cGUgQ29udGVudCA9IEFycmF5PExpc3RJdGVtPjtcbiAgZXhwb3J0IGludGVyZmFjZSBMaXN0SXRlbSB7XG4gICAgbGVmdD86IERPTUNvbnRlbnQ7XG4gICAgY29udGVudD86IERPTUNvbnRlbnQ7XG4gICAgaWNvbj86IERPTUNvbnRlbnQ7XG4gICAgcmlnaHQ/OiBET01Db250ZW50O1xuICAgIGhlYWRlcj86IERPTUNvbnRlbnQ7XG4gICAgZGVzY3JpcHRpb24/OiBET01Db250ZW50O1xuICAgIGhyZWY/OiBzdHJpbmc7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMaXN0IGNvbXBvbmVudCBmb3Igc2hvd2luZyBsaXN0cyBvZiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgYnVsbGV0ZWQ/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBhcyBhIGJ1bGxldGVkIGxpc3QuXG4gICAqICAgb3JkZXJlZD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGFzIGFuIG9yZGVyZWQgbGlzdC5cbiAgICogICBsaW5rPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGxpc3RzIHdpdGggbGlua3MuXG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGhvcml6b250YWxseS5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBvbiBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIHNlbGVjdGlvbj86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBtZWFudCB0byBkaXNwbGF5IGEgc2VsZWN0aW9uLlxuICAgKiAgIGFuaW1hdGVkPzogYm9vbGVhbiAtIEFkZHMgYW4gYW5pbWF0aW9uIHRvIGRpc3BsYXkgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0uXG4gICAqICAgcmVsYXhlZD86IGJvb2xlYW4gLSBBZGRzIG1vcmUgbmVnYXRpdmUgc3BhY2UgYXJyb3VuZCB0aGUgbGlzdC5cbiAgICogICBkaXZpZGVkPzogYm9vbGVhbiAtIEFkZHMgaG9yaXpvbnRhbCBkaXZpZGVycyBiZXR3ZWVuIGNvbnRlbnQgb2YgbGlzdC5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gV3JhcHMgY29udGVudCBvZiBsaXN0IGluIGNlbGxzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxpc3QgYW5kIGl0cyBjb250ZW50LlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiBsaXN0J3MgY29udGVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2V0aGVyIHRoZSBsaXN0IHNob3VsZCBiZSBsZWZ0IG9yIHJpZ2h0IGZsb2F0aW5nLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiAgIGxlZnQ/OiBET01Db250ZW50IC0gTGVmdCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGJvZHk/OiBET01Db250ZW50IC0gQm9keSBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICByaWdodD86IERPTUNvbnRlbnQgLSBSaWdodCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGhlYWRlcj86IERPTUNvbnRlbnQgLSBOYW1lIG9mIHRoZSBsaXN0IGl0ZW1cbiAgICogICBkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQgLSBEZXNjcmlwdGlvbiBvZiB0aGUgbGlzdCBpdGVtLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBMaW5rIGZvciBsaW5rIGxpc3RzXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIubGlzdFwiKS5ldmVudHModHlwZSksXG4gICAgICAgIHZhbHVlJDogeHMubmV2ZXIoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMaXN0IGNvbXBvbmVudCBmb3Igc2hvd2luZyBsaXN0cyBvZiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgYnVsbGV0ZWQ/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBhcyBhIGJ1bGxldGVkIGxpc3QuXG4gICAqICAgb3JkZXJlZD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGFzIGFuIG9yZGVyZWQgbGlzdC5cbiAgICogICBsaW5rPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGxpc3RzIHdpdGggbGlua3MuXG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGhvcml6b250YWxseS5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBvbiBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIHNlbGVjdGlvbj86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBtZWFudCB0byBkaXNwbGF5IGEgc2VsZWN0aW9uLlxuICAgKiAgIGFuaW1hdGVkPzogYm9vbGVhbiAtIEFkZHMgYW4gYW5pbWF0aW9uIHRvIGRpc3BsYXkgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0uXG4gICAqICAgcmVsYXhlZD86IGJvb2xlYW4gLSBBZGRzIG1vcmUgbmVnYXRpdmUgc3BhY2UgYXJyb3VuZCB0aGUgbGlzdC5cbiAgICogICBkaXZpZGVkPzogYm9vbGVhbiAtIEFkZHMgaG9yaXpvbnRhbCBkaXZpZGVycyBiZXR3ZWVuIGNvbnRlbnQgb2YgbGlzdC5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gV3JhcHMgY29udGVudCBvZiBsaXN0IGluIGNlbGxzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxpc3QgYW5kIGl0cyBjb250ZW50LlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiBsaXN0J3MgY29udGVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2V0aGVyIHRoZSBsaXN0IHNob3VsZCBiZSBsZWZ0IG9yIHJpZ2h0IGZsb2F0aW5nLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiAgIGxlZnQ/OiBET01Db250ZW50IC0gTGVmdCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGJvZHk/OiBET01Db250ZW50IC0gQm9keSBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICByaWdodD86IERPTUNvbnRlbnQgLSBSaWdodCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGhlYWRlcj86IERPTUNvbnRlbnQgLSBOYW1lIG9mIHRoZSBsaXN0IGl0ZW1cbiAgICogICBkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQgLSBEZXNjcmlwdGlvbiBvZiB0aGUgbGlzdCBpdGVtLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBMaW5rIGZvciBsaW5rIGxpc3RzXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgQ29udGVudCA9IHt9LCBjOiBDb250ZW50ID0gW10pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gKHBPckMgaW5zdGFuY2VvZiBBcnJheSkgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSAocE9yQyBpbnN0YW5jZW9mIEFycmF5KSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LFxuICAgICAgY29udGVudC5tYXAoKHtoZWFkZXIsIGljb24sIGNvbnRlbnQsIGRlc2NyaXB0aW9uLCBocmVmLCBsZWZ0LCByaWdodH0pID0+IHtcbiAgICAgICAgbGV0IGwgPSBsZWZ0ID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImxlZnQgZmxvYXRlZCBjb250ZW50XCIgfSB9LCBsZWZ0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHIgPSByaWdodCA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJyaWdodCBmbG9hdGVkIGNvbnRlbnRcIiB9IH0sIHJpZ2h0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGggPSBoZWFkZXIgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiaGVhZGVyXCIgfSB9LCBoZWFkZXIpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZCA9IGRlc2NyaXB0aW9uID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImRlc2NyaXB0aW9uXCIgfSB9LCBkZXNjcmlwdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBpID0gaWNvbiA/IGljb24gOiBcIlwiO1xuICAgICAgICBsZXQgYyA9IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LFxuICAgICAgICAgIFtdLmNvbmNhdChoLCBkLCBjb250ZW50KVxuICAgICAgICApO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXS5jb25jYXQobCwgaSwgYywgcik7XG4gICAgICAgIHJldHVybiBocmVmXG4gICAgICAgICAgPyBhKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcIml0ZW1cIiB9IH0sIHsgcHJvcHM6IHsgaHJlZjogaHJlZiB9IH0sIGNoaWxkcmVuKVxuICAgICAgICAgIDogZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcIml0ZW1cIiB9IH0sIGNoaWxkcmVuKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmJ1bGxldGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYnVsbGV0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9yZGVyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBvcmRlcmVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2VsZWN0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5hbmltYXRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFuaW1hdGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yZWxheGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmVsYXhlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpdmlkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbGxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNlbGxlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBWZXJ0aWNhbEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hbGlnbm1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBsaXN0XCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2xpc3QvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7IERpbW1lciB9IGZyb20gXCJtb2R1bGVzL2RpbW1lclwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIExvYWRlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHR5cGU6IExvYWRlclR5cGU7XG4gICAgZWxlbWVudD86IFN0cmVhbTxWTm9kZT47XG4gICAgb24kPzogU3RyZWFtPGJvb2xlYW4+O1xuICAgIGNlbnRlcmVkPzogYm9vbGVhbjtcbiAgICBhY3RpdmU/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBpbmRldGVybWluYXRlPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgdGV4dD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIEEgbG9hZGVyIGNvbXBvbmVudCB0byBzaG93IHRoYXQgY2VydGFpbiBjb250ZW50IG9yIGEgcGFnZSBpcyBsb2FkaW5nLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgdHlwZTogTG9hZGVyVHlwZSAtIFRoZSB0eXBlIG9mIGxvYWRlciB0byB1c2UuIFNlZSBleHBvcnRlZCBlbnVtLlxuICAgKiAgIGVsZW1lbnQ/OiBTdHJlYW08Vk5vZGU+IC0gVGhlIGVsZW1lbnQgdG8gbWFyayBhcyBsb2FkZWQuIChPbmx5IHVzZWQgZm9yIHR5cGUuQ29udGVudClcbiAgICogICBvbiQ6IFN0cmVhbTxib29sZWFuPiAtIFdoZW4gdG8gc2hvdy9oaWRlIHRoZSBsb2FkZXIuIChOb3QgdXNlZCBmb3IgaW5saW5lLCBhZGQgZGlzYWJsZWQgcHJvcGVydHkgaW5zdGVhZC4pXG4gICAqICAgY2VudGVyZWQ/OiBib29sZWFuIC0gQ2VudGVycyB0aGUgbG9hZGVyIHNwaW5uZXIgaW4gaXRzIHBhcmVudCBjb21wb25lbnQuXG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIEFsd2F5cyBzaG93cyB0aGUgbG9hZGVyLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIEFsd2F5cyBoaWRlcyB0aGUgbG9hZGVyLlxuICAgKiAgIGluZGV0ZXJtaW5hdGU/OiBib29sZWFuIC0gTWFrZXMgdGhlIGxvYWRlciBzcGluIGluZGljYXRlIGl0cyB1bnN1cmUgb2YgaG93IGxvbmcgYSB0YXNrIHdpbGwgdGFrZS5cbiAgICogICB0ZXh0PzogYm9vbGVhbiAtIFBvc2l0aW9ucyB0aGUgbG9hZGVyIHRvIGxlYXZlIHNwYWNlIGZvciB0ZXh0LlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxvYWRlci5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JCBvZjogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7IHR5cGU6IExvYWRlclR5cGUuSW5saW5lIH0pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHByb3BzJCA9IHNvdXJjZXMucHJvcHMkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHByb3BzJCwgc291cmNlcy5jb250ZW50JClcbiAgICAgICAgLm1hcCgoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgICApO1xuICAgICAgY29uc3Qgb24kID0gcHJvcHMkLm1hcChwcm9wcyA9PiBwcm9wcy5vbiQpLmZsYXR0ZW4oKTtcbiAgICAgIGNvbnN0IHRhcmdldCQgPSBwcm9wcyQubWFwKHByb3BzID0+IHByb3BzLnR5cGUgPT09IExvYWRlclR5cGUuUGFnZSA/IHhzLm9mKFwicGFnZVwiKSA6IHByb3BzLmVsZW1lbnQpLmZsYXR0ZW4oKTtcbiAgICAgIGNvbnN0IGRpbW1lciA9IERpbW1lci5ydW4oeyBET006IHNvdXJjZXMuRE9NLCBhcmdzJDogb24kLCB0YXJnZXQkLCBjb250ZW50JDogdlRyZWUkIH0sIHByb3BzJC5tYXAocHJvcHMgPT4gcHJvcHMuaW52ZXJ0ZWQpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCQgPSBwcm9wcyQubWFwKFxuICAgICAgICBwcm9wcyA9PiBwcm9wcy50eXBlID09PSBMb2FkZXJUeXBlLklubGluZSA/IHZUcmVlJCA6IGRpbW1lci5ET01cbiAgICAgICkuZmxhdHRlbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiByZXN1bHQkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIubG9hZGVyXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgICAgdmFsdWUkOiB4cy5uZXZlcigpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBsb2FkZXIgY29tcG9uZW50IHRvIHNob3cgdGhhdCBjZXJ0YWluIGNvbnRlbnQgb3IgYSBwYWdlIGlzIGxvYWRpbmcuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIHR5cGU6IExvYWRlclR5cGUgLSBUaGUgdHlwZSBvZiBsb2FkZXIgdG8gdXNlLiBTZWUgZXhwb3J0ZWQgZW51bS5cbiAgICogICBlbGVtZW50PzogU3RyZWFtPFZOb2RlPiAtIFRoZSBlbGVtZW50IHRvIG1hcmsgYXMgbG9hZGVkLiAoT25seSB1c2VkIGZvciB0eXBlLkNvbnRlbnQpXG4gICAqICAgb24kOiBTdHJlYW08Ym9vbGVhbj4gLSBXaGVuIHRvIHNob3cvaGlkZSB0aGUgbG9hZGVyLiAoTm90IHVzZWQgZm9yIGlubGluZSwgYWRkIGRpc2FibGVkIHByb3BlcnR5IGluc3RlYWQuKVxuICAgKiAgIGNlbnRlcmVkPzogYm9vbGVhbiAtIENlbnRlcnMgdGhlIGxvYWRlciBzcGlubmVyIGluIGl0cyBwYXJlbnQgY29tcG9uZW50LlxuICAgKiAgIGFjdGl2ZT86IGJvb2xlYW4gLSBBbHdheXMgc2hvd3MgdGhlIGxvYWRlci5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBBbHdheXMgaGlkZXMgdGhlIGxvYWRlci5cbiAgICogICBpbmRldGVybWluYXRlPzogYm9vbGVhbiAtIE1ha2VzIHRoZSBsb2FkZXIgc3BpbiBpbmRpY2F0ZSBpdHMgdW5zdXJlIG9mIGhvdyBsb25nIGEgdGFzayB3aWxsIHRha2UuXG4gICAqICAgdGV4dD86IGJvb2xlYW4gLSBQb3NpdGlvbnMgdGhlIGxvYWRlciB0byBsZWF2ZSBzcGFjZSBmb3IgdGV4dC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsb2FkZXIuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge3R5cGU6IExvYWRlclR5cGUuUGFnZX0sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGVbXSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8geyB0eXBlOiBMb2FkZXJUeXBlLlBhZ2UgfSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gW2Rpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNvbnRlbnQpXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5hY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbnRlcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2VudGVyZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbmRldGVybWluYXRlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50ZXh0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdGV4dFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBMb2FkZXJUeXBlLlRvQ2xhc3NuYW1lKHByb3BzLnR5cGUpO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbiAgZXhwb3J0IGVudW0gTG9hZGVyVHlwZSB7XG4gICAgSW5saW5lLCBQYWdlLCBDb250ZW50XG4gIH1cbiAgZXhwb3J0IG5hbWVzcGFjZSBMb2FkZXJUeXBlIHtcbiAgICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUodHlwZTogTG9hZGVyVHlwZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgTG9hZGVyVHlwZS5JbmxpbmU6IHJldHVybiBcIiBpbmxpbmUgbG9hZGVyXCI7XG4gICAgICAgIGNhc2UgTG9hZGVyVHlwZS5QYWdlOiByZXR1cm4gXCIgbG9hZGVyXCI7XG4gICAgICAgIGNhc2UgTG9hZGVyVHlwZS5Db250ZW50OiByZXR1cm4gXCIgbG9hZGVyXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvbG9hZGVyL2luZGV4LnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IENvbG9yLCBBdHRhY2htZW50LCBGbG9hdCwgVGV4dEFsaWdubWVudCB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2VnbWVudCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHJhaXNlZD86IGJvb2xlYW47XG4gICAgc3RhY2tlZD86IGJvb2xlYW47XG4gICAgdGFsbFN0YWNrZWQ/OiBib29sZWFuO1xuICAgIHBpbGVkPzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbD86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIHBhZGRlZD86IGJvb2xlYW47XG4gICAgdmVyeVBhZGRlZD86IGJvb2xlYW47XG4gICAgY29tcGFjdD86IGJvb2xlYW47XG4gICAgY2lyY3VsYXI/OiBib29sZWFuO1xuICAgIGNsZWFyaW5nPzogYm9vbGVhbjtcbiAgICBiYXNpYz86IGJvb2xlYW47XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgICBmbG9hdD86IEZsb2F0O1xuICAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2VnbWVudCBjb21wb25lbnQgdG8gZGl2aWRlIHVwIHBhZ2UgY29udGVudCBpbnRvIHNlZ21lbnRzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgcmFpc2VkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGZsb2F0aW5nIGFib3ZlIG5lYXJieSBjb250ZW50LlxuICAgKiAgIHN0YWNrZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgbGlrZSBhIHN0YWNrIG9mIHBhcGVycy5cbiAgICogICB0YWxsU3RhY2tlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGFwcGVhciBsaWtlIGEgdGFsbCBzdGFjayBvZiBwYXBlcnMuXG4gICAqICAgcGlsZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgbGlrZSBhIHBpbGUgb2YgcGFwZXJzLlxuICAgKiAgIHZlcnRpY2FsPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgY29udGVudCB0byBiZSBhbGlnbmVkIGFzIHBhcnQgb2YgYSB2ZXJ0aWNhbCBncm91cC5cbiAgICogICBsb2FkaW5nPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgd2l0aCBhIGxvYWRpbmcgaWNvbi5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IGZvciBkYXJrIGNvbnRlbnQuXG4gICAqICAgcGFkZGVkPzogYm9vbGVhbj8gLSBJbmNyZWFzZXMgdGhlIHBhZGRpbmcgb24gdGhlIHNlZ21lbnQuXG4gICAqICAgdmVyeVBhZGRlZD86IGJvb2xlYW4gLSBJbmNyZWFzZXMgdGhlIHBhZGRpbmcgb24gdGhlIHNlZ21lbnQgYnkgYSBsb3QuXG4gICAqICAgY29tcGFjdD86IGJvb2xlYW4gLSBNYWtlcyB0aGUgc2VnbWVudCB0YWtlIHVwIG9ubHkgdGhlIHNwYWNlIG5lZWRlZCBieSBpdHMgY29udGVudC5cbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYmUgY2lyY3VsYXIuXG4gICAqICAgY2xlYXJpbmc/OiBib29sZWFuIC0gQ2xlYXJzIGZsb2F0ZWQgY29udGVudC5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBSZW1vdmVzIGFueSBzcGVjaWFsIHN0eWxpbmcuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgc2VnbWVudC5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFRoZSBhdHRhY2htZW50IG9mIHRoZSBzZWdtZW50LlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBXaGVyZSB0aGUgc2VnbWVudCBzaG91bGQgZmxvYXQuXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQgLSBUaGUgdGV4dCBhbGlnbm1lbnQgb2YgdGhlIHNlZ21lbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnNlZ21lbnRcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzZWdtZW50IGNvbXBvbmVudCB0byBkaXZpZGUgdXAgcGFnZSBjb250ZW50IGludG8gc2VnbWVudHMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIHJhaXNlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGFwcGVhciBmbG9hdGluZyBhYm92ZSBuZWFyYnkgY29udGVudC5cbiAgICogICBzdGFja2VkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGxpa2UgYSBzdGFjayBvZiBwYXBlcnMuXG4gICAqICAgdGFsbFN0YWNrZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgbGlrZSBhIHRhbGwgc3RhY2sgb2YgcGFwZXJzLlxuICAgKiAgIHBpbGVkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGxpa2UgYSBwaWxlIG9mIHBhcGVycy5cbiAgICogICB2ZXJ0aWNhbD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IGNvbnRlbnQgdG8gYmUgYWxpZ25lZCBhcyBwYXJ0IG9mIGEgdmVydGljYWwgZ3JvdXAuXG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHdpdGggYSBsb2FkaW5nIGljb24uXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCBmb3IgZGFyayBjb250ZW50LlxuICAgKiAgIHBhZGRlZD86IGJvb2xlYW4/IC0gSW5jcmVhc2VzIHRoZSBwYWRkaW5nIG9uIHRoZSBzZWdtZW50LlxuICAgKiAgIHZlcnlQYWRkZWQ/OiBib29sZWFuIC0gSW5jcmVhc2VzIHRoZSBwYWRkaW5nIG9uIHRoZSBzZWdtZW50IGJ5IGEgbG90LlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gTWFrZXMgdGhlIHNlZ21lbnQgdGFrZSB1cCBvbmx5IHRoZSBzcGFjZSBuZWVkZWQgYnkgaXRzIGNvbnRlbnQuXG4gICAqICAgY2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIGNsZWFyaW5nPzogYm9vbGVhbiAtIENsZWFycyBmbG9hdGVkIGNvbnRlbnQuXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gUmVtb3ZlcyBhbnkgc3BlY2lhbCBzdHlsaW5nLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHNlZ21lbnQuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBUaGUgYXR0YWNobWVudCBvZiB0aGUgc2VnbWVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2hlcmUgdGhlIHNlZ21lbnQgc2hvdWxkIGZsb2F0LlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGhlIHRleHQgYWxpZ25tZW50IG9mIHRoZSBzZWdtZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNvbnRlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMucmFpc2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmFpc2VkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zdGFja2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3RhY2tlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGFsbFN0YWNrZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB0YWxsIHN0YWNrZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBpbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcGlsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wYWRkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwYWRkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnlQYWRkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ5IHBhZGRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcGFjdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXBhY3RcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNsZWFyaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2xlYXJpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmJhc2ljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYmFzaWNcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hdHRhY2htZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKHByb3BzLmZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMudGV4dEFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBUZXh0QWxpZ25tZW50LlRvQ2xhc3NuYW1lKHByb3BzLnRleHRBbGlnbm1lbnQpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgc2VnbWVudFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9zZWdtZW50L2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIEF0dGFjaG1lbnQgfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCJ1dGlsc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiwgYSB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgU3RlcHMge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBsaW5rPzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbD86IGJvb2xlYW47XG4gICAgc3RhY2thYmxlPzogYm9vbGVhbjtcbiAgICBldmVubHlEaXZpZGVkPzogYm9vbGVhbjtcbiAgICBmbHVpZD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gIH1cbiAgZXhwb3J0IHR5cGUgQ29udGVudCA9IEFycmF5PFN0ZXBJdGVtPjtcbiAgZXhwb3J0IGludGVyZmFjZSBTdGVwSXRlbSB7XG4gICAgaWNvbj86IERPTUNvbnRlbnQ7XG4gICAgaGVhZGVyPzogRE9NQ29udGVudDtcbiAgICBkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQ7XG4gICAgaXNDb21wbGV0ZWQ/OiBib29sZWFuO1xuICAgIGlzQWN0aXZlPzogYm9vbGVhbjtcbiAgICBpc0Rpc2FibGVkPzogYm9vbGVhbjtcbiAgICBsaW5rPzogYm9vbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0ZXBzIGNvbXBvbmVudCB0byBzaG93IHRoZSBjb21wbGV0aW9uIHN0YXR1cyBvZiBhIHNlcmllcyBvZiBhY3Rpdml0aWVzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICBsaW5rPzogYm9vbGVhbiAtIFN0eWxlcyB0byBzdGVwcyB0byBkaXNwbGF5IGFzIGEgbGluay5cbiAgICogXHR2ZXJ0aWNhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0ZXBzIHRvIGFsaWduIHZlcnRpY2FsbHkuXG4gICAqIFx0c3RhY2thYmxlPzogYm9vbGVhbiAtIExldHMgdGhlIHN0ZXBzIHJlYWxpZ24gdmVydGljYWxseSBvbiBzbWFsbGVyIHNjcmVlbnMuXG4gICAqIFx0ZXZlbmx5RGl2aWRlZD86IGJvb2xlYW4gLSBBcnJhbmdlcyB0aGUgc3RlcHMgdG8gdGFrZSB1cCBlcXVhbCBhbW91bnQgb2Ygd2lkdGggb2YgdGhlaXIgcGFyZW50LlxuICAgKiBcdGZsdWlkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc3RlcHMgdG8gdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiB0aGVpciBwYXJlbnQuXG4gICAqIFx0c2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgc3RlcHMuXG4gICAqIFx0YXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBTdHlsZXMgdGhlIHN0ZXBzIHRvIGFwcGVhciBhdHRhY2hlZCB0byBuZWFyYnkgY29udGVudC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogQXJyYXkgb2Yge31cbiAgICogXHRpY29uPzogRE9NQ29udGVudCBUaGUgaWNvbiB0byB1c2UgZm9yIHRoZSBzdGVwLlxuICAgKiBcdGhlYWRlcj86IERPTUNvbnRlbnQgLSBUaGUgdGl0bGUgZm9yIHRoZSBzdGVwLlxuICAgKiBcdGRlc2NyaXB0aW9uPzogRE9NQ29udGVudCAtIFRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIHN0ZXAuXG4gICAqIFx0aXNDb21wbGV0ZWQ/OiBib29sZWFuIC0gTWFya3MgdGhlIHN0ZXAgYXMgY29tcGxldGVkLlxuICAgKiBcdGlzQWN0aXZlPzogYm9vbGVhbiAtIE1hcmtzIHRoZSBzdGVwIGFzIHRoZSBjdXJyZW50IHN0ZXAuXG4gICAqIFx0aXNEaXNhYmxlZD86IGJvb2xlYW4gLSBNYXJrcyB0aGUgc3RlcCBhcyBkaXNhYmxlZC5cbiAgICogIGxpbms/OiBib29sZWFuIC0gU3R5bGUgdGhlIHN0ZXAgdG8gYmUgY2xpY2thYmxlLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGV2dCA9ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuc3RlcFwiKS5ldmVudHModHlwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiBldnQsXG4gICAgICAgIHZhbHVlJDogeHMubmV2ZXIoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3RlcHMgY29tcG9uZW50IHRvIHNob3cgdGhlIGNvbXBsZXRpb24gc3RhdHVzIG9mIGEgc2VyaWVzIG9mIGFjdGl2aXRpZXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgbGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdG8gc3RlcHMgdG8gZGlzcGxheSBhcyBhIGxpbmsuXG4gICAqIFx0dmVydGljYWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGVwcyB0byBhbGlnbiB2ZXJ0aWNhbGx5LlxuICAgKiBcdHN0YWNrYWJsZT86IGJvb2xlYW4gLSBMZXRzIHRoZSBzdGVwcyByZWFsaWduIHZlcnRpY2FsbHkgb24gc21hbGxlciBzY3JlZW5zLlxuICAgKiBcdGV2ZW5seURpdmlkZWQ/OiBib29sZWFuIC0gQXJyYW5nZXMgdGhlIHN0ZXBzIHRvIHRha2UgdXAgZXF1YWwgYW1vdW50IG9mIHdpZHRoIG9mIHRoZWlyIHBhcmVudC5cbiAgICogXHRmbHVpZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0ZXBzIHRvIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgdGhlaXIgcGFyZW50LlxuICAgKiBcdHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHN0ZXBzLlxuICAgKiBcdGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gU3R5bGVzIHRoZSBzdGVwcyB0byBhcHBlYXIgYXR0YWNoZWQgdG8gbmVhcmJ5IGNvbnRlbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEFycmF5IG9mIHt9XG4gICAqIFx0aWNvbj86IERPTUNvbnRlbnQgVGhlIGljb24gdG8gdXNlIGZvciB0aGUgc3RlcC5cbiAgICogXHRoZWFkZXI/OiBET01Db250ZW50IC0gVGhlIHRpdGxlIGZvciB0aGUgc3RlcC5cbiAgICogXHRkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQgLSBUaGUgZGVzY3JpcHRpb24gZm9yIHRoZSBzdGVwLlxuICAgKiBcdGlzQ29tcGxldGVkPzogYm9vbGVhbiAtIE1hcmtzIHRoZSBzdGVwIGFzIGNvbXBsZXRlZC5cbiAgICogXHRpc0FjdGl2ZT86IGJvb2xlYW4gLSBNYXJrcyB0aGUgc3RlcCBhcyB0aGUgY3VycmVudCBzdGVwLlxuICAgKiBcdGlzRGlzYWJsZWQ/OiBib29sZWFuIC0gTWFya3MgdGhlIHN0ZXAgYXMgZGlzYWJsZWQuXG4gICAqICBsaW5rPzogYm9vbGVhbiAtIFN0eWxlIHRoZSBzdGVwIHRvIGJlIGNsaWNrYWJsZS5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBDb250ZW50ID0ge30sIGM6IENvbnRlbnQgPSBbXSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBwT3JDIGluc3RhbmNlb2YgQXJyYXkgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBwT3JDIGluc3RhbmNlb2YgQXJyYXkgPyBwT3JDIDogYztcbiAgICBsZXQgY2hpbGRyZW4gPSBjb250ZW50Lm1hcCgoe2ljb24sIGhlYWRlciwgZGVzY3JpcHRpb24sIGlzQ29tcGxldGVkLCBpc0FjdGl2ZSwgaXNEaXNhYmxlZCwgbGlua30sIGkpID0+XG4gICAgICBwcm9wcy5saW5rXG4gICAgICAgID8gYSh7IHByb3BzOiB7IGlkOiBpLCBjbGFzc05hbWU6IGdldFN0ZXBDbGFzc25hbWUoaXNDb21wbGV0ZWQsIGlzQWN0aXZlLCBpc0Rpc2FibGVkLCBsaW5rKSB9IH0sIFtcbiAgICAgICAgICBpY29uLFxuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBbXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidGl0bGVcIiB9IH0sIGhlYWRlciksXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiZGVzY3JpcHRpb25cIiB9IH0sIGRlc2NyaXB0aW9uKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICAgIDogZGl2KHsgcHJvcHM6IHsgaWQ6IGksIGNsYXNzTmFtZTogZ2V0U3RlcENsYXNzbmFtZShpc0NvbXBsZXRlZCwgaXNBY3RpdmUsIGlzRGlzYWJsZWQsIGxpbmspIH0gfSwgW1xuICAgICAgICAgIGljb24sXG4gICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImNvbnRlbnRcIiB9IH0sIFtcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ0aXRsZVwiIH0gfSwgaGVhZGVyKSxcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkZXNjcmlwdGlvblwiIH0gfSwgZGVzY3JpcHRpb24pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICApO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcywgY29udGVudC5sZW5ndGgpIH0gfSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RlcENsYXNzbmFtZShpc0NvbXBsZXRlZD86IGJvb2xlYW4sIGlzQWN0aXZlPzogYm9vbGVhbiwgaXNEaXNhYmxlZD86IGJvb2xlYW4sIGxpbms/OiBib29sZWFuKSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCJhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGxldGVkXCI7XG4gICAgfVxuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKGxpbmspIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsaW5rXCI7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBzdGVwXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzLCBsZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMudmVydGljYWwpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ0aWNhbFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc3RhY2thYmxlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3RhY2thYmxlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbHVpZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsdWlkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ldmVubHlEaXZpZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KGxlbmd0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgc3RlcHNcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvc3RlcC9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJVmFsdWVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50IH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IENvbG9yLCBTaXplIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2LCBpbnB1dCwgdGV4dGFyZWEgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFRleHRib3gge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBpbml0aWFsPzogc3RyaW5nO1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGxhYmVsZWQ/OiBib29sZWFuO1xuICAgIGFjdGlvbj86IGJvb2xlYW47XG4gICAgbGVmdENvbnRlbnQ/OiBib29sZWFuO1xuICAgIHJpZ2h0Q29udGVudD86IGJvb2xlYW47XG4gICAgdHJhbnNwYXJlbnQ/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBmb2N1cz86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGxhcmdlPzogYm9vbGVhbjtcbiAgICB0eXBlPzogc3RyaW5nO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cblxuICAvKipcbiAgICogQSB0ZXh0Ym94IGNvbXBvbmVudCBmb3IgY2FwdHVyaW5nIHVzZXIgaW5wdXQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBpbml0aWFsPzogc3RyaW5nIC0gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHRleHRib3guXG4gICAqICAgcGxhY2Vob2xkZXI/OiBzdHJpbmcgLSBUaGUgcGxhY2Vob2xkZXIgdGV4dCBvZiB0aGUgdGV4dGJveC5cbiAgICogICBpY29uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGlzcGxheWluZyBhbiBpY29uIGluIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGxhYmVsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkaXNwbGF5aW5nIGEgbGFiZWwgaW4gdGhlIHRleHRib3guXG4gICAqICAgYWN0aW9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGlzcGxheWluZyBhbiBhY3Rpb24gY29tcG9uZW50IGluIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGxlZnRDb250ZW50PzogYm9vbGVhbiAtIEFkZHMgY29udGVudCB0byB0aGUgbGVmdCBzaWRlIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIHJpZ2h0Q29udGVudD86IGJvb2xlYW4gLSBBZGRzIGNvbnRlbnQgdG8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRleHRib3guXG4gICAqICAgdHJhbnNwYXJlbnQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IHRvIGFwcGVhciB0cmFuc3BhcmVudC5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggZm9yIGRhcmtlciBiYWNrZ3JvdW5kcy5cbiAgICogICBmb2N1cz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gc2hvdyBpdCBoYXMgZm9jdXMuXG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggd2l0aCBhIGxvYWRpbmcgaWNvbi5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHRleHRib3guXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGV4dGJveC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElWYWx1ZUNvbXBvbmVudFNpbmtzPHN0cmluZz4ge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmlucHV0XCIpLmV2ZW50cyh0eXBlKTtcbiAgICAgIGNvbnN0IHByb3BzJCA9IHNvdXJjZXMucHJvcHMkLnJlbWVtYmVyKCk7XG4gICAgICAvLyBjb25zdCBpbml0aWFsVmFsdWUkID0gcHJvcHMkLm1hcChwcm9wcyA9PiBwcm9wcy5pbml0aWFsKTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlJCA9IGV2dChcImlucHV0XCIpLm1hcChldiA9PiAoZXYudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlKS5yZW1lbWJlcigpO1xuICAgICAgLy8gY29uc3QgdmFsdWUkID0geHMubWVyZ2UoaW5pdGlhbFZhbHVlJCwgbmV3VmFsdWUkKTtcbiAgICAgIGNvbnN0IHZ0cmVlJCA9IHhzLmNvbWJpbmUocHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZ0cmVlJCxcbiAgICAgICAgRXZlbnRzOiBldnQsXG4gICAgICAgIHZhbHVlJDogbmV3VmFsdWUkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSB0ZXh0Ym94IGNvbXBvbmVudCBmb3IgY2FwdHVyaW5nIHVzZXIgaW5wdXQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGluaXRpYWw/OiBzdHJpbmcgLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgdGV4dGJveC5cbiAgICogICBwbGFjZWhvbGRlcj86IHN0cmluZyAtIFRoZSBwbGFjZWhvbGRlciB0ZXh0IG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkaXNwbGF5aW5nIGFuIGljb24gaW4gdGhlIHRleHRib3guXG4gICAqICAgbGFiZWxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggZm9yIGRpc3BsYXlpbmcgYSBsYWJlbCBpbiB0aGUgdGV4dGJveC5cbiAgICogICBhY3Rpb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkaXNwbGF5aW5nIGFuIGFjdGlvbiBjb21wb25lbnQgaW4gdGhlIHRleHRib3guXG4gICAqICAgbGVmdENvbnRlbnQ/OiBib29sZWFuIC0gQWRkcyBjb250ZW50IHRvIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHRib3guXG4gICAqICAgcmlnaHRDb250ZW50PzogYm9vbGVhbiAtIEFkZHMgY29udGVudCB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dGJveC5cbiAgICogICB0cmFuc3BhcmVudD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gYXBwZWFyIHRyYW5zcGFyZW50LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGFya2VyIGJhY2tncm91bmRzLlxuICAgKiAgIGZvY3VzPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCB0byBzaG93IGl0IGhhcyBmb2N1cy5cbiAgICogICBsb2FkaW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCB3aXRoIGEgbG9hZGluZyBpY29uLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgdGV4dGJveC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgdGV4dGJveCA9IHByb3BzLmxhcmdlXG4gICAgICA/IHRleHRhcmVhKHsgcHJvcHM6IHsgdmFsdWU6IHByb3BzLmluaXRpYWwsIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlciB9IH0pXG4gICAgICA6IGlucHV0KHsgcHJvcHM6IHsgdHlwZTogcHJvcHMudHlwZSA/IHByb3BzLnR5cGUgOiBcInRleHRcIiwgdmFsdWU6IHByb3BzLmluaXRpYWwsIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlciB9IH0pO1xuICAgIHJldHVybiBwcm9wcy5yaWdodENvbnRlbnRcbiAgICAgID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgICB0ZXh0Ym94LFxuICAgICAgICBjb250ZW50XG4gICAgICBdKVxuICAgICAgOiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIHRleHRib3hcbiAgICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMubGVmdENvbnRlbnQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsZWZ0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yaWdodENvbnRlbnQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxhYmVsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsYWJlbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5hY3Rpb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3Rpb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRyYW5zcGFyZW50KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdHJhbnNwYXJlbnRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZvY3VzKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZm9jdXNcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgaW5wdXRcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvdGV4dGJveC9pbmRleC50cyIsImV4cG9ydCBuYW1lc3BhY2UgSWNvblR5cGUge1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUodHlwZTogSWNvblR5cGUpIHtcbiAgICBpZiAodHlwZSA8IDApXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB2YXIgbmFtZSA9IEljb25UeXBlW3R5cGVdO1xuICAgIHJldHVybiBcIiBcIiArIG5hbWUubWF0Y2goL1tBLVpdW2Etel0rL2cpLmpvaW4oXCIgXCIpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIEdldE5hbWVzKCkge1xuICAgIHZhciBuYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IodmFyIG4gaW4gSWNvblR5cGUpIHtcbiAgICAgIGlmKHR5cGVvZiBJY29uVHlwZVtuXSA9PT0gJ251bWJlcicpIG5hbWVzLnB1c2gobik7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbiAgfVxufVxuXG5leHBvcnQgZW51bSBJY29uVHlwZSB7XG4gIFNlYXJjaCxcbiAgTWFpbE91dGxpbmUsXG4gIEV4dGVybmFsLFxuICBTaWduYWwsXG4gIFNldHRpbmcsXG4gIEhvbWUsXG4gIEluYm94LFxuICBCcm93c2VyLFxuICBUYWcsXG4gIFRhZ3MsXG4gIENhbGVuZGFyLFxuICBDb21tZW50LFxuICBDb21tZW50cyxcbiAgU2hvcCxcbiAgUHJpdmFjeSxcbiAgU2V0dGluZ3MsXG4gIFRyb3BoeSxcbiAgUGF5bWVudCxcbiAgRmVlZCxcbiAgQWxhcm1PdXRsaW5lLFxuICBUYXNrcyxcbiAgQ2xvdWQsXG4gIExhYixcbiAgTWFpbCxcbiAgSWRlYSxcbiAgRGFzaGJvYXJkLFxuICBTaXRlbWFwLFxuICBBbGFybSxcbiAgVGVybWluYWwsXG4gIENvZGUsXG4gIFByb3RlY3QsXG4gIENhbGVuZGFyT3V0bGluZSxcbiAgVGlja2V0LFxuICBFeHRlcm5hbFNxdWFyZSxcbiAgTWFwLFxuICBCdWcsXG4gIE1haWxTcXVhcmUsXG4gIEhpc3RvcnksXG4gIE9wdGlvbnMsXG4gIENvbW1lbnRPdXRsaW5lLFxuICBDb21tZW50c091dGxpbmUsXG4gIFRleHRUZWxlcGhvbmUsXG4gIEZpbmQsXG4gIFdpZmksXG4gIEFsYXJtU2xhc2gsXG4gIEFsYXJtU2xhc2hPdXRsaW5lLFxuICBDb3B5cmlnaHQsXG4gIEF0LFxuICBFeWVkcm9wcGVyLFxuICBQYWludEJydXNoLFxuICBIZWFydGJlYXQsXG4gIERvd25sb2FkLFxuICBSZXBlYXQsXG4gIFJlZnJlc2gsXG4gIExvY2ssXG4gIEJvb2ttYXJrLFxuICBQcmludCxcbiAgV3JpdGUsXG4gIFRoZW1lLFxuICBBZGp1c3QsXG4gIEVkaXQsXG4gIEV4dGVybmFsU2hhcmUsXG4gIEJhbixcbiAgTWFpbEZvcndhcmQsXG4gIFNoYXJlLFxuICBFeHBhbmQsXG4gIENvbXByZXNzLFxuICBVbmhpZGUsXG4gIEhpZGUsXG4gIFJhbmRvbSxcbiAgUmV0d2VldCxcbiAgU2lnbk91dCxcbiAgUGluLFxuICBTaWduSW4sXG4gIFVwbG9hZCxcbiAgQ2FsbCxcbiAgQ2FsbFNxdWFyZSxcbiAgUmVtb3ZlQm9va21hcmssXG4gIFVubG9jayxcbiAgQ29uZmlndXJlLFxuICBGaWx0ZXIsXG4gIFdpemFyZCxcbiAgVW5kbyxcbiAgRXhjaGFuZ2UsXG4gIENsb3VkRG93bmxvYWQsXG4gIENsb3VkVXBsb2FkLFxuICBSZXBseSxcbiAgUmVwbHlBbGwsXG4gIEVyYXNlLFxuICBVbmxvY2tBbHRlcm5hdGUsXG4gIEFyY2hpdmUsXG4gIFRyYW5zbGF0ZSxcbiAgUmVjeWNsZSxcbiAgU2VuZCxcbiAgU2VuZE91dGxpbmUsXG4gIFNoYXJlQWx0ZXJuYXRlLFxuICBTaGFyZUFsdGVybmF0ZVNxdWFyZSxcbiAgV2FpdCxcbiAgV3JpdGVTcXVhcmUsXG4gIFNoYXJlU3F1YXJlLFxuICBBZGRUb0NhcnQsXG4gIEluQ2FydCxcbiAgQWRkVXNlcixcbiAgUmVtb3ZlVXNlcixcbiAgSGVscENpcmNsZSxcbiAgSW5mb0NpcmNsZSxcbiAgV2FybmluZyxcbiAgV2FybmluZ0NpcmNsZSxcbiAgV2FybmluZ1NpZ24sXG4gIEhlbHAsXG4gIEluZm8sXG4gIEFubm91bmNlbWVudCxcbiAgQmlydGhkYXksXG4gIFVzZXJzLFxuICBEb2N0b3IsXG4gIENoaWxkLFxuICBVc2VyLFxuICBIYW5kaWNhcCxcbiAgU3R1ZGVudCxcbiAgU3B5LFxuICBHcmlkTGF5b3V0LFxuICBMaXN0TGF5b3V0LFxuICBCbG9ja0xheW91dCxcbiAgWm9vbSxcbiAgWm9vbU91dCxcbiAgUmVzaXplVmVydGljYWwsXG4gIFJlc2l6ZUhvcml6b250YWwsXG4gIE1heGltaXplLFxuICBDcm9wLFxuICBGZW1hbGUsXG4gIE1hbGUsXG4gIFdvbWFuLFxuICBNYW4sXG4gIE5vbkJpbmFyeVRyYW5zZ2VuZGVyLFxuICBJbnRlcmdlbmRlcixcbiAgVHJhbnNnZW5kZXIsXG4gIExlc2JpYW4sXG4gIEdheSxcbiAgSGV0ZXJvc2V4dWFsLFxuICBPdGhlckdlbmRlcixcbiAgT3RoZXJHZW5kZXJWZXJ0aWNhbCxcbiAgT3RoZXJHZW5kZXJIb3Jpem9udGFsLFxuICBOZXV0ZXIsXG4gIENvY2t0YWlsLFxuICBSb2FkLFxuICBGbGFnLFxuICBCb29rLFxuICBHaWZ0LFxuICBMZWFmLFxuICBGaXJlLFxuICBQbGFuZSxcbiAgTWFnbmV0LFxuICBMZWdhbCxcbiAgTGVtb24sXG4gIFdvcmxkLFxuICBUcmF2ZWwsXG4gIFNoaXBwaW5nLFxuICBNb25leSxcbiAgTGlnaHRuaW5nLFxuICBSYWluLFxuICBUcmVhdG1lbnQsXG4gIFN1aXRjYXNlLFxuICBCYXIsXG4gIEZsYWdPdXRsaW5lLFxuICBGbGFnQ2hlY2tlcmVkLFxuICBQdXp6bGUsXG4gIEZpcmVFeHRpbmd1aXNoZXIsXG4gIFJvY2tldCxcbiAgQW5jaG9yLFxuICBCdWxsc2V5ZSxcbiAgU3VuLFxuICBNb29uLFxuICBGYXgsXG4gIExpZmVSaW5nLFxuICBCb21iLFxuICBTb2NjZXIsXG4gIENhbGN1bGF0b3IsXG4gIERpYW1vbmQsXG4gIENyb3NzaGFpcnMsXG4gIEFzdGVyaXNrLFxuICBDZXJ0aWZpY2F0ZSxcbiAgQ2lyY2xlLFxuICBRdW90ZUxlZnQsXG4gIFF1b3RlUmlnaHQsXG4gIEVsbGlwc2lzSG9yaXpvbnRhbCxcbiAgRWxsaXBzaXNWZXJ0aWNhbCxcbiAgQ3ViZSxcbiAgQ3ViZXMsXG4gIENpcmNsZU5vdGNoZWQsXG4gIENpcmNsZVRoaW4sXG4gIFNxdWFyZU91dGxpbmUsXG4gIFNxdWFyZSxcbiAgQ2hlY2ttYXJrLFxuICBSZW1vdmUsXG4gIENoZWNrbWFya0JveCxcbiAgTW92ZSxcbiAgQWRkQ2lyY2xlLFxuICBNaW51c0NpcmNsZSxcbiAgUmVtb3ZlQ2lyY2xlLFxuICBDaGVja0NpcmNsZSxcbiAgUmVtb3ZlQ2lyY2xlT3V0bGluZSxcbiAgQ2hlY2tDaXJjbGVPdXRsaW5lLFxuICBQbHVzLFxuICBNaW51cyxcbiAgQWRkU3F1YXJlLFxuICBSYWRpbyxcbiAgU2VsZWN0ZWRSYWRpbyxcbiAgTWludXNTcXVhcmUsXG4gIE1pbnVzU3F1YXJlT3V0bGluZSxcbiAgQ2hlY2tTcXVhcmUsXG4gIFBsdXNTcXVhcmVPdXRsaW5lLFxuICBUb2dnbGVPZmYsXG4gIFRvZ2dsZU9uLFxuICBGaWxtLFxuICBTb3VuZCxcbiAgUGhvdG8sXG4gIEJhckNoYXJ0LFxuICBDYW1lcmFSZXRybyxcbiAgTmV3c3BhcGVyLFxuICBBcmVhQ2hhcnQsXG4gIFBpZUNoYXJ0LFxuICBMaW5lQ2hhcnQsXG4gIEFycm93Q2lyY2xlT3V0bGluZURvd24sXG4gIEFycm93Q2lyY2xlT3V0bGluZVVwLFxuICBDaGV2cm9uTGVmdCxcbiAgQ2hldnJvblJpZ2h0LFxuICBBcnJvd0xlZnQsXG4gIEFycm93UmlnaHQsXG4gIEFycm93VXAsXG4gIEFycm93RG93bixcbiAgQ2hldnJvblVwLFxuICBDaGV2cm9uRG93bixcbiAgUG9pbnRpbmdSaWdodCxcbiAgUG9pbnRpbmdMZWZ0LFxuICBQb2ludGluZ1VwLFxuICBQb2ludGluZ0Rvd24sXG4gIEFycm93Q2lyY2xlTGVmdCxcbiAgQXJyb3dDaXJjbGVSaWdodCxcbiAgQXJyb3dDaXJjbGVVcCxcbiAgQXJyb3dDaXJjbGVEb3duLFxuICBDYXJldERvd24sXG4gIENhcmV0VXAsXG4gIENhcmV0TGVmdCxcbiAgQ2FyZXRSaWdodCxcbiAgQW5nbGVEb3VibGVMZWZ0LFxuICBBbmdsZURvdWJsZVJpZ2h0LFxuICBBbmdsZURvdWJsZVVwLFxuICBBbmdsZURvdWJsZURvd24sXG4gIEFuZ2xlTGVmdCxcbiAgQW5nbGVSaWdodCxcbiAgQW5nbGVVcCxcbiAgQW5nbGVEb3duLFxuICBDaGV2cm9uQ2lyY2xlTGVmdCxcbiAgQ2hldnJvbkNpcmNsZVJpZ2h0LFxuICBDaGV2cm9uQ2lyY2xlVXAsXG4gIENoZXZyb25DaXJjbGVEb3duLFxuICBUb2dnbGVEb3duLFxuICBUb2dnbGVVcCxcbiAgVG9nZ2xlUmlnaHQsXG4gIExvbmdBcnJvd0Rvd24sXG4gIExvbmdBcnJvd1VwLFxuICBMb25nQXJyb3dMZWZ0LFxuICBMb25nQXJyb3dSaWdodCxcbiAgQXJyb3dDaXJjbGVPdXRsaW5lUmlnaHQsXG4gIEFycm93Q2lyY2xlT3V0bGluZUxlZnQsXG4gIFRvZ2dsZUxlZnQsXG4gIFBvd2VyLFxuICBUcmFzaCxcbiAgVHJhc2hPdXRsaW5lLFxuICBEaXNrT3V0bGluZSxcbiAgRGVza3RvcCxcbiAgTGFwdG9wLFxuICBUYWJsZXQsXG4gIE1vYmlsZSxcbiAgR2FtZSxcbiAgS2V5Ym9hcmQsXG4gIFBsdWcsXG4gIEZvbGRlcixcbiAgRm9sZGVyT3BlbixcbiAgTGV2ZWxVcCxcbiAgTGV2ZWxEb3duLFxuICBGaWxlLFxuICBGaWxlT3V0bGluZSxcbiAgRmlsZVRleHQsXG4gIEZpbGVUZXh0T3V0bGluZSxcbiAgRm9sZGVyT3V0bGluZSxcbiAgRm9sZGVyT3Blbk91dGxpbmUsXG4gIEZpbGVQZGZPdXRsaW5lLFxuICBGaWxlV29yZE91dGxpbmUsXG4gIEZpbGVFeGNlbE91dGxpbmUsXG4gIEZpbGVQb3dlcnBvaW50T3V0bGluZSxcbiAgRmlsZUltYWdlT3V0bGluZSxcbiAgRmlsZUFyY2hpdmVPdXRsaW5lLFxuICBGaWxlQXVkaW9PdXRsaW5lLFxuICBGaWxlVmlkZW9PdXRsaW5lLFxuICBGaWxlQ29kZU91dGxpbmUsXG4gIEJhcmNvZGUsXG4gIFFyY29kZSxcbiAgRm9yayxcbiAgSHRtbDUsXG4gIENzczMsXG4gIFJzcyxcbiAgUnNzU3F1YXJlLFxuICBPcGVuaWQsXG4gIERhdGFiYXNlLFxuICBTZXJ2ZXIsXG4gIEhlYXJ0LFxuICBTdGFyLFxuICBFbXB0eVN0YXIsXG4gIFRodW1ic091dGxpbmVVcCxcbiAgVGh1bWJzT3V0bGluZURvd24sXG4gIFN0YXJIYWxmLFxuICBFbXB0eUhlYXJ0LFxuICBTbWlsZSxcbiAgRnJvd24sXG4gIE1laCxcbiAgU3RhckhhbGZFbXB0eSxcbiAgVGh1bWJzVXAsXG4gIFRodW1ic0Rvd24sXG4gIE11c2ljLFxuICBWaWRlb1BsYXlPdXRsaW5lLFxuICBWb2x1bWVPZmYsXG4gIFZvbHVtZURvd24sXG4gIFZvbHVtZVVwLFxuICBSZWNvcmQsXG4gIFN0ZXBCYWNrd2FyZCxcbiAgRmFzdEJhY2t3YXJkLFxuICBCYWNrd2FyZCxcbiAgUGxheSxcbiAgUGF1c2UsXG4gIFN0b3AsXG4gIEZvcndhcmQsXG4gIEZhc3RGb3J3YXJkLFxuICBTdGVwRm9yd2FyZCxcbiAgRWplY3QsXG4gIFVubXV0ZSxcbiAgTXV0ZSxcbiAgVmlkZW9QbGF5LFxuICBDbG9zZWRDYXB0aW9uaW5nLFxuICBNYXJrZXIsXG4gIENvZmZlZSxcbiAgRm9vZCxcbiAgQnVpbGRpbmdPdXRsaW5lLFxuICBIb3NwaXRhbCxcbiAgRW1lcmdlbmN5LFxuICBGaXJzdEFpZCxcbiAgTWlsaXRhcnksXG4gIEgsXG4gIExvY2F0aW9uQXJyb3csXG4gIFNwYWNlU2h1dHRsZSxcbiAgVW5pdmVyc2l0eSxcbiAgQnVpbGRpbmcsXG4gIFBhdyxcbiAgU3Bvb24sXG4gIENhcixcbiAgVGF4aSxcbiAgVHJlZSxcbiAgQmljeWNsZSxcbiAgQnVzLFxuICBTaGlwLFxuICBNb3RvcmN5Y2xlLFxuICBTdHJlZXRWaWV3LFxuICBIb3RlbCxcbiAgVHJhaW4sXG4gIFN1YndheSxcbiAgVGFibGUsXG4gIENvbHVtbnMsXG4gIFNvcnQsXG4gIFNvcnRBc2NlbmRpbmcsXG4gIFNvcnREZXNjZW5kaW5nLFxuICBTb3J0QWxwaGFiZXRBc2NlbmRpbmcsXG4gIFNvcnRBbHBoYWJldERlc2NlbmRpbmcsXG4gIFNvcnRDb250ZW50QXNjZW5kaW5nLFxuICBTb3J0Q29udGVudERlc2NlbmRpbmcsXG4gIFNvcnROdW1lcmljQXNjZW5kaW5nLFxuICBTb3J0TnVtZXJpY0Rlc2NlbmRpbmcsXG4gIEZvbnQsXG4gIEJvbGQsXG4gIEl0YWxpYyxcbiAgVGV4dEhlaWdodCxcbiAgVGV4dFdpZHRoLFxuICBBbGlnbkxlZnQsXG4gIEFsaWduQ2VudGVyLFxuICBBbGlnblJpZ2h0LFxuICBBbGlnbkp1c3RpZnksXG4gIExpc3QsXG4gIE91dGRlbnQsXG4gIEluZGVudCxcbiAgTGlua2lmeSxcbiAgQ3V0LFxuICBDb3B5LFxuICBBdHRhY2gsXG4gIFNhdmUsXG4gIENvbnRlbnQsXG4gIFVub3JkZXJlZExpc3QsXG4gIE9yZGVyZWRMaXN0LFxuICBTdHJpa2V0aHJvdWdoLFxuICBVbmRlcmxpbmUsXG4gIFBhc3RlLFxuICBVbmxpbmssXG4gIFN1cGVyc2NyaXB0LFxuICBTdWJzY3JpcHQsXG4gIEhlYWRlcixcbiAgUGFyYWdyYXBoLFxuICBFdXJvLFxuICBQb3VuZCxcbiAgRG9sbGFyLFxuICBSdXBlZSxcbiAgWWVuLFxuICBSdWJsZSxcbiAgV29uLFxuICBMaXJhLFxuICBTaGVrZWwsXG4gIFBheXBhbCxcbiAgUGF5cGFsQ2FyZCxcbiAgR29vZ2xlV2FsbGV0LFxuICBWaXNhLFxuICBNYXN0ZXJjYXJkLFxuICBEaXNjb3ZlcixcbiAgQW1lcmljYW5FeHByZXNzLFxuICBTdHJpcGUsXG4gIFR3aXR0ZXJTcXVhcmUsXG4gIEZhY2Vib29rU3F1YXJlLFxuICBMaW5rZWRpblNxdWFyZSxcbiAgR2l0aHViU3F1YXJlLFxuICBUd2l0dGVyLFxuICBGYWNlYm9vayxcbiAgR2l0aHViLFxuICBQaW50ZXJlc3QsXG4gIFBpbnRlcmVzdFNxdWFyZSxcbiAgR29vZ2xlUGx1c1NxdWFyZSxcbiAgR29vZ2xlUGx1cyxcbiAgTGlua2VkaW4sXG4gIEdpdGh1YkFsdGVybmF0ZSxcbiAgTWF4Y2RuLFxuICBCaXRjb2luLFxuICBZb3V0dWJlU3F1YXJlLFxuICBZb3V0dWJlLFxuICBYaW5nLFxuICBYaW5nU3F1YXJlLFxuICBZb3V0dWJlUGxheSxcbiAgRHJvcGJveCxcbiAgU3RhY2tPdmVyZmxvdyxcbiAgSW5zdGFncmFtLFxuICBGbGlja3IsXG4gIEFkbixcbiAgQml0YnVja2V0LFxuICBCaXRidWNrZXRTcXVhcmUsXG4gIFR1bWJscixcbiAgVHVtYmxyU3F1YXJlLFxuICBBcHBsZSxcbiAgV2luZG93cyxcbiAgQW5kcm9pZCxcbiAgTGludXgsXG4gIERyaWJiYmxlLFxuICBTa3lwZSxcbiAgRm91cnNxdWFyZSxcbiAgVHJlbGxvLFxuICBHaXR0aXAsXG4gIFZrLFxuICBXZWlibyxcbiAgUmVucmVuLFxuICBQYWdlbGluZXMsXG4gIFN0YWNrRXhjaGFuZ2UsXG4gIFZpbWVvLFxuICBTbGFjayxcbiAgV29yZHByZXNzLFxuICBZYWhvbyxcbiAgR29vZ2xlLFxuICBSZWRkaXQsXG4gIFJlZGRpdFNxdWFyZSxcbiAgU3R1bWJsZXVwb25DaXJjbGUsXG4gIFN0dW1ibGV1cG9uLFxuICBEZWxpY2lvdXMsXG4gIERpZ2csXG4gIFBpZWRQaXBlcixcbiAgUGllZFBpcGVyQWx0ZXJuYXRlLFxuICBEcnVwYWwsXG4gIEpvb21sYSxcbiAgQmVoYW5jZSxcbiAgQmVoYW5jZVNxdWFyZSxcbiAgU3RlYW0sXG4gIFN0ZWFtU3F1YXJlLFxuICBTcG90aWZ5LFxuICBEZXZpYW50YXJ0LFxuICBTb3VuZGNsb3VkLFxuICBWaW5lLFxuICBDb2RlcGVuLFxuICBKc2ZpZGRsZSxcbiAgUmViZWwsXG4gIEVtcGlyZSxcbiAgR2l0U3F1YXJlLFxuICBHaXQsXG4gIEhhY2tlck5ld3MsXG4gIFRlbmNlbnRXZWlibyxcbiAgUXEsXG4gIFdlY2hhdCxcbiAgU2xpZGVzaGFyZSxcbiAgVHdpdGNoLFxuICBZZWxwLFxuICBMYXN0Zm0sXG4gIExhc3RmbVNxdWFyZSxcbiAgSW94aG9zdCxcbiAgQW5nZWxsaXN0LFxuICBNZWFucGF0aCxcbiAgQnV5c2VsbGFkcyxcbiAgQ29ubmVjdGRldmVsb3AsXG4gIERhc2hjdWJlLFxuICBGb3J1bWJlZSxcbiAgTGVhbnB1YixcbiAgU2VsbHN5LFxuICBTaGlydHNpbmJ1bGssXG4gIFNpbXBseWJ1aWx0LFxuICBTa3lhdGxhcyxcbiAgV2hhdHNhcHAsXG4gIFZpYWNvaW4sXG4gIE1lZGl1bSxcbiAgTGlrZSxcbiAgRmF2b3JpdGUsXG4gIFZpZGVvLFxuICBDaGVjayxcbiAgQ2xvc2UsXG4gIENhbmNlbCxcbiAgRGVsZXRlLFxuICBYLFxuICBVc2VyVGltZXMsXG4gIFVzZXJDbG9zZSxcbiAgVXNlckNhbmNlbCxcbiAgVXNlckRlbGV0ZSxcbiAgVXNlclgsXG4gIFpvb21JbixcbiAgTWFnbmlmeSxcbiAgU2h1dGRvd24sXG4gIENsb2NrLFxuICBUaW1lLFxuICBQbGF5Q2lyY2xlT3V0bGluZSxcbiAgSGVhZHBob25lLFxuICBDYW1lcmEsXG4gIFZpZGVvQ2FtZXJhLFxuICBQaWN0dXJlLFxuICBQZW5jaWwsXG4gIENvbXBvc2UsXG4gIFBvaW50LFxuICBUaW50LFxuICBTaWdudXAsXG4gIFBsdXNDaXJjbGUsXG4gIERvbnQsXG4gIE1pbmltaXplLFxuICBBZGQsXG4gIEV5ZSxcbiAgQXR0ZW50aW9uLFxuICBDYXJ0LFxuICBTaHVmZmxlLFxuICBUYWxrLFxuICBDaGF0LFxuICBTaG9wcGluZ0NhcnQsXG4gIEJhckdyYXBoLFxuICBBcmVhR3JhcGgsXG4gIFBpZUdyYXBoLFxuICBMaW5lR3JhcGgsXG4gIEtleSxcbiAgQ29ncyxcbiAgRGlzY3Vzc2lvbnMsXG4gIExpa2VPdXRsaW5lLFxuICBEaXNsaWtlT3V0bGluZSxcbiAgSGVhcnRPdXRsaW5lLFxuICBMb2dPdXQsXG4gIFRodW1iVGFjayxcbiAgV2lubmVyLFxuICBCb29rbWFya091dGxpbmUsXG4gIFBob25lLFxuICBQaG9uZVNxdWFyZSxcbiAgQ3JlZGl0Q2FyZCxcbiAgSGRkT3V0bGluZSxcbiAgQnVsbGhvcm4sXG4gIEJlbGwsXG4gIEJlbGxPdXRsaW5lLFxuICBCZWxsU2xhc2gsXG4gIEJlbGxTbGFzaE91dGxpbmUsXG4gIEhhbmRPdXRsaW5lUmlnaHQsXG4gIEhhbmRPdXRsaW5lTGVmdCxcbiAgSGFuZE91dGxpbmVVcCxcbiAgSGFuZE91dGxpbmVEb3duLFxuICBHbG9iZSxcbiAgV3JlbmNoLFxuICBCcmllZmNhc2UsXG4gIEdyb3VwLFxuICBGbGFzayxcbiAgU2lkZWJhcixcbiAgQmFycyxcbiAgTGlzdFVsLFxuICBMaXN0T2wsXG4gIE51bWJlcmVkTGlzdCxcbiAgTWFnaWMsXG4gIFRydWNrLFxuICBDdXJyZW5jeSxcbiAgVHJpYW5nbGVEb3duLFxuICBEcm9wZG93bixcbiAgVHJpYW5nbGVVcCxcbiAgVHJpYW5nbGVMZWZ0LFxuICBUcmlhbmdsZVJpZ2h0LFxuICBFbnZlbG9wZSxcbiAgQ29udmVyc2F0aW9uLFxuICBVbWJyZWxsYSxcbiAgQ2xpcGJvYXJkLFxuICBMaWdodGJ1bGIsXG4gIEFtYnVsYW5jZSxcbiAgTWVka2l0LFxuICBGaWdodGVySmV0LFxuICBCZWVyLFxuICBQbHVzU3F1YXJlLFxuICBDb21wdXRlcixcbiAgQ2lyY2xlT3V0bGluZSxcbiAgSW50ZXJzZXgsXG4gIEFzZXh1YWwsXG4gIFNwaW5uZXIsXG4gIEdhbWVwYWQsXG4gIFN0YXJIYWxmRnVsbCxcbiAgUXVlc3Rpb24sXG4gIEVyYXNlcixcbiAgTWljcm9waG9uZSxcbiAgTWljcm9waG9uZVNsYXNoLFxuICBTaGllbGQsXG4gIFRhcmdldCxcbiAgUGxheUNpcmNsZSxcbiAgUGVuY2lsU3F1YXJlLFxuICBDb21wYXNzLFxuICBBbWV4LFxuICBFdXIsXG4gIEdicCxcbiAgVXNkLFxuICBJbnIsXG4gIENueSxcbiAgUm1iLFxuICBKcHksXG4gIFJvdWJsZSxcbiAgUnViLFxuICBLcncsXG4gIEJ0YyxcbiAgU2hlcWVsLFxuICBJbHMsXG4gIFRyeSxcbiAgWmlwLFxuICBEb3RDaXJjbGVPdXRsaW5lLFxuICBTbGlkZXJzLFxuICBXaSxcbiAgR3JhZHVhdGlvbixcbiAgV2VpeGluLFxuICBCaW5vY3VsYXJzLFxuICBHcmF0aXBheSxcbiAgR2VuZGVybGVzcyxcbiAgVGVsZXR5cGUsXG4gIFBvd2VyQ29yZCxcbiAgVHR5LFxuICBDYyxcbiAgUGx1c0NhcnQsXG4gIEFycm93RG93bkNhcnQsXG4gIERldGVjdGl2ZSxcbiAgVmVudXMsXG4gIE1hcnMsXG4gIE1lcmN1cnksXG4gIFZlbnVzRG91YmxlLFxuICBGZW1hbGVIb21vc2V4dWFsLFxuICBNYXJzRG91YmxlLFxuICBNYWxlSG9tb3NleHVhbCxcbiAgVmVudXNNYXJzLFxuICBNYXJzU3Ryb2tlLFxuICBNYXJzQWx0ZXJuYXRlLFxuICBNYXJzVmVydGljYWwsXG4gIE1hcnNIb3Jpem9udGFsLFxuICBNYXJzU3Ryb2tlVmVydGljYWwsXG4gIE1hcnNTdHJva2VIb3Jpem9udGFsLFxuICBGYWNlYm9va09mZmljaWFsLFxuICBQaW50ZXJlc3RPZmZpY2lhbCxcbiAgQmVkXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZW51bXMvaWNvblR5cGUudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9jb2xsZWN0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZWxlbWVudHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21vZHVsZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3ZpZXdzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9lbnVtc1wiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgaXNET01Db250ZW50fSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7aW5wdXQsIGxhYmVsLCBkaXYsIFZOb2RlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIENoZWNrYm94IHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHk/OiBib29sZWFuO1xuICAgIGNoZWNrZWQ/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBmaXR0ZWQ/OiBib29sZWFuO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgcmFkaW8/OiBib29sZWFuO1xuICAgIHRvZ2dsZT86IGJvb2xlYW47XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIGNoZWNrYm94IGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAqICAgcmVhZG9ubHk/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgcmVhZC1vbmx5LlxuICAqICAgY2hlY2tlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNoZWNrYm94IHRvIGFwcGVhciBjaGVja2VkLlxuICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICogICBmaXR0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCBmb3IgdGlnaHQgZml0cyB3aXRoIG5lYXJieSBjb250ZW50LlxuICAqICAgcmFkaW8/OiBzdHJpbmcgLSBTdHlsZXMgdGhlIGNoZWNrYm94IHRvIGFwcGVhciBsaWtlIGEgcmFkaW8gYnV0dG9uIGJlbG9uZ2luZyB0byB0aGUgZ3JvdXAuXG4gICogICB0b2dnbGU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgbGlrZSBhIHRvZ2dsZS5cbiAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICogQHBhcmFtIHtDb21wb25lbnRTb3VyY2VzfSBzb3VyY2VzIFRoZSBkZWZhdWx0IGNvbXBvbmVudCBzb3VyY2VzLlxuICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IGV2dCA9ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCJpbnB1dFwiKS5ldmVudHModHlwZSk7XG4gICAgICBjb25zdCBjbGlja2VkJCA9IGV2dChcImNsaWNrXCIpO1xuICAgICAgY29uc3QgcHJvcHMkID0gc291cmNlcy5wcm9wcyQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IGNoZWNrZWQkID0gcHJvcHMkLm1hcChwcm9wcyA9PlxuICAgICAgICBjbGlja2VkJC5mb2xkKChhY2MsIGV2dCkgPT4gKGV2dC5zcmNFbGVtZW50IGFzIGFueSkuY2hlY2tlZCwgcHJvcHMuY2hlY2tlZCA/IHRydWUgOiBmYWxzZSlcbiAgICAgICkuZmxhdHRlbigpLnJlbWVtYmVyKCk7XG4gICAgICAvLyBjb25zdCByZW5kZXJQcm9wcyQgPSAgeHMuY29tYmluZShwcm9wcyQsIGNoZWNrZWQkKS5tYXAoXG4gICAgICAvLyAgIChbcHJvcHMsIGNoZWNrZWRdKSA9PiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge2NoZWNrZWR9KVxuICAgICAgLy8gKTtcbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUocHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiBldnQsXG4gICAgICAgIHZhbHVlJDogY2hlY2tlZCRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAqIENyZWF0ZXMgYSBjaGVja2JveCBlbGVtZW50IG9uIHRoZSBwYWdlLlxuICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgKiAgIHJlYWRvbmx5PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIHJlYWQtb25seS5cbiAgKiAgIGNoZWNrZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgY2hlY2tlZC5cbiAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGRpc2FibGVkLlxuICAqICAgZml0dGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggZm9yIHRpZ2h0IGZpdHMgd2l0aCBuZWFyYnkgY29udGVudC5cbiAgKiAgIHJhZGlvPzogc3RyaW5nIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgbGlrZSBhIHJhZGlvIGJ1dHRvbiBiZWxvbmdpbmcgdG8gdGhlIGdyb3VwLlxuICAqICAgdG9nZ2xlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGxpa2UgYSB0b2dnbGUuXG4gICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAqIEBwYXJhbSB7Q29tcG9uZW50U291cmNlc30gc291cmNlcyBUaGUgZGVmYXVsdCBjb21wb25lbnQgc291cmNlcy5cbiAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wc3xET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7Y2xhc3NOYW1lOiBnZXRDbGFzc05hbWUocHJvcHMpIH19LCBbXG4gICAgICBpbnB1dCh7cHJvcHM6IHtcbiAgICAgICAgdHlwZTogcHJvcHMucmFkaW8gPyBcInJhZGlvXCIgOiBcImNoZWNrYm94XCIsXG4gICAgICAgIG5hbWU6cHJvcHMubmFtZSwgXG4gICAgICAgIGNoZWNrZWQ6cHJvcHMuY2hlY2tlZCwgXG4gICAgICAgIGRpc2FibGVkOnByb3BzLnJlYWRvbmx5fHxwcm9wcy5kaXNhYmxlZFxuICAgICAgfX0pLFxuICAgICAgbGFiZWwoe3Byb3BzOiB7Zm9yOnByb3BzLm5hbWV9fSwgcHJvcHMuZml0dGVkID8gXCJcIiA6IGNvbnRlbnQpXG4gICAgXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BzOiBQcm9wcykgOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnJlYWRvbmx5KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmVhZC1vbmx5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaGVja2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2hlY2tlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZml0dGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZml0dGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yYWRpbykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJhZGlvXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50b2dnbGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB0b2dnbGVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIGNoZWNrYm94XCI7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2NoZWNrYm94L2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElWYWx1ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IEljb25UeXBlLCBDb2xvciwgU2l6ZSwgQW5pbWF0aW9uLCBEaXJlY3Rpb24gfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGRyb3BSZXBlYXRzIGZyb20gXCJ4c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcInhzdHJlYW0vZXh0cmEvZGVib3VuY2VcIjtcbmltcG9ydCBjb25jYXQgZnJvbSBcInhzdHJlYW0vZXh0cmEvY29uY2F0XCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCBkZWxheSBmcm9tIFwieHN0cmVhbS9leHRyYS9kZWxheVwiO1xuaW1wb3J0IHsgZGl2LCBpbnB1dCB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmltcG9ydCB7IE1lbnUgfSBmcm9tIFwiY29sbGVjdGlvbnMvbWVudVwiO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gXCJlbGVtZW50cy9pY29uXCI7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIm1vZHVsZXMvdHJhbnNpdGlvblwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIERyb3Bkb3duIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgc3RhdGljPzogc3RyaW5nO1xuICAgIHJpZ2h0QWxpZ25lZD86IGJvb2xlYW47XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBpbml0aWFsPzogYW55O1xuICAgIGRlZmF1bHQ/OiBzdHJpbmc7XG4gICAgc2VsZWN0aW9uPzogYm9vbGVhbjtcbiAgICBpbmxpbmU/OiBib29sZWFuO1xuICAgIGZsb2F0aW5nPzogYm9vbGVhbjtcbiAgICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgc2Nyb2xsaW5nPzogYm9vbGVhbjtcbiAgICBjb21wYWN0PzogYm9vbGVhbjtcbiAgICBzZWFyY2g/OiBib29sZWFuO1xuICAgIHBvaW50aW5nPzogYm9vbGVhbjtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBjb2xvcj86IENvbG9yO1xuICB9XG4gIGV4cG9ydCB0eXBlIENvbnRlbnQ8Vj4gPSBBcnJheTxEcm9wZG93bkl0ZW08Vj4+O1xuICBleHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSXRlbTxWPiB7XG4gICAgYm9keTogRE9NQ29udGVudDtcbiAgICB2YWx1ZTogVjtcbiAgICBoZWFkZXI/OiBib29sZWFuO1xuICAgIGZpdHRlZD86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQSBkcm9wZG93biBjb21wb25lbnQgZm9yIGNhcHR1cmluZyB1c2VyIGlucHV0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICBhY3RpdmU/OiBib29sZWFuLFxuICAgKiAgaW5pdGlhbD86IGFueVxuICAgKiAgZGVmYXVsdD86IHN0cmluZ1xuICAgKiAgc2VsZWN0aW9uPzogYm9vbGVhblxuICAgKiAgaW5saW5lPzogYm9vbGVhblxuICAgKiAgZmxvYXRpbmc/OiBib29sZWFuXG4gICAqICBsb2FkaW5nPzogYm9vbGVhblxuICAgKiAgZGlzYWJsZWQ/OiBib29sZWFuXG4gICAqICBzY3JvbGxpbmc/OiBib29sZWFuXG4gICAqICBzZWFyY2g/OiBib29sZWFuXG4gICAqICBjb21wYWN0PzogYm9vbGVhblxuICAgKiAgc2l6ZT86IFNpemVcbiAgICogIGNvbG9yPzogQ29sb3JcbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogQXJyYXkgb2Yge1xuICAgKiAgYm9keTogRE9NQ29udGVudCxcbiAgICogIHZhbHVlOiBhbnksXG4gICAqICBoZWFkZXI/OiBib29sZWFuLFxuICAgKiAgZml0dGVkPzogYm9vbGVhbixcbiAgICogIGRpc2FibGVkPzogYm9vbGVhbixcbiAgICogIGFjdGl2ZT86IGJvb2xlYW5cbiAgICogfVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bjxWPihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50PFY+Pik6IElWYWx1ZUNvbXBvbmVudFNpbmtzPFY+IHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ8Vj4+KSB7XG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmRyb3Bkb3duXCIpLmV2ZW50cyh0eXBlKTtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcblxuICAgICAgY29uc3QgcHJvcHMkID0gc291cmNlcy5wcm9wcyQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IGl0ZW1DbGljayRwcm94eSA9IHhzLmNyZWF0ZSgpO1xuICAgICAgY29uc3QgdmFsdWUkcHJveHkgPSB4cy5jcmVhdGUoKTtcblxuICAgICAgY29uc3QgZHJvcGRvd25DbGljayQgPSBldnQoXCJjbGlja1wiKVxuICAgICAgICAuZmlsdGVyKGV2dCA9PiAhKGV2dC5zcmNFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGVtXCIpKVxuICAgICAgICAubWFwVG8oRGlyZWN0aW9uLkluKTtcbiAgICAgIGNvbnN0IG1vdXNlbGVhdmUkID0geHMubWVyZ2UoZXZ0KFwibW91c2VsZWF2ZVwiKS5maWx0ZXIoXG4gICAgICAgIGV2dCA9PiBldnQuc3JjRWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZihcImljb25cIikgPT09IC0xXG4gICAgICApLCBldnQoXCJtb3VzZWVudGVyXCIpKVxuICAgICAgICAubWFwKGV2dCA9PiAoZXZ0IGFzIE1vdXNlRXZlbnQpLnR5cGUgPT09IFwibW91c2VlbnRlclwiID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dClcbiAgICAgICAgLmNvbXBvc2UoZGVib3VuY2UoMjUwKSlcbiAgICAgICAgLmZpbHRlcihkaXIgPT4gZGlyID09PSBEaXJlY3Rpb24uT3V0KTtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0geHMubWVyZ2UoZHJvcGRvd25DbGljayQsIGl0ZW1DbGljayRwcm94eSwgbW91c2VsZWF2ZSQpXG4gICAgICAgIC5zdGFydFdpdGgoRGlyZWN0aW9uLk91dClcbiAgICAgICAgLm1hcChkaXIgPT4gKHtcbiAgICAgICAgICBhbmltYXRpb246IEFuaW1hdGlvbi5GYWRlLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyXG4gICAgICAgIH0pKVxuICAgICAgICAuY29tcG9zZShkcm9wUmVwZWF0cyhcbiAgICAgICAgICAoYSwgYikgPT4gKGEgYXMgYW55KS5kaXJlY3Rpb24gPT09IChiIGFzIGFueSkuZGlyZWN0aW9uXG4gICAgICAgICAgICAmJiAoYSBhcyBhbnkpLmFuaW1hdGlvbiA9PT0gKGIgYXMgYW55KS5hbmltYXRpb25cbiAgICAgICAgKSlcbiAgICAgICAgLmRyb3AoMSlcbiAgICAgICAgLnN0YXJ0V2l0aCh7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogRGlyZWN0aW9uLk91dCB9KTtcblxuICAgICAgY29uc3QgZmlsdGVyJCA9IHNvdXJjZXMuRE9NLnNlbGVjdChcImlucHV0XCIpLmV2ZW50cyhcImtleXVwXCIpXG4gICAgICAgIC5tYXAoZXYgPT4gKGV2LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSlcbiAgICAgICAgLnN0YXJ0V2l0aChcIlwiKSBhcyBTdHJlYW08c3RyaW5nPjtcbiAgICAgIGNvbnN0IGZpbHRlcmVkQ29udGVudCQgPSB4cy5jb21iaW5lKHNvdXJjZXMuY29udGVudCQsIGZpbHRlciQpLm1hcChcbiAgICAgICAgKFtjb250ZW50LCBmaWx0ZXJdKSA9PiBjb250ZW50LmZpbHRlcihjID0+IGZpbHRlckNvbnRlbnQoYywgZmlsdGVyKSlcbiAgICAgICkucmVtZW1iZXIoKTtcblxuICAgICAgY29uc3QgY29udGVudCQgPSB4cy5jb21iaW5lKGZpbHRlcmVkQ29udGVudCQsIHZhbHVlJHByb3h5KS5tYXAoXG4gICAgICAgIChbY29udGVudCwgdmFsdWVdKSA9PiBjb250ZW50Lm1hcChcbiAgICAgICAgICBpdGVtID0+IGl0ZW0udmFsdWUgPT09IHZhbHVlID8gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyBhY3RpdmU6IHRydWUgfSkgOiBpdGVtXG4gICAgICAgIClcbiAgICAgICkucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IG1lbnUgPSBNZW51LnJ1bih7IERPTTogc291cmNlcy5ET00sIGNvbnRlbnQkIH0pO1xuXG4gICAgICBjb25zdCB0cmFuc2l0aW9uZWRNZW51ID0gVHJhbnNpdGlvbi5ydW4oeyBET006IHNvdXJjZXMuRE9NLCB0YXJnZXQkOiBtZW51LkRPTSwgYXJncyQ6IHRyYW5zaXRpb24kIGFzIGFueSB9KTtcblxuICAgICAgbGV0IGl0ZW1DbGljayQgPSBldnQoXCJjbGlja1wiKS5maWx0ZXIoeCA9PiB4LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGVtXCIpKS5yZW1lbWJlcigpO1xuICAgICAgaXRlbUNsaWNrJHByb3h5LmltaXRhdGUoaXRlbUNsaWNrJC5tYXBUbyhEaXJlY3Rpb24uT3V0KSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCBjbGlja2VkSWQkID0gaXRlbUNsaWNrJFxuICAgICAgICAubWFwKGV2ID0+IHBhcnNlSW50KChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmlkKSlcbiAgICAgICAgLmZpbHRlcihuID0+ICFpc05hTihuKSAmJiB0eXBlb2YgKG4pICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICAgIGNvbnN0IGVtaXR0ZWRWYWx1ZSQgPSBjbGlja2VkSWQkLm1hcChpZCA9PiBmaWx0ZXJlZENvbnRlbnQkLm1hcChpdGVtcyA9PiBpdGVtc1tpZF0udmFsdWUpLnRha2UoMSkpLmZsYXR0ZW4oKS5yZW1lbWJlcigpIGFzIGFueTtcbiAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSQgPSBwcm9wcyQubWFwKHByb3BzID0+IHByb3BzLmluaXRpYWwpLnJlbWVtYmVyKCk7XG4gICAgICB2YWx1ZSRwcm94eS5pbWl0YXRlKHhzLm1lcmdlKGluaXRpYWxWYWx1ZSQgYXMgYW55LCBlbWl0dGVkVmFsdWUkKSk7XG5cbiAgICAgIGNvbnN0IGljb24gPSBJY29uLnJlbmRlcih7fSwgSWNvblR5cGUuRHJvcGRvd24pO1xuICAgICAgY29uc3QgYWN0aXZlJCA9IHhzLm1lcmdlKFxuICAgICAgICB0cmFuc2l0aW9uJC5maWx0ZXIoeCA9PiB4LmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLkluKS5tYXBUbyh0cnVlKSxcbiAgICAgICAgdHJhbnNpdGlvbiQuZmlsdGVyKHggPT4geC5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5PdXQpLmNvbXBvc2UoZGVsYXkoMjUwKSkubWFwVG8oZmFsc2UpXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RyZWFtcyA9IHhzLmNvbWJpbmUoXG4gICAgICAgIHByb3BzJCxcbiAgICAgICAgYWN0aXZlJCxcbiAgICAgICAgdHJhbnNpdGlvbmVkTWVudS5ET00sXG4gICAgICAgIGNvbnRlbnQkLm1hcChjb250ZW50ID0+IGNvbnRlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5hY3RpdmUpWzBdKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZ0cmVlJCA9IHN0cmVhbXMubWFwKFxuICAgICAgICAoW3Byb3BzLCBhY3RpdmUsIG1lbnUsIGl0ZW1dKSA9PlxuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKHByb3BzLCBhY3RpdmUpIH0gfSwgW1xuICAgICAgICAgICAgZ2V0VGV4dChpdGVtLCBwcm9wcyksXG4gICAgICAgICAgICBwcm9wcy5zZWFyY2ggPyBpbnB1dCh7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJzZWFyY2hcIiB9IH0pIDogXCJcIixcbiAgICAgICAgICAgIGljb24sIG1lbnVcbiAgICAgICAgICBdKVxuICAgICAgKS5yZW1lbWJlcigpO1xuXG4gICAgICAvL1RvZG8gZmluZCBjbGVhbmVyIHdheSB0byBjbGVhciBpbnB1dCB1c2luZyBzbmFiYmRvbSBob29rcz9cbiAgICAgIGVtaXR0ZWRWYWx1ZSQubWFwKF8gPT4gdnRyZWUkLnRha2UoMSkpLmZsYXR0ZW4oKS5hZGRMaXN0ZW5lcihuZXcgRXhlY3V0ZUxpc3RlbmVyKGZ1bmN0aW9uICh2bm9kZTogVk5vZGUpIHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiAodm5vZGUuZWxtKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IGVsbSA9ICh2bm9kZS5lbG0gYXMgRWxlbWVudCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlmIChlbG1bMF0gJiYgZWxtWzBdLnZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgbmV4dFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbG1bMF0udmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICBmaWx0ZXIkLnNoYW1lZnVsbHlTZW5kTmV4dChcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChjbGVhciwgMTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIoKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2dHJlZSQsXG4gICAgICAgIEV2ZW50czogZXZ0LFxuICAgICAgICB2YWx1ZSQ6IGNvbmNhdChpbml0aWFsVmFsdWUkLCBlbWl0dGVkVmFsdWUkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZHJvcGRvd24gY29tcG9uZW50IGZvciBjYXB0dXJpbmcgdXNlciBpbnB1dC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICBhY3RpdmU/OiBib29sZWFuLFxuICAgKiAgaW5pdGlhbD86IGFueVxuICAgKiAgZGVmYXVsdD86IHN0cmluZ1xuICAgKiAgc2VsZWN0aW9uPzogYm9vbGVhblxuICAgKiAgaW5saW5lPzogYm9vbGVhblxuICAgKiAgZmxvYXRpbmc/OiBib29sZWFuXG4gICAqICBsb2FkaW5nPzogYm9vbGVhblxuICAgKiAgZGlzYWJsZWQ/OiBib29sZWFuXG4gICAqICBzY3JvbGxpbmc/OiBib29sZWFuXG4gICAqICBzZWFyY2g/OiBib29sZWFuXG4gICAqICBjb21wYWN0PzogYm9vbGVhblxuICAgKiAgc2l6ZT86IFNpemVcbiAgICogIGNvbG9yPzogQ29sb3JcbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogQXJyYXkgb2Yge1xuICAgKiAgYm9keTogRE9NQ29udGVudCxcbiAgICogIHZhbHVlOiBhbnksXG4gICAqICBoZWFkZXI/OiBib29sZWFuLFxuICAgKiAgZml0dGVkPzogYm9vbGVhbixcbiAgICogIGRpc2FibGVkPzogYm9vbGVhbixcbiAgICogIGFjdGl2ZT86IGJvb2xlYW5cbiAgICogfVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IENvbnRlbnQ8YW55PiA9IHt9LCBjOiBDb250ZW50PGFueT4gPSBbXSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSAocE9yQyBpbnN0YW5jZW9mIEFycmF5KSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IChwT3JDIGluc3RhbmNlb2YgQXJyYXkpID8gcE9yQyA6IGM7XG4gICAgY29uc3QgaWNvbiA9IEljb24ucmVuZGVyKHt9LCBJY29uVHlwZS5Ecm9wZG93bik7XG4gICAgY29uc3QgbWVudSA9IE1lbnUucmVuZGVyKHt9LCBjb250ZW50KTtcbiAgICBjb25zdCBpdGVtID0gY29udGVudC5maWx0ZXIoaXRlbSA9PiBpdGVtLmFjdGl2ZSlbMF07XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKHByb3BzKSB9IH0sIFtcbiAgICAgIGdldFRleHQoaXRlbSwgcHJvcHMpLFxuICAgICAgcHJvcHMuc2VhcmNoID8gaW5wdXQoeyBwcm9wczogeyBjbGFzc05hbWU6IFwic2VhcmNoXCIgfSB9KSA6IFwiXCIsXG4gICAgICBpY29uLCBtZW51XG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcHM6IFByb3BzLCBhY3RpdmU/KSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMucmlnaHRBbGlnbmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmlnaHRcIjtcblxuICAgIH1cbiAgICBpZiAocHJvcHMuc2VsZWN0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VsZWN0aW9uXCI7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmlubGluZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGlubGluZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmxvYXRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbG9hdGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubG9hZGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxvYWRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNjcm9sbGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNjcm9sbGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2VhcmNoKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VhcmNoXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wYWN0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGFjdFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucG9pbnRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwb2ludGluZ1wiO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlIHx8IHByb3BzLmFjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIGRyb3Bkb3duXCI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VGV4dDxWPihpdGVtOiBEcm9wZG93bkl0ZW08Vj4sIHByb3BzOiBQcm9wcyk6IFZOb2RlIHtcbiAgICBpZiAodHlwZW9mIChwcm9wcy5zdGF0aWMpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInRleHRcIiB9IH0sIHByb3BzLnN0YXRpYyk7XG4gICAgfVxuICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImRlZmF1bHQgdGV4dFwiIH0gfSwgcHJvcHMuZGVmYXVsdCk7XG4gICAgfVxuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidGV4dFwiIH0gfSwgaXRlbS5ib2R5KTtcbiAgfVxuICBmdW5jdGlvbiBmaWx0ZXJDb250ZW50PFY+KGl0ZW06IERyb3Bkb3duSXRlbTxWPiwgZmlsdGVyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBmdW5jdGlvbiBmKG5vZGU6IFZOb2RlKSB7XG4gICAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgIHJldHVybiBub2RlLnRleHQuaW5kZXhPZihmaWx0ZXIpICE9PSAtMSB8fCAhZmlsdGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGMgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChmKGMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIChpdGVtLmJvZHkgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICByZXR1cm4gKGl0ZW0uYm9keSBhcyBzdHJpbmcpLmluZGV4T2YoZmlsdGVyKSAhPT0gLTEgfHwgIWZpbHRlcjtcbiAgICB9XG4gICAgaWYgKCEoaXRlbS5ib2R5IGFzIGFueSkucHVzaCkge1xuICAgICAgcmV0dXJuIGYoaXRlbS5ib2R5IGFzIFZOb2RlKTtcbiAgICB9XG4gICAgZm9yIChsZXQgYyBpbiAoaXRlbS5ib2R5IGFzIFZOb2RlKS5jaGlsZHJlbikge1xuICAgICAgaWYgKGYoYykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjbGFzcyBFeGVjdXRlTGlzdGVuZXIge1xuICAgIGY6IEZ1bmN0aW9uO1xuICAgIGNvbnN0cnVjdG9yKGY6IEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLmYgPSBmO1xuICAgIH1cbiAgICBuZXh0KGkpIHsgdGhpcy5mKGkpOyB9XG4gICAgZXJyb3IoaSkgeyB9XG4gICAgY29tcGxldGUoKSB7IH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvZHJvcGRvd24vaW5kZXgudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9jaGVja2JveFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZGltbWVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9kcm9wZG93blwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbW9kYWxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BvcHVwXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wcm9ncmVzc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNpdGlvblwiO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIERPTVNvdXJjZSB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtLCBNZW1vcnlTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuXG5pbXBvcnQgeyBJY29uVHlwZSwgRGlyZWN0aW9uLCBBbmltYXRpb259IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHsgRGltbWVyfSBmcm9tIFwibW9kdWxlcy9kaW1tZXJcIjtcbmltcG9ydCB7IEljb24gfSBmcm9tIFwiZWxlbWVudHMvaWNvblwiO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCJtb2R1bGVzL3RyYW5zaXRpb25cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBNb2RhbCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGhlYWRlcj86IHN0cmluZztcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBNb2RhbFNvdXJjZXMge1xuICAgIERPTTogRE9NU291cmNlO1xuICAgIG9uJDogU3RyZWFtPGJvb2xlYW4+O1xuICAgIHByb3BzJD86IFN0cmVhbTxQcm9wcz47XG4gICAgY29udGVudCQ/OiBTdHJlYW08RE9NQ29udGVudD47XG4gICAgYWN0aW9ucyQ/OiBTdHJlYW08RE9NQ29udGVudD47XG4gICAgdGFyZ2V0JD86IFN0cmVhbTxWTm9kZT47XG4gIH1cbiAgLyoqXG4gICAqIEEgbW9kYWwgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGNvbnRlbnQgaW4gYSBtb2RhbC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgaGVhZGVyOiBTdHJpbmcgLSBUaGUgaGVhZGVyIHRleHQgZm9yIHRoZSBjb21wb25lbnQuXG4gICAqICAgb24kOiBTdHJlYW08Qm9vbGVhbj4gLSBXaGVuIHRvIGRpc3BsYXkgdGhlIG1vZGFsLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IE1vZGFsU291cmNlcykge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogTW9kYWxTb3VyY2VzKSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7IG9uJDogeHMub2YoZmFsc2UpIH0pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLmFjdGlvbnMkID0gc291cmNlcy5hY3Rpb25zJCA/IHNvdXJjZXMuYWN0aW9ucyQgOiB4cy5vZihcIlwiKTtcbiAgICAgIHNvdXJjZXMudGFyZ2V0JCA9IHNvdXJjZXMudGFyZ2V0JCA/IHNvdXJjZXMudGFyZ2V0JCA6IHhzLm9mKFwicGFnZVwiKTtcblxuICAgICAgY29uc3QgY2xvc2VJY29uID0gSWNvbi5ydW4oeyBET006IHNvdXJjZXMuRE9NLCBwcm9wcyQ6IHhzLm9mKHsgbGluazogdHJ1ZSB9KSwgY29udGVudCQ6IHhzLm9mKEljb25UeXBlLkNsb3NlKSB9KTtcbiAgICAgIGNvbnN0IGNsb3NlJCA9IGNsb3NlSWNvbi5FdmVudHMoXCJjbGlja1wiKS5tYXBUbyhmYWxzZSk7XG5cbiAgICAgIC8qKiogUmVuZGVyIG1vZGFsICoqKi9cbiAgICAgIGxldCBkaW1tZXJjbGljayRwcm94eSA9IHhzLmNyZWF0ZSgpIGFzIFN0cmVhbTxib29sZWFuPjtcbiAgICAgIGNvbnN0IG9uJCA9IHhzLm1lcmdlKHNvdXJjZXMub24kLCBkaW1tZXJjbGljayRwcm94eSwgY2xvc2UkKS5yZW1lbWJlcigpIGFzIE1lbW9yeVN0cmVhbTxib29sZWFuPjtcbiAgICAgIGNvbnN0IGNvbnRlbnQkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCwgc291cmNlcy5hY3Rpb25zJCwgY2xvc2VJY29uLkRPTSkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50LCBhY3Rpb25zLCBpY29uXSkgPT5cbiAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidWkgc2Nyb2xsaW5nIGFjdGl2ZSBtb2RhbFwiIH0gfSwgW1xuICAgICAgICAgICAgaWNvbixcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJoZWFkZXJcIiB9IH0sIHByb3BzLmhlYWRlciksXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY29udGVudFwiIH0gfSwgY29udGVudCksXG4gICAgICAgICAgICBhY3Rpb25zID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImFjdGlvbnNcIiB9IH0sIGFjdGlvbnMpIDogXCJcIlxuICAgICAgICAgIF0pXG4gICAgICApLnJlbWVtYmVyKCk7XG5cbiAgICAgIC8qKiogQW5pbWF0aW9uICoqKi9cbiAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0gb24kXG4gICAgICAgIC5mb2xkKChwcmV2QW5pbSwgYWN0aXZlKSA9PiBwcmV2QW5pbS5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5Ob25lXG4gICAgICAgICAgPyAoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IGFjdGl2ZSA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXQgfSlcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogQW5pbWF0aW9uLkZhZGUsIGRpcmVjdGlvbjogYWN0aXZlID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dFxuICAgICAgICAgIH1cbiAgICAgICAgLCAoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IERpcmVjdGlvbi5Ob25lIH0pKTtcbiAgICAgIGNvbnN0IGFuaW1hdGVkQ29udGVudCA9IFRyYW5zaXRpb24ucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgdGFyZ2V0JDogY29udGVudCQsIGFyZ3MkOiB0cmFuc2l0aW9uJCB9KTtcblxuICAgICAgLyoqKiBBY3RpdmF0ZSBkaW1tZXIgKioqL1xuICAgICAgbGV0IGRpbW1lckNvbnRlbnQkID0gYW5pbWF0ZWRDb250ZW50LkRPTS5tYXAoeCA9PiBbeF0pO1xuICAgICAgY29uc3QgZGltbWVyID0gRGltbWVyLnJ1bih7IERPTTogc291cmNlcy5ET00sIHRhcmdldCQ6IHNvdXJjZXMudGFyZ2V0JCwgYXJncyQ6IG9uJCwgY29udGVudCQ6IGRpbW1lckNvbnRlbnQkIH0sIHNvdXJjZXMucHJvcHMkLm1hcCh4ID0+IHguaW52ZXJ0ZWQpKTtcbiAgICAgIGNvbnN0IGRpbW1lcmNsaWNrJCA9IGRpbW1lci5FdmVudHMoXCJtb3VzZWRvd25cIilcbiAgICAgICAgLmZpbHRlcihldnQgPT4gZXZ0LnNyY0VsZW1lbnQgPT09IChldnQgYXMgTW91c2VFdmVudCkuY3VycmVudFRhcmdldClcbiAgICAgICAgLm1hcFRvKGZhbHNlKTtcbiAgICAgIGRpbW1lcmNsaWNrJHByb3h5LmltaXRhdGUoZGltbWVyY2xpY2skKTtcblxuICAgICAgY29uc3QgZmFkZU91dEVuZCQgPSBvbiQubWFwKGFjdGl2ZSA9PiAhYWN0aXZlID8gZGltbWVyLkV2ZW50cyhcImFuaW1hdGlvbmVuZFwiKSA6IHhzLm5ldmVyKCkpLmZsYXR0ZW4oKS5tYXBUbyhmYWxzZSk7XG4gICAgICAvLyBjb25zdCBhY3RpdmUkID0geHMubWVyZ2Uoc291cmNlcy5vbiQsIGZhZGVPdXRFbmQkKS5yZW1lbWJlcigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlJDogeHMubWVyZ2Uoc291cmNlcy5vbiQsIGZhZGVPdXRFbmQkKSxcbiAgICAgICAgRE9NOiBkaW1tZXIuRE9NLFxuICAgICAgICBFdmVudHM6IGFuaW1hdGVkQ29udGVudC5FdmVudHNcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvbW9kYWwvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB9IGZyb20gXCJpbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplLCBBbmltYXRpb24sIERpcmVjdGlvbiB9IGZyb20gXCJlbnVtc1wiO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gXCJtb2R1bGVzL3RyYW5zaXRpb25cIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCJ4c3RyZWFtL2V4dHJhL2RlYm91bmNlXCI7XG5pbXBvcnQgZHJvcFJlcGVhdHMgZnJvbSBcInhzdHJlYW0vZXh0cmEvZHJvcFJlcGVhdHNcIjtcbmltcG9ydCBkZWxheSBmcm9tIFwieHN0cmVhbS9leHRyYS9kZWxheVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFBvcHVwIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBcmdzIHtcbiAgICBhY3RpdmU6IGJvb2xlYW47XG4gICAgYXR0YWNobWVudDogUG9wdXBBdHRhY2htZW50O1xuICAgIGhlYWRlcj86IHN0cmluZztcbiAgICB3aWRlPzogYm9vbGVhbjtcbiAgICB2ZXJ5V2lkZT86IGJvb2xlYW47XG4gICAgZmxvd2luZz86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBJVGV0aGVyZWRJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIGV4dGVuZHMgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIHRldGhlcjogYW55O1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXM8Vk5vZGUsIEFyZ3MsIERPTUNvbnRlbnQ+KTogSVRldGhlcmVkSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXM8Vk5vZGUsIEFyZ3MsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLmFyZ3MkID0gc291cmNlcy5hcmdzJCA/IHNvdXJjZXMuYXJncyQgOiB4cy5vZih7IGFjdGl2ZTogZmFsc2UsIGF0dGFjaG1lbnQ6IFBvcHVwQXR0YWNobWVudC5Cb3R0b21MZWZ0IH0pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IGFyZ3MkID0gc291cmNlcy5hcmdzJC5yZW1lbWJlcigpO1xuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShhcmdzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW2FyZ3MsIGNvbnRlbnRdKSA9PiByZW5kZXIoYXJncywgY29udGVudClcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG1vdXNlbGVhdmUkcHJveHkgPSB4cy5jcmVhdGUoKTtcbiAgICAgIGNvbnN0IG1vdXNlZW50ZXIkcHJveHkgPSB4cy5jcmVhdGUoKTtcbiAgICAgIGNvbnN0IGFjdGl2ZSQgPSBhcmdzJC5tYXAoYXJnID0+IGFyZy5hY3RpdmUgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0KS5kcm9wKDEpO1xuICAgICAgY29uc3QgdGltZXIkID0gYWN0aXZlJC5tYXAoZGlyID0+IGRpciA9PT0gRGlyZWN0aW9uLk91dCA/IHhzLm9mKERpcmVjdGlvbi5PdXQpXG4gICAgICAgIDogeHMub2YoRGlyZWN0aW9uLk91dCkuY29tcG9zZShkZWxheSgxMDAwKSkuZW5kV2hlbihtb3VzZWVudGVyJHByb3h5KVxuICAgICAgKS5mbGF0dGVuKCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uJCA9IHhzLm1lcmdlKGFjdGl2ZSQsIG1vdXNlbGVhdmUkcHJveHksIHRpbWVyJClcbiAgICAgICAgLm1hcChkaXIgPT4gKHtcbiAgICAgICAgICBhbmltYXRpb246IEFuaW1hdGlvbi5GYWRlLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyXG4gICAgICAgIH0pKVxuICAgICAgICAuY29tcG9zZShkcm9wUmVwZWF0cyhcbiAgICAgICAgICAoYSwgYikgPT4gKGEgYXMgYW55KS5kaXJlY3Rpb24gPT09IChiIGFzIGFueSkuZGlyZWN0aW9uXG4gICAgICAgICAgICAmJiAoYSBhcyBhbnkpLmFuaW1hdGlvbiA9PT0gKGIgYXMgYW55KS5hbmltYXRpb25cbiAgICAgICAgKSlcbiAgICAgICAgLnN0YXJ0V2l0aCh7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogRGlyZWN0aW9uLk91dCB9KSBhcyBTdHJlYW08YW55PjtcbiAgICAgIGNvbnN0IGFuaW1hdGVkUG9wdXAgPSBUcmFuc2l0aW9uLnJ1bih7IERPTTogc291cmNlcy5ET00sIHRhcmdldCQ6IHZUcmVlJCwgYXJncyQ6IHRyYW5zaXRpb24kIH0pO1xuICAgICAgY29uc3QgbW91c2VlbnRlciQgPSBhbmltYXRlZFBvcHVwLkV2ZW50cyhcIm1vdXNlZW50ZXJcIik7XG4gICAgICBjb25zdCBtb3VzZWxlYXZlJCA9IHhzLm1lcmdlKGFuaW1hdGVkUG9wdXAuRXZlbnRzKFwibW91c2VsZWF2ZVwiKSwgbW91c2VlbnRlciQpXG4gICAgICAgIC5tYXAoZXZ0ID0+IGV2dC50eXBlID09PSBcIm1vdXNlZW50ZXJcIiA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXQpXG4gICAgICAgIC5jb21wb3NlKGRlYm91bmNlKDIwMCkpXG4gICAgICAgIC5maWx0ZXIoZGlyID0+IGRpciA9PT0gRGlyZWN0aW9uLk91dCk7XG4gICAgICBtb3VzZWxlYXZlJHByb3h5LmltaXRhdGUobW91c2VsZWF2ZSQpO1xuICAgICAgbW91c2VlbnRlciRwcm94eS5pbWl0YXRlKG1vdXNlZW50ZXIkKTtcblxuICAgICAgY29uc3QgcG9wdXAkID0gYW5pbWF0ZWRQb3B1cC5ET00ucmVtZW1iZXIoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogcG9wdXAkLFxuICAgICAgICBFdmVudHM6IGFuaW1hdGVkUG9wdXAuRXZlbnRzLFxuICAgICAgICB0ZXRoZXI6IHhzLmNvbWJpbmUocG9wdXAkLCBzb3VyY2VzLnRhcmdldCQsIGFyZ3MkKVxuICAgICAgICAgIC5tYXAoKFtlbGVtZW50LCB0YXJnZXQsIGFyZ3NdKSA9PiAoeyBlbGVtZW50LCB0YXJnZXQsIGFyZ3MgfSkpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKGFyZ3M6IEFyZ3MgPSB7IGFjdGl2ZTogdHJ1ZSwgYXR0YWNobWVudDogUG9wdXBBdHRhY2htZW50LkJvdHRvbUxlZnQgfSwgY29udGVudDogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKGFyZ3MpIH0gfSwgW1xuICAgICAgYXJncy5oZWFkZXIgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiaGVhZGVyXCIgfSB9LCBhcmdzLmhlYWRlcikgOiBcIlwiLFxuICAgICAgY29udGVudFxuICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBBcmdzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy53aWRlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgd2lkZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmVyeVdpZGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ5IHdpZGVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZsb3dpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbG93aW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFBvcHVwQXR0YWNobWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hdHRhY2htZW50KSArIFwiIHBvcHVwXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuICBleHBvcnQgZW51bSBQb3B1cEF0dGFjaG1lbnQge1xuICAgIFRvcExlZnQsIFRvcE1pZGRsZSwgVG9wUmlnaHQsIExlZnRDZW50ZXIsIFJpZ2h0Q2VudGVyLFxuICAgIEJvdHRvbUxlZnQsIEJvdHRvbU1pZGRsZSwgQm90dG9tUmlnaHQsXG4gICAgQ2VudGVyXG4gIH1cbiAgZXhwb3J0IG5hbWVzcGFjZSBQb3B1cEF0dGFjaG1lbnQge1xuICAgIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShhdHRhY2htZW50OiBQb3B1cEF0dGFjaG1lbnQpIHtcbiAgICAgIHN3aXRjaCAoYXR0YWNobWVudCkge1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BMZWZ0OiByZXR1cm4gXCIgdG9wIGxlZnRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wTWlkZGxlOiByZXR1cm4gXCIgdG9wIGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BSaWdodDogcmV0dXJuIFwiIHRvcCByaWdodFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5MZWZ0Q2VudGVyOiByZXR1cm4gXCIgbGVmdCBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuUmlnaHRDZW50ZXI6IHJldHVybiBcIiByaWdodCBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTGVmdDogcmV0dXJuIFwiIGJvdHRvbSBsZWZ0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbU1pZGRsZTogcmV0dXJuIFwiIGJvdHRvbSBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tUmlnaHQ6IHJldHVybiBcIiBib3R0b20gcmlnaHRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQ2VudGVyOiByZXR1cm4gXCIgY2VudGVyXCI7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBcIiBib3R0b20gbGVmdFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBleHBvcnQgZnVuY3Rpb24gVG9UZXRoZXIoYXR0YWNobWVudDogUG9wdXBBdHRhY2htZW50KSB7XG4gICAgICBzd2l0Y2ggKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wTGVmdDogcmV0dXJuIFwidG9wIGxlZnRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wTWlkZGxlOiByZXR1cm4gXCJ0b3AgY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcFJpZ2h0OiByZXR1cm4gXCJ0b3AgcmlnaHRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuTGVmdENlbnRlcjogcmV0dXJuIFwibGVmdCBtaWRkbGVcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuUmlnaHRDZW50ZXI6IHJldHVybiBcInJpZ2h0IG1pZGRsZVwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21MZWZ0OiByZXR1cm4gXCJib3R0b20gbGVmdFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21NaWRkbGU6IHJldHVybiBcImJvdHRvbSBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tUmlnaHQ6IHJldHVybiBcImJvdHRvbSByaWdodFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5DZW50ZXI6IHJldHVybiBcImNlbnRlclwiO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gXCJib3R0b20gbGVmdFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBleHBvcnQgZnVuY3Rpb24gVG9PcHBvc2l0ZVRldGhlcihhdHRhY2htZW50OiBQb3B1cEF0dGFjaG1lbnQpIHtcbiAgICAgIHN3aXRjaCAoYXR0YWNobWVudCkge1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BMZWZ0OiByZXR1cm4gXCJib3R0b20gcmlnaHRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wTWlkZGxlOiByZXR1cm4gXCJib3R0b20gY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcFJpZ2h0OiByZXR1cm4gXCJib3R0b20gbGVmdFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5MZWZ0Q2VudGVyOiByZXR1cm4gXCJyaWdodCBtaWRkbGVcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuUmlnaHRDZW50ZXI6IHJldHVybiBcImxlZnQgbWlkZGxlXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbUxlZnQ6IHJldHVybiBcInRvcCByaWdodFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21NaWRkbGU6IHJldHVybiBcInRvcCBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tUmlnaHQ6IHJldHVybiBcInRvcCBsZWZ0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkNlbnRlcjogcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBcImJvdHRvbSBsZWZ0XCI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kdWxlcy9wb3B1cC9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50IH0gZnJvbSBcImludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIEF0dGFjaG1lbnQsIENvbG9yIH0gZnJvbSBcImVudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBQcm9ncmVzc0JhciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHByb2dyZXNzOiBudW1iZXI7XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50O1xuICAgIHNpemU/OiBTaXplO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMYWJlbCBjb21wb25lbnQgdG8gYWRkIGluZm9ybWF0aW9uIHRvIGNlcnRhaW4gY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIHByb2dyZXNzOiBudW1iZXIgLSBUaGUgJSBvZiBwcm9ncmVzcyB0aGUgcHJvZ3Jlc3MgYmFyIHNob3VsZCByZWZsZWN0LlxuICAgKiAgIGFjdGl2ZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHByb2dyZXNzIGJhciB0byByZWZsZWN0IGFjdGl2aXRpeS5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHByb2dyZXNzIGJhciB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBwcm9ncmVzcyBiYXIgZm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBXaGVyZSB0aGUgcHJvZ3Jlc3MgYmFyIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHsgcHJvZ3Jlc3M6IDAgfSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnByb2dyZXNzXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMYWJlbCBjb21wb25lbnQgdG8gYWRkIGluZm9ybWF0aW9uIHRvIGNlcnRhaW4gY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZWE6XG4gICAqICAgcHJvZ3Jlc3M6IG51bWJlciAtIFRoZSAlIG9mIHByb2dyZXNzIHRoZSBwcm9ncmVzcyBiYXIgc2hvdWxkIHJlZmxlY3QuXG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcHJvZ3Jlc3MgYmFyIHRvIHJlZmxlY3QgYWN0aXZpdGl5LlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcHJvZ3Jlc3MgYmFyIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHByb2dyZXNzIGJhciBmb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFdoZXJlIHRoZSBwcm9ncmVzcyBiYXIgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge3Byb2dyZXNzOiAwfSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8geyBwcm9ncmVzczogMCB9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiYmFyXCIgfSB9LCB7IHN0eWxlOiB7IHdpZHRoOiBwcm9wcy5wcm9ncmVzcyArIFwiJVwiIH0gfSwgW1xuICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwicHJvZ3Jlc3NcIiB9IH0sIFtwcm9wcy5wcm9ncmVzcyArIFwiJVwiXSlcbiAgICAgIF0pLFxuICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImxhYmVsXCIgfSB9LCBjb250ZW50KVxuICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuYWN0aXZlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYWN0aXZlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmF0dGFjaG1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQXR0YWNobWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hdHRhY2htZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBwcm9ncmVzc1wiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL3Byb2dyZXNzL2luZGV4LnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vc3RhdGlzdGljXCI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdmlld3MvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50fSBmcm9tIFwiaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgQ29sb3IsIEZsb2F0LCBTaXplfSBmcm9tIFwiZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQge2Rpdn0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuXG5leHBvcnQgbmFtZXNwYWNlIFN0YXRpc3RpYyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHRleHQ/OiBib29sZWFuO1xuICAgIGhvcml6b250YWw/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBjb2xvcj86IENvbG9yO1xuICAgIHNpemU/OiBTaXplO1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzdGF0aXN0aWMgY29tcG9uZW50IHRvIHNob3cgc3RhdGlzdGljcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGhvcml6b250YWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGF0aXN0aWMgdG8gZGlzcGxheSBob3Jpem9udGFsbHkuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGF0aXN0aWMgZm9yIGEgZGFyayBiYWNrZ3JvdW5kLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHN0YXRpc3RpYy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFdoZXJlIHRvIGZsb2F0IHRoZSBzdGF0aXN0aWMuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IHt9IG9mXG4gICAqICAgdmFsdWU6IFN0cmluZ3xWTm9kZSAtIFRoZSB2YWx1ZSBmb3IgdGhlIHN0YXRpc3RpYy5cbiAgICogICBsYWJlbDogU3RyaW5nfFZOb2RlIC0gVGhlIGxhYmVsIGZvciB0aGUgc3RhdGlzdGljLlxuICAgKiAgIGlzVGV4dD86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBzdGF0aXN0aWMgdmFsdWUgZm9yIHRleHQgYmFzZWQgdmFsdWVzLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIERPTUNvbnRlbnQ+KSA6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuICAgICAgc291cmNlcy5leHRyYXMkID0gc291cmNlcy5leHRyYXMkID8gc291cmNlcy5leHRyYXMkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcyxjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuc3RhdGlzdGljXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3RhdGlzdGljIGNvbXBvbmVudCB0byBzaG93IHN0YXRpc3RpY3MuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGhvcml6b250YWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGF0aXN0aWMgdG8gZGlzcGxheSBob3Jpem9udGFsbHkuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGF0aXN0aWMgZm9yIGEgZGFyayBiYWNrZ3JvdW5kLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHN0YXRpc3RpYy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFdoZXJlIHRvIGZsb2F0IHRoZSBzdGF0aXN0aWMuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IHt9IG9mXG4gICAqICAgdmFsdWU6IFN0cmluZ3xWTm9kZSAtIFRoZSB2YWx1ZSBmb3IgdGhlIHN0YXRpc3RpYy5cbiAgICogICBsYWJlbDogU3RyaW5nfFZOb2RlIC0gVGhlIGxhYmVsIGZvciB0aGUgc3RhdGlzdGljLlxuICAgKiAgIGlzVGV4dD86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBzdGF0aXN0aWMgdmFsdWUgZm9yIHRleHQgYmFzZWQgdmFsdWVzLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wc3xET01Db250ZW50ID0ge30sIGM6RE9NQ29udGVudCA9IFwiXCIsIGU6RE9NQ29udGVudCA9IFwiXCIpIDogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDpwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgbGV0IGxhYmVsID0gaXNET01Db250ZW50KHBPckMpID8gYyA6IGU7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9fSwgW1xuICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBwcm9wcy50ZXh0ID8gXCJ0ZXh0IHZhbHVlXCIgOiBcInZhbHVlXCJ9fSwgY29udGVudCksXG4gICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwibGFiZWxcIiB9fSwgbGFiZWwpXG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKSA6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWkgXCI7XG4gICAgaWYgKHByb3BzLmhvcml6b250YWwpIHsgXG4gICAgICAgY2xhc3NOYW1lICs9IFwiIGhvcml6b250YWxcIjtcbn1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHsgXG4gICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG59XG4gICAgaWYgKHR5cGVvZihwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHsgXG4gICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbn1cbiAgICBpZiAodHlwZW9mKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7IFxuICAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xufVxuICAgIGlmICh0eXBlb2YocHJvcHMuZmxvYXQpICE9PSBcInVuZGVmaW5lZFwiKSB7IFxuICAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG59XG4gICAgY2xhc3NOYW1lICs9IFwiIHN0YXRpc3RpY1wiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy92aWV3cy9zdGF0aXN0aWMvaW5kZXgudHMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIENvbmNhdFByb2R1Y2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jYXRQcm9kdWNlcihzdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IHN0cmVhbXM7XG4gICAgICAgIHRoaXMudHlwZSA9ICdjb25jYXQnO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgfVxuICAgIENvbmNhdFByb2R1Y2VyLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLnN0cmVhbXNbdGhpcy5pXS5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgQ29uY2F0UHJvZHVjZXIucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyZWFtcyA9IHRoaXMuc3RyZWFtcztcbiAgICAgICAgaWYgKHRoaXMuaSA8IHN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJlYW1zW3RoaXMuaV0uX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgfTtcbiAgICBDb25jYXRQcm9kdWNlci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBDb25jYXRQcm9kdWNlci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgQ29uY2F0UHJvZHVjZXIucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzdHJlYW1zID0gdGhpcy5zdHJlYW1zO1xuICAgICAgICBzdHJlYW1zW3RoaXMuaV0uX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgaWYgKCsrdGhpcy5pIDwgc3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbXNbdGhpcy5pXS5fYWRkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdS5fYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29uY2F0UHJvZHVjZXI7XG59KCkpO1xuLyoqXG4gKiBQdXRzIG9uZSBzdHJlYW0gYWZ0ZXIgdGhlIG90aGVyLiAqY29uY2F0KiBpcyBhIGZhY3RvcnkgdGhhdCB0YWtlcyBtdWx0aXBsZVxuICogc3RyZWFtcyBhcyBhcmd1bWVudHMsIGFuZCBzdGFydHMgdGhlIGBuKzFgLXRoIHN0cmVhbSBvbmx5IHdoZW4gdGhlIGBuYC10aFxuICogc3RyZWFtIGhhcyBjb21wbGV0ZWQuIEl0IGNvbmNhdGVuYXRlcyB0aG9zZSBzdHJlYW1zIHRvZ2V0aGVyLlxuICpcbiAqIE1hcmJsZSBkaWFncmFtOlxuICpcbiAqIGBgYHRleHRcbiAqIC0tMS0tMi0tLTMtLS00LXxcbiAqIC4uLi4uLi4uLi4uLi4uLi0tYS1iLWMtLWQtfFxuICogICAgICAgICAgIGNvbmNhdFxuICogLS0xLS0yLS0tMy0tLTQtLS1hLWItYy0tZC18XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgY29uY2F0IGZyb20gJ3hzdHJlYW0vZXh0cmEvY29uY2F0J1xuICpcbiAqIGNvbnN0IHN0cmVhbUEgPSB4cy5vZignYScsICdiJywgJ2MnKVxuICogY29uc3Qgc3RyZWFtQiA9IHhzLm9mKDEwLCAyMCwgMzApXG4gKiBjb25zdCBzdHJlYW1DID0geHMub2YoJ1gnLCAnWScsICdaJylcbiAqXG4gKiBjb25zdCBvdXRwdXRTdHJlYW0gPSBjb25jYXQoc3RyZWFtQSwgc3RyZWFtQiwgc3RyZWFtQylcbiAqXG4gKiBvdXRwdXRTdHJlYW0uYWRkTGlzdGVuZXIoe1xuICogICBuZXh0OiAoeCkgPT4gY29uc29sZS5sb2coeCksXG4gKiAgIGVycm9yOiAoZXJyKSA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29uY2F0IGNvbXBsZXRlZCcpLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBmYWN0b3J5IHRydWVcbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0xIEEgc3RyZWFtIHRvIGNvbmNhdGVuYXRlIHRvZ2V0aGVyIHdpdGggb3RoZXIgc3RyZWFtcy5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0yIEEgc3RyZWFtIHRvIGNvbmNhdGVuYXRlIHRvZ2V0aGVyIHdpdGggb3RoZXIgc3RyZWFtcy4gVHdvXG4gKiBvciBtb3JlIHN0cmVhbXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50cy5cbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqL1xuZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHZhciBzdHJlYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3RyZWFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGluZGV4XzEuU3RyZWFtKG5ldyBDb25jYXRQcm9kdWNlcihzdHJlYW1zKSk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjb25jYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3hzdHJlYW0vZXh0cmEvY29uY2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcbnZhciBGQ0lMID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGQ0lMKG91dCwgb3ApIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgRkNJTC5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLm91dC5fbih0KTtcbiAgICB9O1xuICAgIEZDSUwucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLm91dC5fZShlcnIpO1xuICAgIH07XG4gICAgRkNJTC5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3AubGVzcygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZDSUw7XG59KCkpO1xudmFyIEZsYXR0ZW5Db25jT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZsYXR0ZW5Db25jT3BlcmF0b3IoaW5zKSB7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmxhdHRlbkNvbmN1cnJlbnRseSc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMTsgLy8gbnVtYmVyIG9mIG91dGVycyBhbmQgaW5uZXJzIHRoYXQgaGF2ZSBub3QgeWV0IGVuZGVkXG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICB9XG4gICAgRmxhdHRlbkNvbmNPcGVyYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIEZsYXR0ZW5Db25jT3BlcmF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDE7XG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIEZsYXR0ZW5Db25jT3BlcmF0b3IucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHUuX2MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmxhdHRlbkNvbmNPcGVyYXRvci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHMuX2FkZChuZXcgRkNJTCh1LCB0aGlzKSk7XG4gICAgfTtcbiAgICBGbGF0dGVuQ29uY09wZXJhdG9yLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBGbGF0dGVuQ29uY09wZXJhdG9yLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sZXNzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRmxhdHRlbkNvbmNPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLkZsYXR0ZW5Db25jT3BlcmF0b3IgPSBGbGF0dGVuQ29uY09wZXJhdG9yO1xuLyoqXG4gKiBGbGF0dGVucyBhIFwic3RyZWFtIG9mIHN0cmVhbXNcIiwgaGFuZGxpbmcgbXVsdGlwbGUgY29uY3VycmVudCBuZXN0ZWQgc3RyZWFtc1xuICogc2ltdWx0YW5lb3VzbHkuXG4gKlxuICogSWYgdGhlIGlucHV0IHN0cmVhbSBpcyBhIHN0cmVhbSB0aGF0IGVtaXRzIHN0cmVhbXMsIHRoZW4gdGhpcyBvcGVyYXRvciB3aWxsXG4gKiByZXR1cm4gYW4gb3V0cHV0IHN0cmVhbSB3aGljaCBpcyBhIGZsYXQgc3RyZWFtOiBlbWl0cyByZWd1bGFyIGV2ZW50cy4gVGhlXG4gKiBmbGF0dGVuaW5nIGhhcHBlbnMgY29uY3VycmVudGx5LiBJdCB3b3JrcyBsaWtlIHRoaXM6IHdoZW4gdGhlIGlucHV0IHN0cmVhbVxuICogZW1pdHMgYSBuZXN0ZWQgc3RyZWFtLCAqZmxhdHRlbkNvbmN1cnJlbnRseSogd2lsbCBzdGFydCBpbWl0YXRpbmcgdGhhdFxuICogbmVzdGVkIG9uZS4gV2hlbiB0aGUgbmV4dCBuZXN0ZWQgc3RyZWFtIGlzIGVtaXR0ZWQgb24gdGhlIGlucHV0IHN0cmVhbSxcbiAqICpmbGF0dGVuQ29uY3VycmVudGx5KiB3aWxsIGFsc28gaW1pdGF0ZSB0aGF0IG5ldyBvbmUsIGJ1dCB3aWxsIGNvbnRpbnVlIHRvXG4gKiBpbWl0YXRlIHRoZSBwcmV2aW91cyBuZXN0ZWQgc3RyZWFtcyBhcyB3ZWxsLlxuICpcbiAqIE1hcmJsZSBkaWFncmFtOlxuICpcbiAqIGBgYHRleHRcbiAqIC0tKy0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLVxuICogICBcXCAgICAgICAgXFxcbiAqICAgIFxcICAgICAgIC0tLS0xLS0tLTItLS0zLS1cbiAqICAgIC0tYS0tYi0tLS1jLS0tLWQtLS0tLS0tLVxuICogICAgIGZsYXR0ZW5Db25jdXJyZW50bHlcbiAqIC0tLS0tYS0tYi0tLS1jLTEtLWQtMi0tLTMtLVxuICogYGBgXG4gKlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ29uY3VycmVudGx5KGlucykge1xuICAgIHJldHVybiBuZXcgaW5kZXhfMS5TdHJlYW0obmV3IEZsYXR0ZW5Db25jT3BlcmF0b3IoaW5zKSk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmbGF0dGVuQ29uY3VycmVudGx5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmxhdHRlbkNvbmN1cnJlbnRseS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHN0cmVhbS9leHRyYS9mbGF0dGVuQ29uY3VycmVudGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==