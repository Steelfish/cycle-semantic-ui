/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/cycle-semantic-ui/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 219);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var symbol_observable_1 = __webpack_require__(171);
var NO = {};
exports.NO = NO;
function noop() { }
function cp(a) {
    var l = a.length;
    var b = Array(l);
    for (var i = 0; i < l; ++i)
        b[i] = a[i];
    return b;
}
function and(f1, f2) {
    return function andFn(t) {
        return f1(t) && f2(t);
    };
}
function _try(c, t, u) {
    try {
        return c.f(t);
    }
    catch (e) {
        u._e(e);
        return NO;
    }
}
var NO_IL = {
    _n: noop,
    _e: noop,
    _c: noop,
};
exports.NO_IL = NO_IL;
// mutates the input
function internalizeProducer(producer) {
    producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
    };
    producer._stop = producer.stop;
}
var StreamSub = (function () {
    function StreamSub(_stream, _listener) {
        this._stream = _stream;
        this._listener = _listener;
    }
    StreamSub.prototype.unsubscribe = function () {
        this._stream.removeListener(this._listener);
    };
    return StreamSub;
}());
var Observer = (function () {
    function Observer(_listener) {
        this._listener = _listener;
    }
    Observer.prototype.next = function (value) {
        this._listener._n(value);
    };
    Observer.prototype.error = function (err) {
        this._listener._e(err);
    };
    Observer.prototype.complete = function () {
        this._listener._c();
    };
    return Observer;
}());
var FromObservable = (function () {
    function FromObservable(observable) {
        this.type = 'fromObservable';
        this.ins = observable;
        this.active = false;
    }
    FromObservable.prototype._start = function (out) {
        this.out = out;
        this.active = true;
        this._sub = this.ins.subscribe(new Observer(out));
        if (!this.active)
            this._sub.unsubscribe();
    };
    FromObservable.prototype._stop = function () {
        if (this._sub)
            this._sub.unsubscribe();
        this.active = false;
    };
    return FromObservable;
}());
var Merge = (function () {
    function Merge(insArr) {
        this.type = 'merge';
        this.insArr = insArr;
        this.out = NO;
        this.ac = 0;
    }
    Merge.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var L = s.length;
        this.ac = L;
        for (var i = 0; i < L; i++)
            s[i]._add(this);
    };
    Merge.prototype._stop = function () {
        var s = this.insArr;
        var L = s.length;
        for (var i = 0; i < L; i++)
            s[i]._remove(this);
        this.out = NO;
    };
    Merge.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    Merge.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Merge.prototype._c = function () {
        if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
                return;
            u._c();
        }
    };
    return Merge;
}());
var CombineListener = (function () {
    function CombineListener(i, out, p) {
        this.i = i;
        this.out = out;
        this.p = p;
        p.ils.push(this);
    }
    CombineListener.prototype._n = function (t) {
        var p = this.p, out = this.out;
        if (out === NO)
            return;
        if (p.up(t, this.i))
            out._n(p.vals);
    };
    CombineListener.prototype._e = function (err) {
        var out = this.out;
        if (out === NO)
            return;
        out._e(err);
    };
    CombineListener.prototype._c = function () {
        var p = this.p;
        if (p.out === NO)
            return;
        if (--p.Nc === 0)
            p.out._c();
    };
    return CombineListener;
}());
var Combine = (function () {
    function Combine(insArr) {
        this.type = 'combine';
        this.insArr = insArr;
        this.out = NO;
        this.ils = [];
        this.Nc = this.Nn = 0;
        this.vals = [];
    }
    Combine.prototype.up = function (t, i) {
        var v = this.vals[i];
        var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
        this.vals[i] = t;
        return Nn === 0;
    };
    Combine.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var n = this.Nc = this.Nn = s.length;
        var vals = this.vals = new Array(n);
        if (n === 0) {
            out._n([]);
            out._c();
        }
        else {
            for (var i = 0; i < n; i++) {
                vals[i] = NO;
                s[i]._add(new CombineListener(i, out, this));
            }
        }
    };
    Combine.prototype._stop = function () {
        var s = this.insArr;
        var n = s.length;
        var ils = this.ils;
        for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
        this.out = NO;
        this.ils = [];
        this.vals = [];
    };
    return Combine;
}());
var FromArray = (function () {
    function FromArray(a) {
        this.type = 'fromArray';
        this.a = a;
    }
    FromArray.prototype._start = function (out) {
        var a = this.a;
        for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
        out._c();
    };
    FromArray.prototype._stop = function () {
    };
    return FromArray;
}());
var FromPromise = (function () {
    function FromPromise(p) {
        this.type = 'fromPromise';
        this.on = false;
        this.p = p;
    }
    FromPromise.prototype._start = function (out) {
        var prod = this;
        this.on = true;
        this.p.then(function (v) {
            if (prod.on) {
                out._n(v);
                out._c();
            }
        }, function (e) {
            out._e(e);
        }).then(noop, function (err) {
            setTimeout(function () { throw err; });
        });
    };
    FromPromise.prototype._stop = function () {
        this.on = false;
    };
    return FromPromise;
}());
var Periodic = (function () {
    function Periodic(period) {
        this.type = 'periodic';
        this.period = period;
        this.intervalID = -1;
        this.i = 0;
    }
    Periodic.prototype._start = function (out) {
        var self = this;
        function intervalHandler() { out._n(self.i++); }
        this.intervalID = setInterval(intervalHandler, this.period);
    };
    Periodic.prototype._stop = function () {
        if (this.intervalID !== -1)
            clearInterval(this.intervalID);
        this.intervalID = -1;
        this.i = 0;
    };
    return Periodic;
}());
var Debug = (function () {
    function Debug(ins, arg) {
        this.type = 'debug';
        this.ins = ins;
        this.out = NO;
        this.s = noop;
        this.l = '';
        if (typeof arg === 'string')
            this.l = arg;
        else if (typeof arg === 'function')
            this.s = arg;
    }
    Debug.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Debug.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Debug.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var s = this.s, l = this.l;
        if (s !== noop) {
            try {
                s(t);
            }
            catch (e) {
                u._e(e);
            }
        }
        else if (l)
            console.log(l + ':', t);
        else
            console.log(t);
        u._n(t);
    };
    Debug.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Debug.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Debug;
}());
var Drop = (function () {
    function Drop(max, ins) {
        this.type = 'drop';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.dropped = 0;
    }
    Drop.prototype._start = function (out) {
        this.out = out;
        this.dropped = 0;
        this.ins._add(this);
    };
    Drop.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Drop.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        if (this.dropped++ >= this.max)
            u._n(t);
    };
    Drop.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Drop.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Drop;
}());
var EndWhenListener = (function () {
    function EndWhenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    EndWhenListener.prototype._n = function () {
        this.op.end();
    };
    EndWhenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    EndWhenListener.prototype._c = function () {
        this.op.end();
    };
    return EndWhenListener;
}());
var EndWhen = (function () {
    function EndWhen(o, ins) {
        this.type = 'endWhen';
        this.ins = ins;
        this.out = NO;
        this.o = o;
        this.oil = NO_IL;
    }
    EndWhen.prototype._start = function (out) {
        this.out = out;
        this.o._add(this.oil = new EndWhenListener(out, this));
        this.ins._add(this);
    };
    EndWhen.prototype._stop = function () {
        this.ins._remove(this);
        this.o._remove(this.oil);
        this.out = NO;
        this.oil = NO_IL;
    };
    EndWhen.prototype.end = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    EndWhen.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    EndWhen.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    EndWhen.prototype._c = function () {
        this.end();
    };
    return EndWhen;
}());
var Filter = (function () {
    function Filter(passes, ins) {
        this.type = 'filter';
        this.ins = ins;
        this.out = NO;
        this.f = passes;
    }
    Filter.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Filter.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Filter.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO || !r)
            return;
        u._n(t);
    };
    Filter.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Filter.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Filter;
}());
var FlattenListener = (function () {
    function FlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    FlattenListener.prototype._n = function (t) {
        this.out._n(t);
    };
    FlattenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    FlattenListener.prototype._c = function () {
        this.op.inner = NO;
        this.op.less();
    };
    return FlattenListener;
}());
var Flatten = (function () {
    function Flatten(ins) {
        this.type = 'flatten';
        this.ins = ins;
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    }
    Flatten.prototype._start = function (out) {
        this.out = out;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
        this.ins._add(this);
    };
    Flatten.prototype._stop = function () {
        this.ins._remove(this);
        if (this.inner !== NO)
            this.inner._remove(this.il);
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    };
    Flatten.prototype.less = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (!this.open && this.inner === NO)
            u._c();
    };
    Flatten.prototype._n = function (s) {
        var u = this.out;
        if (u === NO)
            return;
        var _a = this, inner = _a.inner, il = _a.il;
        if (inner !== NO && il !== NO_IL)
            inner._remove(il);
        (this.inner = s)._add(this.il = new FlattenListener(u, this));
    };
    Flatten.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Flatten.prototype._c = function () {
        this.open = false;
        this.less();
    };
    return Flatten;
}());
var Fold = (function () {
    function Fold(f, seed, ins) {
        var _this = this;
        this.type = 'fold';
        this.ins = ins;
        this.out = NO;
        this.f = function (t) { return f(_this.acc, t); };
        this.acc = this.seed = seed;
    }
    Fold.prototype._start = function (out) {
        this.out = out;
        this.acc = this.seed;
        out._n(this.acc);
        this.ins._add(this);
    };
    Fold.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.acc = this.seed;
    };
    Fold.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(this.acc = r);
    };
    Fold.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Fold.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Fold;
}());
var Last = (function () {
    function Last(ins) {
        this.type = 'last';
        this.ins = ins;
        this.out = NO;
        this.has = false;
        this.val = NO;
    }
    Last.prototype._start = function (out) {
        this.out = out;
        this.has = false;
        this.ins._add(this);
    };
    Last.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.val = NO;
    };
    Last.prototype._n = function (t) {
        this.has = true;
        this.val = t;
    };
    Last.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Last.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (this.has) {
            u._n(this.val);
            u._c();
        }
        else
            u._e(new Error('last() failed because input stream completed'));
    };
    return Last;
}());
var MapFlattenListener = (function () {
    function MapFlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    MapFlattenListener.prototype._n = function (r) {
        this.out._n(r);
    };
    MapFlattenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    MapFlattenListener.prototype._c = function () {
        this.op.inner = NO;
        this.op.less();
    };
    return MapFlattenListener;
}());
var MapFlatten = (function () {
    function MapFlatten(mapOp) {
        this.type = mapOp.type + "+flatten";
        this.ins = mapOp.ins;
        this.out = NO;
        this.mapOp = mapOp;
        this.inner = NO;
        this.il = NO_IL;
        this.open = true;
    }
    MapFlatten.prototype._start = function (out) {
        this.out = out;
        this.inner = NO;
        this.il = NO_IL;
        this.open = true;
        this.mapOp.ins._add(this);
    };
    MapFlatten.prototype._stop = function () {
        this.mapOp.ins._remove(this);
        if (this.inner !== NO)
            this.inner._remove(this.il);
        this.out = NO;
        this.inner = NO;
        this.il = NO_IL;
    };
    MapFlatten.prototype.less = function () {
        if (!this.open && this.inner === NO) {
            var u = this.out;
            if (u === NO)
                return;
            u._c();
        }
    };
    MapFlatten.prototype._n = function (v) {
        var u = this.out;
        if (u === NO)
            return;
        var _a = this, inner = _a.inner, il = _a.il;
        var s = _try(this.mapOp, v, u);
        if (s === NO)
            return;
        if (inner !== NO && il !== NO_IL)
            inner._remove(il);
        (this.inner = s)._add(this.il = new MapFlattenListener(u, this));
    };
    MapFlatten.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    MapFlatten.prototype._c = function () {
        this.open = false;
        this.less();
    };
    return MapFlatten;
}());
var MapOp = (function () {
    function MapOp(project, ins) {
        this.type = 'map';
        this.ins = ins;
        this.out = NO;
        this.f = project;
    }
    MapOp.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    MapOp.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    MapOp.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(r);
    };
    MapOp.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    MapOp.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return MapOp;
}());
var FilterMapFusion = (function (_super) {
    __extends(FilterMapFusion, _super);
    function FilterMapFusion(passes, project, ins) {
        var _this = _super.call(this, project, ins) || this;
        _this.type = 'filter+map';
        _this.passes = passes;
        return _this;
    }
    FilterMapFusion.prototype._n = function (t) {
        if (!this.passes(t))
            return;
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(r);
    };
    return FilterMapFusion;
}(MapOp));
var Remember = (function () {
    function Remember(ins) {
        this.type = 'remember';
        this.ins = ins;
        this.out = NO;
    }
    Remember.prototype._start = function (out) {
        this.out = out;
        this.ins._add(out);
    };
    Remember.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return Remember;
}());
var ReplaceError = (function () {
    function ReplaceError(replacer, ins) {
        this.type = 'replaceError';
        this.ins = ins;
        this.out = NO;
        this.f = replacer;
    }
    ReplaceError.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    ReplaceError.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    ReplaceError.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    ReplaceError.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
        }
        catch (e) {
            u._e(e);
        }
    };
    ReplaceError.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return ReplaceError;
}());
var StartWith = (function () {
    function StartWith(ins, val) {
        this.type = 'startWith';
        this.ins = ins;
        this.out = NO;
        this.val = val;
    }
    StartWith.prototype._start = function (out) {
        this.out = out;
        this.out._n(this.val);
        this.ins._add(out);
    };
    StartWith.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return StartWith;
}());
var Take = (function () {
    function Take(max, ins) {
        this.type = 'take';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.taken = 0;
    }
    Take.prototype._start = function (out) {
        this.out = out;
        this.taken = 0;
        if (this.max <= 0)
            out._c();
        else
            this.ins._add(this);
    };
    Take.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Take.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var m = ++this.taken;
        if (m < this.max)
            u._n(t);
        else if (m === this.max) {
            u._n(t);
            u._c();
        }
    };
    Take.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Take.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Take;
}());
var Stream = (function () {
    function Stream(producer) {
        this._prod = producer || NO;
        this._ils = [];
        this._stopID = NO;
        this._dl = NO;
        this._d = false;
        this._target = NO;
        this._err = NO;
    }
    Stream.prototype._n = function (t) {
        var a = this._ils;
        var L = a.length;
        if (this._d)
            this._dl._n(t);
        if (L == 1)
            a[0]._n(t);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._n(t);
        }
    };
    Stream.prototype._e = function (err) {
        if (this._err !== NO)
            return;
        this._err = err;
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._e(err);
        if (L == 1)
            a[0]._e(err);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._e(err);
        }
        if (!this._d && L == 0)
            throw this._err;
    };
    Stream.prototype._c = function () {
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._c();
        if (L == 1)
            a[0]._c();
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._c();
        }
    };
    Stream.prototype._x = function () {
        if (this._ils.length === 0)
            return;
        if (this._prod !== NO)
            this._prod._stop();
        this._err = NO;
        this._ils = [];
    };
    Stream.prototype._stopNow = function () {
        // WARNING: code that calls this method should
        // first check if this._prod is valid (not `NO`)
        this._prod._stop();
        this._err = NO;
        this._stopID = NO;
    };
    Stream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1)
            return;
        if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    Stream.prototype._remove = function (il) {
        var _this = this;
        var ta = this._target;
        if (ta !== NO)
            return ta._remove(il);
        var a = this._ils;
        var i = a.indexOf(il);
        if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
                this._err = NO;
                this._stopID = setTimeout(function () { return _this._stopNow(); });
            }
            else if (a.length === 1) {
                this._pruneCycles();
            }
        }
    };
    // If all paths stemming from `this` stream eventually end at `this`
    // stream, then we remove the single listener of `this` stream, to
    // force it to end its execution and dispose resources. This method
    // assumes as a precondition that this._ils has just one listener.
    Stream.prototype._pruneCycles = function () {
        if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
    };
    // Checks whether *there is no* path starting from `x` that leads to an end
    // listener (sink) in the stream graph, following edges A->B where B is a
    // listener of A. This means these paths constitute a cycle somehow. Is given
    // a trace of all visited nodes so far.
    Stream.prototype._hasNoSinks = function (x, trace) {
        if (trace.indexOf(x) !== -1)
            return true;
        else if (x.out === this)
            return true;
        else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
        else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
                if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                    return false;
            return true;
        }
        else
            return false;
    };
    Stream.prototype.ctor = function () {
        return this instanceof MemoryStream ? MemoryStream : Stream;
    };
    /**
     * Adds a Listener to the Stream.
     *
     * @param {Listener} listener
     */
    Stream.prototype.addListener = function (listener) {
        listener._n = listener.next || noop;
        listener._e = listener.error || noop;
        listener._c = listener.complete || noop;
        this._add(listener);
    };
    /**
     * Removes a Listener from the Stream, assuming the Listener was added to it.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.removeListener = function (listener) {
        this._remove(listener);
    };
    /**
     * Adds a Listener to the Stream returning a Subscription to remove that
     * listener.
     *
     * @param {Listener} listener
     * @returns {Subscription}
     */
    Stream.prototype.subscribe = function (listener) {
        this.addListener(listener);
        return new StreamSub(this, listener);
    };
    /**
     * Add interop between most.js and RxJS 5
     *
     * @returns {Stream}
     */
    Stream.prototype[symbol_observable_1.default] = function () {
        return this;
    };
    /**
     * Creates a new Stream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {Stream}
     */
    Stream.create = function (producer) {
        if (producer) {
            if (typeof producer.start !== 'function'
                || typeof producer.stop !== 'function')
                throw new Error('producer requires both start and stop functions');
            internalizeProducer(producer); // mutates the input
        }
        return new Stream(producer);
    };
    /**
     * Creates a new MemoryStream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {MemoryStream}
     */
    Stream.createWithMemory = function (producer) {
        if (producer)
            internalizeProducer(producer); // mutates the input
        return new MemoryStream(producer);
    };
    /**
     * Creates a Stream that does nothing when started. It never emits any event.
     *
     * Marble diagram:
     *
     * ```text
     *          never
     * -----------------------
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.never = function () {
        return new Stream({ _start: noop, _stop: noop });
    };
    /**
     * Creates a Stream that immediately emits the "complete" notification when
     * started, and that's it.
     *
     * Marble diagram:
     *
     * ```text
     * empty
     * -|
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.empty = function () {
        return new Stream({
            _start: function (il) { il._c(); },
            _stop: noop,
        });
    };
    /**
     * Creates a Stream that immediately emits an "error" notification with the
     * value you passed as the `error` argument when the stream starts, and that's
     * it.
     *
     * Marble diagram:
     *
     * ```text
     * throw(X)
     * -X
     * ```
     *
     * @factory true
     * @param error The error event to emit on the created stream.
     * @return {Stream}
     */
    Stream.throw = function (error) {
        return new Stream({
            _start: function (il) { il._e(error); },
            _stop: noop,
        });
    };
    /**
     * Creates a stream from an Array, Promise, or an Observable.
     *
     * @factory true
     * @param {Array|Promise|Observable} input The input to make a stream from.
     * @return {Stream}
     */
    Stream.from = function (input) {
        if (typeof input[symbol_observable_1.default] === 'function')
            return Stream.fromObservable(input);
        else if (typeof input.then === 'function')
            return Stream.fromPromise(input);
        else if (Array.isArray(input))
            return Stream.fromArray(input);
        throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    };
    /**
     * Creates a Stream that immediately emits the arguments that you give to
     * *of*, then completes.
     *
     * Marble diagram:
     *
     * ```text
     * of(1,2,3)
     * 123|
     * ```
     *
     * @factory true
     * @param a The first value you want to emit as an event on the stream.
     * @param b The second value you want to emit as an event on the stream. One
     * or more of these values may be given as arguments.
     * @return {Stream}
     */
    Stream.of = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        return Stream.fromArray(items);
    };
    /**
     * Converts an array to a stream. The returned stream will emit synchronously
     * all the items in the array, and then complete.
     *
     * Marble diagram:
     *
     * ```text
     * fromArray([1,2,3])
     * 123|
     * ```
     *
     * @factory true
     * @param {Array} array The array to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromArray = function (array) {
        return new Stream(new FromArray(array));
    };
    /**
     * Converts a promise to a stream. The returned stream will emit the resolved
     * value of the promise, and then complete. However, if the promise is
     * rejected, the stream will emit the corresponding error.
     *
     * Marble diagram:
     *
     * ```text
     * fromPromise( ----42 )
     * -----------------42|
     * ```
     *
     * @factory true
     * @param {Promise} promise The promise to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromPromise = function (promise) {
        return new Stream(new FromPromise(promise));
    };
    /**
     * Converts an Observable into a Stream.
     *
     * @factory true
     * @param {any} observable The observable to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromObservable = function (obs) {
        if (obs.endWhen)
            return obs;
        return new Stream(new FromObservable(obs));
    };
    /**
     * Creates a stream that periodically emits incremental numbers, every
     * `period` milliseconds.
     *
     * Marble diagram:
     *
     * ```text
     *     periodic(1000)
     * ---0---1---2---3---4---...
     * ```
     *
     * @factory true
     * @param {number} period The interval in milliseconds to use as a rate of
     * emission.
     * @return {Stream}
     */
    Stream.periodic = function (period) {
        return new Stream(new Periodic(period));
    };
    Stream.prototype._map = function (project) {
        var p = this._prod;
        var ctor = this.ctor();
        if (p instanceof Filter)
            return new ctor(new FilterMapFusion(p.f, project, p.ins));
        return new ctor(new MapOp(project, this));
    };
    /**
     * Transforms each event from the input Stream through a `project` function,
     * to get a Stream that emits those transformed events.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7------
     *    map(i => i * 10)
     * --10--30-50----70-----
     * ```
     *
     * @param {Function} project A function of type `(t: T) => U` that takes event
     * `t` of type `T` from the input Stream and produces an event of type `U`, to
     * be emitted on the output Stream.
     * @return {Stream}
     */
    Stream.prototype.map = function (project) {
        return this._map(project);
    };
    /**
     * It's like `map`, but transforms each input event to always the same
     * constant value on the output Stream.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7-----
     *       mapTo(10)
     * --10--10-10----10----
     * ```
     *
     * @param projectedValue A value to emit on the output Stream whenever the
     * input Stream emits any value.
     * @return {Stream}
     */
    Stream.prototype.mapTo = function (projectedValue) {
        var s = this.map(function () { return projectedValue; });
        var op = s._prod;
        op.type = op.type.replace('map', 'mapTo');
        return s;
    };
    /**
     * Only allows events that pass the test given by the `passes` argument.
     *
     * Each event from the input stream is given to the `passes` function. If the
     * function returns `true`, the event is forwarded to the output stream,
     * otherwise it is ignored and not forwarded.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2--3-----4-----5---6--7-8--
     *     filter(i => i % 2 === 0)
     * ------2--------4---------6----8--
     * ```
     *
     * @param {Function} passes A function of type `(t: T) +> boolean` that takes
     * an event from the input stream and checks if it passes, by returning a
     * boolean.
     * @return {Stream}
     */
    Stream.prototype.filter = function (passes) {
        var p = this._prod;
        if (p instanceof Filter)
            return new Stream(new Filter(and(p.f, passes), p.ins));
        return new Stream(new Filter(passes, this));
    };
    /**
     * Lets the first `amount` many events from the input stream pass to the
     * output stream, then makes the output stream complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *    take(3)
     * --a---b--c|
     * ```
     *
     * @param {number} amount How many events to allow from the input stream
     * before completing the output stream.
     * @return {Stream}
     */
    Stream.prototype.take = function (amount) {
        return new (this.ctor())(new Take(amount, this));
    };
    /**
     * Ignores the first `amount` many events from the input stream, and then
     * after that starts forwarding events from the input stream to the output
     * stream.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *       drop(3)
     * --------------d---e--
     * ```
     *
     * @param {number} amount How many events to ignore from the input stream
     * before forwarding all events from the input stream to the output stream.
     * @return {Stream}
     */
    Stream.prototype.drop = function (amount) {
        return new Stream(new Drop(amount, this));
    };
    /**
     * When the input stream completes, the output stream will emit the last event
     * emitted by the input stream, and then will also complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c--d----|
     *       last()
     * -----------------d|
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.last = function () {
        return new Stream(new Last(this));
    };
    /**
     * Prepends the given `initial` value to the sequence of events emitted by the
     * input stream. The returned stream is a MemoryStream, which means it is
     * already `remember()`'d.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3---
     *   startWith(0)
     * 0--1---2-----3---
     * ```
     *
     * @param initial The value or event to prepend.
     * @return {MemoryStream}
     */
    Stream.prototype.startWith = function (initial) {
        return new MemoryStream(new StartWith(this, initial));
    };
    /**
     * Uses another stream to determine when to complete the current stream.
     *
     * When the given `other` stream emits an event or completes, the output
     * stream will complete. Before that happens, the output stream will behaves
     * like the input stream.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3--4----5----6---
     *   endWhen( --------a--b--| )
     * ---1---2-----3--4--|
     * ```
     *
     * @param other Some other stream that is used to know when should the output
     * stream of this operator complete.
     * @return {Stream}
     */
    Stream.prototype.endWhen = function (other) {
        return new (this.ctor())(new EndWhen(other, this));
    };
    /**
     * "Folds" the stream onto itself.
     *
     * Combines events from the past throughout
     * the entire execution of the input stream, allowing you to accumulate them
     * together. It's essentially like `Array.prototype.reduce`. The returned
     * stream is a MemoryStream, which means it is already `remember()`'d.
     *
     * The output stream starts by emitting the `seed` which you give as argument.
     * Then, when an event happens on the input stream, it is combined with that
     * seed value through the `accumulate` function, and the output value is
     * emitted on the output stream. `fold` remembers that output value as `acc`
     * ("accumulator"), and then when a new input event `t` happens, `acc` will be
     * combined with that to produce the new `acc` and so forth.
     *
     * Marble diagram:
     *
     * ```text
     * ------1-----1--2----1----1------
     *   fold((acc, x) => acc + x, 3)
     * 3-----4-----5--7----8----9------
     * ```
     *
     * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that
     * takes the previous accumulated value `acc` and the incoming event from the
     * input stream and produces the new accumulated value.
     * @param seed The initial accumulated value, of type `R`.
     * @return {MemoryStream}
     */
    Stream.prototype.fold = function (accumulate, seed) {
        return new MemoryStream(new Fold(accumulate, seed, this));
    };
    /**
     * Replaces an error with another stream.
     *
     * When (and if) an error happens on the input stream, instead of forwarding
     * that error to the output stream, *replaceError* will call the `replace`
     * function which returns the stream that the output stream will replicate.
     * And, in case that new stream also emits an error, `replace` will be called
     * again to get another stream to start replicating.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2-----3--4-----X
     *   replaceError( () => --10--| )
     * --1---2-----3--4--------10--|
     * ```
     *
     * @param {Function} replace A function of type `(err) => Stream` that takes
     * the error that occurred on the input stream or on the previous replacement
     * stream and returns a new stream. The output stream will behave like the
     * stream that this function returns.
     * @return {Stream}
     */
    Stream.prototype.replaceError = function (replace) {
        return new (this.ctor())(new ReplaceError(replace, this));
    };
    /**
     * Flattens a "stream of streams", handling only one nested stream at a time
     * (no concurrency).
     *
     * If the input stream is a stream that emits streams, then this operator will
     * return an output stream which is a flat stream: emits regular events. The
     * flattening happens without concurrency. It works like this: when the input
     * stream emits a nested stream, *flatten* will start imitating that nested
     * one. However, as soon as the next nested stream is emitted on the input
     * stream, *flatten* will forget the previous nested one it was imitating, and
     * will start imitating the new nested one.
     *
     * Marble diagram:
     *
     * ```text
     * --+--------+---------------
     *   \        \
     *    \       ----1----2---3--
     *    --a--b----c----d--------
     *           flatten
     * -----a--b------1----2---3--
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.flatten = function () {
        var p = this._prod;
        return new Stream(p instanceof MapOp && !(p instanceof FilterMapFusion) ?
            new MapFlatten(p) :
            new Flatten(this));
    };
    /**
     * Passes the input stream to a custom operator, to produce an output stream.
     *
     * *compose* is a handy way of using an existing function in a chained style.
     * Instead of writing `outStream = f(inStream)` you can write
     * `outStream = inStream.compose(f)`.
     *
     * @param {function} operator A function that takes a stream as input and
     * returns a stream as well.
     * @return {Stream}
     */
    Stream.prototype.compose = function (operator) {
        return operator(this);
    };
    /**
     * Returns an output stream that behaves like the input stream, but also
     * remembers the most recent event that happens on the input stream, so that a
     * newly added listener will immediately receive that memorised event.
     *
     * @return {MemoryStream}
     */
    Stream.prototype.remember = function () {
        return new MemoryStream(new Remember(this));
    };
    /**
     * Returns an output stream that identically behaves like the input stream,
     * but also runs a `spy` function fo each event, to help you debug your app.
     *
     * *debug* takes a `spy` function as argument, and runs that for each event
     * happening on the input stream. If you don't provide the `spy` argument,
     * then *debug* will just `console.log` each event. This helps you to
     * understand the flow of events through some operator chain.
     *
     * Please note that if the output stream has no listeners, then it will not
     * start, which means `spy` will never run because no actual event happens in
     * that case.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3-----4--
     *         debug
     * --1----2-----3-----4--
     * ```
     *
     * @param {function} labelOrSpy A string to use as the label when printing
     * debug information on the console, or a 'spy' function that takes an event
     * as argument, and does not need to return anything.
     * @return {Stream}
     */
    Stream.prototype.debug = function (labelOrSpy) {
        return new (this.ctor())(new Debug(this, labelOrSpy));
    };
    /**
     * *imitate* changes this current Stream to emit the same events that the
     * `other` given Stream does. This method returns nothing.
     *
     * This method exists to allow one thing: **circular dependency of streams**.
     * For instance, let's imagine that for some reason you need to create a
     * circular dependency where stream `first$` depends on stream `second$`
     * which in turn depends on `first$`:
     *
     * <!-- skip-example -->
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var first$ = second$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * ```
     *
     * However, that is invalid JavaScript, because `second$` is undefined
     * on the first line. This is how *imitate* can help solve it:
     *
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var secondProxy$ = xs.create();
     * var first$ = secondProxy$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * secondProxy$.imitate(second$);
     * ```
     *
     * We create `secondProxy$` before the others, so it can be used in the
     * declaration of `first$`. Then, after both `first$` and `second$` are
     * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell
     * that they are "the same". `imitate` will not trigger the start of any
     * stream, it just binds `secondProxy$` and `second$` together.
     *
     * The following is an example where `imitate()` is important in Cycle.js
     * applications. A parent component contains some child components. A child
     * has an action stream which is given to the parent to define its state:
     *
     * <!-- skip-example -->
     * ```js
     * const childActionProxy$ = xs.create();
     * const parent = Parent({...sources, childAction$: childActionProxy$});
     * const childAction$ = parent.state$.map(s => s.child.action$).flatten();
     * childActionProxy$.imitate(childAction$);
     * ```
     *
     * Note, though, that **`imitate()` does not support MemoryStreams**. If we
     * would attempt to imitate a MemoryStream in a circular dependency, we would
     * either get a race condition (where the symptom would be "nothing happens")
     * or an infinite cyclic emission of values. It's useful to think about
     * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to
     * define a spreadsheet cell `A1` with a formula that depends on `B1` and
     * cell `B1` defined with a formula that depends on `A1`.
     *
     * If you find yourself wanting to use `imitate()` with a
     * MemoryStream, you should rework your code around `imitate()` to use a
     * Stream instead. Look for the stream in the circular dependency that
     * represents an event stream, and that would be a candidate for creating a
     * proxy Stream which then imitates the target Stream.
     *
     * @param {Stream} target The other stream to imitate on the current one. Must
     * not be a MemoryStream.
     */
    Stream.prototype.imitate = function (target) {
        if (target instanceof MemoryStream)
            throw new Error('A MemoryStream was given to imitate(), but it only ' +
                'supports a Stream. Read more about this restriction here: ' +
                'https://github.com/staltz/xstream#faq');
        this._target = target;
        for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
        this._ils = [];
    };
    /**
     * Forces the Stream to emit the given value to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param value The "next" value you want to broadcast to all listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendNext = function (value) {
        this._n(value);
    };
    /**
     * Forces the Stream to emit the given error to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param {any} error The error you want to broadcast to all the listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendError = function (error) {
        this._e(error);
    };
    /**
     * Forces the Stream to emit the "completed" event to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     */
    Stream.prototype.shamefullySendComplete = function () {
        this._c();
    };
    /**
     * Adds a "debug" listener to the stream. There can only be one debug
     * listener, that's why this is 'setDebugListener'. To remove the debug
     * listener, just call setDebugListener(null).
     *
     * A debug listener is like any other listener. The only difference is that a
     * debug listener is "stealthy": its presence/absence does not trigger the
     * start/stop of the stream (or the producer inside the stream). This is
     * useful so you can inspect what is going on without changing the behavior
     * of the program. If you have an idle stream and you add a normal listener to
     * it, the stream will start executing. But if you set a debug listener on an
     * idle stream, it won't start executing (not until the first normal listener
     * is added).
     *
     * As the name indicates, we don't recommend using this method to build app
     * logic. In fact, in most cases the debug operator works just fine. Only use
     * this one if you know what you're doing.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.setDebugListener = function (listener) {
        if (!listener) {
            this._d = false;
            this._dl = NO;
        }
        else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
        }
    };
    return Stream;
}());
/**
 * Blends multiple streams together, emitting events from all of them
 * concurrently.
 *
 * *merge* takes multiple streams as arguments, and creates a stream that
 * behaves like each of the argument streams, in parallel.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2-----3--------4---
 * ----a-----b----c---d------
 *            merge
 * --1-a--2--b--3-c---d--4---
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to merge together with other streams.
 * @param {Stream} stream2 A stream to merge together with other streams. Two
 * or more streams may be given as arguments.
 * @return {Stream}
 */
Stream.merge = function merge() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new Stream(new Merge(streams));
};
/**
 * Combines multiple input streams together to return a stream whose events
 * are arrays that collect the latest events from each input stream.
 *
 * *combine* internally remembers the most recent event from each of the input
 * streams. When any of the input streams emits an event, that event together
 * with all the other saved events are combined into an array. That array will
 * be emitted on the output stream. It's essentially a way of joining together
 * the events from multiple streams.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2-----3--------4---
 * ----a-----b-----c--d------
 *          combine
 * ----1a-2a-2b-3b-3c-3d-4d--
 * ```
 *
 * Note: to minimize garbage collection, *combine* uses the same array
 * instance for each emission.  If you need to compare emissions over time,
 * cache the values with `map` first:
 *
 * ```js
 * import pairwise from 'xstream/extra/pairwise'
 *
 * const stream1 = xs.of(1);
 * const stream2 = xs.of(2);
 *
 * xs.combine(stream1, stream2).map(
 *   combinedEmissions => ([ ...combinedEmissions ])
 * ).compose(pairwise)
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to combine together with other streams.
 * @param {Stream} stream2 A stream to combine together with other streams.
 * Multiple streams, not just two, may be given as arguments.
 * @return {Stream}
 */
Stream.combine = function combine() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new Stream(new Combine(streams));
};
exports.Stream = Stream;
var MemoryStream = (function (_super) {
    __extends(MemoryStream, _super);
    function MemoryStream(producer) {
        var _this = _super.call(this, producer) || this;
        _this._has = false;
        return _this;
    }
    MemoryStream.prototype._n = function (x) {
        this._v = x;
        this._has = true;
        _super.prototype._n.call(this, x);
    };
    MemoryStream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1) {
            if (this._has)
                il._n(this._v);
            return;
        }
        if (this._stopID !== NO) {
            if (this._has)
                il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else if (this._has)
            il._n(this._v);
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    MemoryStream.prototype._stopNow = function () {
        this._has = false;
        _super.prototype._stopNow.call(this);
    };
    MemoryStream.prototype._x = function () {
        this._has = false;
        _super.prototype._x.call(this);
    };
    MemoryStream.prototype.map = function (project) {
        return this._map(project);
    };
    MemoryStream.prototype.mapTo = function (projectedValue) {
        return _super.prototype.mapTo.call(this, projectedValue);
    };
    MemoryStream.prototype.take = function (amount) {
        return _super.prototype.take.call(this, amount);
    };
    MemoryStream.prototype.endWhen = function (other) {
        return _super.prototype.endWhen.call(this, other);
    };
    MemoryStream.prototype.replaceError = function (replace) {
        return _super.prototype.replaceError.call(this, replace);
    };
    MemoryStream.prototype.remember = function () {
        return this;
    };
    MemoryStream.prototype.debug = function (labelOrSpy) {
        return _super.prototype.debug.call(this, labelOrSpy);
    };
    return MemoryStream;
}(Stream));
exports.MemoryStream = MemoryStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Stream;
//# sourceMappingURL=index.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var thunk = __webpack_require__(167);
exports.thunk = thunk;
/**
 * A factory for the DOM driver function.
 *
 * Takes a `container` to define the target on the existing DOM which this
 * driver will operate on, and an `options` object as the second argument. The
 * input to this driver is a stream of virtual DOM objects, or in other words,
 * Snabbdom "VNode" objects. The output of this driver is a "DOMSource": a
 * collection of Observables queried with the methods `select()` and `events()`.
 *
 * `DOMSource.select(selector)` returns a new DOMSource with scope restricted to
 * the element(s) that matches the CSS `selector` given.
 *
 * `DOMSource.events(eventType, options)` returns a stream of events of
 * `eventType` happening on the elements that match the current DOMSource. The
 * event object contains the `ownerTarget` property that behaves exactly like
 * `currentTarget`. The reason for this is that some browsers doesn't allow
 * `currentTarget` property to be mutated, hence a new property is created. The
 * returned stream is an *xstream* Stream if you use `@cycle/xstream-run` to run
 * your app with this driver, or it is an RxJS Observable if you use
 * `@cycle/rxjs-run`, and so forth. The `options` parameter can have the
 * property `useCapture`, which is by default `false`, except it is `true` for
 * event types that do not bubble. Read more here
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * about the `useCapture` and its purpose.
 *
 * `DOMSource.elements()` returns a stream of the DOM element(s) matched by the
 * selectors in the DOMSource. Also, `DOMSource.select(':root').elements()`
 * returns a stream of DOM element corresponding to the root (or container) of
 * the app on the DOM.
 *
 * @param {(String|HTMLElement)} container the DOM selector for the element
 * (or the element itself) to contain the rendering of the VTrees.
 * @param {DOMDriverOptions} options an object with two optional properties:
 *
 *   - `modules: array` overrides `@cycle/dom`'s default Snabbdom modules as
 *     as defined in [`src/modules.ts`](./src/modules.ts).
 *   - `transposition: boolean` enables/disables transposition of inner streams
 *     in the virtual DOM tree.
 * @return {Function} the DOM driver function. The function expects a stream of
 * VNode as input, and outputs the DOMSource object.
 * @function makeDOMDriver
 */
var makeDOMDriver_1 = __webpack_require__(76);
exports.makeDOMDriver = makeDOMDriver_1.makeDOMDriver;
/**
 * A factory for the HTML driver function.
 *
 * Takes an `effect` callback function and an `options` object as arguments. The
 * input to this driver is a stream of virtual DOM objects, or in other words,
 * Snabbdom "VNode" objects. The output of this driver is a "DOMSource": a
 * collection of Observables queried with the methods `select()` and `events()`.
 *
 * The HTML Driver is supplementary to the DOM Driver. Instead of producing
 * elements on the DOM, it generates HTML as strings and does a side effect on
 * those HTML strings. That side effect is described by the `effect` callback
 * function. So, if you want to use the HTML Driver on the server-side to render
 * your application as HTML and send as a response (which is the typical use
 * case for the HTML Driver), you need to pass something like the
 * `html => response.send(html)` function as the `effect` argument. This way,
 * the driver knows what side effect to cause based on the HTML string it just
 * rendered.
 *
 * The HTML driver is useful only for that side effect in the `effect` callback.
 * It can be considered a sink-only driver. However, in order to serve as a
 * transparent replacement to the DOM Driver when rendering from the server, the
 * HTML driver returns a source object that behaves just like the DOMSource.
 * This helps reuse the same application that is written for the DOM Driver.
 * This fake DOMSource returns empty streams when you query it, because there
 * are no user events on the server.
 *
 * `DOMSource.select(selector)` returns a new DOMSource with scope restricted to
 * the element(s) that matches the CSS `selector` given.
 *
 * `DOMSource.events(eventType, options)` returns an empty stream. The returned
 * stream is an *xstream* Stream if you use `@cycle/xstream-run` to run your app
 * with this driver, or it is an RxJS Observable if you use `@cycle/rxjs-run`,
 * and so forth.
 *
 * `DOMSource.elements()` returns the stream of HTML string rendered from your
 * sink virtual DOM stream.
 *
 * @param {Function} effect a callback function that takes a string of rendered
 * HTML as input and should run a side effect, returning nothing.
 * @param {HTMLDriverOptions} options an object with one optional property:
 * `transposition: boolean` enables/disables transposition of inner streams in
 * the virtual DOM tree.
 * @return {Function} the HTML driver function. The function expects a stream of
 * VNode as input, and outputs the DOMSource object.
 * @function makeHTMLDriver
 */
var makeHTMLDriver_1 = __webpack_require__(77);
exports.makeHTMLDriver = makeHTMLDriver_1.makeHTMLDriver;
/**
 * A factory function to create mocked DOMSource objects, for testing purposes.
 *
 * Takes a `streamAdapter` and a `mockConfig` object as arguments, and returns
 * a DOMSource that can be given to any Cycle.js app that expects a DOMSource in
 * the sources, for testing.
 *
 * The `streamAdapter` parameter is a package such as `@cycle/xstream-adapter`,
 * `@cycle/rxjs-adapter`, etc. Import it as `import a from '@cycle/rx-adapter`,
 * then provide it to `mockDOMSource. This is important so the DOMSource created
 * knows which stream library should it use to export its streams when you call
 * `DOMSource.events()` for instance.
 *
 * The `mockConfig` parameter is an object specifying selectors, eventTypes and
 * their streams. Example:
 *
 * ```js
 * const domSource = mockDOMSource(RxAdapter, {
 *   '.foo': {
 *     'click': Rx.Observable.of({target: {}}),
 *     'mouseover': Rx.Observable.of({target: {}}),
 *   },
 *   '.bar': {
 *     'scroll': Rx.Observable.of({target: {}}),
 *     elements: Rx.Observable.of({tagName: 'div'}),
 *   }
 * });
 *
 * // Usage
 * const click$ = domSource.select('.foo').events('click');
 * const element$ = domSource.select('.bar').elements();
 * ```
 *
 * The mocked DOM Source supports isolation. It has the functions `isolateSink`
 * and `isolateSource` attached to it, and performs simple isolation using
 * classNames. *isolateSink* with scope `foo` will append the class `___foo` to
 * the stream of virtual DOM nodes, and *isolateSource* with scope `foo` will
 * perform a conventional `mockedDOMSource.select('.__foo')` call.
 *
 * @param {Object} mockConfig an object where keys are selector strings
 * and values are objects. Those nested objects have `eventType` strings as keys
 * and values are streams you created.
 * @return {Object} fake DOM source object, with an API containing `select()`
 * and `events()` and `elements()` which can be used just like the DOM Driver's
 * DOMSource.
 *
 * @function mockDOMSource
 */
var mockDOMSource_1 = __webpack_require__(78);
exports.mockDOMSource = mockDOMSource_1.mockDOMSource;
/**
 * The hyperscript function `h()` is a function to create virtual DOM objects,
 * also known as VNodes. Call
 *
 * ```js
 * h('div.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * to create a VNode that represents a `DIV` element with className `myClass`,
 * styled with red color, and no children because the `[]` array was passed. The
 * API is `h(tagOrSelector, optionalData, optionalChildrenOrText)`.
 *
 * However, usually you should use "hyperscript helpers", which are shortcut
 * functions based on hyperscript. There is one hyperscript helper function for
 * each DOM tagName, such as `h1()`, `h2()`, `div()`, `span()`, `label()`,
 * `input()`. For instance, the previous example could have been written
 * as:
 *
 * ```js
 * div('.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * There are also SVG helper functions, which apply the appropriate SVG
 * namespace to the resulting elements. `svg()` function creates the top-most
 * SVG element, and `svg.g`, `svg.polygon`, `svg.circle`, `svg.path` are for
 * SVG-specific child elements. Example:
 *
 * ```js
 * svg({width: 150, height: 150}, [
 *   svg.polygon({
 *     attrs: {
 *       class: 'triangle',
 *       points: '20 0 20 150 150 20'
 *     }
 *   })
 * ])
 * ```
 *
 * @function h
 */
var hyperscript_1 = __webpack_require__(25);
exports.h = hyperscript_1.h;
var hyperscript_helpers_1 = __webpack_require__(73);
exports.svg = hyperscript_helpers_1.default.svg;
exports.a = hyperscript_helpers_1.default.a;
exports.abbr = hyperscript_helpers_1.default.abbr;
exports.address = hyperscript_helpers_1.default.address;
exports.area = hyperscript_helpers_1.default.area;
exports.article = hyperscript_helpers_1.default.article;
exports.aside = hyperscript_helpers_1.default.aside;
exports.audio = hyperscript_helpers_1.default.audio;
exports.b = hyperscript_helpers_1.default.b;
exports.base = hyperscript_helpers_1.default.base;
exports.bdi = hyperscript_helpers_1.default.bdi;
exports.bdo = hyperscript_helpers_1.default.bdo;
exports.blockquote = hyperscript_helpers_1.default.blockquote;
exports.body = hyperscript_helpers_1.default.body;
exports.br = hyperscript_helpers_1.default.br;
exports.button = hyperscript_helpers_1.default.button;
exports.canvas = hyperscript_helpers_1.default.canvas;
exports.caption = hyperscript_helpers_1.default.caption;
exports.cite = hyperscript_helpers_1.default.cite;
exports.code = hyperscript_helpers_1.default.code;
exports.col = hyperscript_helpers_1.default.col;
exports.colgroup = hyperscript_helpers_1.default.colgroup;
exports.dd = hyperscript_helpers_1.default.dd;
exports.del = hyperscript_helpers_1.default.del;
exports.dfn = hyperscript_helpers_1.default.dfn;
exports.dir = hyperscript_helpers_1.default.dir;
exports.div = hyperscript_helpers_1.default.div;
exports.dl = hyperscript_helpers_1.default.dl;
exports.dt = hyperscript_helpers_1.default.dt;
exports.em = hyperscript_helpers_1.default.em;
exports.embed = hyperscript_helpers_1.default.embed;
exports.fieldset = hyperscript_helpers_1.default.fieldset;
exports.figcaption = hyperscript_helpers_1.default.figcaption;
exports.figure = hyperscript_helpers_1.default.figure;
exports.footer = hyperscript_helpers_1.default.footer;
exports.form = hyperscript_helpers_1.default.form;
exports.h1 = hyperscript_helpers_1.default.h1;
exports.h2 = hyperscript_helpers_1.default.h2;
exports.h3 = hyperscript_helpers_1.default.h3;
exports.h4 = hyperscript_helpers_1.default.h4;
exports.h5 = hyperscript_helpers_1.default.h5;
exports.h6 = hyperscript_helpers_1.default.h6;
exports.head = hyperscript_helpers_1.default.head;
exports.header = hyperscript_helpers_1.default.header;
exports.hgroup = hyperscript_helpers_1.default.hgroup;
exports.hr = hyperscript_helpers_1.default.hr;
exports.html = hyperscript_helpers_1.default.html;
exports.i = hyperscript_helpers_1.default.i;
exports.iframe = hyperscript_helpers_1.default.iframe;
exports.img = hyperscript_helpers_1.default.img;
exports.input = hyperscript_helpers_1.default.input;
exports.ins = hyperscript_helpers_1.default.ins;
exports.kbd = hyperscript_helpers_1.default.kbd;
exports.keygen = hyperscript_helpers_1.default.keygen;
exports.label = hyperscript_helpers_1.default.label;
exports.legend = hyperscript_helpers_1.default.legend;
exports.li = hyperscript_helpers_1.default.li;
exports.link = hyperscript_helpers_1.default.link;
exports.main = hyperscript_helpers_1.default.main;
exports.map = hyperscript_helpers_1.default.map;
exports.mark = hyperscript_helpers_1.default.mark;
exports.menu = hyperscript_helpers_1.default.menu;
exports.meta = hyperscript_helpers_1.default.meta;
exports.nav = hyperscript_helpers_1.default.nav;
exports.noscript = hyperscript_helpers_1.default.noscript;
exports.object = hyperscript_helpers_1.default.object;
exports.ol = hyperscript_helpers_1.default.ol;
exports.optgroup = hyperscript_helpers_1.default.optgroup;
exports.option = hyperscript_helpers_1.default.option;
exports.p = hyperscript_helpers_1.default.p;
exports.param = hyperscript_helpers_1.default.param;
exports.pre = hyperscript_helpers_1.default.pre;
exports.progress = hyperscript_helpers_1.default.progress;
exports.q = hyperscript_helpers_1.default.q;
exports.rp = hyperscript_helpers_1.default.rp;
exports.rt = hyperscript_helpers_1.default.rt;
exports.ruby = hyperscript_helpers_1.default.ruby;
exports.s = hyperscript_helpers_1.default.s;
exports.samp = hyperscript_helpers_1.default.samp;
exports.script = hyperscript_helpers_1.default.script;
exports.section = hyperscript_helpers_1.default.section;
exports.select = hyperscript_helpers_1.default.select;
exports.small = hyperscript_helpers_1.default.small;
exports.source = hyperscript_helpers_1.default.source;
exports.span = hyperscript_helpers_1.default.span;
exports.strong = hyperscript_helpers_1.default.strong;
exports.style = hyperscript_helpers_1.default.style;
exports.sub = hyperscript_helpers_1.default.sub;
exports.sup = hyperscript_helpers_1.default.sup;
exports.table = hyperscript_helpers_1.default.table;
exports.tbody = hyperscript_helpers_1.default.tbody;
exports.td = hyperscript_helpers_1.default.td;
exports.textarea = hyperscript_helpers_1.default.textarea;
exports.tfoot = hyperscript_helpers_1.default.tfoot;
exports.th = hyperscript_helpers_1.default.th;
exports.thead = hyperscript_helpers_1.default.thead;
exports.title = hyperscript_helpers_1.default.title;
exports.tr = hyperscript_helpers_1.default.tr;
exports.u = hyperscript_helpers_1.default.u;
exports.ul = hyperscript_helpers_1.default.ul;
exports.video = hyperscript_helpers_1.default.video;
//# sourceMappingURL=index.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var counter = 0;
function newScope() {
    return "cycle" + ++counter;
}
function checkIsolateArgs(dataflowComponent, scope) {
    if (typeof dataflowComponent !== "function") {
        throw new Error("First argument given to isolate() must be a " +
            "'dataflowComponent' function");
    }
    if (scope === null) {
        throw new Error("Second argument given to isolate() must not be null");
    }
}
function isolateAllSources(sources, scope) {
    var scopedSources = {};
    for (var key in sources) {
        if (sources.hasOwnProperty(key) && sources[key]
            && typeof sources[key].isolateSource === "function") {
            scopedSources[key] = sources[key].isolateSource(sources[key], scope);
        }
        else if (sources.hasOwnProperty(key)) {
            scopedSources[key] = sources[key];
        }
    }
    return scopedSources;
}
function isolateAllSinks(sources, sinks, scope) {
    var scopedSinks = {};
    for (var key in sinks) {
        if (sinks.hasOwnProperty(key)
            && sources[key]
            && typeof sources[key].isolateSink === "function") {
            scopedSinks[key] = sources[key].isolateSink(sinks[key], scope);
        }
        else if (sinks.hasOwnProperty(key)) {
            scopedSinks[key] = sinks[key];
        }
    }
    return scopedSinks;
}
/**
 * Takes a `dataflowComponent` function and an optional `scope` string, and
 * returns a scoped version of the `dataflowComponent` function.
 *
 * When the scoped dataflow component is invoked, each source provided to the
 * scoped dataflowComponent is isolated to the scope using
 * `source.isolateSource(source, scope)`, if possible. Likewise, the sinks
 * returned from the scoped dataflow component are isolate to the scope using
 * `source.isolateSink(sink, scope)`.
 *
 * If the `scope` is not provided, a new scope will be automatically created.
 * This means that while **`isolate(dataflowComponent, scope)` is pure**
 * (referentially transparent), **`isolate(dataflowComponent)` is impure**
 * (not referentially transparent). Two calls to `isolate(Foo, bar)` will
 * generate two indistinct dataflow components. But, two calls to `isolate(Foo)`
 * will generate two distinct dataflow components.
 *
 * Note that both `isolateSource()` and `isolateSink()` are static members of
 * `source`. The reason for this is that drivers produce `source` while the
 * application produces `sink`, and it's the driver's responsibility to
 * implement `isolateSource()` and `isolateSink()`.
 *
 * @param {Function} dataflowComponent a function that takes `sources` as input
 * and outputs a collection of `sinks`.
 * @param {String} scope an optional string that is used to isolate each
 * `sources` and `sinks` when the returned scoped dataflow component is invoked.
 * @return {Function} the scoped dataflow component function that, as the
 * original `dataflowComponent` function, takes `sources` and returns `sinks`.
 * @function isolate
 */
function isolate(component, scope) {
    if (scope === void 0) { scope = newScope(); }
    checkIsolateArgs(component, scope);
    var convertedScope = typeof scope === 'string' ? scope : scope.toString();
    return function scopedComponent(sources) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var scopedSources = isolateAllSources(sources, convertedScope);
        var sinks = component.apply(void 0, [scopedSources].concat(rest));
        var scopedSinks = isolateAllSinks(sources, sinks, convertedScope);
        return scopedSinks;
    };
}
isolate.reset = function () { return counter = 0; };
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = isolate;
//# sourceMappingURL=index.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var utils_1 = __webpack_require__(8);
__export(__webpack_require__(207));
var Size;
(function (Size) {
    Size[Size["Mini"] = 0] = "Mini";
    Size[Size["Tiny"] = 1] = "Tiny";
    Size[Size["Small"] = 2] = "Small";
    Size[Size["Medium"] = 3] = "Medium";
    Size[Size["Large"] = 4] = "Large";
    Size[Size["Big"] = 5] = "Big";
    Size[Size["Huge"] = 6] = "Huge";
    Size[Size["Massive"] = 7] = "Massive";
    Size[Size["Fluid"] = 8] = "Fluid";
})(Size = exports.Size || (exports.Size = {}));
(function (Size) {
    function ToEnum(sizeOrString) {
        return typeof (sizeOrString) === "number"
            ? sizeOrString
            : Size[utils_1.capitalize(sizeOrString)];
    }
    Size.ToEnum = ToEnum;
    function ToClassname(size) {
        size = ToEnum(size);
        switch (size) {
            case Size.Mini: return " mini";
            case Size.Tiny: return " tiny";
            case Size.Small: return " small";
            case Size.Medium: return " medium";
            case Size.Large: return " large";
            case Size.Big: return " big";
            case Size.Huge: return " huge";
            case Size.Massive: return " massive";
            case Size.Fluid: return " fluid";
            default: return "";
        }
    }
    Size.ToClassname = ToClassname;
})(Size = exports.Size || (exports.Size = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = 0] = "Top";
    VerticalAlignment[VerticalAlignment["Middle"] = 1] = "Middle";
    VerticalAlignment[VerticalAlignment["Bottom"] = 2] = "Bottom";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
(function (VerticalAlignment) {
    function ToClassname(alignment) {
        switch (alignment) {
            case VerticalAlignment.Top: return " top aligned";
            case VerticalAlignment.Middle: return " middle aligned";
            case VerticalAlignment.Bottom: return " bottom aligned";
            default: return "";
        }
    }
    VerticalAlignment.ToClassname = ToClassname;
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
var TextAlignment;
(function (TextAlignment) {
    TextAlignment[TextAlignment["Left"] = 0] = "Left";
    TextAlignment[TextAlignment["Right"] = 1] = "Right";
    TextAlignment[TextAlignment["Center"] = 2] = "Center";
    TextAlignment[TextAlignment["Justified"] = 3] = "Justified";
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
(function (TextAlignment) {
    function ToClassname(alignment) {
        switch (alignment) {
            case TextAlignment.Left: return " left aligned.";
            case TextAlignment.Right: return " right aligned.";
            case TextAlignment.Center: return " center aligned";
            case TextAlignment.Justified: return " justified";
            default: return "";
        }
    }
    TextAlignment.ToClassname = ToClassname;
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
var Float;
(function (Float) {
    Float[Float["None"] = 0] = "None";
    Float[Float["Right"] = 1] = "Right";
    Float[Float["Left"] = 2] = "Left";
})(Float = exports.Float || (exports.Float = {}));
(function (Float) {
    function ToClassname(float) {
        switch (float) {
            case Float.Left: return " left floated";
            case Float.Right: return " right floated";
            default: return "";
        }
    }
    Float.ToClassname = ToClassname;
})(Float = exports.Float || (exports.Float = {}));
var Attachment;
(function (Attachment) {
    Attachment[Attachment["None"] = 0] = "None";
    Attachment[Attachment["Top"] = 1] = "Top";
    Attachment[Attachment["TopRight"] = 2] = "TopRight";
    Attachment[Attachment["TopLeft"] = 3] = "TopLeft";
    Attachment[Attachment["Bottom"] = 4] = "Bottom";
    Attachment[Attachment["BottomLeft"] = 5] = "BottomLeft";
    Attachment[Attachment["BottomRight"] = 6] = "BottomRight";
    Attachment[Attachment["Right"] = 7] = "Right";
    Attachment[Attachment["Left"] = 8] = "Left";
})(Attachment = exports.Attachment || (exports.Attachment = {}));
(function (Attachment) {
    function ToClassname(attachment) {
        switch (attachment) {
            case Attachment.None: return " attached";
            case Attachment.Top: return " top attached";
            case Attachment.Bottom: return " bottom attached";
            case Attachment.Left: return " left attached";
            case Attachment.Right: return " right attached";
            case Attachment.TopRight: return " top right attached";
            case Attachment.TopLeft: return " top left attached";
            case Attachment.BottomLeft: return " bottom left attached";
            case Attachment.BottomRight: return " bottom right attached";
            default: return "";
        }
    }
    Attachment.ToClassname = ToClassname;
})(Attachment = exports.Attachment || (exports.Attachment = {}));
var Color;
(function (Color) {
    Color[Color["None"] = 0] = "None";
    Color[Color["Primary"] = 1] = "Primary";
    Color[Color["Secondary"] = 2] = "Secondary";
    Color[Color["Success"] = 3] = "Success";
    Color[Color["Info"] = 4] = "Info";
    Color[Color["Warning"] = 5] = "Warning";
    Color[Color["Error"] = 6] = "Error";
})(Color = exports.Color || (exports.Color = {}));
(function (Color) {
    function ToClassname(color) {
        switch (color) {
            case Color.Primary: return " primaryColored";
            case Color.Secondary: return " secondaryColored";
            case Color.Success: return " successColored";
            case Color.Info: return " infoColored";
            case Color.Warning: return " warningColored";
            case Color.Error: return " errorColored ";
            default: return "";
        }
    }
    Color.ToClassname = ToClassname;
})(Color = exports.Color || (exports.Color = {}));
var Animation;
(function (Animation) {
    Animation[Animation["Browse"] = 0] = "Browse";
    Animation[Animation["Drop"] = 1] = "Drop";
    Animation[Animation["Fade"] = 2] = "Fade";
    Animation[Animation["Flip"] = 3] = "Flip";
    Animation[Animation["Scale"] = 4] = "Scale";
    Animation[Animation["Fly"] = 5] = "Fly";
    Animation[Animation["Slide"] = 6] = "Slide";
    Animation[Animation["Swing"] = 7] = "Swing";
    Animation[Animation["Flash"] = 8] = "Flash";
    Animation[Animation["Shake"] = 9] = "Shake";
    Animation[Animation["Bounce"] = 10] = "Bounce";
    Animation[Animation["Tada"] = 11] = "Tada";
    Animation[Animation["Pulse"] = 12] = "Pulse";
    Animation[Animation["Jiggle"] = 13] = "Jiggle";
    Animation[Animation["None"] = 14] = "None";
})(Animation = exports.Animation || (exports.Animation = {}));
(function (Animation) {
    function ToClassname(anim) {
        switch (anim) {
            case Animation.Browse: return " browse";
            case Animation.Drop: return " drop";
            case Animation.Fade: return " fade";
            case Animation.Flip: return " flip";
            case Animation.Scale: return " scale";
            case Animation.Fly: return " fly";
            case Animation.Slide: return " slide";
            case Animation.Swing: return " swing";
            case Animation.Flash: return " flash";
            case Animation.Shake: return " shake";
            case Animation.Bounce: return " bounce";
            case Animation.Tada: return " tada";
            case Animation.Pulse: return " pulse";
            case Animation.Jiggle: return " jiggle";
        }
    }
    Animation.ToClassname = ToClassname;
    function isStatic(anim) {
        var staticAnimations = [Animation.Flash, Animation.Shake,
            Animation.Bounce, Animation.Tada, Animation.Pulse, Animation.Jiggle];
        return staticAnimations.indexOf(anim) !== -1;
    }
    Animation.isStatic = isStatic;
    function isDirectional(anim) {
        var directionAnimations = [Animation.Browse, Animation.Fade,
            Animation.Fly, Animation.Slide, Animation.Swing];
        return directionAnimations.indexOf(anim) !== -1;
    }
    Animation.isDirectional = isDirectional;
})(Animation = exports.Animation || (exports.Animation = {}));
var Direction;
(function (Direction) {
    Direction[Direction["In"] = 0] = "In";
    Direction[Direction["Out"] = 1] = "Out";
    Direction[Direction["None"] = 2] = "None";
})(Direction = exports.Direction || (exports.Direction = {}));
(function (Direction) {
    function ToClassname(direction) {
        return direction === Direction.In ? " in" : " out";
    }
    Direction.ToClassname = ToClassname;
})(Direction = exports.Direction || (exports.Direction = {}));
var AnimationDirection;
(function (AnimationDirection) {
    AnimationDirection[AnimationDirection["Up"] = 0] = "Up";
    AnimationDirection[AnimationDirection["Down"] = 1] = "Down";
    AnimationDirection[AnimationDirection["Left"] = 2] = "Left";
    AnimationDirection[AnimationDirection["Right"] = 3] = "Right";
})(AnimationDirection = exports.AnimationDirection || (exports.AnimationDirection = {}));
(function (AnimationDirection) {
    function ToClassname(dir) {
        switch (dir) {
            case AnimationDirection.Up: return " up";
            case AnimationDirection.Down: return " down";
            case AnimationDirection.Left: return " left";
            case AnimationDirection.Right: return " right";
            default: return "";
        }
    }
    AnimationDirection.ToClassname = ToClassname;
})(AnimationDirection = exports.AnimationDirection || (exports.AnimationDirection = {}));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDOMContent(content) {
    if (!content) {
        return false;
    }
    if (typeof (content) === "string") {
        return true;
    }
    if (content instanceof (Array)) {
        if (content.length === 0) {
            return true;
        }
        else {
            return content[0].sel !== undefined;
        }
        ;
    }
    return false;
}
exports.isDOMContent = isDOMContent;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var XStreamAdapter = {
    adapt: function (originStream, originStreamSubscribe) {
        if (XStreamAdapter.isValidStream(originStream)) {
            return originStream;
        }
        ;
        var dispose = null;
        return xstream_1.default.create({
            start: function (out) {
                var observer = out;
                dispose = originStreamSubscribe(originStream, observer);
            },
            stop: function () {
                if (typeof dispose === 'function') {
                    dispose();
                }
            },
        });
    },
    makeSubject: function () {
        var stream = xstream_1.default.create();
        var observer = {
            next: function (x) { stream.shamefullySendNext(x); },
            error: function (err) { stream.shamefullySendError(err); },
            complete: function () { stream.shamefullySendComplete(); },
        };
        return { observer: observer, stream: stream };
    },
    remember: function (stream) {
        return stream.remember();
    },
    isValidStream: function (stream) {
        return (typeof stream.addListener === 'function' &&
            typeof stream.shamefullySendNext === 'function');
    },
    streamSubscribe: function (stream, observer) {
        stream.addListener(observer);
        return function () { return stream.removeListener(observer); };
    },
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = XStreamAdapter;
//# sourceMappingURL=index.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var flattenConcurrently_1 = __webpack_require__(218);
function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
exports.capitalize = capitalize;
function patchClassList(target, classes, classesToAdd) {
    var className = "";
    if (target.data) {
        var props = target.data.props ? target.data.props : { className: target.sel.split(".").join(" ") };
        var classList = props.className.split(" ");
        classList.forEach(function (item) {
            if (classes.indexOf(item) === -1) {
                className += item + " ";
            }
        });
    }
    className += classesToAdd;
    return Object.assign({}, target.data, {
        "props": {
            className: className
        }
    });
}
exports.patchClassList = patchClassList;
/**
 * Adds one VNode to another and handles updates for stream by replacing based on the identifier class.
 * @param  {VNode}  element    The element to be added.
 * @param  {VNode}  target     The target for the element
 * @param  {string} identifier The identifying class for the element to be added.
 * @return {Array} The target element's children with the element added.
 */
function addElement(element, target, identifier) {
    var c = [];
    if (target.children) {
        c = target.children;
    }
    if (target.text) {
        c.push(target.text);
    }
    for (var i = 0; i < c.length; i++) {
        var child = c[i];
        var cProps = child.data ? child.data.props ? child.data.props : {} : {};
        if (typeof (child) !== "undefined" && typeof (cProps.className) !== "undefined") {
            var classList = child.data.props.className.split(" ");
            for (var _i = 0, classList_1 = classList; _i < classList_1.length; _i++) {
                var s = classList_1[_i];
                if (s === identifier) {
                    c.splice(i, 1);
                }
            }
        }
    }
    c.push(element);
    return c;
}
exports.addElement = addElement;
/**
 * Converts anything to a stream
 * @param  {any} obj - The object.
 * @return {Stream<any>} The object as a stream.
 */
function asStream(obj) {
    if (typeof (obj) !== "undefined") {
        if (typeof (obj.addListener) === "function") {
            return obj;
        }
        if (Object.prototype.toString.call(obj) === "[object Array]") {
            var isStreams = true;
            for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
                var subobj = obj_1[_i];
                if (typeof (subobj.addListener) !== "function") {
                    isStreams = false;
                }
            }
            if (isStreams) {
                return xstream_1.default.combine.apply(this, obj);
            }
        }
        return xstream_1.default.of(obj);
    }
    return xstream_1.default.of("");
}
exports.asStream = asStream;
/**
 * Converts a number of objects to a stream of an Array.
 * @param  {any} ...objs   The objects to include in the stream
 * @return {Stream<any[]>} The objects as a stream of an array.
 */
function asArrayStream() {
    var objs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objs[_i] = arguments[_i];
    }
    var streams = Array.from(arguments);
    streams = streams.map(function (obj) { return asStream(obj); });
    return xstream_1.default.combine.apply(this, streams);
}
exports.asArrayStream = asArrayStream;
/**
 * Flattens a stream of an array of streams into a stream of an array.
 * @param  {Stream<Stream<any>[]>} stream The stream to flatten
 * @return {Stream<any[]>}                The flattened stream.
 */
function flattenStreamArray(stream) {
    var _this = this;
    return flattenConcurrently_1.default(stream.map(function (children) { return xstream_1.default.combine.apply(_this, children); }));
}
exports.flattenStreamArray = flattenStreamArray;
/**
 * Converts a natural number between 1-16 to text.
 * @param  {number} num The number to convert.
 * @return {string}     That number as text.
 */
function numToText(num) {
    switch (num) {
        case 1: return " one";
        case 2: return " two";
        case 3: return " three";
        case 4: return " four";
        case 5: return " five";
        case 6: return " six";
        case 7: return " seven";
        case 8: return " eight";
        case 9: return " nine";
        case 10: return " ten";
        case 11: return " eleven";
        case 12: return " twelve";
        case 13: return " thirteen";
        case 14: return " fourteen";
        case 15: return " fifteen";
        case 16: return " sixteen";
    }
}
exports.numToText = numToText;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPath = exports.parsePath = exports.getQueryStringValueFromPath = exports.stripQueryStringValueFromPath = exports.addQueryStringValueToPath = exports.isAbsolutePath = undefined;

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isAbsolutePath = exports.isAbsolutePath = function isAbsolutePath(path) {
  return typeof path === 'string' && path.charAt(0) === '/';
};

var addQueryStringValueToPath = exports.addQueryStringValueToPath = function addQueryStringValueToPath(path, key, value) {
  var _parsePath = parsePath(path);

  var pathname = _parsePath.pathname;
  var search = _parsePath.search;
  var hash = _parsePath.hash;


  return createPath({
    pathname: pathname,
    search: search + (search.indexOf('?') === -1 ? '?' : '&') + key + '=' + value,
    hash: hash
  });
};

var stripQueryStringValueFromPath = exports.stripQueryStringValueFromPath = function stripQueryStringValueFromPath(path, key) {
  var _parsePath2 = parsePath(path);

  var pathname = _parsePath2.pathname;
  var search = _parsePath2.search;
  var hash = _parsePath2.hash;


  return createPath({
    pathname: pathname,
    search: search.replace(new RegExp('([?&])' + key + '=[a-zA-Z0-9]+(&?)'), function (match, prefix, suffix) {
      return prefix === '?' ? prefix : suffix;
    }),
    hash: hash
  });
};

var getQueryStringValueFromPath = exports.getQueryStringValueFromPath = function getQueryStringValueFromPath(path, key) {
  var _parsePath3 = parsePath(path);

  var search = _parsePath3.search;

  var match = search.match(new RegExp('[?&]' + key + '=([a-zA-Z0-9]+)'));
  return match && match[1];
};

var extractPath = function extractPath(string) {
  var match = string.match(/^(https?:)?\/\/[^\/]*/);
  return match == null ? string : string.substring(match[0].length);
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = extractPath(path);
  var search = '';
  var hash = '';

  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(path === pathname, 'A path must be pathname + search + hash only, not a full URL like "%s"', path) : void 0;

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substring(hashIndex);
    pathname = pathname.substring(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substring(searchIndex);
    pathname = pathname.substring(0, searchIndex);
  }

  if (pathname === '') pathname = '/';

  return {
    pathname: pathname,
    search: search,
    hash: hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  if (location == null || typeof location === 'string') return location;

  var basename = location.basename;
  var pathname = location.pathname;
  var search = location.search;
  var hash = location.hash;

  var path = (basename || '') + pathname;

  if (search && search !== '?') path += search;

  if (hash) path += hash;

  return path;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign        = __webpack_require__(27)
  , normalizeOpts = __webpack_require__(108)
  , isCallable    = __webpack_require__(102)
  , contains      = __webpack_require__(47)

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.statesAreEqual = exports.createLocation = exports.createQuery = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _PathUtils = __webpack_require__(9);

var _Actions = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createQuery = exports.createQuery = function createQuery(props) {
  return _extends(Object.create(null), props);
};

var createLocation = exports.createLocation = function createLocation() {
  var input = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var object = typeof input === 'string' ? (0, _PathUtils.parsePath)(input) : input;

  var pathname = object.pathname || '/';
  var search = object.search || '';
  var hash = object.hash || '';
  var state = object.state;

  return {
    pathname: pathname,
    search: search,
    hash: hash,
    state: state,
    action: action,
    key: key
  };
};

var isDate = function isDate(object) {
  return Object.prototype.toString.call(object) === '[object Date]';
};

var statesAreEqual = exports.statesAreEqual = function statesAreEqual(a, b) {
  if (a === b) return true;

  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (typeofA !== typeofB) return false;

  !(typeofA !== 'function') ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store functions in location state') : (0, _invariant2.default)(false) : void 0;

  // Not the same object, but same type.
  if (typeofA === 'object') {
    !!(isDate(a) && isDate(b)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store Date objects in location state') : (0, _invariant2.default)(false) : void 0;

    if (!Array.isArray(a)) return Object.keys(a).every(function (key) {
      return statesAreEqual(a[key], b[key]);
    });

    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return statesAreEqual(item, b[index]);
    });
  }

  // All other serializable types (string, number, boolean)
  // should be strict equal.
  return false;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.key === b.key &&
  // a.action === b.action && // Different action !== location change.
  a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && statesAreEqual(a.state, b.state);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var dom_1 = __webpack_require__(1);
var isolate_1 = __webpack_require__(2);
var Transition;
(function (Transition) {
    /**
     * A transition wrapper for animating dom content.
     * Accepts the following targets: VNode
     * Expects the following arguments: {} of
     *   animation: Animation - The animation to use.
     *   direction?: Direction - Wether to animate to visible or invisible.
     *   animationDirection?: AnimationDirection - The direction for the animation.
     * Disregards any content.
     */
    function run(sources) {
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".transition").events(type); };
            sources.args$ = sources.args$ ? sources.args$ : xstream_1.default.of({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var animationEnd$ = evt("animationend").map(function (evt) { return ({
                animation: enums_1.Animation.None,
                direction: evt.currentTarget.classList.contains("out") ? enums_1.Direction.Out : enums_1.Direction.In
            }); });
            var animation$ = xstream_1.default.merge(sources.args$, animationEnd$);
            var vTree$ = xstream_1.default.combine(animation$, sources.target$).map(function (_a) {
                var transition = _a[0], target = _a[1];
                return render(target, transition);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".transition").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Transition.run = run;
    /**
     * A transition wrapper for animating dom content.
     * Accepts the following targets: VNode
     * Expects the following arguments: {} of
     *   animation: Animation - The animation to use.
     *   direction?: Direction - Wether to animate to visible or invisible.
     *   animationDirection?: AnimationDirection - The direction for the animation.
     * Disregards any content.
     */
    function render(target, args) {
        if (args === void 0) { args = { animation: enums_1.Animation.None }; }
        var className = "", c;
        if (target.data) {
            var classList = target.data.props.className.split(" ");
            classList.forEach(function (item) {
                if (["hidden", "visible", "animating", "transition"].indexOf(item) === -1) {
                    className += item + " ";
                }
            });
        }
        className += getClassName(args);
        var data = Object.assign({}, target.data, {
            "props": {
                className: className
            }
        });
        if (target.children) {
            c = target.children;
        }
        if (target.text) {
            c = target.text;
        }
        return dom_1.h(target.sel, data, c);
    }
    Transition.render = render;
    function getClassName(transition) {
        if (transition.animation === enums_1.Animation.None) {
            return transition.direction === enums_1.Direction.Out ? "transition hidden" : "transition visible";
        }
        var animation = enums_1.Animation.ToClassname(transition.animation);
        if (enums_1.Animation.isStatic(transition.animation)) {
            return "visible animating transition " + animation;
        }
        var direction = enums_1.Direction.ToClassname(transition.direction);
        if (enums_1.Animation.isDirectional(transition.animation)) {
            animation += enums_1.AnimationDirection.ToClassname(transition.animationDirection);
        }
        return "visible transition animating " + direction + animation;
    }
})(Transition = exports.Transition || (exports.Transition = {}));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isElement(obj) {
    return typeof HTMLElement === "object" ?
        obj instanceof HTMLElement || obj instanceof DocumentFragment :
        obj && typeof obj === "object" && obj !== null &&
            (obj.nodeType === 1 || obj.nodeType === 11) &&
            typeof obj.nodeName === "string";
}
exports.SCOPE_PREFIX = "$$CYCLEDOM$$-";
function getElement(selectors) {
    var domElement = typeof selectors === 'string' ?
        document.querySelector(selectors) :
        selectors;
    if (typeof selectors === 'string' && domElement === null) {
        throw new Error("Cannot render into unknown element `" + selectors + "`");
    }
    else if (!isElement(domElement)) {
        throw new Error("Given container is not a DOM element neither a " +
            "selector string.");
    }
    return domElement;
}
exports.getElement = getElement;
function getScope(namespace) {
    return namespace
        .filter(function (c) { return c.indexOf(exports.SCOPE_PREFIX) > -1; })
        .map(function (c) { return c.replace(exports.SCOPE_PREFIX, ''); })
        .join("-");
}
exports.getScope = getScope;
function getSelectors(namespace) {
    return namespace.filter(function (c) { return c.indexOf(exports.SCOPE_PREFIX) === -1; }).join(" ");
}
exports.getSelectors = getSelectors;
//# sourceMappingURL=utils.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(122)() ? Symbol : __webpack_require__(124);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(45)()
	? Object.setPrototypeOf
	: __webpack_require__(46);


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Indicates that navigation was caused by a call to history.push.
 */
var PUSH = exports.PUSH = 'PUSH';

/**
 * Indicates that navigation was caused by a call to history.replace.
 */
var REPLACE = exports.REPLACE = 'REPLACE';

/**
 * Indicates that navigation was caused by some other action such
 * as using a browser's back/forward buttons and/or manually manipulating
 * the URL in a browser's location bar. This is the default.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
 * for more information.
 */
var POP = exports.POP = 'POP';

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = {
  array: Array.isArray,
  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(208));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Icon;
(function (Icon) {
    /**
     * An icon component for displaying icons.
     * Accepts the following properties in props$:
     *  button?: boolean - Styles the icon to display well on buttons
     * 	bordered?: boolean - Adds a border around the icon.
     * 	circular?: boolean - Styles the icon to appear circular.
     * 	disabled?: boolean - Styles the icon to appear disabled.
     * 	loading?: boolean - Rotates the icon to allow it to be used for loaders.
     * 	fitted?: boolean - Styles the icon for tight fits.
     * 	link?: boolean - Styles the icon to appear clickable.
     * 	flipped?: boolean - Flips the icon.
     * 	rotated?: boolean - Rotates the icon.
     * 	inverted?: boolean - Styles the icon to appear on dark background.
     * 	color?: Color - The color of the icon.
     * 	size?: Size - The size of the icon.
     * Accepts the following type of content in content$: IconType
     * @param  {ComponentSources} sources - The component's sources.
     * @return {ComponentSinks} The Icon component.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ type: "" });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of(0);
            return {
                DOM: xstream_1.default.combine(sources.props$, sources.content$)
                    .map(function (_a) {
                    var props = _a[0], content = _a[1];
                    return render(props, content);
                }),
                Events: function (type) { return sources.DOM.select(".icon").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Icon.run = run;
    /**
     * An icon component for displaying icons.
     * Accepts the following properties:
     *  button?: boolean - Styles the icon to display well on buttons
     * 	bordered?: boolean - Adds a border around the icon.
     * 	circular?: boolean - Styles the icon to appear circular.
     * 	disabled?: boolean - Styles the icon to appear disabled.
     * 	loading?: boolean - Rotates the icon to allow it to be used for loaders.
     * 	fitted?: boolean - Styles the icon for tight fits.
     * 	link?: boolean - Styles the icon to appear clickable.
     * 	flipped?: boolean - Flips the icon.
     * 	rotated?: boolean - Rotates the icon.
     * 	inverted?: boolean - Styles the icon to appear on dark background.
     * 	color?: Color - The color of the icon.
     * 	size?: Size - The size of the icon.
     * Accepts the following type of content: IconType
     * @param  {ComponentSources} sources - The component's sources.
     * @return {ComponentSinks} The Icon component.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = -1; }
        var props = isProps(pOrC) ? pOrC : {};
        var content = isProps(pOrC) ? c : pOrC;
        var className = getClassname(props, content);
        return className !== "ui icon" ? dom_1.i({ props: { className: className } }) : "";
    }
    Icon.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.button) {
            className += " button";
        }
        if (props.bordered) {
            className += " bordered";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.link) {
            className += " link";
        }
        if (props.flipped) {
            className += " flipped";
        }
        if (props.rotated) {
            className += " rotated";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += enums_1.IconType.ToClassname(content);
        return className + " icon";
    }
    function isProps(props) {
        return typeof (props) === "object";
    }
})(Icon = exports.Icon || (exports.Icon = {}));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
function fromEvent(element, eventName, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    return xstream_1.Stream.create({
        element: element,
        next: null,
        start: function start(listener) {
            this.next = function next(event) { listener.next(event); };
            this.element.addEventListener(eventName, this.next, useCapture);
        },
        stop: function stop() {
            this.element.removeEventListener(eventName, this.next, useCapture);
        },
    });
}
exports.fromEvent = fromEvent;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var is = __webpack_require__(21);
var vnode = __webpack_require__(36);
function isGenericStream(x) {
    return !Array.isArray(x) && typeof x.map === "function";
}
function mutateStreamWithNS(vNode) {
    addNS(vNode.data, vNode.children, vNode.sel);
    return vNode;
}
function addNS(data, children, selector) {
    data.ns = "http://www.w3.org/2000/svg";
    if (selector !== "text" && selector !== "foreignObject" &&
        typeof children !== 'undefined' && is.array(children)) {
        for (var i = 0; i < children.length; ++i) {
            if (isGenericStream(children[i])) {
                children[i] = children[i].map(mutateStreamWithNS);
            }
            else {
                addNS(children[i].data, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {};
    var children;
    var text;
    if (arguments.length === 3) {
        data = b;
        if (is.array(c)) {
            children = c;
        }
        else if (is.primitive(c)) {
            text = c;
        }
    }
    else if (arguments.length === 2) {
        if (is.array(b)) {
            children = b;
        }
        else if (is.primitive(b)) {
            text = b;
        }
        else {
            data = b;
        }
    }
    if (is.array(children)) {
        children = children.filter(function (x) { return x; });
        for (var i = 0; i < children.length; ++i) {
            if (is.primitive(children[i])) {
                children[i] = vnode(undefined, undefined, undefined, children[i]);
            }
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
        addNS(data, children, sel);
    }
    return vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
//# sourceMappingURL=hyperscript.js.map

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = Object.prototype.toString

  , id = toString.call((function () { return arguments; }()));

module.exports = function (x) { return (toString.call(x) === id); };


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(97)()
	? Object.assign
	: __webpack_require__(98);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = Object.prototype.toString

  , id = toString.call('');

module.exports = function (x) {
	return (typeof x === 'string') || (x && (typeof x === 'object') &&
		((x instanceof String) || (toString.call(x) === id))) || false;
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear    = __webpack_require__(44)
  , assign   = __webpack_require__(27)
  , callable = __webpack_require__(11)
  , value    = __webpack_require__(7)
  , d        = __webpack_require__(10)
  , autoBind = __webpack_require__(89)
  , Symbol   = __webpack_require__(16)

  , defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) return new Iterator(list, context);
	defineProperties(this, {
		__list__: d('w', value(list)),
		__context__: d('w', context),
		__nextIndex__: d('w', 0)
	});
	if (!context) return;
	callable(context.on);
	context.on('_add', this._onAdd);
	context.on('_delete', this._onDelete);
	context.on('_clear', this._onClear);
};

defineProperties(Iterator.prototype, assign({
	constructor: d(Iterator),
	_next: d(function () {
		var i;
		if (!this.__list__) return;
		if (this.__redo__) {
			i = this.__redo__.shift();
			if (i !== undefined) return i;
		}
		if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
		this._unBind();
	}),
	next: d(function () { return this._createResult(this._next()); }),
	_createResult: d(function (i) {
		if (i === undefined) return { done: true, value: undefined };
		return { done: false, value: this._resolve(i) };
	}),
	_resolve: d(function (i) { return this.__list__[i]; }),
	_unBind: d(function () {
		this.__list__ = null;
		delete this.__redo__;
		if (!this.__context__) return;
		this.__context__.off('_add', this._onAdd);
		this.__context__.off('_delete', this._onDelete);
		this.__context__.off('_clear', this._onClear);
		this.__context__ = null;
	}),
	toString: d(function () { return '[object Iterator]'; })
}, autoBind({
	_onAdd: d(function (index) {
		if (index >= this.__nextIndex__) return;
		++this.__nextIndex__;
		if (!this.__redo__) {
			defineProperty(this, '__redo__', d('c', [index]));
			return;
		}
		this.__redo__.forEach(function (redo, i) {
			if (redo >= index) this.__redo__[i] = ++redo;
		}, this);
		this.__redo__.push(index);
	}),
	_onDelete: d(function (index) {
		var i;
		if (index >= this.__nextIndex__) return;
		--this.__nextIndex__;
		if (!this.__redo__) return;
		i = this.__redo__.indexOf(index);
		if (i !== -1) this.__redo__.splice(i, 1);
		this.__redo__.forEach(function (redo, i) {
			if (redo > index) this.__redo__[i] = --redo;
		}, this);
	}),
	_onClear: d(function () {
		if (this.__redo__) clear.call(this.__redo__);
		this.__nextIndex__ = 0;
	})
})));

defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
	return this;
}));
defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.go = exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getUserConfirmation = exports.getCurrentLocation = undefined;

var _LocationUtils = __webpack_require__(12);

var _DOMUtils = __webpack_require__(17);

var _DOMStateStorage = __webpack_require__(50);

var _PathUtils = __webpack_require__(9);

/* eslint-disable no-alert */


var PopStateEvent = 'popstate';

var _createLocation = function _createLocation(historyState) {
  var key = historyState && historyState.key;

  return (0, _LocationUtils.createLocation)({
    pathname: window.location.pathname,
    search: window.location.search,
    hash: window.location.hash,
    state: key ? (0, _DOMStateStorage.readState)(key) : undefined
  }, undefined, key);
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  var historyState = void 0;
  try {
    historyState = window.history.state || {};
  } catch (error) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/mjackson/history/pull/289
    historyState = {};
  }

  return _createLocation(historyState);
};

var getUserConfirmation = exports.getUserConfirmation = function getUserConfirmation(message, callback) {
  return callback(window.confirm(message));
};

var startListener = exports.startListener = function startListener(listener) {
  var handlePopState = function handlePopState(event) {
    if (event.state !== undefined) // Ignore extraneous popstate events in WebKit
      listener(_createLocation(event.state));
  };

  (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);
  };
};

var updateLocation = function updateLocation(location, updateState) {
  var state = location.state;
  var key = location.key;


  if (state !== undefined) (0, _DOMStateStorage.saveState)(key, state);

  updateState({ key: key }, (0, _PathUtils.createPath)(location));
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.pushState(state, null, path);
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.replaceState(state, null, path);
  });
};

var go = exports.go = function go(n) {
  if (n) window.history.go(n);
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AsyncUtils = __webpack_require__(127);

var _PathUtils = __webpack_require__(9);

var _runTransitionHook = __webpack_require__(33);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _Actions = __webpack_require__(20);

var _LocationUtils = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var createHistory = function createHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var getCurrentLocation = options.getCurrentLocation;
  var getUserConfirmation = options.getUserConfirmation;
  var pushLocation = options.pushLocation;
  var replaceLocation = options.replaceLocation;
  var go = options.go;
  var keyLength = options.keyLength;


  var currentLocation = void 0;
  var pendingLocation = void 0;
  var beforeListeners = [];
  var listeners = [];
  var allKeys = [];

  var getCurrentIndex = function getCurrentIndex() {
    if (pendingLocation && pendingLocation.action === _Actions.POP) return allKeys.indexOf(pendingLocation.key);

    if (currentLocation) return allKeys.indexOf(currentLocation.key);

    return -1;
  };

  var updateLocation = function updateLocation(nextLocation) {
    currentLocation = nextLocation;

    var currentIndex = getCurrentIndex();

    if (currentLocation.action === _Actions.PUSH) {
      allKeys = [].concat(_toConsumableArray(allKeys.slice(0, currentIndex + 1)), [currentLocation.key]);
    } else if (currentLocation.action === _Actions.REPLACE) {
      allKeys[currentIndex] = currentLocation.key;
    }

    listeners.forEach(function (listener) {
      return listener(currentLocation);
    });
  };

  var listenBefore = function listenBefore(listener) {
    beforeListeners.push(listener);

    return function () {
      return beforeListeners = beforeListeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var listen = function listen(listener) {
    listeners.push(listener);

    return function () {
      return listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, callback) {
    (0, _AsyncUtils.loopAsync)(beforeListeners.length, function (index, next, done) {
      (0, _runTransitionHook2.default)(beforeListeners[index], location, function (result) {
        return result != null ? done(result) : next();
      });
    }, function (message) {
      if (getUserConfirmation && typeof message === 'string') {
        getUserConfirmation(message, function (ok) {
          return callback(ok !== false);
        });
      } else {
        callback(message !== false);
      }
    });
  };

  var transitionTo = function transitionTo(nextLocation) {
    if (currentLocation && (0, _LocationUtils.locationsAreEqual)(currentLocation, nextLocation) || pendingLocation && (0, _LocationUtils.locationsAreEqual)(pendingLocation, nextLocation)) return; // Nothing to do

    pendingLocation = nextLocation;

    confirmTransitionTo(nextLocation, function (ok) {
      if (pendingLocation !== nextLocation) return; // Transition was interrupted during confirmation

      pendingLocation = null;

      if (ok) {
        // Treat PUSH to same path like REPLACE to be consistent with browsers
        if (nextLocation.action === _Actions.PUSH) {
          var prevPath = (0, _PathUtils.createPath)(currentLocation);
          var nextPath = (0, _PathUtils.createPath)(nextLocation);

          if (nextPath === prevPath && (0, _LocationUtils.statesAreEqual)(currentLocation.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
        }

        if (nextLocation.action === _Actions.POP) {
          updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.PUSH) {
          if (pushLocation(nextLocation) !== false) updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.REPLACE) {
          if (replaceLocation(nextLocation) !== false) updateLocation(nextLocation);
        }
      } else if (currentLocation && nextLocation.action === _Actions.POP) {
        var prevIndex = allKeys.indexOf(currentLocation.key);
        var nextIndex = allKeys.indexOf(nextLocation.key);

        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL
      }
    });
  };

  var push = function push(input) {
    return transitionTo(createLocation(input, _Actions.PUSH));
  };

  var replace = function replace(input) {
    return transitionTo(createLocation(input, _Actions.REPLACE));
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength || 6);
  };

  var createHref = function createHref(location) {
    return (0, _PathUtils.createPath)(location);
  };

  var createLocation = function createLocation(location, action) {
    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
    return (0, _LocationUtils.createLocation)(location, action, key);
  };

  return {
    getCurrentLocation: getCurrentLocation,
    listenBefore: listenBefore,
    listen: listen,
    transitionTo: transitionTo,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    createKey: createKey,
    createPath: _PathUtils.createPath,
    createHref: createHref,
    createLocation: createLocation
  };
};

exports.default = createHistory;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var runTransitionHook = function runTransitionHook(hook, location, callback) {
  var result = hook(location, callback);

  if (hook.length < 2) {
    // Assume the hook runs synchronously and automatically
    // call the callback with the return value.
    callback(result);
  } else {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(result === undefined, 'You should not "return" in a transition hook with a callback argument; ' + 'call the callback instead') : void 0;
  }
};

exports.default = runTransitionHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal ||
  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
    freeSelf || thisGlobal || Function('return this')();

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = root;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60)(module), __webpack_require__(38)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var proto = Element.prototype;
var vendor = proto.matches
  || proto.matchesSelector
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function(sel, data, children, text, elm) {
  var key = data === undefined ? undefined : data.key;
  return {sel: sel, data: data, children: children,
          text: text, elm: elm, key: key};
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var xstream_1 = __webpack_require__(0);
var enums_1 = __webpack_require__(3);
var dom_1 = __webpack_require__(1);
var transition_1 = __webpack_require__(13);
var utils_1 = __webpack_require__(8);
;
var Dimmer;
(function (Dimmer) {
    /**
     * A dimmer wrapper to show extra hidden content on an element.
     * Accepts the following type of target:
     *   VNode - The element to attach the dimmer to.
     *   "Page" - Creates a dimmer for the entire page.
     * Expects the following type of args: Boolean
     * Expects the following type of content: DOMContent
     * @param  {ComponentSources} sources The Component's sources.
     * @return {ComponentSinks} The Dimmer Component.
     */
    function run(sources, invert$) {
        if (invert$ === void 0) { invert$ = xstream_1.default.of(false); }
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".dimmable").events(type); };
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.args$ = sources.args$ ? sources.args$ : onHover(evt);
            var target$ = sources.target$.remember();
            var active$ = sources.args$.remember();
            var transition$ = active$
                .fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? ({ animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out })
                : { animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out
                }; }, ({ animation: enums_1.Animation.None, direction: enums_1.Direction.None }));
            var content$ = xstream_1.default.combine(sources.content$, target$, invert$)
                .map(function (_a) {
                var content = _a[0], target = _a[1], inverted = _a[2];
                return render(content, target, inverted);
            });
            var animatedContent = transition_1.Transition.run({ DOM: sources.DOM, args$: transition$, target$: content$ });
            var vTree$ = xstream_1.default.combine(target$, animatedContent.DOM, active$)
                .map(function (_a) {
                var target = _a[0], content = _a[1], active = _a[2];
                return dimElement(target, content, active);
            });
            return {
                DOM: vTree$,
                Events: animatedContent.Events,
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Dimmer.run = run;
    function render(content, target, inverted) {
        if (content === void 0) { content = ""; }
        if (target === void 0) { target = "page"; }
        if (inverted === void 0) { inverted = false; }
        return target === "page"
            ? dom_1.div({ props: { className: "ui " + (inverted ? "inverted " : "") + "dimmer modals page dimmer" } }, content)
            : dom_1.div({ props: { className: "ui " + (inverted ? "inverted " : "") + "targetted dimmer" } }, [
                dom_1.div({ props: { className: "content" } }, [
                    dom_1.div({ props: { className: "center" } }, content)
                ])
            ]);
    }
    Dimmer.render = render;
    function onHover(events) {
        return xstream_1.default.merge(events("mouseenter"), events("mouseleave"))
            .map(function (evt) { return evt.type === "mouseenter"; }).startWith(false);
    }
    function dimElement(targetOrString, content, active) {
        var isPage = typeof (targetOrString) === "string";
        var target = isPage ? content : targetOrString;
        var className = isPage ? "" : "dimmable", c;
        if (active) {
            className += isPage ? "active" : " dimmed";
        }
        var data = utils_1.patchClassList(target, ["dimmable", "dimmed", "inverted", "active"], className);
        if (isPage) {
            if (target.children) {
                c = target.children;
            }
            else if (target.text) {
                c = target.text;
            }
        }
        else {
            c = utils_1.addElement(content, target, "targetted");
        }
        return dom_1.h(target.sel, data, c);
    }
})(Dimmer = exports.Dimmer || (exports.Dimmer = {}));


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker = (function () {
    function ScopeChecker(scope, isolateModule) {
        this.scope = scope;
        this.isolateModule = isolateModule;
    }
    ScopeChecker.prototype.isStrictlyInRootScope = function (leaf) {
        for (var el = leaf; el; el = el.parentElement) {
            var scope = this.isolateModule.isIsolatedElement(el);
            if (scope && scope !== this.scope) {
                return false;
            }
            if (scope) {
                return true;
            }
        }
        return true;
    };
    return ScopeChecker;
}());
exports.ScopeChecker = ScopeChecker;
//# sourceMappingURL=ScopeChecker.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var xstream_1 = __webpack_require__(0);
function createVTree(vnode, children) {
    return {
        sel: vnode.sel,
        data: vnode.data,
        text: vnode.text,
        elm: vnode.elm,
        key: vnode.key,
        children: children,
    };
}
function makeTransposeVNode(runStreamAdapter) {
    function internalTransposeVNode(vnode) {
        if (!vnode) {
            return null;
        }
        else if (vnode && vnode.data && vnode.data.static) {
            return xstream_1.default.of(vnode);
        }
        else if (runStreamAdapter.isValidStream(vnode)) {
            var xsStream = xstream_adapter_1.default.adapt(vnode, runStreamAdapter.streamSubscribe);
            return xsStream.map(internalTransposeVNode).flatten();
        }
        else if (typeof vnode === "object") {
            if (!vnode.children || vnode.children.length === 0) {
                return xstream_1.default.of(vnode);
            }
            var vnodeChildren = vnode.children
                .map(internalTransposeVNode)
                .filter(function (x) { return x !== null; });
            if (vnodeChildren.length === 0) {
                return xstream_1.default.of(createVTree(vnode, []));
            }
            else {
                return xstream_1.default.combine.apply(xstream_1.default, vnodeChildren)
                    .map(function (children) { return createVTree(vnode, children.slice()); });
            }
        }
        else {
            throw new Error("Unhandled vTree Value");
        }
    }
    ;
    return function transposeVNode(vnode) {
        return internalTransposeVNode(vnode);
    };
}
exports.makeTransposeVNode = makeTransposeVNode;
//# sourceMappingURL=transposition.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * History driver factory
 *
 * This is a function which, when called, returns a History Driver for Cycle.js
 * apps. The driver is also a function, and it takes a stream of new locations
 * (strings representing pathnames or location objects) as input, and outputs
 * another stream of locations that were applied.
 *
 * @param {History} history the History object created by the history library.
 * This object is usually created through `createBrowserHistory()` or
 * `createHashHistory()` or `createMemoryHistory()` from the `history` library.
 * Alternatively, you may use `createServerHistory` from this library.
 * @param {object} options an object with some options specific to this driver.
 * Options may be: `capture`, a boolean to indicate whether the driver should
 * intercept and handle any click event that leads to a link, like on an `<a>`
 * element; `onError`, a callback function that takes an error as argument and
 * handles it, use this to configure what to do with driver errors.
 * @return {Function} the History Driver function
 * @function makeHistoryDriver
 */
var makeHistoryDriver_1 = __webpack_require__(81);
exports.makeHistoryDriver = makeHistoryDriver_1.makeHistoryDriver;
/**
 * Creates a "ServerHistory" object similar to the History objects that the
 * `history` library can create. Use this when you want to support server-side
 * rendering.
 *
 * @param {string|object} location this may be either a string representing the
 * pathname, or a location object with fields like `pathname`, `search`,
 * `query`, `state`, `action`, `key`, `hash`, etc.
 * @return {object} a History object.
 * @function createServerHistory
 */
var serverHistory_1 = __webpack_require__(82);
exports.createServerHistory = serverHistory_1.createServerHistory;
var util_1 = __webpack_require__(42);
exports.supportsHistory = util_1.supportsHistory;
exports.createLocation = util_1.createLocation;
//# sourceMappingURL=index.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var objectAssign = __webpack_require__(56);
function supportsHistory() {
    if (typeof navigator === 'undefined') {
        return false;
    }
    var ua = navigator.userAgent;
    if ((ua.indexOf('Android 2.') !== -1 ||
        ua.indexOf('Android 4.0') !== -1) &&
        ua.indexOf('Mobile Safari') !== -1 &&
        ua.indexOf('Chrome') === -1 &&
        ua.indexOf('Windows Phone') === -1) {
        return false;
    }
    if (typeof window !== 'undefined') {
        return window.history && 'pushState' in window.history;
    }
    else {
        return false;
    }
}
exports.supportsHistory = supportsHistory;
var locationDefaults = {
    pathname: '/',
    action: 'POP',
    hash: '',
    search: '',
    state: undefined,
    key: null,
    query: null,
};
function createLocation(location) {
    if (typeof location === 'string') {
        return objectAssign({}, locationDefaults, { pathname: location });
    }
    return objectAssign({}, locationDefaults, location);
}
exports.createLocation = createLocation;
//# sourceMappingURL=util.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports) {

/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear



var value = __webpack_require__(7);

module.exports = function () {
	value(this).length = 0;
	return this;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = Object.create, getPrototypeOf = Object.getPrototypeOf
  , x = {};

module.exports = function (/*customCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf
	  , customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== 'function') return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554



var isObject      = __webpack_require__(103)
  , value         = __webpack_require__(7)

  , isPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty = Object.defineProperty
  , nullDesc = { configurable: true, enumerable: false, writable: true,
		value: undefined }
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if ((prototype === null) || isObject(prototype)) return obj;
	throw new TypeError('Prototype must be null or an object');
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, 'level', { configurable: false,
		enumerable: false, writable: false, value: status.level });
}((function () {
	var x = Object.create(null), y = {}, set
	  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');

	if (desc) {
		try {
			set = desc.set; // Opera crashes at this point
			set.call(x, y);
		} catch (ignore) { }
		if (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };
	}

	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 2 };

	x = {};
	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 1 };

	return false;
}())));

__webpack_require__(100);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(110)()
	? String.prototype.contains
	: __webpack_require__(111);


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isIterable = __webpack_require__(115);

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(117)() ? Map : __webpack_require__(121);


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readState = exports.saveState = undefined;

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR']; /* eslint-disable no-empty */


var SecurityError = 'SecurityError';
var KeyPrefix = '@@History/';

var createKey = function createKey(key) {
  return KeyPrefix + key;
};

var saveState = exports.saveState = function saveState(key, state) {
  if (!window.sessionStorage) {
    // Session storage is not available or hidden.
    // sessionStorage is undefined in Internet Explorer when served via file protocol.
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available') : void 0;
    return;
  }

  try {
    if (state == null) {
      window.sessionStorage.removeItem(createKey(key));
    } else {
      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
    }
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available due to security settings') : void 0;

      return;
    }

    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
      // Safari "private mode" throws QuotaExceededError.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : void 0;

      return;
    }

    throw error;
  }
};

var readState = exports.readState = function readState(key) {
  var json = void 0;
  try {
    json = window.sessionStorage.getItem(createKey(key));
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to read state; sessionStorage is not available due to security settings') : void 0;

      return undefined;
    }
  }

  if (json) {
    try {
      return JSON.parse(json);
    } catch (error) {
      // Ignore invalid JSON.
    }
  }

  return undefined;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 51 */
/***/ (function(module, exports) {

/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(34);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeHtmlChar(chr) {
  return htmlEscapes[chr];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value.
 * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
 * for more details.
 *
 * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
 * to reduce XSS vectors.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFor = __webpack_require__(138),
    bindCallback = __webpack_require__(141),
    keys = __webpack_require__(146);

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

/**
 * Creates a function for `_.forOwn` or `_.forOwnRight`.
 *
 * @private
 * @param {Function} objectFunc The function to iterate over an object.
 * @returns {Function} Returns the new each function.
 */
function createForOwn(objectFunc) {
  return function(object, iteratee, thisArg) {
    if (typeof iteratee != 'function' || thisArg !== undefined) {
      iteratee = bindCallback(iteratee, thisArg, 3);
    }
    return objectFunc(object, iteratee);
  };
}

/**
 * Iterates over own enumerable properties of an object invoking `iteratee`
 * for each property. The `iteratee` is bound to `thisArg` and invoked with
 * three arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => logs 'a' and 'b' (iteration order is not guaranteed)
 */
var forOwn = createForOwn(baseForOwn);

module.exports = forOwn;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isArguments;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = selectorParser;

var _browserSplit = __webpack_require__(43);

var _browserSplit2 = _interopRequireDefault(_browserSplit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

function selectorParser() {
  var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

  var tagName = void 0;
  var id = '';
  var classes = [];

  var tagParts = (0, _browserSplit2.default)(selector, classIdSplit);

  if (notClassId.test(tagParts[1]) || selector === '') {
    tagName = 'div';
  }

  var part = void 0;
  var type = void 0;
  var i = void 0;

  for (i = 0; i < tagParts.length; i++) {
    part = tagParts[i];

    if (!part) {
      continue;
    }

    type = part.charAt(0);

    if (!tagName) {
      tagName = part;
    } else if (type === '.') {
      classes.push(part.substring(1, part.length));
    } else if (type === '#') {
      id = part.substring(1, part.length);
    }
  }

  return {
    tagName: tagName,
    id: id,
    className: classes.join(' ')
  };
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {


// https://github.com/Matt-Esch/virtual-dom/blob/master/virtual-hyperscript/parse-tag.js

var split = __webpack_require__(43);

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

module.exports = function parseSelector(selector, upper) {
  selector = selector || '';
  var tagName;
  var id = '';
  var classes = [];

  var tagParts = split(selector, classIdSplit);

  if (notClassId.test(tagParts[1]) || selector === '') {
    tagName = 'div';
  }

  var part, type, i;

  for (i = 0; i < tagParts.length; i++) {
    part = tagParts[i];

    if (!part) {
      continue;
    }

    type = part.charAt(0);

    if (!tagName) {
      tagName = part;
    } else if (type === '.') {
      classes.push(part.substring(1, part.length));
    } else if (type === '#') {
      id = part.substring(1, part.length);
    }
  }

  return {
    tagName: upper === true ? tagName.toUpperCase() : tagName,
    id: id,
    className: classes.join(' ')
  };
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(8);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var Menu;
(function (Menu) {
    /**
     * A menu component for displaying an assortment of items.
     * Accepts the following properties:
     * 	secondary?: boolean - Styles the menu to de-emphasize its content.
     * 	pointing?: boolean - Styles the menu to be pointing to nearby content.
     * 	tabular?: boolean - Styles the menu to be suited for tabs.
     * 	text?: boolean - Styles the menu for text content.
     * 	vertical?: boolean - Styles the menu to display its content vertically.
     * 	pagination?: boolean - Formats the menu content to present links to pages of content.
     * 	fixed?: boolean - Styles the menu to appear fixed to its context.
     * 	stackable?: boolean - Ensures the menu content stacks on mobile resolutions.
     * 	inverted?: boolean - Styles the menu to have its colors inverted.
     * 	icon?: boolean - Styles the menu for icon content.
     * 	labelled?: boolean - Styles the menu for labelled icon content.
     * 	compact?: boolean - Styles the menu so that it takes only the amount of space neccesary.
     * 	evenlyDivided?: boolean - Styles the menu so that its content is evenly divided.
     * 	borderless?: boolean - Styles the menu so that there are no borders between its content.
     * 	color?: Color - The color of the menu.
     * 	attachment?: Attachment - The attachment of the menu.
     * 	size?: Size - The size of the menu.
     * Expects the following type of content: Array of {}
     * 	link?: boolean - Styles the item to appear clickable.
     * 	down?: boolean - Styles the item to appear pressed.
     * 	active?: boolean - Styles the item to be more pronounced.
     * 	disabled?: boolean - Styles the item to appear disabled.
     * 	header?: boolean - Styles the item text to be more pronounced.
     * 	fitted?: boolean - Removes the padding of the item.
     *         icon?: boolean - Styles the item for icon content.
     * 	color?: Color - The color of the item.
     * 	float? Float - The alignment of the item.
     * 	href?: string - The link for the item.
     * 	body: DOMContent - The content of the item.
     */
    function run(sources) {
        function main(sources) {
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            var click$ = sources.DOM.select(".ui.menu > .item").events("click");
            var items$ = sources.content$.remember();
            var clickedId$ = click$.map(function (ev) { return parseInt(ev.currentTarget.id); })
                .filter(function (n) { return !isNaN(n) && typeof (n) !== "undefined"; });
            var clickedItem$ = items$.map(function (items) { return clickedId$.map(function (id) { return items[id]; }); }).flatten()
                .filter(function (item) { return !item.disabled; });
            var vtree$ = xstream_1.default.combine(sources.props$, items$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vtree$,
                Events: function (type) { return sources.DOM.select(".menu").events(type); },
                value$: clickedItem$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Menu.run = run;
    /**
     * A menu component for displaying an assortment of items.
     * Accepts the following properties:
     * 	secondary?: boolean - Styles the menu to de-emphasize its content.
     * 	pointing?: boolean - Styles the menu to be pointing to nearby content.
     * 	tabular?: boolean - Styles the menu to be suited for tabs.
     * 	text?: boolean - Styles the menu for text content.
     * 	vertical?: boolean - Styles the menu to display its content vertically.
     * 	pagination?: boolean - Formats the menu content to present links to pages of content.
     * 	fixed?: boolean - Styles the menu to appear fixed to its context.
     * 	stackable?: boolean - Ensures the menu content stacks on mobile resolutions.
     * 	inverted?: boolean - Styles the menu to have its colors inverted.
     * 	icon?: boolean - Styles the menu for icon content.
     * 	labelled?: boolean - Styles the menu for labelled icon content.
     * 	compact?: boolean - Styles the menu so that it takes only the amount of space neccesary.
     * 	evenlyDivided?: boolean - Styles the menu so that its content is evenly divided.
     * 	borderless?: boolean - Styles the menu so that there are no borders between its content.
     * 	color?: Color - The color of the menu.
     * 	attachment?: Attachment - The attachment of the menu.
     * 	size?: Size - The size of the menu.
     * Expects the following type of content: Array of {}
     * 	link?: boolean - Styles the item to appear clickable.
     * 	down?: boolean - Styles the item to appear pressed.
     * 	active?: boolean - Styles the item to be more pronounced.
     * 	disabled?: boolean - Styles the item to appear disabled.
     * 	header?: boolean - Styles the item text to be more pronounced.
     * 	fitted?: boolean - Removes the padding of the item.
     *  icon?: boolean - Styles the item for icon content.
     * 	color?: Color - The color of the item.
     * 	float? Float - The alignment of the item.
     * 	href?: string - The link for the item.
     * 	body: DOMContent - The content of the item.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        var items = content.map(function (item) { return item.href
            ? dom_1.a({ props: { className: getItemClassname(item), id: content.indexOf(item), href: item.href } }, item.body)
            : dom_1.div({ props: { className: getItemClassname(item), id: content.indexOf(item) } }, item.body); });
        return dom_1.div({ props: { className: getClassname(props, content.length) } }, items);
    }
    Menu.render = render;
    function getClassname(props, length) {
        var className;
        if (!props.submenu) {
            className = "ui";
        }
        if (props.secondary) {
            className += " secondary";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (props.tabular) {
            className += " tabular";
        }
        if (props.text) {
            className += " text";
        }
        if (props.vertical) {
            className += " vertical";
        }
        if (props.pagination) {
            className += " pagination";
        }
        if (props.fixed) {
            className += " fixed";
        }
        if (props.stackable) {
            className += " stackable";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.labelled) {
            className += " labelled icon";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.borderless) {
            className += " borderless";
        }
        if (props.evenlyDivided) {
            className += utils_1.numToText(length) + " item";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " menu";
        return className;
    }
    function getItemClassname(item) {
        var className = "";
        if (item.down) {
            className += " down";
        }
        if (item.active) {
            className += " active";
        }
        if (item.header) {
            className += " header";
        }
        if (item.fitted) {
            className += " vertically fitted";
        }
        if (item.link) {
            className += " link";
        }
        if (item.icon) {
            className += " icon";
        }
        if (item.disabled) {
            className += " disabled";
        }
        if (typeof (item.float) !== "undefined") {
            className += enums_1.Float.ToClassname(item.float);
        }
        if (typeof (item.color) !== "undefined") {
            className += enums_1.Color.ToClassname(item.color);
        }
        className += " item";
        return className;
    }
})(Menu = exports.Menu || (exports.Menu = {}));


/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var DebounceOperator = (function () {
    function DebounceOperator(dt, ins) {
        this.dt = dt;
        this.ins = ins;
        this.type = 'debounce';
        this.out = null;
        this.id = null;
    }
    DebounceOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DebounceOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
        this.id = null;
    };
    DebounceOperator.prototype.clearInterval = function () {
        var id = this.id;
        if (id !== null) {
            clearInterval(id);
        }
        this.id = null;
    };
    DebounceOperator.prototype._n = function (t) {
        var _this = this;
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        this.id = setInterval(function () {
            _this.clearInterval();
            u._n(t);
        }, this.dt);
    };
    DebounceOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        u._e(err);
    };
    DebounceOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        this.clearInterval();
        u._c();
    };
    return DebounceOperator;
}());
/**
 * Delays events until a certain amount of silence has passed. If that timespan
 * of silence is not met the event is dropped.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2--3--4----5|
 *     debounce(60)
 * -----1----------4--|
 * ```
 *
 * Example:
 *
 * ```js
 * import fromDiagram from 'xstream/extra/fromDiagram'
 * import debounce from 'xstream/extra/debounce'
 *
 * const stream = fromDiagram('--1----2--3--4----5|')
 *  .compose(debounce(60))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1
 * > 4
 * > completed
 * ```
 *
 * @param {number} period The amount of silence required in milliseconds.
 * @return {Stream}
 */
function debounce(period) {
    return function debounceOperator(ins) {
        return new index_1.Stream(new DebounceOperator(period, ins));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = debounce;
//# sourceMappingURL=debounce.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var DelayOperator = (function () {
    function DelayOperator(dt, ins) {
        this.dt = dt;
        this.ins = ins;
        this.type = 'delay';
        this.out = null;
    }
    DelayOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DelayOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
    };
    DelayOperator.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._n(t);
            clearInterval(id);
        }, this.dt);
    };
    DelayOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._e(err);
            clearInterval(id);
        }, this.dt);
    };
    DelayOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        var id = setInterval(function () {
            u._c();
            clearInterval(id);
        }, this.dt);
    };
    return DelayOperator;
}());
/**
 * Delays periodic events by a given time period.
 *
 * Marble diagram:
 *
 * ```text
 * 1----2--3--4----5|
 *     delay(60)
 * ---1----2--3--4----5|
 * ```
 *
 * Example:
 *
 * ```js
 * import fromDiagram from 'xstream/extra/fromDiagram'
 * import delay from 'xstream/extra/delay'
 *
 * const stream = fromDiagram('1----2--3--4----5|')
 *  .compose(delay(60))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1  (after 60 ms)
 * > 2  (after 160 ms)
 * > 3  (after 220 ms)
 * > 4  (after 280 ms)
 * > 5  (after 380 ms)
 * > completed
 * ```
 *
 * @param {number} period The amount of silence required in milliseconds.
 * @return {Stream}
 */
function delay(period) {
    return function delayOperator(ins) {
        return new index_1.Stream(new DelayOperator(period, ins));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = delay;
//# sourceMappingURL=delay.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var empty = {};
var DropRepeatsOperator = (function () {
    function DropRepeatsOperator(ins, fn) {
        this.ins = ins;
        this.fn = fn;
        this.type = 'dropRepeats';
        this.out = null;
        this.v = empty;
    }
    DropRepeatsOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    DropRepeatsOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.out = null;
        this.v = empty;
    };
    DropRepeatsOperator.prototype.isEq = function (x, y) {
        return this.fn ? this.fn(x, y) : x === y;
    };
    DropRepeatsOperator.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        var v = this.v;
        if (v !== empty && this.isEq(t, v))
            return;
        this.v = Array.isArray(t) ? t.slice() : t;
        u._n(t);
    };
    DropRepeatsOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    DropRepeatsOperator.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        u._c();
    };
    return DropRepeatsOperator;
}());
exports.DropRepeatsOperator = DropRepeatsOperator;
/**
 * Drops consecutive duplicate values in a stream.
 *
 * Marble diagram:
 *
 * ```text
 * --1--2--1--1--1--2--3--4--3--3|
 *     dropRepeats
 * --1--2--1--------2--3--4--3---|
 * ```
 *
 * Example:
 *
 * ```js
 * import dropRepeats from 'xstream/extra/dropRepeats'
 *
 * const stream = xs.of(1, 2, 1, 1, 1, 2, 3, 4, 3, 3)
 *   .compose(dropRepeats())
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > 1
 * > 2
 * > 1
 * > 2
 * > 3
 * > 4
 * > 3
 * > completed
 * ```
 *
 * Example with a custom isEqual function:
 *
 * ```js
 * import dropRepeats from 'xstream/extra/dropRepeats'
 *
 * const stream = xs.of('a', 'b', 'a', 'A', 'B', 'b')
 *   .compose(dropRepeats((x, y) => x.toLowerCase() === y.toLowerCase()))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > a
 * > b
 * > a
 * > B
 * > completed
 * ```
 *
 * @param {Function} isEqual An optional function of type
 * `(x: T, y: T) => boolean` that takes an event from the input stream and
 * checks if it is equal to previous event, by returning a boolean.
 * @return {Stream}
 */
function dropRepeats(isEqual) {
    if (isEqual === void 0) { isEqual = void 0; }
    return function dropRepeatsOperator(ins) {
        return new index_1.Stream(new DropRepeatsOperator(ins, isEqual));
    };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = dropRepeats;
//# sourceMappingURL=dropRepeats.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_run_1 = __webpack_require__(83);
var dom_1 = __webpack_require__(1);
var cyclic_router_1 = __webpack_require__(86);
var history_1 = __webpack_require__(133);
var xstream_1 = __webpack_require__(0);
var switch_path_1 = __webpack_require__(169);
var router_1 = __webpack_require__(181);
var routes_1 = __webpack_require__(182);
var layout_1 = __webpack_require__(179);
var history = cyclic_router_1.supportsHistory()
    ? [history_1.createHistory(), switch_path_1.default, { capture: true }]
    : [history_1.createHashHistory(), switch_path_1.default, { capture: true }];
function app(drivers) {
    var page = router_1.default(Object.assign({}, drivers, { routes: routes_1.default }));
    var layout = layout_1.Layout.run(drivers, page);
    var sinks = {
        DOM: layout.DOM,
        router: xstream_1.default.merge(page.router, layout.router),
    };
    return sinks;
}
xstream_run_1.run(app, {
    DOM: dom_1.makeDOMDriver(".app"),
    router: cyclic_router_1.makeRouterDriver.apply(null, history),
});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var fromEvent_1 = __webpack_require__(24);
var BodyDOMSource = (function () {
    function BodyDOMSource(_runStreamAdapter, _name) {
        this._runStreamAdapter = _runStreamAdapter;
        this._name = _name;
    }
    BodyDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    BodyDOMSource.prototype.elements = function () {
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(xstream_1.default.of(document.body), xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    BodyDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        var stream;
        if (options && typeof options.useCapture === 'boolean') {
            stream = fromEvent_1.fromEvent(document.body, eventType, options.useCapture);
        }
        else {
            stream = fromEvent_1.fromEvent(document.body, eventType);
        }
        var out = this._runStreamAdapter.adapt(stream, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    return BodyDOMSource;
}());
exports.BodyDOMSource = BodyDOMSource;
//# sourceMappingURL=BodyDOMSource.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var fromEvent_1 = __webpack_require__(24);
var DocumentDOMSource = (function () {
    function DocumentDOMSource(_runStreamAdapter, _name) {
        this._runStreamAdapter = _runStreamAdapter;
        this._name = _name;
    }
    DocumentDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    DocumentDOMSource.prototype.elements = function () {
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(xstream_1.default.of(document), xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    DocumentDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        var stream;
        if (options && typeof options.useCapture === 'boolean') {
            stream = fromEvent_1.fromEvent(document, eventType, options.useCapture);
        }
        else {
            stream = fromEvent_1.fromEvent(document, eventType);
        }
        var out = this._runStreamAdapter.adapt(stream, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    return DocumentDOMSource;
}());
exports.DocumentDOMSource = DocumentDOMSource;
//# sourceMappingURL=DocumentDOMSource.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker_1 = __webpack_require__(39);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(35);
}
catch (e) {
    matchesSelector = Function.prototype;
}
function toElArray(input) {
    return Array.prototype.slice.call(input);
}
var ElementFinder = (function () {
    function ElementFinder(namespace, isolateModule) {
        this.namespace = namespace;
        this.isolateModule = isolateModule;
    }
    ElementFinder.prototype.call = function (rootElement) {
        var namespace = this.namespace;
        if (namespace.join("") === "") {
            return rootElement;
        }
        var scope = utils_1.getScope(namespace);
        var scopeChecker = new ScopeChecker_1.ScopeChecker(scope, this.isolateModule);
        var selector = utils_1.getSelectors(namespace);
        var topNode = rootElement;
        var topNodeMatches = [];
        if (scope.length > 0) {
            topNode = this.isolateModule.getIsolatedElement(scope) || rootElement;
            if (selector && matchesSelector(topNode, selector)) {
                topNodeMatches.push(topNode);
            }
        }
        return toElArray(topNode.querySelectorAll(selector))
            .filter(scopeChecker.isStrictlyInRootScope, scopeChecker)
            .concat(topNodeMatches);
    };
    return ElementFinder;
}());
exports.ElementFinder = ElementFinder;
//# sourceMappingURL=ElementFinder.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ScopeChecker_1 = __webpack_require__(39);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(35);
}
catch (e) {
    matchesSelector = Function.prototype;
}
var gDestinationId = 0;
function findDestinationId(arr, searchId) {
    var minIndex = 0;
    var maxIndex = arr.length - 1;
    var currentIndex;
    var currentElement;
    while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0; // tslint:disable-line:no-bitwise
        currentElement = arr[currentIndex];
        var currentId = currentElement.destinationId;
        if (currentId < searchId) {
            minIndex = currentIndex + 1;
        }
        else if (currentId > searchId) {
            maxIndex = currentIndex - 1;
        }
        else {
            return currentIndex;
        }
    }
    return -1;
}
/**
 * Attaches an actual event listener to the DOM root element,
 * handles "destinations" (interested DOMSource output subjects), and bubbling.
 */
var EventDelegator = (function () {
    function EventDelegator(topElement, eventType, useCapture, isolateModule) {
        var _this = this;
        this.topElement = topElement;
        this.eventType = eventType;
        this.useCapture = useCapture;
        this.isolateModule = isolateModule;
        this.destinations = [];
        this.roof = topElement.parentElement;
        if (useCapture) {
            this.domListener = function (ev) { return _this.capture(ev); };
        }
        else {
            this.domListener = function (ev) { return _this.bubble(ev); };
        }
        topElement.addEventListener(eventType, this.domListener, useCapture);
    }
    EventDelegator.prototype.bubble = function (rawEvent) {
        if (!this.topElement.contains(rawEvent.currentTarget)) {
            return;
        }
        var ev = this.patchEvent(rawEvent);
        for (var el = ev.target; el && el !== this.roof; el = el.parentElement) {
            if (!this.topElement.contains(el)) {
                ev.stopPropagation();
            }
            if (ev.propagationHasBeenStopped) {
                return;
            }
            this.matchEventAgainstDestinations(el, ev);
        }
    };
    EventDelegator.prototype.matchEventAgainstDestinations = function (el, ev) {
        for (var i = 0, n = this.destinations.length; i < n; i++) {
            var dest = this.destinations[i];
            if (!dest.scopeChecker.isStrictlyInRootScope(el)) {
                continue;
            }
            if (matchesSelector(el, dest.selector)) {
                this.mutateEventCurrentTarget(ev, el);
                dest.subject._n(ev);
            }
        }
    };
    EventDelegator.prototype.capture = function (ev) {
        for (var i = 0, n = this.destinations.length; i < n; i++) {
            var dest = this.destinations[i];
            if (matchesSelector(ev.target, dest.selector)) {
                dest.subject._n(ev);
            }
        }
    };
    EventDelegator.prototype.addDestination = function (subject, namespace, destinationId) {
        var scope = utils_1.getScope(namespace);
        var selector = utils_1.getSelectors(namespace);
        var scopeChecker = new ScopeChecker_1.ScopeChecker(scope, this.isolateModule);
        this.destinations.push({ subject: subject, scopeChecker: scopeChecker, selector: selector, destinationId: destinationId });
    };
    EventDelegator.prototype.createDestinationId = function () {
        return gDestinationId++;
    };
    EventDelegator.prototype.removeDestinationId = function (destinationId) {
        var i = findDestinationId(this.destinations, destinationId);
        if (i >= 0) {
            this.destinations.splice(i, 1);
        }
    };
    EventDelegator.prototype.patchEvent = function (event) {
        var pEvent = event;
        pEvent.propagationHasBeenStopped = false;
        var oldStopPropagation = pEvent.stopPropagation;
        pEvent.stopPropagation = function stopPropagation() {
            oldStopPropagation.call(this);
            this.propagationHasBeenStopped = true;
        };
        return pEvent;
    };
    EventDelegator.prototype.mutateEventCurrentTarget = function (event, currentTargetElement) {
        try {
            Object.defineProperty(event, "currentTarget", {
                value: currentTargetElement,
                configurable: true,
            });
        }
        catch (err) {
            console.log("please use event.ownerTarget");
        }
        event.ownerTarget = currentTargetElement;
    };
    EventDelegator.prototype.updateTopElement = function (newTopElement) {
        this.topElement.removeEventListener(this.eventType, this.domListener, this.useCapture);
        newTopElement.addEventListener(this.eventType, this.domListener, this.useCapture);
        this.topElement = newTopElement;
    };
    return EventDelegator;
}());
exports.EventDelegator = EventDelegator;
//# sourceMappingURL=EventDelegator.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_1 = __webpack_require__(0);
var xstream_adapter_1 = __webpack_require__(6);
var HTMLSource = (function () {
    function HTMLSource(html$, runSA, _name) {
        this.runSA = runSA;
        this._name = _name;
        this._html$ = html$;
        this._empty$ = runSA.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
    }
    HTMLSource.prototype.elements = function () {
        var out = this.runSA.adapt(this._html$, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = this._name;
        return out;
    };
    HTMLSource.prototype.select = function (selector) {
        return new HTMLSource(xstream_1.default.empty(), this.runSA, this._name);
    };
    HTMLSource.prototype.events = function (eventType, options) {
        var out = this._empty$;
        out._isCycleSource = this._name;
        return out;
    };
    return HTMLSource;
}());
exports.HTMLSource = HTMLSource;
//# sourceMappingURL=HTMLSource.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var DocumentDOMSource_1 = __webpack_require__(67);
var BodyDOMSource_1 = __webpack_require__(66);
var xstream_1 = __webpack_require__(0);
var ElementFinder_1 = __webpack_require__(68);
var fromEvent_1 = __webpack_require__(24);
var isolate_1 = __webpack_require__(74);
var EventDelegator_1 = __webpack_require__(69);
var utils_1 = __webpack_require__(15);
var matchesSelector;
try {
    matchesSelector = __webpack_require__(35);
}
catch (e) {
    matchesSelector = Function.prototype;
}
var eventTypesThatDontBubble = [
    "blur",
    "canplay",
    "canplaythrough",
    "change",
    "durationchange",
    "emptied",
    "ended",
    "focus",
    "load",
    "loadeddata",
    "loadedmetadata",
    "mouseenter",
    "mouseleave",
    "pause",
    "play",
    "playing",
    "ratechange",
    "reset",
    "scroll",
    "seeked",
    "seeking",
    "stalled",
    "submit",
    "suspend",
    "timeupdate",
    "unload",
    "volumechange",
    "waiting",
];
function determineUseCapture(eventType, options) {
    var result = false;
    if (typeof options.useCapture === 'boolean') {
        result = options.useCapture;
    }
    if (eventTypesThatDontBubble.indexOf(eventType) !== -1) {
        result = true;
    }
    return result;
}
function filterBasedOnIsolation(domSource, scope) {
    return function filterBasedOnIsolationOperator(rootElement$) {
        return rootElement$
            .fold(function shouldPass(state, element) {
            var hasIsolated = !!domSource._isolateModule.getIsolatedElement(scope);
            var shouldPass = hasIsolated && !state.hadIsolatedMutable;
            return { hadIsolatedMutable: hasIsolated, shouldPass: shouldPass, element: element };
        }, { hadIsolatedMutable: false, shouldPass: false, element: null })
            .drop(1)
            .filter(function (s) { return s.shouldPass; })
            .map(function (s) { return s.element; });
    };
}
var MainDOMSource = (function () {
    function MainDOMSource(_rootElement$, _sanitation$, _runStreamAdapter, _namespace, _isolateModule, _delegators, _name) {
        var _this = this;
        if (_namespace === void 0) { _namespace = []; }
        this._rootElement$ = _rootElement$;
        this._sanitation$ = _sanitation$;
        this._runStreamAdapter = _runStreamAdapter;
        this._namespace = _namespace;
        this._isolateModule = _isolateModule;
        this._delegators = _delegators;
        this._name = _name;
        this.__JANI_EVAKALLIO_WE_WILL_MISS_YOU_PLEASE_COME_BACK_EVENTUALLY = false;
        this.__JANI_EVAKALLIO_WE_WILL_MISS_YOU_PLEASE_COME_BACK_EVENTUALLY = true;
        this.isolateSource = isolate_1.isolateSource;
        this.isolateSink = function (sink, scope) {
            var existingScope = utils_1.getScope(_this._namespace);
            var deeperScope = [existingScope, scope].filter(function (x) { return !!x; }).join('-');
            return isolate_1.isolateSink(sink, deeperScope);
        };
    }
    MainDOMSource.prototype.elements = function () {
        var output$;
        if (this._namespace.length === 0) {
            output$ = this._rootElement$;
        }
        else {
            var elementFinder_1 = new ElementFinder_1.ElementFinder(this._namespace, this._isolateModule);
            output$ = this._rootElement$.map(function (el) { return elementFinder_1.call(el); });
        }
        var runSA = this._runStreamAdapter;
        var out = runSA.remember(runSA.adapt(output$, xstream_adapter_1.default.streamSubscribe));
        out._isCycleSource = this._name;
        return out;
    };
    Object.defineProperty(MainDOMSource.prototype, "namespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    MainDOMSource.prototype.select = function (selector) {
        if (typeof selector !== 'string') {
            throw new Error("DOM driver's select() expects the argument to be a " +
                "string as a CSS selector");
        }
        if (selector === 'document') {
            return new DocumentDOMSource_1.DocumentDOMSource(this._runStreamAdapter, this._name);
        }
        if (selector === 'body') {
            return new BodyDOMSource_1.BodyDOMSource(this._runStreamAdapter, this._name);
        }
        var trimmedSelector = selector.trim();
        var childNamespace = trimmedSelector === ":root" ?
            this._namespace :
            this._namespace.concat(trimmedSelector);
        return new MainDOMSource(this._rootElement$, this._sanitation$, this._runStreamAdapter, childNamespace, this._isolateModule, this._delegators, this._name);
    };
    MainDOMSource.prototype.events = function (eventType, options) {
        if (options === void 0) { options = {}; }
        if (typeof eventType !== "string") {
            throw new Error("DOM driver's events() expects argument to be a " +
                "string representing the event type to listen for.");
        }
        var useCapture = determineUseCapture(eventType, options);
        var namespace = this._namespace;
        var scope = utils_1.getScope(namespace);
        var keyParts = [eventType, useCapture];
        if (scope) {
            keyParts.push(scope);
        }
        var key = keyParts.join('~');
        var domSource = this;
        var rootElement$;
        if (scope) {
            rootElement$ = this._rootElement$
                .compose(filterBasedOnIsolation(domSource, scope));
        }
        else {
            rootElement$ = this._rootElement$.take(2);
        }
        var event$ = rootElement$
            .map(function setupEventDelegatorOnTopElement(rootElement) {
            // Event listener just for the root element
            if (!namespace || namespace.length === 0) {
                return fromEvent_1.fromEvent(rootElement, eventType, useCapture);
            }
            // Event listener on the top element as an EventDelegator
            var delegators = domSource._delegators;
            var top = domSource._isolateModule.getIsolatedElement(scope) || rootElement;
            var delegator;
            if (delegators.has(key)) {
                delegator = delegators.get(key);
                delegator.updateTopElement(top);
            }
            else {
                delegator = new EventDelegator_1.EventDelegator(top, eventType, useCapture, domSource._isolateModule);
                delegators.set(key, delegator);
            }
            if (scope) {
                domSource._isolateModule.addEventDelegator(scope, delegator);
            }
            var destinationId = delegator.createDestinationId();
            var subject = xstream_1.default.create({
                start: function () { },
                stop: function () {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(function () {
                            delegator.removeDestinationId(destinationId);
                        });
                    }
                    else {
                        delegator.removeDestinationId(destinationId);
                    }
                },
            });
            delegator.addDestination(subject, namespace, destinationId);
            return subject;
        })
            .flatten();
        var out = this._runStreamAdapter.adapt(event$, xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = domSource._name;
        return out;
    };
    MainDOMSource.prototype.dispose = function () {
        this._sanitation$.shamefullySendNext('');
        this._isolateModule.reset();
    };
    return MainDOMSource;
}());
exports.MainDOMSource = MainDOMSource;
//# sourceMappingURL=MainDOMSource.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hyperscript_1 = __webpack_require__(25);
var classNameFromVNode_1 = __webpack_require__(151);
var selectorParser_1 = __webpack_require__(57);
var VNodeWrapper = (function () {
    function VNodeWrapper(rootElement) {
        this.rootElement = rootElement;
    }
    VNodeWrapper.prototype.call = function (vnode) {
        var _a = selectorParser_1.default(vnode.sel), selectorTagName = _a.tagName, selectorId = _a.id;
        var vNodeClassName = classNameFromVNode_1.default(vnode);
        var vNodeData = vnode.data || {};
        var vNodeDataProps = vNodeData.props || {};
        var _b = vNodeDataProps.id, vNodeId = _b === void 0 ? selectorId : _b;
        var isVNodeAndRootElementIdentical = vNodeId.toUpperCase() === this.rootElement.id.toUpperCase() &&
            selectorTagName.toUpperCase() === this.rootElement.tagName.toUpperCase() &&
            vNodeClassName.toUpperCase() === this.rootElement.className.toUpperCase();
        if (isVNodeAndRootElementIdentical) {
            return vnode;
        }
        var _c = this.rootElement, tagName = _c.tagName, id = _c.id, className = _c.className;
        var elementId = id ? "#" + id : "";
        var elementClassName = className ?
            "." + className.split(" ").join(".") : "";
        return hyperscript_1.h("" + tagName.toLowerCase() + elementId + elementClassName, {}, [
            vnode,
        ]);
    };
    return VNodeWrapper;
}());
exports.VNodeWrapper = VNodeWrapper;
//# sourceMappingURL=VNodeWrapper.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hyperscript_1 = __webpack_require__(25);
function isValidString(param) {
    return typeof param === 'string' && param.length > 0;
}
function isSelector(param) {
    return isValidString(param) && (param[0] === '.' || param[0] === '#');
}
function createTagFunction(tagName) {
    return function hyperscript(first, b, c) {
        if (isSelector(first)) {
            if (typeof b !== 'undefined' && typeof c !== 'undefined') {
                return hyperscript_1.h(tagName + first, b, c);
            }
            else if (typeof b !== 'undefined') {
                return hyperscript_1.h(tagName + first, b);
            }
            else {
                return hyperscript_1.h(tagName + first, {});
            }
        }
        else if (!!b) {
            return hyperscript_1.h(tagName, first, b);
        }
        else if (!!first) {
            return hyperscript_1.h(tagName, first);
        }
        else {
            return hyperscript_1.h(tagName, {});
        }
    };
}
var SVG_TAG_NAMES = [
    'a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
    'animateMotion', 'animateTransform', 'circle', 'clipPath', 'colorProfile',
    'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
    'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting',
    'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB',
    'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',
    'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting',
    'feSpotlight', 'feTile', 'feTurbulence', 'filter', 'font', 'fontFace',
    'fontFaceFormat', 'fontFaceName', 'fontFaceSrc', 'fontFaceUri',
    'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line',
    'linearGradient', 'marker', 'mask', 'metadata', 'missingGlyph', 'mpath',
    'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script',
    'set', 'stop', 'style', 'switch', 'symbol', 'text', 'textPath', 'title',
    'tref', 'tspan', 'use', 'view', 'vkern',
];
var svg = createTagFunction('svg');
SVG_TAG_NAMES.forEach(function (tag) {
    svg[tag] = createTagFunction(tag);
});
var TAG_NAMES = [
    'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base',
    'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption',
    'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'dir', 'div', 'dl',
    'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html',
    'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend',
    'li', 'link', 'main', 'map', 'mark', 'menu', 'meta', 'nav', 'noscript',
    'object', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'progress', 'q',
    'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small',
    'source', 'span', 'strong', 'style', 'sub', 'sup', 'table', 'tbody', 'td',
    'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'u', 'ul', 'video',
];
var exported = { SVG_TAG_NAMES: SVG_TAG_NAMES, TAG_NAMES: TAG_NAMES, svg: svg, isSelector: isSelector, createTagFunction: createTagFunction };
TAG_NAMES.forEach(function (n) {
    exported[n] = createTagFunction(n);
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exported;
//# sourceMappingURL=hyperscript-helpers.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils_1 = __webpack_require__(15);
function isolateSource(source, scope) {
    return source.select(utils_1.SCOPE_PREFIX + scope);
}
exports.isolateSource = isolateSource;
function isolateSink(sink, scope) {
    return sink.map(function (vTree) {
        if (vTree.data && vTree.data.isolate) {
            var existingScope = vTree.data.isolate.replace(/(cycle|\-)/g, '');
            var _scope = scope.replace(/(cycle|\-)/g, '');
            if (isNaN(parseInt(existingScope))
                || isNaN(parseInt(_scope))
                || existingScope > _scope) {
                return vTree;
            }
        }
        vTree.data = vTree.data || {};
        vTree.data.isolate = scope;
        if (typeof vTree.key === 'undefined') {
            vTree.key = utils_1.SCOPE_PREFIX + scope;
        }
        return vTree;
    });
}
exports.isolateSink = isolateSink;
//# sourceMappingURL=isolate.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MapPolyfill = __webpack_require__(49);
var IsolateModule = (function () {
    function IsolateModule(isolatedElements) {
        this.isolatedElements = isolatedElements;
        this.eventDelegators = new MapPolyfill();
    }
    IsolateModule.prototype.setScope = function (elm, scope) {
        this.isolatedElements.set(scope, elm);
    };
    IsolateModule.prototype.removeScope = function (scope) {
        this.isolatedElements.delete(scope);
    };
    IsolateModule.prototype.cleanupVNode = function (_a) {
        var data = _a.data, elm = _a.elm;
        data = data || {};
        var scope = data.isolate || '';
        var isCurrentElm = this.isolatedElements.get(scope) === elm;
        if (scope && isCurrentElm) {
            this.removeScope(scope);
            if (this.eventDelegators.get(scope)) {
                this.eventDelegators.set(scope, []);
            }
        }
    };
    IsolateModule.prototype.getIsolatedElement = function (scope) {
        return this.isolatedElements.get(scope);
    };
    IsolateModule.prototype.isIsolatedElement = function (elm) {
        var iterator = this.isolatedElements.entries();
        for (var result = iterator.next(); !!result.value; result = iterator.next()) {
            var _a = result.value, scope = _a[0], element = _a[1];
            if (elm === element) {
                return scope;
            }
        }
        return false;
    };
    IsolateModule.prototype.addEventDelegator = function (scope, eventDelegator) {
        var delegators = this.eventDelegators.get(scope);
        if (!delegators) {
            delegators = [];
            this.eventDelegators.set(scope, delegators);
        }
        delegators[delegators.length] = eventDelegator;
    };
    IsolateModule.prototype.reset = function () {
        this.isolatedElements.clear();
    };
    IsolateModule.prototype.createModule = function () {
        var self = this;
        return {
            create: function (oldVNode, vNode) {
                var _a = oldVNode.data, oldData = _a === void 0 ? {} : _a;
                var elm = vNode.elm, _b = vNode.data, data = _b === void 0 ? {} : _b;
                var oldScope = oldData.isolate || "";
                var scope = data.isolate || "";
                if (scope) {
                    if (oldScope) {
                        self.removeScope(oldScope);
                    }
                    self.setScope(elm, scope);
                    var delegators = self.eventDelegators.get(scope);
                    if (delegators) {
                        for (var i = 0, len = delegators.length; i < len; ++i) {
                            delegators[i].updateTopElement(elm);
                        }
                    }
                    else if (delegators === void 0) {
                        self.eventDelegators.set(scope, []);
                    }
                }
                if (oldScope && !scope) {
                    self.removeScope(scope);
                }
            },
            update: function (oldVNode, vNode) {
                var _a = oldVNode.data, oldData = _a === void 0 ? {} : _a;
                var elm = vNode.elm, _b = vNode.data, data = _b === void 0 ? {} : _b;
                var oldScope = oldData.isolate || "";
                var scope = data.isolate || "";
                if (scope && scope !== oldScope) {
                    if (oldScope) {
                        self.removeScope(oldScope);
                    }
                    self.setScope(elm, scope);
                }
                if (oldScope && !scope) {
                    self.removeScope(scope);
                }
            },
            remove: function (vNode, cb) {
                self.cleanupVNode(vNode);
                cb();
            },
            destroy: function (vNode) {
                self.cleanupVNode(vNode);
            },
        };
    };
    return IsolateModule;
}());
exports.IsolateModule = IsolateModule;
//# sourceMappingURL=isolateModule.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var snabbdom_1 = __webpack_require__(166);
var xstream_1 = __webpack_require__(0);
var MainDOMSource_1 = __webpack_require__(71);
var VNodeWrapper_1 = __webpack_require__(72);
var utils_1 = __webpack_require__(15);
var modules_1 = __webpack_require__(79);
var isolateModule_1 = __webpack_require__(75);
var transposition_1 = __webpack_require__(40);
var xstream_adapter_1 = __webpack_require__(6);
var MapPolyfill = __webpack_require__(49);
function makeDOMDriverInputGuard(modules) {
    if (!Array.isArray(modules)) {
        throw new Error("Optional modules option must be " +
            "an array for snabbdom modules");
    }
}
function domDriverInputGuard(view$) {
    if (!view$
        || typeof view$.addListener !== "function"
        || typeof view$.fold !== "function") {
        throw new Error("The DOM driver function expects as input a Stream of " +
            "virtual DOM elements");
    }
}
function makeDOMDriver(container, options) {
    if (!options) {
        options = {};
    }
    var transposition = options.transposition || false;
    var modules = options.modules || modules_1.default;
    var isolateModule = new isolateModule_1.IsolateModule((new MapPolyfill()));
    var patch = snabbdom_1.init([isolateModule.createModule()].concat(modules));
    var rootElement = utils_1.getElement(container);
    var vnodeWrapper = new VNodeWrapper_1.VNodeWrapper(rootElement);
    var delegators = new MapPolyfill();
    makeDOMDriverInputGuard(modules);
    function DOMDriver(vnode$, runStreamAdapter, name) {
        domDriverInputGuard(vnode$);
        var transposeVNode = transposition_1.makeTransposeVNode(runStreamAdapter);
        var preprocessedVNode$ = (transposition ? vnode$.map(transposeVNode).flatten() : vnode$);
        var sanitation$ = xstream_1.default.create();
        var rootElement$ = xstream_1.default.merge(preprocessedVNode$.endWhen(sanitation$), sanitation$)
            .map(function (vnode) { return vnodeWrapper.call(vnode); })
            .fold(patch, rootElement)
            .drop(1)
            .map(function unwrapElementFromVNode(vnode) { return vnode.elm; })
            .compose(function (stream) { return xstream_1.default.merge(stream, xstream_1.default.never()); }) // don't complete this stream
            .startWith(rootElement);
        rootElement$.addListener({ next: function () { }, error: function () { }, complete: function () { } });
        return new MainDOMSource_1.MainDOMSource(rootElement$, sanitation$, runStreamAdapter, [], isolateModule, delegators, name);
    }
    ;
    DOMDriver.streamAdapter = xstream_adapter_1.default;
    return DOMDriver;
}
exports.makeDOMDriver = makeDOMDriver;
//# sourceMappingURL=makeDOMDriver.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var transposition_1 = __webpack_require__(40);
var HTMLSource_1 = __webpack_require__(70);
var toHTML = __webpack_require__(153);
var noop = function () { };
function makeHTMLDriver(effect, options) {
    if (!options) {
        options = {};
    }
    var transposition = options.transposition || false;
    function htmlDriver(vnode$, runStreamAdapter, name) {
        var transposeVNode = transposition_1.makeTransposeVNode(runStreamAdapter);
        var preprocessedVNode$ = (transposition ? vnode$.map(transposeVNode).flatten() : vnode$);
        var html$ = preprocessedVNode$.map(toHTML);
        html$.addListener({
            next: effect || noop,
            error: noop,
            complete: noop,
        });
        return new HTMLSource_1.HTMLSource(html$, runStreamAdapter, name);
    }
    ;
    htmlDriver.streamAdapter = xstream_adapter_1.default;
    return htmlDriver;
}
exports.makeHTMLDriver = makeHTMLDriver;
//# sourceMappingURL=makeHTMLDriver.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var xstream_adapter_1 = __webpack_require__(6);
var xstream_1 = __webpack_require__(0);
var SCOPE_PREFIX = '___';
var MockedDOMSource = (function () {
    function MockedDOMSource(_streamAdapter, _mockConfig) {
        this._streamAdapter = _streamAdapter;
        this._mockConfig = _mockConfig;
        if (_mockConfig.elements) {
            this._elements = _mockConfig.elements;
        }
        else {
            this._elements = _streamAdapter.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
        }
    }
    MockedDOMSource.prototype.elements = function () {
        var out = this._elements;
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.events = function (eventType, options) {
        var mockConfig = this._mockConfig;
        var keys = Object.keys(mockConfig);
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
            var key = keys[i];
            if (key === eventType) {
                var out_1 = mockConfig[key];
                out_1._isCycleSource = 'MockedDOM';
                return out_1;
            }
        }
        var out = this._streamAdapter.adapt(xstream_1.default.empty(), xstream_adapter_1.default.streamSubscribe);
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.select = function (selector) {
        var mockConfig = this._mockConfig;
        var keys = Object.keys(mockConfig);
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
            var key = keys[i];
            if (key === selector) {
                return new MockedDOMSource(this._streamAdapter, mockConfig[key]);
            }
        }
        return new MockedDOMSource(this._streamAdapter, {});
    };
    MockedDOMSource.prototype.isolateSource = function (source, scope) {
        return source.select('.' + SCOPE_PREFIX + scope);
    };
    MockedDOMSource.prototype.isolateSink = function (sink, scope) {
        return sink.map(function (vnode) {
            if (vnode.sel && vnode.sel.indexOf(SCOPE_PREFIX + scope) !== -1) {
                return vnode;
            }
            else {
                vnode.sel += "." + SCOPE_PREFIX + scope;
                return vnode;
            }
        });
    };
    return MockedDOMSource;
}());
exports.MockedDOMSource = MockedDOMSource;
function mockDOMSource(streamAdapter, mockConfig) {
    return new MockedDOMSource(streamAdapter, mockConfig);
}
exports.mockDOMSource = mockDOMSource;
//# sourceMappingURL=mockDOMSource.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ClassModule = __webpack_require__(161);
exports.ClassModule = ClassModule;
var PropsModule = __webpack_require__(164);
exports.PropsModule = PropsModule;
var AttrsModule = __webpack_require__(160);
exports.AttrsModule = AttrsModule;
var EventsModule = __webpack_require__(162);
exports.EventsModule = EventsModule;
var StyleModule = __webpack_require__(165);
exports.StyleModule = StyleModule;
var HeroModule = __webpack_require__(163);
exports.HeroModule = HeroModule;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = [StyleModule, ClassModule, PropsModule, AttrsModule];
//# sourceMappingURL=modules.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var clickEvent = 'undefined' !== typeof document && document.ontouchstart ?
    'touchstart' : 'click';
function which(ev) {
    if (typeof window === 'undefined') {
        return false;
    }
    var e = ev || window.event;
    return e.which === null ? e.button : e.which;
}
function sameOrigin(href) {
    if (typeof window === 'undefined') {
        return false;
    }
    return href && href.indexOf(window.location.origin) === 0;
}
function makeClickListener(push) {
    return function clickListener(event) {
        if (which(event) !== 1) {
            return;
        }
        if (event.metaKey || event.ctrlKey || event.shiftKey) {
            return;
        }
        if (event.defaultPrevented) {
            return;
        }
        var element = event.target;
        while (element && element.nodeName !== 'A') {
            element = element.parentNode;
        }
        if (!element || element.nodeName !== 'A') {
            return;
        }
        if (element.hasAttribute('download') ||
            element.getAttribute('rel') === 'external') {
            return;
        }
        if (element.target) {
            return;
        }
        var link = element.getAttribute('href');
        if (link && link.indexOf('mailto:') > -1 || link.charAt(0) === '#') {
            return;
        }
        if (!sameOrigin(element.href)) {
            return;
        }
        event.preventDefault();
        var pathname = element.pathname, search = element.search, _a = element.hash, hash = _a === void 0 ? '' : _a;
        push(pathname + search + hash);
    };
}
function captureClicks(push) {
    var listener = makeClickListener(push);
    if (typeof window !== 'undefined') {
        document.addEventListener(clickEvent, listener, false);
    }
}
exports.captureClicks = captureClicks;
//# sourceMappingURL=captureClicks.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var captureClicks_1 = __webpack_require__(80);
function makeUpdateHistory(history) {
    return function updateHistory(location) {
        if (typeof location === 'string') {
            history.push(history.createLocation(location));
        }
        else if (typeof location === 'object') {
            // suport things like history.replace()
            var _a = location.type, type = _a === void 0 ? 'push' : _a;
            if (type === 'go') {
                history[type](location);
            }
            else {
                history[type](location);
            }
        }
        else {
            throw new Error('History Driver input must be a string or an ' +
                'object but received ${typeof url}');
        }
    };
}
function defaultOnErrorFn(err) {
    if (console && console.error !== void 0) {
        console.error(err);
    }
}
function makeHistoryDriver(history, options) {
    if (!history || typeof history !== 'object'
        || typeof history.createLocation !== 'function'
        || typeof history.createHref !== 'function'
        || typeof history.listen !== 'function'
        || typeof history.push !== 'function') {
        throw new TypeError('makeHistoryDriver requires an valid history object ' +
            'containing createLocation(), createHref(), push(), and listen() methods');
    }
    var capture = options && options.capture || false;
    var onError = options && options.onError || defaultOnErrorFn;
    return function historyDriver(sink$, runSA) {
        var _a = runSA.makeSubject(), observer = _a.observer, stream = _a.stream;
        var history$ = runSA.remember(stream
            .startWith(history.getCurrentLocation())
            .filter(Boolean));
        var unlisten = history.listen(function (location) {
            observer.next(location);
        });
        if (typeof history.addCompleteCallback === 'function'
            && typeof history.complete === 'function') {
            history.addCompleteCallback(function () {
                observer.complete();
            });
        }
        runSA.streamSubscribe(sink$, {
            next: makeUpdateHistory(history),
            error: onError,
            complete: function () {
                unlisten();
                observer.complete();
            },
        });
        if (capture) {
            captureClicks_1.captureClicks(function (pathname) {
                var location = history.createLocation(pathname);
                history.push(location);
            });
        }
        history$.createHref = function (href) { return history.createHref(href); };
        history$.createLocation = function (location) { return history.createLocation(location); };
        return history$;
    };
}
exports.makeHistoryDriver = makeHistoryDriver;
//# sourceMappingURL=makeHistoryDriver.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util_1 = __webpack_require__(42);
var ServerHistory = (function () {
    function ServerHistory(currentLocation) {
        this.currentLocation = currentLocation;
        this.listeners = [];
    }
    ServerHistory.prototype.listen = function (listener) {
        this.listeners.push(listener);
        return function noop() { return void 0; };
    };
    ServerHistory.prototype.push = function (location) {
        var length = this.listeners.length;
        if (length === 0) {
            throw new Error('Must be given at least one listener before pushing');
        }
        for (var i = 0; i < length; ++i) {
            this.listeners[i](util_1.createLocation(location));
        }
    };
    ServerHistory.prototype.replace = function (location) {
        this.push(location);
    };
    ServerHistory.prototype.createHref = function (path) {
        return path;
    };
    ServerHistory.prototype.createLocation = function (location) {
        return util_1.createLocation(location);
    };
    ServerHistory.prototype.getCurrentLocation = function () {
        return this.currentLocation;
    };
    ServerHistory.prototype.addCompleteCallback = function (complete) {
        this._completeCallback = complete;
    };
    ServerHistory.prototype.complete = function () {
        this._completeCallback();
    };
    return ServerHistory;
}());
function createServerHistory(loc) {
    return new ServerHistory(loc ? util_1.createLocation(loc) : null);
}
exports.createServerHistory = createServerHistory;
//# sourceMappingURL=serverHistory.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var base_1 = __webpack_require__(84);
var xstream_adapter_1 = __webpack_require__(6);
/**
 * Takes a `main` function and circularly connects it to the given collection
 * of driver functions.
 *
 * **Example:**
 * ```js
 * import {run} from '@cycle/xstream-run';
 * const dispose = run(main, drivers);
 * // ...
 * dispose();
 * ```
 *
 * The `main` function expects a collection of "source" streams (returned from
 * drivers) as input, and should return a collection of "sink" streams (to be
 * given to drivers). A "collection of streams" is a JavaScript object where
 * keys match the driver names registered by the `drivers` object, and values
 * are the streams. Refer to the documentation of each driver to see more
 * details on what types of sources it outputs and sinks it receives.
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Function} a dispose function, used to terminate the execution of the
 * Cycle.js program, cleaning up resources used.
 * @function run
 */
function run(main, drivers) {
    var _a = base_1.default(main, drivers, { streamAdapter: xstream_adapter_1.default }), run = _a.run, sinks = _a.sinks;
    if (typeof window !== 'undefined' && window['CyclejsDevTool_startGraphSerializer']) {
        window['CyclejsDevTool_startGraphSerializer'](sinks);
    }
    return run();
}
exports.run = run;
/**
 * A function that prepares the Cycle application to be executed. Takes a `main`
 * function and prepares to circularly connects it to the given collection of
 * driver functions. As an output, `Cycle()` returns an object with three
 * properties: `sources`, `sinks` and `run`. Only when `run()` is called will
 * the application actually execute. Refer to the documentation of `run()` for
 * more details.
 *
 * **Example:**
 * ```js
 * import Cycle from '@cycle/xstream-run';
 * const {sources, sinks, run} = Cycle(main, drivers);
 * // ...
 * const dispose = run(); // Executes the application
 * // ...
 * dispose();
 * ```
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Object} an object with three properties: `sources`, `sinks` and
 * `run`. `sources` is the collection of driver sources, `sinks` is the
 * collection of driver sinks, these can be used for debugging or testing. `run`
 * is the function that once called will execute the application.
 * @function Cycle
 */
var Cycle = function (main, drivers) {
    var out = base_1.default(main, drivers, { streamAdapter: xstream_adapter_1.default });
    if (typeof window !== 'undefined' && window['CyclejsDevTool_startGraphSerializer']) {
        window['CyclejsDevTool_startGraphSerializer'](out.sinks);
    }
    return out;
};
Cycle.run = run;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Cycle;
//# sourceMappingURL=index.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function logToConsoleError(err) {
    var target = err.stack || err;
    if (console && console.error) {
        console.error(target);
    }
    else if (console && console.log) {
        console.log(target);
    }
}
function makeSinkProxies(drivers, streamAdapter) {
    var sinkProxies = {};
    for (var name_1 in drivers) {
        if (drivers.hasOwnProperty(name_1)) {
            var subject = streamAdapter.makeSubject();
            var driverStreamAdapter = drivers[name_1].streamAdapter || streamAdapter;
            var stream = driverStreamAdapter.adapt(subject.stream, streamAdapter.streamSubscribe);
            sinkProxies[name_1] = {
                stream: stream,
                observer: subject.observer,
            };
        }
    }
    return sinkProxies;
}
function callDrivers(drivers, sinkProxies, streamAdapter) {
    var sources = {};
    for (var name_2 in drivers) {
        if (drivers.hasOwnProperty(name_2)) {
            var driverOutput = drivers[name_2](sinkProxies[name_2].stream, streamAdapter, name_2);
            var driverStreamAdapter = drivers[name_2].streamAdapter;
            if (driverStreamAdapter && driverStreamAdapter.isValidStream(driverOutput)) {
                sources[name_2] = streamAdapter.adapt(driverOutput, driverStreamAdapter.streamSubscribe);
            }
            else {
                sources[name_2] = driverOutput;
            }
            if (sources[name_2] && typeof sources[name_2] === 'object') {
                sources[name_2]._isCycleSource = name_2;
            }
        }
    }
    return sources;
}
function replicateMany(sinks, sinkProxies, streamAdapter) {
    var sinkNames = Object.keys(sinks).filter(function (name) { return !!sinkProxies[name]; });
    var buffers = {};
    var replicators = {};
    sinkNames.forEach(function (name) {
        buffers[name] = { next: [], error: [], complete: [] };
        replicators[name] = {
            next: function (x) { return buffers[name].next.push(x); },
            error: function (x) { return buffers[name].error.push(x); },
            complete: function (x) { return buffers[name].complete.push(x); },
        };
    });
    var subscriptions = sinkNames.map(function (name) {
        return streamAdapter.streamSubscribe(sinks[name], {
            next: function (x) {
                replicators[name].next(x);
            },
            error: function (err) {
                logToConsoleError(err);
                replicators[name].error(err);
            },
            complete: function (x) {
                replicators[name].complete(x);
            },
        });
    });
    var disposeFunctions = subscriptions
        .filter(function (fn) { return typeof fn === 'function'; });
    sinkNames.forEach(function (name) {
        var observer = sinkProxies[name].observer;
        var next = observer.next;
        var error = observer.error;
        var complete = observer.complete;
        buffers[name].next.forEach(next);
        buffers[name].error.forEach(error);
        buffers[name].complete.forEach(complete);
        replicators[name].next = next;
        replicators[name].error = error;
        replicators[name].complete = complete;
    });
    return function () {
        disposeFunctions.forEach(function (dispose) { return dispose(); });
    };
}
function disposeSources(sources) {
    for (var k in sources) {
        if (sources.hasOwnProperty(k) && sources[k]
            && typeof sources[k].dispose === 'function') {
            sources[k].dispose();
        }
    }
}
var isObjectEmpty = function (obj) { return Object.keys(obj).length === 0; };
function Cycle(main, drivers, options) {
    if (typeof main !== "function") {
        throw new Error("First argument given to Cycle must be the 'main' " +
            "function.");
    }
    if (typeof drivers !== "object" || drivers === null) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with driver functions as properties.");
    }
    if (isObjectEmpty(drivers)) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with at least one driver function declared as a property.");
    }
    var streamAdapter = options.streamAdapter;
    if (!streamAdapter || isObjectEmpty(streamAdapter)) {
        throw new Error("Third argument given to Cycle must be an options object " +
            "with the streamAdapter key supplied with a valid stream adapter.");
    }
    var sinkProxies = makeSinkProxies(drivers, streamAdapter);
    var sources = callDrivers(drivers, sinkProxies, streamAdapter);
    var sinks = main(sources);
    if (typeof window !== 'undefined') {
        window.Cyclejs = { sinks: sinks };
    }
    var run = function () {
        var disposeReplication = replicateMany(sinks, sinkProxies, streamAdapter);
        return function () {
            disposeSources(sources);
            disposeReplication();
        };
    };
    return { sinks: sinks, sources: sources, run: run };
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Cycle;
//# sourceMappingURL=index.js.map

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(88);
function isStrictlyInScope(namespace, path) {
    var pathParts = util.splitPath(path);
    return namespace.every(function (v, i) {
        return pathParts[i] === v;
    });
}
function getFilteredPath(namespace, path) {
    var pathParts = util.splitPath(path);
    return '/' + util.filterPath(pathParts, namespace);
}
var RouterSource = (function () {
    function RouterSource(history$, _namespace, _createHref, _runSA, _routeMatcher) {
        this.history$ = history$;
        this._namespace = _namespace;
        this._createHref = _createHref;
        this._runSA = _runSA;
        this._routeMatcher = _routeMatcher;
    }
    RouterSource.prototype.path = function (pathname) {
        var scopedNamespace = this._namespace.concat(util.splitPath(pathname));
        var scopedHistory$ = this._runSA.remember(this.history$
            .filter(function (_a) {
            var _path = _a.pathname;
            return isStrictlyInScope(scopedNamespace, _path);
        }));
        var createHref = this._createHref;
        return new RouterSource(scopedHistory$, scopedNamespace, createHref, this._runSA, this._routeMatcher);
    };
    RouterSource.prototype.define = function (routes, routeMatcher) {
        var _this = this;
        var namespace = this._namespace;
        var _createHref = this._createHref;
        var createHref = util.makeCreateHref(namespace, _createHref);
        var match$ = this._runSA.remember(this.history$
            .map(function (location) {
            var matcher = routeMatcher || _this._routeMatcher;
            var filteredPath = getFilteredPath(namespace, location.pathname);
            var _a = matcher(filteredPath, routes), path = _a.path, value = _a.value;
            return { path: path, value: value, location: location, createHref: createHref };
        }));
        match$.createHref = createHref;
        return match$;
    };
    RouterSource.prototype.createHref = function (path) {
        return util.makeCreateHref(this._namespace, this._createHref)(path);
    };
    return RouterSource;
}());
exports.RouterSource = RouterSource;
//# sourceMappingURL=RouterSource.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var makeRouterDriver_1 = __webpack_require__(87);
exports.makeRouterDriver = makeRouterDriver_1.makeRouterDriver;
var history_1 = __webpack_require__(41);
exports.supportsHistory = history_1.supportsHistory;
exports.createLocation = history_1.createLocation;
exports.createServerHistory = history_1.createServerHistory;
//# sourceMappingURL=index.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var history_1 = __webpack_require__(41);
var RouterSource_1 = __webpack_require__(85);
/**
 * Instantiates an new router driver function using the same arguments required
 * by @cycle/history.
 * @public
 * @method makeRouterDriver
 * @return {routerDriver} The router driver function
 */
function makeRouterDriver(history, routeMatcher, options) {
    var historyDriver = history_1.makeHistoryDriver(history, options);
    /**
     * The actual router driver.
     * @public
     * @typedef {routerDriver}
     * @name routerDriver
     * @method routerDriver
     * @param  {Stream<string|Location>} sink$ - This is the same input that the
     * history driver would expect.
     * @return {routerAPI}
     */
    return function routerDriver(sink$, runSA) {
        var history$ = runSA.remember(historyDriver(sink$, runSA));
        return new RouterSource_1.RouterSource(history$, [], history.createHref, runSA, routeMatcher);
    };
}
exports.makeRouterDriver = makeRouterDriver;
//# sourceMappingURL=makeRouterDriver.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function splitPath(path) {
    return path.split('/').filter(function (p) { return p.length > 0; });
}
exports.splitPath = splitPath;
function filterPath(pathParts, namespace) {
    return pathParts.filter(function (part) { return namespace.indexOf(part) < 0; }).join('/');
}
exports.filterPath = filterPath;
var startsWith = function (param, value) { return param[0] === value; };
var startsWith2 = function (param, value1, value2) {
    return param[0] === value1 && param[1] === value2;
};
function makeCreateHref(namespace, _createHref) {
    /**
     * Function used to create HREFs that are properly namespaced
     * @typedef {createHref}
     * @name createHref
     * @method createHref
     * @param  {string} path - the HREF that will be appended to the current
     * namespace
     * @return {string} a fully qualified HREF composed from the current
     * namespace and the path provided
     */
    return function createHref(path) {
        var fullPath = "" + namespace.join('/') + path;
        return startsWith(fullPath, '/') || startsWith2(fullPath, '#', '/')
            ? _createHref(fullPath)
            : _createHref('/' + fullPath);
    };
}
exports.makeCreateHref = makeCreateHref;
//# sourceMappingURL=util.js.map

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copy       = __webpack_require__(99)
  , map        = __webpack_require__(107)
  , callable   = __webpack_require__(11)
  , validValue = __webpack_require__(7)

  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, bindTo) {
	var value = validValue(desc) && callable(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, bindTo*/) {
	var bindTo = arguments[1];
	return map(props, function (desc, name) {
		return define(name, desc, bindTo);
	});
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toPosInt = __webpack_require__(95)
  , value    = __webpack_require__(7)

  , indexOf = Array.prototype.indexOf
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , abs = Math.abs, floor = Math.floor;

module.exports = function (searchElement/*, fromIndex*/) {
	var i, l, fromIndex, val;
	if (searchElement === searchElement) { //jslint: ignore
		return indexOf.apply(this, arguments);
	}

	l = toPosInt(value(this).length);
	fromIndex = arguments[1];
	if (isNaN(fromIndex)) fromIndex = 0;
	else if (fromIndex >= 0) fromIndex = floor(fromIndex);
	else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

	for (i = fromIndex; i < l; ++i) {
		if (hasOwnProperty.call(this, i)) {
			val = this[i];
			if (val !== val) return i; //jslint: ignore
		}
	}
	return -1;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(92)()
	? Math.sign
	: __webpack_require__(93);


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== 'function') return false;
	return ((sign(10) === 1) && (sign(-20) === -1));
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) return value;
	return (value > 0) ? 1 : -1;
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var sign = __webpack_require__(91)

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if ((value === 0) || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(94)

  , max = Math.max;

module.exports = function (value) { return max(0, toInteger(value)); };


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order



var callable = __webpack_require__(11)
  , value    = __webpack_require__(7)

  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys
  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== 'function') method = list[method];
		return call.call(method, list, function (key, index) {
			if (!propertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys  = __webpack_require__(104)
  , value = __webpack_require__(7)

  , max = Math.max;

module.exports = function (dest, src/*, …srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(27)
  , value  = __webpack_require__(7);

module.exports = function (obj) {
	var copy = Object(value(obj));
	if (copy !== obj) return copy;
	return assign({}, obj);
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804



var create = Object.create, shim;

if (!__webpack_require__(45)()) {
	shim = __webpack_require__(46);
}

module.exports = (function () {
	var nullObject, props, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	props = {};
	desc = { configurable: false, enumerable: false, writable: true,
		value: undefined };
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === '__proto__') {
			props[name] = { configurable: true, enumerable: false, writable: true,
				value: undefined };
			return;
		}
		props[name] = desc;
	});
	Object.defineProperties(nullObject, props);

	Object.defineProperty(shim, 'nullPolyfill', { configurable: false,
		enumerable: false, writable: false, value: nullObject });

	return function (prototype, props) {
		return create((prototype === null) ? nullObject : prototype, props);
	};
}());


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(96)('forEach');


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Deprecated



module.exports = function (obj) { return typeof obj === 'function'; };


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var map = { function: true, object: true };

module.exports = function (x) {
	return ((x != null) && map[typeof x]) || false;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(105)()
	? Object.keys
	: __webpack_require__(106);


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callable = __webpack_require__(11)
  , forEach  = __webpack_require__(101)

  , call = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var o = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, obj, index) {
		o[key] = call.call(cb, thisArg, value, key, obj, index);
	});
	return o;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, …options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = Array.prototype.forEach, create = Object.create;

module.exports = function (arg/*, …args*/) {
	var set = create(null);
	forEach.call(arguments, function (name) { set[name] = true; });
	return set;
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(19)
  , contains       = __webpack_require__(47)
  , d              = __webpack_require__(10)
  , Iterator       = __webpack_require__(29)

  , defineProperty = Object.defineProperty
  , ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
	Iterator.call(this, arr);
	if (!kind) kind = 'value';
	else if (contains.call(kind, 'key+value')) kind = 'key+value';
	else if (contains.call(kind, 'key')) kind = 'key';
	else kind = 'value';
	defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(ArrayIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__list__[i];
		if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
		return i;
	}),
	toString: d(function () { return '[object Array Iterator]'; })
});


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(26)
  , callable    = __webpack_require__(11)
  , isString    = __webpack_require__(28)
  , get         = __webpack_require__(114)

  , isArray = Array.isArray, call = Function.prototype.call
  , some = Array.prototype.some;

module.exports = function (iterable, cb/*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = 'array';
	else if (isString(iterable)) mode = 'string';
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () { broken = true; };
	if (mode === 'array') {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			if (broken) return true;
		});
		return;
	}
	if (mode === 'string') {
		l = iterable.length;
		for (i = 0; i < l; ++i) {
			char = iterable[i];
			if ((i + 1) < l) {
				code = char.charCodeAt(0);
				if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(26)
  , isString       = __webpack_require__(28)
  , ArrayIterator  = __webpack_require__(112)
  , StringIterator = __webpack_require__(116)
  , iterable       = __webpack_require__(48)
  , iteratorSymbol = __webpack_require__(16).iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(26)
  , isString       = __webpack_require__(28)
  , iteratorSymbol = __webpack_require__(16).iterator

  , isArray = Array.isArray;

module.exports = function (value) {
	if (value == null) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return (typeof value[iteratorSymbol] === 'function');
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols



var setPrototypeOf = __webpack_require__(19)
  , d              = __webpack_require__(10)
  , Iterator       = __webpack_require__(29)

  , defineProperty = Object.defineProperty
  , StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) return new StringIterator(str);
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, '__length__', d('', str.length));

};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

StringIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(StringIterator),
	_next: d(function () {
		if (!this.__list__) return;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
		return char;
	}),
	toString: d(function () { return '[object String Iterator]'; })
});


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var map, iterator, result;
	if (typeof Map !== 'function') return false;
	try {
		// WebKit doesn't support arguments and crashes
		map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
	} catch (e) {
		return false;
	}
	if (String(map) !== '[object Map]') return false;
	if (map.size !== 3) return false;
	if (typeof map.clear !== 'function') return false;
	if (typeof map.delete !== 'function') return false;
	if (typeof map.entries !== 'function') return false;
	if (typeof map.forEach !== 'function') return false;
	if (typeof map.get !== 'function') return false;
	if (typeof map.has !== 'function') return false;
	if (typeof map.keys !== 'function') return false;
	if (typeof map.set !== 'function') return false;
	if (typeof map.values !== 'function') return false;

	iterator = map.entries();
	result = iterator.next();
	if (result.done !== false) return false;
	if (!result.value) return false;
	if (result.value[0] !== 'raz') return false;
	if (result.value[1] !== 'one') return false;

	return true;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Exports true if environment provides native `Map` implementation,
// whatever that is.



module.exports = (function () {
	if (typeof Map === 'undefined') return false;
	return (Object.prototype.toString.call(new Map()) === '[object Map]');
}());


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109)('key',
	'value', 'key+value');


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf    = __webpack_require__(19)
  , d                 = __webpack_require__(10)
  , Iterator          = __webpack_require__(29)
  , toStringTagSymbol = __webpack_require__(16).toStringTag
  , kinds             = __webpack_require__(119)

  , defineProperties = Object.defineProperties
  , unBind = Iterator.prototype._unBind
  , MapIterator;

MapIterator = module.exports = function (map, kind) {
	if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
	Iterator.call(this, map.__mapKeysData__, map);
	if (!kind || !kinds[kind]) kind = 'key+value';
	defineProperties(this, {
		__kind__: d('', kind),
		__values__: d('w', map.__mapValuesData__)
	});
};
if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);

MapIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(MapIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__values__[i];
		if (this.__kind__ === 'key') return this.__list__[i];
		return [this.__list__[i], this.__values__[i]];
	}),
	_unBind: d(function () {
		this.__values__ = null;
		unBind.call(this);
	}),
	toString: d(function () { return '[object Map Iterator]'; })
});
Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
	d('c', 'Map Iterator'));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear          = __webpack_require__(44)
  , eIndexOf       = __webpack_require__(90)
  , setPrototypeOf = __webpack_require__(19)
  , callable       = __webpack_require__(11)
  , validValue     = __webpack_require__(7)
  , d              = __webpack_require__(10)
  , ee             = __webpack_require__(126)
  , Symbol         = __webpack_require__(16)
  , iterator       = __webpack_require__(48)
  , forOf          = __webpack_require__(113)
  , Iterator       = __webpack_require__(120)
  , isNative       = __webpack_require__(118)

  , call = Function.prototype.call
  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf
  , MapPoly;

module.exports = MapPoly = function (/*iterable*/) {
	var iterable = arguments[0], keys, values, self;
	if (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (Map !== MapPoly)) {
		self = setPrototypeOf(new Map(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) iterator(iterable);
	defineProperties(self, {
		__mapKeysData__: d('c', keys = []),
		__mapValuesData__: d('c', values = [])
	});
	if (!iterable) return self;
	forOf(iterable, function (value) {
		var key = validValue(value)[0];
		value = value[1];
		if (eIndexOf.call(keys, key) !== -1) return;
		keys.push(key);
		values.push(value);
	}, self);
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
	MapPoly.prototype = Object.create(Map.prototype, {
		constructor: d(MapPoly)
	});
}

ee(defineProperties(MapPoly.prototype, {
	clear: d(function () {
		if (!this.__mapKeysData__.length) return;
		clear.call(this.__mapKeysData__);
		clear.call(this.__mapValuesData__);
		this.emit('_clear');
	}),
	delete: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return false;
		this.__mapKeysData__.splice(index, 1);
		this.__mapValuesData__.splice(index, 1);
		this.emit('_delete', index, key);
		return true;
	}),
	entries: d(function () { return new Iterator(this, 'key+value'); }),
	forEach: d(function (cb/*, thisArg*/) {
		var thisArg = arguments[1], iterator, result;
		callable(cb);
		iterator = this.entries();
		result = iterator._next();
		while (result !== undefined) {
			call.call(cb, thisArg, this.__mapValuesData__[result],
				this.__mapKeysData__[result], this);
			result = iterator._next();
		}
	}),
	get: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return;
		return this.__mapValuesData__[index];
	}),
	has: d(function (key) {
		return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
	}),
	keys: d(function () { return new Iterator(this, 'key'); }),
	set: d(function (key, value) {
		var index = eIndexOf.call(this.__mapKeysData__, key), emit;
		if (index === -1) {
			index = this.__mapKeysData__.push(key) - 1;
			emit = true;
		}
		this.__mapValuesData__[index] = value;
		if (emit) this.emit('_add', index, key);
		return this;
	}),
	size: d.gs(function () { return this.__mapKeysData__.length; }),
	values: d(function () { return new Iterator(this, 'value'); }),
	toString: d(function () { return '[object Map]'; })
}));
Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
	return this.entries();
}));
Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var validTypes = { object: true, symbol: true };

module.exports = function () {
	var symbol;
	if (typeof Symbol !== 'function') return false;
	symbol = Symbol('test symbol');
	try { String(symbol); } catch (e) { return false; }

	// Return 'true' also for polyfills
	if (!validTypes[typeof Symbol.iterator]) return false;
	if (!validTypes[typeof Symbol.toPrimitive]) return false;
	if (!validTypes[typeof Symbol.toStringTag]) return false;

	return true;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (x) {
	if (!x) return false;
	if (typeof x === 'symbol') return true;
	if (!x.constructor) return false;
	if (x.constructor.name !== 'Symbol') return false;
	return (x[x.constructor.toStringTag] === 'Symbol');
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ES2015 Symbol polyfill for environments that do not support it (or partially support it)



var d              = __webpack_require__(10)
  , validateSymbol = __webpack_require__(125)

  , create = Object.create, defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
  , isNativeSafe;

if (typeof Symbol === 'function') {
	NativeSymbol = Symbol;
	try {
		String(NativeSymbol());
		isNativeSafe = true;
	} catch (ignore) {}
}

var generateName = (function () {
	var created = create(null);
	return function (desc) {
		var postfix = 0, name, ie11BugWorkaround;
		while (created[desc + (postfix || '')]) ++postfix;
		desc += (postfix || '');
		created[desc] = true;
		name = '@@' + desc;
		defineProperty(objPrototype, name, d.gs(null, function (value) {
			// For IE11 issue see:
			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
			//    ie11-broken-getters-on-dom-objects
			// https://github.com/medikoo/es6-symbol/issues/12
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		}));
		return name;
	};
}());

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
	return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
	if (isNativeSafe) return NativeSymbol(description);
	symbol = create(HiddenSymbol.prototype);
	description = (description === undefined ? '' : String(description));
	return defineProperties(symbol, {
		__description__: d('', description),
		__name__: d('', generateName(description))
	});
};
defineProperties(SymbolPolyfill, {
	for: d(function (key) {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
	keyFor: d(function (s) {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

	// If there's native implementation of given symbol, let's fallback to it
	// to ensure proper interoperability with other native functions e.g. Array.from
	hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
	isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
		SymbolPolyfill('isConcatSpreadable')),
	iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
	match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
	replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
	search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
	species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
	split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
	toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
	toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
	unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
});

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d('', function () { return this.__name__; })
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
	var symbol = validateSymbol(this);
	if (typeof symbol === 'symbol') return symbol;
	return symbol.toString();
}));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(123);

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d        = __webpack_require__(10)
  , callable = __webpack_require__(11)

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {
  var currentTurn = 0,
      isDone = false;
  var isSync = false,
      hasNext = false,
      doneArgs = void 0;

  var done = function done() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    isDone = true;

    if (isSync) {
      // Iterate instead of recursing if possible.
      doneArgs = args;
      return;
    }

    callback.apply(undefined, args);
  };

  var next = function next() {
    if (isDone) return;

    hasNext = true;

    if (isSync) return; // Iterate instead of recursing if possible.

    isSync = true;

    while (!isDone && currentTurn < turns && hasNext) {
      hasNext = false;
      work(currentTurn++, next, done);
    }

    isSync = false;

    if (isDone) {
      // This means the loop finished synchronously.
      callback.apply(undefined, _toConsumableArray(doneArgs));
      return;
    }

    if (currentTurn >= turns && hasNext) {
      isDone = true;
      callback();
    }
  };

  next();
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = __webpack_require__(30);

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _LocationUtils = __webpack_require__(12);

var _DOMUtils = __webpack_require__(17);

var _DOMStateStorage = __webpack_require__(50);

var _PathUtils = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.substring(index + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var i = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
};

var ensureSlash = function ensureSlash() {
  var path = getHashPath();

  if ((0, _PathUtils.isAbsolutePath)(path)) return true;

  replaceHashPath('/' + path);

  return false;
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation(queryKey) {
  var path = getHashPath();
  var key = (0, _PathUtils.getQueryStringValueFromPath)(path, queryKey);

  var state = void 0;
  if (key) {
    path = (0, _PathUtils.stripQueryStringValueFromPath)(path, queryKey);
    state = (0, _DOMStateStorage.readState)(key);
  }

  var init = (0, _PathUtils.parsePath)(path);
  init.state = state;

  return (0, _LocationUtils.createLocation)(init, undefined, key);
};

var prevLocation = void 0;

var startListener = exports.startListener = function startListener(listener, queryKey) {
  var handleHashChange = function handleHashChange() {
    if (!ensureSlash()) return; // Hash path must always begin with a /

    var currentLocation = getCurrentLocation(queryKey);

    if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key) return; // Ignore extraneous hashchange events

    prevLocation = currentLocation;

    listener(currentLocation);
  };

  ensureSlash();
  (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
  };
};

var updateLocation = function updateLocation(location, queryKey, updateHash) {
  var state = location.state;
  var key = location.key;

  var path = (0, _PathUtils.createPath)(location);

  if (state !== undefined) {
    path = (0, _PathUtils.addQueryStringValueToPath)(path, queryKey, key);
    (0, _DOMStateStorage.saveState)(key, state);
  }

  prevLocation = location;

  updateHash(path);
};

var pushLocation = exports.pushLocation = function pushLocation(location, queryKey) {
  return updateLocation(location, queryKey, function (path) {
    if (getHashPath() !== path) {
      pushHashPath(path);
    } else {
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'You cannot PUSH the same path using hash history') : void 0;
    }
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location, queryKey) {
  return updateLocation(location, queryKey, function (path) {
    if (getHashPath() !== path) replaceHashPath(path);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceLocation = exports.pushLocation = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = __webpack_require__(30);

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(9);

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  return (0, _LocationUtils.createLocation)(window.location);
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  window.location.href = (0, _PathUtils.createPath)(location);
  return false; // Don't update location
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  window.location.replace((0, _PathUtils.createPath)(location));
  return false; // Don't update location
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = __webpack_require__(31);

var _BrowserProtocol = __webpack_require__(30);

var BrowserProtocol = _interopRequireWildcard(_BrowserProtocol);

var _RefreshProtocol = __webpack_require__(129);

var RefreshProtocol = _interopRequireWildcard(_RefreshProtocol);

var _DOMUtils = __webpack_require__(17);

var _createHistory = __webpack_require__(32);

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates and returns a history object that uses HTML5's history API
 * (pushState, replaceState, and the popstate event) to manage history.
 * This is the recommended method of managing history in browsers because
 * it provides the cleanest URLs.
 *
 * Note: In browsers that do not support the HTML5 history API full
 * page reloads will be used to preserve clean URLs. You can force this
 * behavior using { forceRefresh: true } in options.
 */
var createBrowserHistory = function createBrowserHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Browser history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var useRefresh = options.forceRefresh || !(0, _DOMUtils.supportsHistory)();
  var Protocol = useRefresh ? RefreshProtocol : BrowserProtocol;

  var getUserConfirmation = Protocol.getUserConfirmation;
  var getCurrentLocation = Protocol.getCurrentLocation;
  var pushLocation = Protocol.pushLocation;
  var replaceLocation = Protocol.replaceLocation;
  var go = Protocol.go;


  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = BrowserProtocol.startListener(history.transitionTo);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen
  });
};

exports.default = createBrowserHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = __webpack_require__(31);

var _DOMUtils = __webpack_require__(17);

var _HashProtocol = __webpack_require__(128);

var HashProtocol = _interopRequireWildcard(_HashProtocol);

var _createHistory = __webpack_require__(32);

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DefaultQueryKey = '_k';

var createHashHistory = function createHashHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Hash history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var queryKey = options.queryKey;


  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(queryKey !== false, 'Using { queryKey: false } no longer works. Instead, just don\'t ' + 'use location state if you don\'t want a key in your URL query string') : void 0;

  if (typeof queryKey !== 'string') queryKey = DefaultQueryKey;

  var getUserConfirmation = HashProtocol.getUserConfirmation;


  var getCurrentLocation = function getCurrentLocation() {
    return HashProtocol.getCurrentLocation(queryKey);
  };

  var pushLocation = function pushLocation(location) {
    return HashProtocol.pushLocation(location, queryKey);
  };

  var replaceLocation = function replaceLocation(location) {
    return HashProtocol.replaceLocation(location, queryKey);
  };

  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: HashProtocol.go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = HashProtocol.startListener(history.transitionTo, queryKey);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  var goIsSupportedWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var go = function go(n) {
    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;

    history.go(n);
  };

  var createHref = function createHref(path) {
    return '#' + history.createHref(path);
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen,
    go: go,
    createHref: createHref
  });
};

exports.default = createHashHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(14);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(9);

var _createHistory = __webpack_require__(32);

var _createHistory2 = _interopRequireDefault(_createHistory);

var _Actions = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createStateStorage = function createStateStorage(entries) {
  return entries.filter(function (entry) {
    return entry.state;
  }).reduce(function (memo, entry) {
    memo[entry.key] = entry.state;
    return memo;
  }, {});
};

var createMemoryHistory = function createMemoryHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  if (Array.isArray(options)) {
    options = { entries: options };
  } else if (typeof options === 'string') {
    options = { entries: [options] };
  }

  var getCurrentLocation = function getCurrentLocation() {
    var entry = entries[current];
    var path = (0, _PathUtils.createPath)(entry);

    var key = void 0,
        state = void 0;
    if (entry.key) {
      key = entry.key;
      state = readState(key);
    }

    var init = (0, _PathUtils.parsePath)(path);

    return (0, _LocationUtils.createLocation)(_extends({}, init, { state: state }), undefined, key);
  };

  var canGo = function canGo(n) {
    var index = current + n;
    return index >= 0 && index < entries.length;
  };

  var go = function go(n) {
    if (!n) return;

    if (!canGo(n)) {
      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Cannot go(%s) there is not enough history', n) : void 0;

      return;
    }

    current += n;
    var currentLocation = getCurrentLocation();

    // Change action to POP
    history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
  };

  var pushLocation = function pushLocation(location) {
    current += 1;

    if (current < entries.length) entries.splice(current);

    entries.push(location);

    saveState(location.key, location.state);
  };

  var replaceLocation = function replaceLocation(location) {
    entries[current] = location;
    saveState(location.key, location.state);
  };

  var history = (0, _createHistory2.default)(_extends({}, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var _options = options;
  var entries = _options.entries;
  var current = _options.current;


  if (typeof entries === 'string') {
    entries = [entries];
  } else if (!Array.isArray(entries)) {
    entries = ['/'];
  }

  entries = entries.map(function (entry) {
    return (0, _LocationUtils.createLocation)(entry);
  });

  if (current == null) {
    current = entries.length - 1;
  } else {
    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : (0, _invariant2.default)(false) : void 0;
  }

  var storage = createStateStorage(entries);

  var saveState = function saveState(key, state) {
    return storage[key] = state;
  };

  var readState = function readState(key) {
    return storage[key];
  };

  return history;
};

exports.default = createMemoryHistory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.Actions = exports.useQueries = exports.useBeforeUnload = exports.useBasename = exports.createMemoryHistory = exports.createHashHistory = exports.createHistory = undefined;

var _LocationUtils = __webpack_require__(12);

Object.defineProperty(exports, 'locationsAreEqual', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.locationsAreEqual;
  }
});

var _createBrowserHistory = __webpack_require__(130);

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _createHashHistory2 = __webpack_require__(131);

var _createHashHistory3 = _interopRequireDefault(_createHashHistory2);

var _createMemoryHistory2 = __webpack_require__(132);

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

var _useBasename2 = __webpack_require__(134);

var _useBasename3 = _interopRequireDefault(_useBasename2);

var _useBeforeUnload2 = __webpack_require__(135);

var _useBeforeUnload3 = _interopRequireDefault(_useBeforeUnload2);

var _useQueries2 = __webpack_require__(136);

var _useQueries3 = _interopRequireDefault(_useQueries2);

var _Actions2 = __webpack_require__(20);

var _Actions3 = _interopRequireDefault(_Actions2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.createHistory = _createBrowserHistory2.default;
exports.createHashHistory = _createHashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;
exports.useBasename = _useBasename3.default;
exports.useBeforeUnload = _useBeforeUnload3.default;
exports.useQueries = _useQueries3.default;
exports.Actions = _Actions3.default;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _runTransitionHook = __webpack_require__(33);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _PathUtils = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var useBasename = function useBasename(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var basename = options.basename;


    var addBasename = function addBasename(location) {
      if (!location) return location;

      if (basename && location.basename == null) {
        if (location.pathname.indexOf(basename) === 0) {
          location.pathname = location.pathname.substring(basename.length);
          location.basename = basename;

          if (location.pathname === '') location.pathname = '/';
        } else {
          location.basename = '';
        }
      }

      return location;
    };

    var prependBasename = function prependBasename(location) {
      if (!basename) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var pname = object.pathname;
      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
      var pathname = normalizedBasename + normalizedPathname;

      return _extends({}, location, {
        pathname: pathname
      });
    };

    // Override all read methods with basename-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return addBasename(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, addBasename(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(addBasename(location));
      });
    };

    // Override all write methods with basename-aware versions.
    var push = function push(location) {
      return history.push(prependBasename(location));
    };

    var replace = function replace(location) {
      return history.replace(prependBasename(location));
    };

    var createPath = function createPath(location) {
      return history.createPath(prependBasename(location));
    };

    var createHref = function createHref(location) {
      return history.createHref(prependBasename(location));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useBasename;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = __webpack_require__(18);

var _invariant2 = _interopRequireDefault(_invariant);

var _DOMUtils = __webpack_require__(17);

var _ExecutionEnvironment = __webpack_require__(31);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var startListener = function startListener(getPromptMessage) {
  var handleBeforeUnload = function handleBeforeUnload(event) {
    var message = getPromptMessage();

    if (typeof message === 'string') {
      (event || window.event).returnValue = message;
      return message;
    }

    return undefined;
  };

  (0, _DOMUtils.addEventListener)(window, 'beforeunload', handleBeforeUnload);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, 'beforeunload', handleBeforeUnload);
  };
};

/**
 * Returns a new createHistory function that can be used to create
 * history objects that know how to use the beforeunload event in web
 * browsers to cancel navigation.
 */
var useBeforeUnload = function useBeforeUnload(createHistory) {
  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'useBeforeUnload only works in DOM environments') : (0, _invariant2.default)(false) : void 0;

  return function (options) {
    var history = createHistory(options);

    var listeners = [];
    var stopListener = void 0;

    var getPromptMessage = function getPromptMessage() {
      var message = void 0;
      for (var i = 0, len = listeners.length; message == null && i < len; ++i) {
        message = listeners[i].call();
      }return message;
    };

    var listenBeforeUnload = function listenBeforeUnload(listener) {
      if (listeners.push(listener) === 1) stopListener = startListener(getPromptMessage);

      return function () {
        listeners = listeners.filter(function (item) {
          return item !== listener;
        });

        if (listeners.length === 0 && stopListener) {
          stopListener();
          stopListener = null;
        }
      };
    };

    return _extends({}, history, {
      listenBeforeUnload: listenBeforeUnload
    });
  };
};

exports.default = useBeforeUnload;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _queryString = __webpack_require__(150);

var _runTransitionHook = __webpack_require__(33);

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _LocationUtils = __webpack_require__(12);

var _PathUtils = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultStringifyQuery = function defaultStringifyQuery(query) {
  return (0, _queryString.stringify)(query).replace(/%20/g, '+');
};

var defaultParseQueryString = _queryString.parse;

/**
 * Returns a new createHistory function that may be used to create
 * history objects that know how to handle URL queries.
 */
var useQueries = function useQueries(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var stringifyQuery = options.stringifyQuery;
    var parseQueryString = options.parseQueryString;


    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;

    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;

    var decodeQuery = function decodeQuery(location) {
      if (!location) return location;

      if (location.query == null) location.query = parseQueryString(location.search.substring(1));

      return location;
    };

    var encodeQuery = function encodeQuery(location, query) {
      if (query == null) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var queryString = stringifyQuery(query);
      var search = queryString ? '?' + queryString : '';

      return _extends({}, object, {
        search: search
      });
    };

    // Override all read methods with query-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return decodeQuery(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, decodeQuery(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(decodeQuery(location));
      });
    };

    // Override all write methods with query-aware versions.
    var push = function push(location) {
      return history.push(encodeQuery(location, location.query));
    };

    var replace = function replace(location) {
      return history.replace(encodeQuery(location, location.query));
    };

    var createPath = function createPath(location) {
      return history.createPath(encodeQuery(location, location.query));
    };

    var createHref = function createHref(location) {
      return history.createHref(encodeQuery(location, location.query));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var newLocation = history.createLocation.apply(history, [encodeQuery(location, location.query)].concat(args));

      if (location.query) newLocation.query = (0, _LocationUtils.createQuery)(location.query);

      return decodeQuery(newLocation);
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useQueries;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArguments = __webpack_require__(54),
    isArray = __webpack_require__(55);

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.flatten` with added support for restricting
 * flattening and specifying the start index.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, isDeep, isStrict, result) {
  result || (result = []);

  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index];
    if (isObjectLike(value) && isArrayLike(value) &&
        (isStrict || isArray(value) || isArguments(value))) {
      if (isDeep) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, isDeep, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = baseFlatten;


/***/ }),
/* 138 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * Creates a base function for methods like `_.forIn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = baseFor;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.indexOf` without support for binary searches.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 * If `fromRight` is provided elements of `array` are iterated from right to left.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 0 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseIndexOf = __webpack_require__(139),
    cacheIndexOf = __webpack_require__(142),
    createCache = __webpack_require__(143);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniq` without support for callback shorthands
 * and `this` binding.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The function invoked per iteration.
 * @returns {Array} Returns the new duplicate-value-free array.
 */
function baseUniq(array, iteratee) {
  var index = -1,
      indexOf = baseIndexOf,
      length = array.length,
      isCommon = true,
      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
      seen = isLarge ? createCache() : null,
      result = [];

  if (seen) {
    indexOf = cacheIndexOf;
    isCommon = false;
  } else {
    isLarge = false;
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

    if (isCommon && value === value) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (indexOf(seen, computed, 0) < 0) {
      if (iteratee || isLarge) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;


/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is in `cache` mimicking the return signature of
 * `_.indexOf` by returning `0` if the value is found, else `-1`.
 *
 * @private
 * @param {Object} cache The cache to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns `0` if `value` is found, else `-1`.
 */
function cacheIndexOf(cache, value) {
  var data = cache.data,
      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

  return result ? 0 : -1;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = cacheIndexOf;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = __webpack_require__(51);

/** Native method references. */
var Set = getNative(global, 'Set');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeCreate = getNative(Object, 'create');

/**
 *
 * Creates a cache object to store unique values.
 *
 * @private
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var length = values ? values.length : 0;

  this.data = { 'hash': nativeCreate(null), 'set': new Set };
  while (length--) {
    this.push(values[length]);
  }
}

/**
 * Adds `value` to the cache.
 *
 * @private
 * @name push
 * @memberOf SetCache
 * @param {*} value The value to cache.
 */
function cachePush(value) {
  var data = this.data;
  if (typeof value == 'string' || isObject(value)) {
    data.set.add(value);
  } else {
    data.hash[value] = true;
  }
}

/**
 * Creates a `Set` cache object to optimize linear searches of large arrays.
 *
 * @private
 * @param {Array} [values] The values to cache.
 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
 */
function createCache(values) {
  return (nativeCreate && Set) ? new SetCache(values) : null;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

// Add functions to the `Set` cache.
SetCache.prototype.push = cachePush;

module.exports = createCache;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38)))

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(34);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match latin-1 supplementary letters (excluding mathematical operators). */
var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0';

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to map latin-1 supplementary letters to basic latin letters. */
var deburredLetters = {
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss'
};

/**
 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
function deburrLetter(letter) {
  return deburredLetters[letter];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var deburr = __webpack_require__(144),
    words = __webpack_require__(149);

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string)), callback, '');
  };
}

/**
 * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__foo_bar__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

module.exports = kebabCase;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = __webpack_require__(51),
    isArguments = __webpack_require__(54),
    isArray = __webpack_require__(55);

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFlatten = __webpack_require__(137),
    baseUniq = __webpack_require__(140),
    restParam = __webpack_require__(147);

/**
 * Creates an array of unique values, in order, of the provided arrays using
 * `SameValueZero` for equality comparisons.
 *
 * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 * comparisons are like strict equality comparisons, e.g. `===`, except that
 * `NaN` matches `NaN`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([1, 2], [4, 2], [2, 1]);
 * // => [1, 2, 4]
 */
var union = restParam(function(arrays) {
  return baseUniq(baseFlatten(arrays, false, true));
});

module.exports = union;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = __webpack_require__(34);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match non-compound words composed of alphanumeric characters. */
var reBasicWord = /[a-zA-Z0-9]+/g;

/** Used to match complex or compound words. */
var reComplexWord = RegExp([
  rsUpper + '?' + rsLower + '+(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+',
  rsUpper + '+',
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasComplexWord = /[a-z][A-Z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = Symbol ? symbolProto.toString : undefined;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (value == null) {
    return '';
  }
  if (isSymbol(value)) {
    return Symbol ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strictUriEncode = __webpack_require__(168);
var objectAssign = __webpack_require__(56);

function encoderForArrayFormat(opts) {
	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, index) {
				return value === null ? [
					encode(key, opts),
					'[',
					index,
					']'
				].join('') : [
					encode(key, opts),
					'[',
					encode(index, opts),
					']=',
					encode(value, opts)
				].join('');
			};

		case 'bracket':
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'[]=',
					encode(value, opts)
				].join('');
			};

		default:
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'=',
					encode(value, opts)
				].join('');
			};
	}
}

function parserForArrayFormat(opts) {
	var result;

	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, accumulator) {
				result = /\[(\d*)]$/.exec(key);

				key = key.replace(/\[\d*]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return function (key, value, accumulator) {
				result = /(\[])$/.exec(key);

				key = key.replace(/\[]$/, '');

				if (!result || accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		default:
			return function (key, value, accumulator) {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function encode(value, opts) {
	if (opts.encode) {
		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	} else if (typeof input === 'object') {
		return keysSorter(Object.keys(input)).sort(function (a, b) {
			return Number(a) - Number(b);
		}).map(function (key) {
			return input[key];
		});
	}

	return input;
}

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str, opts) {
	opts = objectAssign({arrayFormat: 'none'}, opts);

	var formatter = parserForArrayFormat(opts);

	// Create an object with no prototype
	// https://github.com/sindresorhus/query-string/issues/47
	var ret = Object.create(null);

	if (typeof str !== 'string') {
		return ret;
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return ret;
	}

	str.split('&').forEach(function (param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		formatter(decodeURIComponent(key), val, ret);
	});

	return Object.keys(ret).sort().reduce(function (result, key) {
		var val = ret[key];
		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
			// Sort object keys, not values
			result[key] = keysSorter(val);
		} else {
			result[key] = val;
		}

		return result;
	}, Object.create(null));
};

exports.stringify = function (obj, opts) {
	var defaults = {
		encode: true,
		strict: true,
		arrayFormat: 'none'
	};

	opts = objectAssign(defaults, opts);

	var formatter = encoderForArrayFormat(opts);

	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return encode(key, opts);
		}

		if (Array.isArray(val)) {
			var result = [];

			val.slice().forEach(function (val2) {
				if (val2 === undefined) {
					return;
				}

				result.push(formatter(key, val2, result.length));
			});

			return result.join('&');
		}

		return encode(key, opts) + '=' + encode(val, opts);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = classNameFromVNode;

var _selectorParser2 = __webpack_require__(57);

var _selectorParser3 = _interopRequireDefault(_selectorParser2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function classNameFromVNode(vNode) {
  var _selectorParser = (0, _selectorParser3.default)(vNode.sel);

  var cn = _selectorParser.className;


  if (!vNode.data) {
    return cn;
  }

  var _vNode$data = vNode.data;
  var dataClass = _vNode$data.class;
  var props = _vNode$data.props;


  if (dataClass) {
    var c = Object.keys(vNode.data.class).filter(function (cl) {
      return vNode.data.class[cl];
    });
    cn += ' ' + c.join(' ');
  }

  if (props && props.className) {
    cn += ' ' + props.className;
  }

  return cn.trim();
}

/***/ }),
/* 152 */
/***/ (function(module, exports) {


// All SVG children elements, not in this list, should self-close

module.exports = {
  // http://www.w3.org/TR/SVG/intro.html#TermContainerElement
  'a': true,
  'defs': true,
  'glyph': true,
  'g': true,
  'marker': true,
  'mask': true,
  'missing-glyph': true,
  'pattern': true,
  'svg': true,
  'switch': true,
  'symbol': true,

  // http://www.w3.org/TR/SVG/intro.html#TermDescriptiveElement
  'desc': true,
  'metadata': true,
  'title': true
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {


var init = __webpack_require__(154);

module.exports = init([__webpack_require__(155), __webpack_require__(156)]);

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {


var parseSelector = __webpack_require__(58);
var VOID_ELEMENTS = __webpack_require__(157);
var CONTAINER_ELEMENTS = __webpack_require__(152);

module.exports = function init(modules) {
  function parse(data) {
    return modules.reduce(function (arr, fn) {
      arr.push(fn(data));
      return arr;
    }, []).filter(function (result) {
      return result !== '';
    });
  }

  return function renderToString(vnode) {
    if (!vnode.sel && vnode.text) {
      return vnode.text;
    }

    vnode.data = vnode.data || {};

    // Support thunks
    if (typeof vnode.sel === 'string' && vnode.sel.slice(0, 5) === 'thunk') {
      vnode = vnode.data.fn.apply(null, vnode.data.args);
    }

    var tagName = parseSelector(vnode.sel).tagName;
    var attributes = parse(vnode);
    var svg = vnode.data.ns === 'http://www.w3.org/2000/svg';
    var tag = [];

    // Open tag
    tag.push('<' + tagName);
    if (attributes.length) {
      tag.push(' ' + attributes.join(' '));
    }
    if (svg && CONTAINER_ELEMENTS[tagName] !== true) {
      tag.push(' /');
    }
    tag.push('>');

    // Close tag, if needed
    if (VOID_ELEMENTS[tagName] !== true && !svg || svg && CONTAINER_ELEMENTS[tagName] === true) {
      if (vnode.data.props && vnode.data.props.innerHTML) {
        tag.push(vnode.data.props.innerHTML);
      } else if (vnode.text) {
        tag.push(vnode.text);
      } else if (vnode.children) {
        vnode.children.forEach(function (child) {
          tag.push(renderToString(child));
        });
      }
      tag.push('</' + tagName + '>');
    }

    return tag.join('');
  };
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {


var forOwn = __webpack_require__(53);
var escape = __webpack_require__(52);
var union = __webpack_require__(148);

var parseSelector = __webpack_require__(58);

// data.attrs, data.props, data.class

module.exports = function attributes(vnode) {
  var selector = parseSelector(vnode.sel);
  var parsedClasses = selector.className.split(' ');

  var attributes = [];
  var classes = [];
  var values = {};

  if (selector.id) {
    values.id = selector.id;
  }

  setAttributes(vnode.data.props, values);
  setAttributes(vnode.data.attrs, values); // `attrs` override `props`, not sure if this is good so

  if (vnode.data.class) {
    // Omit `className` attribute if `class` is set on vnode
    values.class = undefined;
  }
  forOwn(vnode.data.class, function (value, key) {
    if (value === true) {
      classes.push(key);
    }
  });
  classes = union(classes, values.class, parsedClasses).filter(function (x) {
    return x !== '';
  });

  if (classes.length) {
    values.class = classes.join(' ');
  }

  forOwn(values, function (value, key) {
    attributes.push(value === true ? key : key + '="' + escape(value) + '"');
  });

  return attributes.length ? attributes.join(' ') : '';
};

function setAttributes(values, target) {
  forOwn(values, function (value, key) {
    if (key === 'htmlFor') {
      target['for'] = value;
      return;
    }
    if (key === 'className') {
      target['class'] = value.split(' ');
      return;
    }
    if (key === 'innerHTML') {
      return;
    }
    target[key] = value;
  });
}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var forOwn = __webpack_require__(53);
var escape = __webpack_require__(52);
var kebabCase = __webpack_require__(145);

// data.style

module.exports = function style(vnode) {
  var styles = [];
  var style = vnode.data.style || {};

  // merge in `delayed` properties
  if (style.delayed) {
    _extends(style, style.delayed);
  }

  forOwn(style, function (value, key) {
    // omit hook objects
    if (typeof value === 'string') {
      styles.push(kebabCase(key) + ': ' + escape(value));
    }
  });

  return styles.length ? 'style="' + styles.join('; ') + '"' : '';
};

/***/ }),
/* 157 */
/***/ (function(module, exports) {


// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements

module.exports = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var VNode = __webpack_require__(36);
var is = __webpack_require__(21);

function addNS(data, children) {
  data.ns = 'http://www.w3.org/2000/svg';
  if (children !== undefined) {
    for (var i = 0; i < children.length; ++i) {
      addNS(children[i].data, children[i].children);
    }
  }
}

module.exports = function h(sel, b, c) {
  var data = {}, children, text, i;
  if (c !== undefined) {
    data = b;
    if (is.array(c)) { children = c; }
    else if (is.primitive(c)) { text = c; }
  } else if (b !== undefined) {
    if (is.array(b)) { children = b; }
    else if (is.primitive(b)) { text = b; }
    else { data = b; }
  }
  if (is.array(children)) {
    for (i = 0; i < children.length; ++i) {
      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
    }
  }
  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
    addNS(data, children);
  }
  return VNode(sel, data, children, text, undefined);
};


/***/ }),
/* 159 */
/***/ (function(module, exports) {

function createElement(tagName){
  return document.createElement(tagName);
}

function createElementNS(namespaceURI, qualifiedName){
  return document.createElementNS(namespaceURI, qualifiedName);
}

function createTextNode(text){
  return document.createTextNode(text);
}


function insertBefore(parentNode, newNode, referenceNode){
  parentNode.insertBefore(newNode, referenceNode);
}


function removeChild(node, child){
  node.removeChild(child);
}

function appendChild(node, child){
  node.appendChild(child);
}

function parentNode(node){
  return node.parentElement;
}

function nextSibling(node){
  return node.nextSibling;
}

function tagName(node){
  return node.tagName;
}

function setTextContent(node, text){
  node.textContent = text;
}

module.exports = {
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  appendChild: appendChild,
  removeChild: removeChild,
  insertBefore: insertBefore,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent
};


/***/ }),
/* 160 */
/***/ (function(module, exports) {

var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", 
                "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", 
                "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", 
                "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", 
                "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", 
                "truespeed", "typemustmatch", "visible"];
    
var booleanAttrsDict = {};
for(var i=0, len = booleanAttrs.length; i < len; i++) {
  booleanAttrsDict[booleanAttrs[i]] = true;
}
    
function updateAttrs(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
  
  // update modified attributes, add new attributes
  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      // TODO: add support to namespaced attributes (setAttributeNS)
      if(!cur && booleanAttrsDict[key])
        elm.removeAttribute(key);
      else
        elm.setAttribute(key, cur);
    }
  }
  //remove removed attributes
  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
  // the other option is to remove all attributes with value == undefined
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}

module.exports = {create: updateAttrs, update: updateAttrs};


/***/ }),
/* 161 */
/***/ (function(module, exports) {

function updateClass(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldClass = oldVnode.data.class || {},
      klass = vnode.data.class || {};
  for (name in oldClass) {
    if (!klass[name]) {
      elm.classList.remove(name);
    }
  }
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      elm.classList[cur ? 'add' : 'remove'](name);
    }
  }
}

module.exports = {create: updateClass, update: updateClass};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var is = __webpack_require__(21);

function arrInvoker(arr) {
  return function() {
    if (!arr.length) return;
    // Special case when length is two, for performance
    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));
  };
}

function fnInvoker(o) {
  return function(ev) { 
    if (o.fn === null) return;
    o.fn(ev); 
  };
}

function updateEventListeners(oldVnode, vnode) {
  var name, cur, old, elm = vnode.elm,
      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
  if (!on) return;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    if (old === undefined) {
      if (is.array(cur)) {
        elm.addEventListener(name, arrInvoker(cur));
      } else {
        cur = {fn: cur};
        on[name] = cur;
        elm.addEventListener(name, fnInvoker(cur));
      }
    } else if (is.array(old)) {
      // Deliberately modify old array since it's captured in closure created with `arrInvoker`
      old.length = cur.length;
      for (var i = 0; i < old.length; ++i) old[i] = cur[i];
      on[name]  = old;
    } else {
      old.fn = cur;
      on[name] = old;
    }
  }
  if (oldOn) {
    for (name in oldOn) {
      if (on[name] === undefined) {
        var old = oldOn[name];
        if (is.array(old)) {
          old.length = 0;
        }
        else {
          old.fn = null;
        }
      }
    }
  }
}

module.exports = {create: updateEventListeners, update: updateEventListeners};


/***/ }),
/* 163 */
/***/ (function(module, exports) {

var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function getTextNodeRect(textNode) {
  var rect;
  if (document.createRange) {
    var range = document.createRange();
    range.selectNodeContents(textNode);
    if (range.getBoundingClientRect) {
        rect = range.getBoundingClientRect();
    }
  }
  return rect;
}

function calcTransformOrigin(isTextNode, textRect, boundingRect) {
  if (isTextNode) {
    if (textRect) {
      //calculate pixels to center of text from left edge of bounding box
      var relativeCenterX = textRect.left + textRect.width/2 - boundingRect.left;
      var relativeCenterY = textRect.top + textRect.height/2 - boundingRect.top;
      return relativeCenterX + 'px ' + relativeCenterY + 'px';
    }
  }
  return '0 0'; //top left
}

function getTextDx(oldTextRect, newTextRect) {
  if (oldTextRect && newTextRect) {
    return ((oldTextRect.left + oldTextRect.width/2) - (newTextRect.left + newTextRect.width/2));
  }
  return 0;
}
function getTextDy(oldTextRect, newTextRect) {
  if (oldTextRect && newTextRect) {
    return ((oldTextRect.top + oldTextRect.height/2) - (newTextRect.top + newTextRect.height/2));
  }
  return 0;
}

function isTextElement(elm) {
  return elm.childNodes.length === 1 && elm.childNodes[0].nodeType === 3;
}

var removed, created;

function pre(oldVnode, vnode) {
  removed = {};
  created = [];
}

function create(oldVnode, vnode) {
  var hero = vnode.data.hero;
  if (hero && hero.id) {
    created.push(hero.id);
    created.push(vnode);
  }
}

function destroy(vnode) {
  var hero = vnode.data.hero;
  if (hero && hero.id) {
    var elm = vnode.elm;
    vnode.isTextNode = isTextElement(elm); //is this a text node?
    vnode.boundingRect = elm.getBoundingClientRect(); //save the bounding rectangle to a new property on the vnode
    vnode.textRect = vnode.isTextNode ? getTextNodeRect(elm.childNodes[0]) : null; //save bounding rect of inner text node
    var computedStyle = window.getComputedStyle(elm, null); //get current styles (includes inherited properties)
    vnode.savedStyle = JSON.parse(JSON.stringify(computedStyle)); //save a copy of computed style values
    removed[hero.id] = vnode;
  }
}

function post() {
  var i, id, newElm, oldVnode, oldElm, hRatio, wRatio,
      oldRect, newRect, dx, dy, origTransform, origTransition,
      newStyle, oldStyle, newComputedStyle, isTextNode,
      newTextRect, oldTextRect;
  for (i = 0; i < created.length; i += 2) {
    id = created[i];
    newElm = created[i+1].elm;
    oldVnode = removed[id];
    if (oldVnode) {
      isTextNode = oldVnode.isTextNode && isTextElement(newElm); //Are old & new both text?
      newStyle = newElm.style;
      newComputedStyle = window.getComputedStyle(newElm, null); //get full computed style for new element
      oldElm = oldVnode.elm;
      oldStyle = oldElm.style;
      //Overall element bounding boxes
      newRect = newElm.getBoundingClientRect();
      oldRect = oldVnode.boundingRect; //previously saved bounding rect
      //Text node bounding boxes & distances
      if (isTextNode) {
        newTextRect = getTextNodeRect(newElm.childNodes[0]);
        oldTextRect = oldVnode.textRect;
        dx = getTextDx(oldTextRect, newTextRect);
        dy = getTextDy(oldTextRect, newTextRect);
      } else {
        //Calculate distances between old & new positions
        dx = oldRect.left - newRect.left;
        dy = oldRect.top - newRect.top;
      }
      hRatio = newRect.height / (Math.max(oldRect.height, 1));
      wRatio = isTextNode ? hRatio : newRect.width / (Math.max(oldRect.width, 1)); //text scales based on hRatio
      // Animate new element
      origTransform = newStyle.transform;
      origTransition = newStyle.transition;
      if (newComputedStyle.display === 'inline') //inline elements cannot be transformed
        newStyle.display = 'inline-block';        //this does not appear to have any negative side effects
      newStyle.transition = origTransition + 'transform 0s';
      newStyle.transformOrigin = calcTransformOrigin(isTextNode, newTextRect, newRect);
      newStyle.opacity = '0';
      newStyle.transform = origTransform + 'translate('+dx+'px, '+dy+'px) ' +
                               'scale('+1/wRatio+', '+1/hRatio+')';
      setNextFrame(newStyle, 'transition', origTransition);
      setNextFrame(newStyle, 'transform', origTransform);
      setNextFrame(newStyle, 'opacity', '1');
      // Animate old element
      for (var key in oldVnode.savedStyle) { //re-apply saved inherited properties
        if (parseInt(key) != key) {
          var ms = key.substring(0,2) === 'ms';
          var moz = key.substring(0,3) === 'moz';
          var webkit = key.substring(0,6) === 'webkit';
      	  if (!ms && !moz && !webkit) //ignore prefixed style properties
        	  oldStyle[key] = oldVnode.savedStyle[key];
        }
      }
      oldStyle.position = 'absolute';
      oldStyle.top = oldRect.top + 'px'; //start at existing position
      oldStyle.left = oldRect.left + 'px';
      oldStyle.width = oldRect.width + 'px'; //Needed for elements who were sized relative to their parents
      oldStyle.height = oldRect.height + 'px'; //Needed for elements who were sized relative to their parents
      oldStyle.margin = 0; //Margin on hero element leads to incorrect positioning
      oldStyle.transformOrigin = calcTransformOrigin(isTextNode, oldTextRect, oldRect);
      oldStyle.transform = '';
      oldStyle.opacity = '1';
      document.body.appendChild(oldElm);
      setNextFrame(oldStyle, 'transform', 'translate('+ -dx +'px, '+ -dy +'px) scale('+wRatio+', '+hRatio+')'); //scale must be on far right for translate to be correct
      setNextFrame(oldStyle, 'opacity', '0');
      oldElm.addEventListener('transitionend', function(ev) {
        if (ev.propertyName === 'transform')
          document.body.removeChild(ev.target);
      });
    }
  }
  removed = created = undefined;
}

module.exports = {pre: pre, create: create, destroy: destroy, post: post};


/***/ }),
/* 164 */
/***/ (function(module, exports) {

function updateProps(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
  for (key in oldProps) {
    if (!props[key]) {
      delete elm[key];
    }
  }
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}

module.exports = {create: updateProps, update: updateProps};


/***/ }),
/* 165 */
/***/ (function(module, exports) {

var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function updateStyle(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldStyle = oldVnode.data.style || {},
      style = vnode.data.style || {},
      oldHasDel = 'delayed' in oldStyle;
  for (name in oldStyle) {
    if (!style[name]) {
      elm.style[name] = '';
    }
  }
  for (name in style) {
    cur = style[name];
    if (name === 'delayed') {
      for (name in style.delayed) {
        cur = style.delayed[name];
        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
          setNextFrame(elm.style, name, cur);
        }
      }
    } else if (name !== 'remove' && cur !== oldStyle[name]) {
      elm.style[name] = cur;
    }
  }
}

function applyDestroyStyle(vnode) {
  var style, name, elm = vnode.elm, s = vnode.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}

function applyRemoveStyle(vnode, rm) {
  var s = vnode.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
      compStyle, style = s.remove, amount = 0, applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle['transition-property'].split(', ');
  for (; i < props.length; ++i) {
    if(applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener('transitionend', function(ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}

module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint newcap: false
/* global require, module, document, Node */


var VNode = __webpack_require__(36);
var is = __webpack_require__(21);
var domApi = __webpack_require__(159);

function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }

var emptyNode = VNode('', {}, [], undefined, undefined);

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, map = {}, key;
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) map[key] = i;
  }
  return map;
}

var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

function init(modules, api) {
  var i, j, cbs = {};

  if (isUndef(api)) api = domApi;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
    }
  }

  function emptyNodeAt(elm) {
    return VNode(api.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    return function() {
      if (--listeners === 0) {
        var parent = api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }

  function createElm(vnode, insertedVnodeQueue) {
    var i, data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode);
        data = vnode.data;
      }
    }
    var elm, children = vnode.children, sel = vnode.sel;
    if (isDef(sel)) {
      // Parse selector
      var hashIdx = sel.indexOf('#');
      var dotIdx = sel.indexOf('.', hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                                                          : api.createElement(tag);
      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          api.appendChild(elm, createElm(children[i], insertedVnodeQueue));
        }
      } else if (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (i.create) i.create(emptyNode, vnode);
        if (i.insert) insertedVnodeQueue.push(vnode);
      }
    } else {
      elm = vnode.elm = api.createTextNode(vnode.text);
    }
    return vnode.elm;
  }

  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j, data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i, listeners, rm, ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
            i(ch, rm);
          } else {
            rm();
          }
        } else { // Text node
          api.removeChild(parentElm, ch.elm);
        }
      }
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    var oldStartIdx = 0, newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, before;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) { // New element
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
          oldCh[idxInOld] = undefined;
          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
    var i, hook;
    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
    if (oldVnode === vnode) return;
    if (!sameVnode(oldVnode, vnode)) {
      var parentElm = api.parentNode(oldVnode.elm);
      elm = createElm(vnode, insertedVnodeQueue);
      api.insertBefore(parentElm, elm, oldVnode.elm);
      removeVnodes(parentElm, [oldVnode], 0, 0);
      return;
    }
    if (isDef(vnode.data)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
      i = vnode.data.hook;
      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, '');
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      api.setTextContent(elm, vnode.text);
    }
    if (isDef(hook) && isDef(i = hook.postpatch)) {
      i(oldVnode, vnode);
    }
  }

  return function(oldVnode, vnode) {
    var i, elm, parent;
    var insertedVnodeQueue = [];
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();

    if (isUndef(oldVnode.sel)) {
      oldVnode = emptyNodeAt(oldVnode);
    }

    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent = api.parentNode(elm);

      createElm(vnode, insertedVnodeQueue);

      if (parent !== null) {
        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }

    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
}

module.exports = {init: init};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var h = __webpack_require__(158);

function copyToThunk(vnode, thunk) {
  thunk.elm = vnode.elm;
  vnode.data.fn = thunk.data.fn;
  vnode.data.args = thunk.data.args;
  thunk.data = vnode.data;
  thunk.children = vnode.children;
  thunk.text = vnode.text;
  thunk.elm = vnode.elm;
}

function init(thunk) {
  var i, cur = thunk.data;
  var vnode = cur.fn.apply(undefined, cur.args);
  copyToThunk(vnode, thunk);
}

function prepatch(oldVnode, thunk) {
  var i, old = oldVnode.data, cur = thunk.data, vnode;
  var oldArgs = old.args, args = cur.args;
  if (old.fn !== cur.fn || oldArgs.length !== args.length) {
    copyToThunk(cur.fn.apply(undefined, args), thunk);
  }
  for (i = 0; i < args.length; ++i) {
    if (oldArgs[i] !== args[i]) {
      copyToThunk(cur.fn.apply(undefined, args), thunk);
      return;
    }
  }
  copyToThunk(oldVnode, thunk);
}

module.exports = function(sel, key, fn, args) {
  if (args === undefined) {
    args = fn;
    fn = key;
    key = undefined;
  }
  return h(sel, {
    key: key,
    hook: {init: init, prepatch: prepatch},
    fn: fn,
    args: args
  });
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(170);
/* harmony export (immutable) */ __webpack_exports__["default"] = switchPath;

function switchPathInputGuard(path, routes) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["a" /* isPattern */])(path)) {
        throw new Error("First parameter to switchPath must be a route path.");
    }
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(routes)) {
        throw new Error("Second parameter to switchPath must be an object " +
            "containing route patterns.");
    }
}
function validatePath(sourcePath, matchedPath) {
    var sourceParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(sourcePath);
    var matchedParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(matchedPath);
    for (var i = 0; i < matchedParts.length; ++i) {
        if (matchedParts[i] !== sourceParts[i]) {
            return null;
        }
    }
    return "/" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* extractPartial */])(sourcePath, matchedPath);
}
function betterMatch(candidate, reference) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */])(candidate)) {
        return false;
    }
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */])(reference)) {
        return true;
    }
    if (!validatePath(candidate, reference)) {
        return false;
    }
    return candidate.length >= reference.length;
}
function matchesWithParams(sourcePath, pattern) {
    var sourceParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(sourcePath);
    var patternParts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["c" /* splitPath */])(pattern);
    var params = patternParts
        .map(function (part, i) { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isParam */])(part) ? sourceParts[i] : null; })
        .filter(__WEBPACK_IMPORTED_MODULE_0__util__["e" /* isNotNull */]);
    var matched = patternParts
        .every(function (part, i) { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["f" /* isParam */])(part) || part === sourceParts[i]; });
    return matched ? params : [];
}
function getParamFnValue(paramFn, params) {
    var _paramFn = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(paramFn) ? paramFn["/"] : paramFn;
    return typeof _paramFn === "function" ? _paramFn.apply(void 0, params) : _paramFn;
}
function validate(_a) {
    var sourcePath = _a.sourcePath, matchedPath = _a.matchedPath, matchedValue = _a.matchedValue, routes = _a.routes;
    var path = matchedPath ? validatePath(sourcePath, matchedPath) : null;
    var value = matchedValue;
    if (!path) {
        path = routes["*"] ? sourcePath : null;
        value = path ? routes["*"] : null;
    }
    return { path: path, value: value };
}
function switchPath(sourcePath, routes) {
    switchPathInputGuard(sourcePath, routes);
    var matchedPath = null;
    var matchedValue = null;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["g" /* traverseRoutes */])(routes, function matchPattern(pattern) {
        if (sourcePath.search(pattern) === 0 && betterMatch(pattern, matchedPath)) {
            matchedPath = pattern;
            matchedValue = routes[pattern];
        }
        var params = matchesWithParams(sourcePath, pattern).filter(Boolean);
        if (params.length > 0 && betterMatch(sourcePath, matchedPath)) {
            matchedPath = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["d" /* extractPartial */])(sourcePath, pattern);
            matchedValue = getParamFnValue(routes[pattern], params);
        }
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["b" /* isRouteDefinition */])(routes[pattern]) && params.length === 0) {
            if (sourcePath !== "/") {
                var child = switchPath(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["h" /* unprefixed */])(sourcePath, pattern) || "/", routes[pattern]);
                var nestedPath = pattern + child.path;
                if (child.path !== null &&
                    betterMatch(nestedPath, matchedPath)) {
                    matchedPath = nestedPath;
                    matchedValue = child.value;
                }
            }
        }
    });
    return validate({ sourcePath: sourcePath, matchedPath: matchedPath, matchedValue: matchedValue, routes: routes });
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isPattern;
/* harmony export (immutable) */ __webpack_exports__["b"] = isRouteDefinition;
/* harmony export (immutable) */ __webpack_exports__["g"] = traverseRoutes;
/* harmony export (immutable) */ __webpack_exports__["e"] = isNotNull;
/* harmony export (immutable) */ __webpack_exports__["c"] = splitPath;
/* harmony export (immutable) */ __webpack_exports__["f"] = isParam;
/* harmony export (immutable) */ __webpack_exports__["d"] = extractPartial;
/* harmony export (immutable) */ __webpack_exports__["h"] = unprefixed;
function isPattern(candidate) {
    return candidate.charAt(0) === "/" || candidate === "*";
}
function isRouteDefinition(candidate) {
    return !candidate || typeof candidate !== "object" ?
        false : isPattern(Object.keys(candidate)[0]);
}
function traverseRoutes(routes, callback) {
    var keys = Object.keys(routes);
    for (var i = 0; i < keys.length; ++i) {
        var pattern = keys[i];
        if (pattern === "*")
            continue;
        callback(pattern);
    }
}
function isNotNull(candidate) {
    return candidate !== null;
}
function splitPath(path) {
    return path.split("/").filter(function (s) { return !!s; });
}
function isParam(candidate) {
    return candidate.match(/:\w+/) !== null;
}
function extractPartial(sourcePath, pattern) {
    var patternParts = splitPath(pattern);
    var sourceParts = splitPath(sourcePath);
    var matchedParts = [];
    for (var i = 0; i < patternParts.length; ++i) {
        matchedParts.push(sourceParts[i]);
    }
    return matchedParts.filter(isNotNull).join("/");
}
function unprefixed(fullString, prefix) {
    return fullString.split(prefix)[1];
}
//# sourceMappingURL=util.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(172);


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(173);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38), __webpack_require__(60)(module)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(22);
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var components_1 = __webpack_require__(177);
var Breadcrumb;
(function (Breadcrumb) {
    function run(sources) {
        var basics = createBasicExamples(sources);
        var content = createContentExamples(sources);
        var variations = createVariationExamples(sources);
        var vTree$ = xstream_1.default.combine(basics, content, variations).map(function (_a) {
            var basics = _a[0], content = _a[1], variations = _a[2];
            return dom_1.div({ props: { className: "article" } }, [
                UI.Segment.render({ vertical: true }, [
                    UI.Container.render([
                        UI.Header.render({ size: UI.Size.Huge }, "Breadcrumb", {
                            subtext: "A breadcrumb is used to show hierarchy between content"
                        }),
                    ]),
                ]),
                UI.Container.render([
                    UI.Segment.render({ basic: true }, [UI.Header.render({ dividing: true, size: UI.Size.Huge }, "Types")].concat(basics)),
                    UI.Segment.render({ basic: true }, [UI.Header.render({ dividing: true, size: UI.Size.Huge }, "Content")].concat(content)),
                    UI.Segment.render({ basic: true }, [UI.Header.render({ dividing: true, size: UI.Size.Huge }, "Variations")].concat(variations))
                ]),
            ]);
        });
        return {
            DOM: vTree$,
            router: xstream_1.default.never()
        };
    }
    Breadcrumb.run = run;
    function createBasicExamples(sources) {
        var ex1 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render([
                { text: "Home", href: "#" },
                { text: "Store", href: "#" },
                { text: "T-Shirt", active: true }
            ])),
            code: "Breadcrumb.render([\n  { text: \"Home\", href: \"#\" },\n  { text: \"Store\", href: \"#\" },\n  { text: \"T-Shirt\", active: true }\n])",
            header: "Breadcrumb",
            description: "A standard breadcrumb."
        });
        var ex2 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { divider: UI.Icon.render(UI.IconType.AngleRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Store", href: "#" },
                    { text: "T-Shirt", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { divider: Icon.render(IconType.AngleRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Store\", href: \"#\" },\n    { text: \"T-Shirt\", active: true }\n  ]\n})"
        });
        return xstream_1.default.combine(ex1.DOM, ex2.DOM);
    }
    function createContentExamples(sources) {
        var ex1 = components_1.Example.run(sources, {
            header: "Divider",
            description: "A breadcrumb can contain a divider to show the relationship between sections, this can be formatted as an icon or text.",
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\nstyle: { divider: Icon.render(IconType.ArrowRight) },\ncontent:[\n  { text: \"Home\", href: \"#\" },\n  { text: \"Registration\", href: \"#\" },\n  { text: \"Personal Information\", active: true }\n]})"
        });
        var ex2 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { divider: "|" },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { divider: \"|\" },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex3 = components_1.Example.run(sources, {
            header: "Section",
            description: "A breadcrumb can contain sections that can either be formatted as a link or text.",
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { divider: UI.Icon.render(UI.IconType.AngleRight) },
                content: [
                    { text: "Home" },
                    { text: "Search", active: true },
                ]
            })),
            code: "Breadcrumb.render({\n  style: { divider: Icon.render(IconType.AngleRight) },\n  content: [\n    { text: \"Home\" },\n    { text: \"Search\", active: true },\n  ]\n})"
        });
        var ex4 = components_1.Example.run(sources, {
            header: "Link",
            description: "A section may be linkable or contain a link.",
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { divider: UI.Icon.render(UI.IconType.AngleRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: ["Search for: ", dom_1.a("paper towels")], active: true },
                ]
            })),
            code: "Breadcrumb.render({\n  style: { divider: Icon.render(IconType.AngleRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: [\"Search for: \", a(\"paper towels\")], active: true },\n  ]\n})"
        });
        return xstream_1.default.combine(ex1.DOM, ex2.DOM, ex3.DOM, ex4.DOM);
    }
    function createVariationExamples(sources) {
        var ex1 = components_1.Example.run(sources, {
            header: "Size",
            description: "A breadcrumb can vary in size.",
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Mini, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Mini, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex2 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Tiny, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Tiny, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex3 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Small, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Small, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex4 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Medium, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Medium, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex5 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Large, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Large, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex6 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Big, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Big, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex7 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Huge, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Huge, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        var ex8 = components_1.Example.run(sources, {
            VNode$: xstream_1.default.of(UI.Breadcrumb.render({
                style: { size: UI.Size.Massive, divider: UI.Icon.render(UI.IconType.ArrowRight) },
                content: [
                    { text: "Home", href: "#" },
                    { text: "Registration", href: "#" },
                    { text: "Personal Information", active: true }
                ]
            })),
            code: "Breadcrumb.render({\n  style: { size: Size.Massive, divider: Icon.render(UI.IconType.ArrowRight) },\n  content: [\n    { text: \"Home\", href: \"#\" },\n    { text: \"Registration\", href: \"#\" },\n    { text: \"Personal Information\", active: true }\n  ]\n})"
        });
        return xstream_1.default.combine(ex1.DOM, ex2.DOM, ex3.DOM, ex4.DOM, ex5.DOM, ex6.DOM, ex7.DOM, ex8.DOM);
    }
})(Breadcrumb = exports.Breadcrumb || (exports.Breadcrumb = {}));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(174));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(22);
var xstream_1 = __webpack_require__(0);
var dom_1 = __webpack_require__(1);
var Example;
(function (Example) {
    function run(sources, args) {
        //Show code icon
        var btnShow = UI.Icon.run({
            DOM: sources.DOM,
            content$: xstream_1.default.of(UI.IconType.Code)
        });
        var animation$ = btnShow.Events("click").fold(function (prev, n) { return !prev; }, false).drop(1).map(function (n) { return ({
            animation: UI.Animation.Slide,
            direction: n ? UI.Direction.In : UI.Direction.Out
        }); }).startWith({
            animation: UI.Animation.None,
            direction: UI.Direction.Out
        });
        //Sliding code view
        var code$ = xstream_1.default.of(UI.Segment.render({ attachment: UI.Attachment.Bottom }, [dom_1.pre([
                dom_1.code({
                    props: { className: "javascript" }, hook: {
                        insert: function (vnode) { hljs.highlightBlock(vnode.elm); }
                    }
                }, args.code.split(/\r?\n/).map(function (line) { return [line, dom_1.br()]; }).reduce(function (acc, n) { return acc.concat(n); }, []))
            ])
        ]));
        var animatedCode$ = UI.Transition.run({
            DOM: sources.DOM,
            target$: code$,
            args$: animation$
        });
        //Example bar
        var top$ = xstream_1.default.combine(animation$, args.VNode$).map(function (_a) {
            var animation = _a[0], obj = _a[1];
            var isActive = animation.direction === UI.Direction.In;
            var elem = dom_1.div({ props: { className: isActive ? "ui top attached segment code" : "code" } }, [
                isActive ? UI.Label.render({ attachment: UI.Attachment.Top }, [
                    "Example"
                ]) : dom_1.div({ style: { display: "none" }, props: { className: "" } }),
                obj
            ]);
            return elem;
        });
        var vTree$ = xstream_1.default.combine(btnShow.DOM, animatedCode$.DOM, top$).map(function (_a) {
            var btnShow = _a[0], code = _a[1], top = _a[2];
            var content = [btnShow, top, code];
            if (typeof (args.description) !== "undefined") {
                content = [dom_1.p(args.description)].concat(content);
            }
            if (typeof (args.header) !== "undefined") {
                content = [UI.Header.render(args.header)].concat(content);
            }
            return dom_1.div({ props: { className: "example" } }, content);
        });
        return {
            DOM: vTree$
        };
    }
    Example.run = run;
})(Example = exports.Example || (exports.Example = {}));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(176));


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(22);
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var Index;
(function (Index) {
    function run(sources) {
        var vTree$ = xstream_1.default.of(dom_1.div(".centered", [
            UI.Container.render([
                UI.Grid.render({ centered: true }, [
                    UI.Row.render([
                        UI.Header.render({ size: UI.Size.Huge }, "Welcome.", {
                            subtext: "At the moment the docs are a WIP. Planned pages are scaffolded in the sidemenu."
                        }),
                    ])
                ])
            ])
        ]));
        return {
            DOM: vTree$,
            router: xstream_1.default.never()
        };
    }
    Index.run = run;
})(Index = exports.Index || (exports.Index = {}));


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable-next-line:no-unused-variable
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var sidebar_1 = __webpack_require__(180);
var Layout;
(function (Layout) {
    function run(sources, page) {
        /*** Create components ***/
        var sidebar = sidebar_1.Sidebar.run(sources);
        /*** Compose view ***/
        var vTree$ = xstream_1.default.combine(sidebar.DOM, page.DOM)
            .map(function (_a) {
            var sidebar = _a[0], page = _a[1];
            return dom_1.div(".full.height", [
                dom_1.div(".content.pusher", [
                    sidebar,
                    page
                ]),
            ]);
        });
        return {
            DOM: vTree$,
            router: page.router
        };
    }
    Layout.run = run;
})(Layout = exports.Layout || (exports.Layout = {}));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UI = __webpack_require__(22);
var xstream_1 = __webpack_require__(0);
// tslint:disable-next-line:no-unused-variable
var dom_1 = __webpack_require__(1);
var Sidebar;
(function (Sidebar) {
    function run(sources) {
        var currentPage$ = sources.router.history$.map(function (x) { return x.pathname; });
        var prefix = "/cycle-semantic-ui";
        var vTree$ = currentPage$.map(function (page) {
            return dom_1.div(".left.menu", [
                dom_1.div(".fixed", [
                    UI.Menu.render({
                        vertical: true, inverted: true,
                        attachment: UI.Attachment.None, size: UI.Size.Fluid
                    }, [{
                            header: true,
                            body: ["Introduction", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/", active: page === prefix + "/" || page === prefix + "/home",
                                        body: "About"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Elements", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/elements/button", active: page === prefix + "/elements/button",
                                        body: "Button"
                                    }, {
                                        link: true, href: prefix + "/elements/container", active: page === prefix + "/elements/container",
                                        body: "Container"
                                    }, {
                                        link: true, href: prefix + "/elements/divider", active: page === prefix + "/elements/divider",
                                        body: "Divider"
                                    }, {
                                        link: true, href: prefix + "/elements/header", active: page === prefix + "/elements/header",
                                        body: "Header"
                                    }, {
                                        link: true, href: prefix + "/elements/icon", active: page === prefix + "/elements/icon",
                                        body: "Icon"
                                    }, {
                                        link: true, href: prefix + "/elements/image", active: page === prefix + "/elements/image",
                                        body: "Image"
                                    }, {
                                        link: true, href: prefix + "/elements/label", active: page === prefix + "/elements/label",
                                        body: "Label"
                                    }, {
                                        link: true, href: prefix + "/elements/list", active: page === prefix + "/elements/list",
                                        body: "List"
                                    }, {
                                        link: true, href: prefix + "/elements/loader", active: page === prefix + "/elements/loader",
                                        body: "Loader"
                                    }, {
                                        link: true, href: prefix + "/elements/segment", active: page === prefix + "/elements/segment",
                                        body: "Segment"
                                    }, {
                                        link: true, href: prefix + "/elements/step", active: page === prefix + "/elements/step",
                                        body: "Step"
                                    }, {
                                        link: true, href: prefix + "/elements/textbox", active: page === prefix + "/elements/textbox",
                                        body: "Textbox"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Collections", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/collections/breadcrumb", active: page === prefix + "/collections/breadcrumb",
                                        body: "Breadcrumb"
                                    }, {
                                        link: true, href: prefix + "/collections/form", active: page === prefix + "/collections/form",
                                        body: "Form"
                                    }, {
                                        link: true, href: prefix + "/collections/grid", active: page === prefix + "/collections/grid",
                                        body: "Grid"
                                    }, {
                                        link: true, href: prefix + "/collections/menu", active: page === prefix + "/collections/menu",
                                        body: "Menu"
                                    }, {
                                        link: true, href: prefix + "/collections/message", active: page === prefix + "/collections/message",
                                        body: "Message"
                                    }, {
                                        link: true, href: prefix + "/collections/table", active: page === prefix + "/collections/table",
                                        body: "Table"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Modules", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/modules/checkbox", active: page === prefix + "/modules/checkbox",
                                        body: "Checkbox"
                                    }, {
                                        link: true, href: prefix + "/modules/dimmer", active: page === prefix + "/modules/dimmer",
                                        body: "Dimmer"
                                    }, {
                                        link: true, href: prefix + "/modules/dropdown", active: page === prefix + "/modules/dropdown",
                                        body: "Dropdown"
                                    }, {
                                        link: true, href: prefix + "/modules/modal", active: page === prefix + "/modules/modal",
                                        body: "Modal"
                                    }, {
                                        link: true, href: prefix + "/modules/popup", active: page === prefix + "/modules/popup",
                                        body: "Popup"
                                    }, {
                                        link: true, href: prefix + "/modules/progress", active: page === prefix + "/modules/progress",
                                        body: "Progress"
                                    }, {
                                        link: true, href: prefix + "/modules/transition", active: page === prefix + "/modules/transition",
                                        body: "Transition"
                                    }])]
                        },
                        {
                            header: true,
                            body: ["Views", UI.Menu.render({ submenu: true, }, [{
                                        link: true, href: prefix + "/views/statistic", active: page === prefix + "/views/statistic",
                                        body: "Statistic"
                                    }])]
                        }])
                ])
            ]);
        });
        return {
            DOM: vTree$,
            router: xstream_1.default.never()
        };
    }
    Sidebar.run = run;
})(Sidebar = exports.Sidebar || (exports.Sidebar = {}));


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var xstream_1 = __webpack_require__(0);
var callPage = function (sources) {
    return function (_a) {
        var path = _a.path, value = _a.value;
        var pSources = Object.assign({}, sources, { router: sources.router.path(path) });
        var isolatedPage = isolate_1.default(value)(pSources);
        return isolatedPage;
    };
};
function propOrNever(key, x) {
    if (x.hasOwnProperty(key)) {
        return x[key];
    }
    return xstream_1.default.never();
}
function flattenByKey(key, stream) {
    return stream.map(function (x) { return propOrNever(key, x); }).flatten();
}
function ComponentRouter(sources) {
    var component$ = sources.router.define(sources.routes)
        .map(function (route) { return callPage(sources)(route); })
        .remember()
        .debug(function () { }); //State$ does not work without this line. Unable to reproduce in webpackbin.
    var pluck = function (key) { return flattenByKey(key, component$); };
    var sinks = {
        pluck: pluck,
        DOM: pluck("DOM"),
        router: pluck("router"),
    };
    return sinks;
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = function (sources) { return isolate_1.default(ComponentRouter)(sources); };


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(178);
var collections_1 = __webpack_require__(175);
var prefix = "/cycle-semantic-ui";
var routes = {
    "/": index_1.Index.run,
};
routes[prefix + "/collections/breadcrumb"] = collections_1.Breadcrumb.run;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = routes;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var enums_1 = __webpack_require__(3);
var Breadcrumb;
(function (Breadcrumb) {
    function render(arg1, arg2) {
        if (isArgs(arg1)) {
            return breadcrumb(arg1);
        }
        var args = {};
        if (isContent(arg1)) {
            args.style = { divider: "/" };
            args.content = { main: arg1 };
        }
        else {
            args.style = arg1 || { divider: "/" };
            args.content = { main: arg2 || [] };
        }
        return breadcrumb(args);
    }
    Breadcrumb.render = render;
    function run(sources) {
        function main(sources) {
            sources.style$ = sources.style$ ? sources.style$ : xstream_1.default.of({ divider: "/" });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var breadcrumb$ = xstream_1.default.combine(sources.style$, sources.content$).map(function (_a) {
                var style = _a[0], content = _a[1];
                return render({
                    style: style,
                    content: isContent(content) ? { main: content } : content
                });
            });
            return {
                DOM: breadcrumb$,
                Events: function (type) { return sources.DOM.select(".breadcrumb").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Breadcrumb.run = run;
    function breadcrumb(args) {
        var content = isContent(args.content) ? args.content : args.content.main;
        var children = content.map(function (c) { return [
            section(c), divider(args.style)
        ]; }).reduce(function (a, n) { return a.concat(n); }, []);
        children.splice(-1, 1);
        return dom_1.div({ props: { className: getClassName(args.style) } }, children);
    }
    function getClassName(style) {
        var className = "ui";
        if (typeof (style.size) !== "undefined") {
            className += enums_1.Size.ToClassname(style.size);
        }
        return className + " breadcrumb";
    }
    function section(section) {
        return section.active
            ? dom_1.div({ props: { className: "active section" } }, section.text)
            : section.href
                ? dom_1.a({ props: { className: "section", href: section.href } }, section.text)
                : dom_1.div({ props: { className: "section" } }, section.text);
    }
    function divider(style) {
        if (typeof (style.divider) === "string") {
            return dom_1.span({ props: { className: "divider" } }, style.divider);
        }
        if (style.divider.data.props.className.indexOf("ui") !== -1) {
            style.divider.data.props.className = style.divider.data.props.className.substring(3);
        }
        if (style.divider.data.props.className.indexOf("divider") === -1) {
            style.divider.data.props.className += " divider";
        }
        return style.divider;
    }
    function isContent(obj) {
        return obj instanceof Array;
    }
    function isArgs(obj) {
        return obj && (typeof (obj.style) !== "undefined" ||
            (typeof (obj.content) !== "undefined" && isContent(obj.content.main)));
    }
})(Breadcrumb = exports.Breadcrumb || (exports.Breadcrumb = {}));


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(8);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Field;
(function (Field) {
    /**
     * Wraps content in a Field suitable for the Form component.
     * Accepts the following properties in props$:
     *   width?: number - The width of the field in grid columns.
     *   inline?: boolean - Styles the label to be next to the field instead of above it.
     *   centered?: boolean - Styles the content of the field to be centered.
     *   required?: boolean - Styles the field to show it is mandatory.
     * Expects the following type of content in content$: {} of
     *   label?: DOMContent - The label for the field.
     *   body: DOMContent - The field input.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extra = _a[2];
                return render(props, content, extra);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".field").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Field.run = run;
    /**
     * Wraps content in a Field suitable for the Form component.
     * Accepts the following properties:
     *   width?: number - The width of the field in grid columns.
     *   inline?: boolean - Styles the label to be next to the field instead of above it.
     *   centered?: boolean - Styles the content of the field to be centered.
     *   required?: boolean - Styles the field to show it is mandatory.
     * Expects the following type of content: {} of
     *   label?: DOMContent - The label for the field.
     *   body: DOMContent - The field input.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var extra = interfaces_1.isDOMContent(pOrC) ? (c === "") ? e : c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [].concat(extra ? dom_1.label(extra) : "", content));
    }
    Field.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.width) {
            className += utils_1.numToText(props.width) + " wide";
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.centered) {
            className += " centered";
        }
        if (props.required) {
            className += " required";
        }
        className += " field";
        return className;
    }
})(Field = exports.Field || (exports.Field = {}));


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(8);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Fields;
(function (Fields) {
    /**
     * Wraps multiple related Field components together.
     * Accepts the following properties in props$:
     *   label?: DOMContent - A label for the fields.
     *   equalWidth?: boolean - Divides fields in equal width.
     *   grouped?: boolean - Groups fields together for related choices.
     *   inline?: boolean - Styles the labels to be next to the fields instead of above them.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".fields").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Fields.run = run;
    /**
     * Wraps multiple related Field components together.
     * Accepts the following properties:
     *   label?: DOMContent - A label for the fields.
     *   equalWidth?: boolean - Divides fields in equal width.
     *   grouped?: boolean - Groups fields together for related choices.
     *   inline?: boolean - Styles the labels to be next to the fields instead of above them.
     *   required?: boolean - Styles the the fields to make them appear mandetory.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var lbl = props.label ? dom_1.label(props.label) : "";
        var children = content.length ? [lbl].concat(content) : [lbl, content];
        return dom_1.div({ props: { className: getClassname(props, content) } }, children);
    }
    Fields.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.equalWidth && content.length) {
            className += utils_1.numToText(content.length);
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.grouped) {
            className += " grouped";
        }
        if (props.required) {
            className += " required";
        }
        className += " fields";
        return className;
    }
})(Fields = exports.Fields || (exports.Fields = {}));


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Form;
(function (Form) {
    /**
     * A form component for capturing groups of user input.
     * Accepts the following properties in props$:
     *   loading?: boolean - Styles the form with a loader.
     *   equalWidth?: boolean - Styles the form content to have equal widths per row.
     *   inverted?: boolean - Styles the form for dark backgrounds.
     *   size?: Size - The size of the form's content.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".form").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Form.run = run;
    /**
     * A form component for capturing groups of user input.
     * Accepts the following properties:
     *   loading?: boolean - Styles the form with a loader.
     *   equalWidth?: boolean - Styles the form content to have equal widths per row.
     *   inverted?: boolean - Styles the form for dark backgrounds.
     *   size?: Size - The size of the form's content.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Form.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.loading) {
            className += " loading";
        }
        if (props.equalWidth) {
            className += " equal width";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " form";
        return className;
    }
})(Form = exports.Form || (exports.Form = {}));


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(186));
__export(__webpack_require__(184));
__export(__webpack_require__(185));


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(8);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Column;
(function (Column) {
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties in props$:
     *   float?: Float - Wether the column should be left or right floated.
     *   width?: int - The default width of the column.
     *   mobile?: int - The width of the column on mobile devices.
     *   tablet?: int - The width of the column on tablet devices.
     *   computer?: int - The width of the column on computer devices.
     *   largescreen?: int - The width of the column on large screen devices.
     *   size?: Size - The size of the column.
     *   alignment?: VerticalAlignment - The vertical alignment of the column.
     *   textAlignment?: TextAlignment - The text alignment of the column.
     * Expects the following type of content in Content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".column").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Column.run = run;
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties:
     *   float?: Float - Wether the column should be left or right floated.
     *   width?: int - The default width of the column.
     *   mobile?: int - The width of the column on mobile devices.
     *   tablet?: int - The width of the column on tablet devices.
     *   computer?: int - The width of the column on computer devices.
     *   largescreen?: int - The width of the column on large screen devices.
     *   size?: Size - The size of the column.
     *   alignment?: VerticalAlignment - The vertical alignment of the column.
     *   textAlignment?: TextAlignment - The text alignment of the column.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Column.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.float && props.float === enums_1.Float.Right) {
            className += " right floated";
        }
        if (props.float && props.float === enums_1.Float.Left) {
            className += " left floated";
        }
        if (props.mobile) {
            className += utils_1.numToText(props.mobile) + " wide mobile";
        }
        if (props.tablet) {
            className += utils_1.numToText(props.tablet) + " wide tablet";
        }
        if (props.computer) {
            className += utils_1.numToText(props.computer) + " wide computer";
        }
        if (props.largescreen) {
            className += utils_1.numToText(props.largescreen) + " wide largescreen";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        if (props.width) {
            className += utils_1.numToText(props.width) + " wide";
        }
        className += " column";
        return className;
    }
})(Column = exports.Column || (exports.Column = {}));


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(8);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Grid;
(function (Grid) {
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties in props$:
     *   equallyDivided?: boolean - Styles grid content to take up equal amounts of space.
     *   divided?: boolean - Use dividers to seperate content in the Grid.
     *   container? : boolean - Wraps the grid in a container.
     *   celled?: boolean - Divides the grid into cells.
     *   intCelled?: boolean - Divides the grid into cells with only internal dividers.
     *   padded?: boolean - Adds vertical and horizontal gutters to the grid.
     *   relaxed?: boolean - Increases the amount of negative space.
     *   centered?: boolean - Centers the content of the Grid.
     *   alignment?: VerticalAlignment: Determines the alignment of content in the Grid.
     *   textAlignment?: TextAlignment: Determines the text alignment of content in the Grid.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".grid").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Grid.run = run;
    /**
     * Wraps content in a column suitable for the Grid component.
     * Accepts the following properties:
     *   equallyDivided?: boolean - Styles grid content to take up equal amounts of space.
     *   divided?: boolean - Use dividers to seperate content in the Grid.
     *   container? : boolean - Wraps the grid in a container.
     *   celled?: boolean - Divides the grid into cells.
     *   intCelled?: boolean - Divides the grid into cells with only internal dividers.
     *   padded?: boolean - Adds vertical and horizontal gutters to the grid.
     *   relaxed?: boolean - Increases the amount of negative space.
     *   centered?: boolean - Centers the content of the Grid.
     *   alignment?: VerticalAlignment: Determines the alignment of content in the Grid.
     *   textAlignment?: TextAlignment: Determines the text alignment of content in the Grid.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props, content) } }, content);
    }
    Grid.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.equallyDivided) {
            className += utils_1.numToText(content.length ? content.length : 1) + " column";
        }
        if (props.divided) {
            className += " divided";
        }
        if (props.container) {
            className += " container";
        }
        if (props.celled) {
            className += " celled";
        }
        if (props.intCelled) {
            className += " internally celled";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.relaxed) {
            className += " relaxed";
        }
        if (props.centered) {
            className += " centered";
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        className += " grid";
        return className;
    }
    Grid.getClassname = getClassname;
})(Grid = exports.Grid || (exports.Grid = {}));


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(189));
__export(__webpack_require__(191));
__export(__webpack_require__(188));


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var utils_1 = __webpack_require__(8);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Row;
(function (Row) {
    /**
     * Creates a Row component that wraps Column content.
     * Accepts the following properties in props$:
     *   stretched?: boolean - Ensures the columns are stretched to equal height.
     *   mobile?: boolean - Makes the row visible only on mobile devices.
     *   tablet?: boolean - Makes the row visible only on tablet devices.
     *   computer?: boolean - Makes the row visible only on computer devices.
     *   largescreen?: boolean - Makes the row visible only on largescreen devices.
     *   equallyDivided?: boolean - Makes each column of the row equal in width.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".row").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Row.run = run;
    /**
     * Creates a Row component that wraps Column content.
     * Accepts the following properties:
     *   stretched?: boolean - Ensures the columns are stretched to equal height.
     *   mobile?: boolean - Makes the row visible only on mobile devices.
     *   tablet?: boolean - Makes the row visible only on tablet devices.
     *   computer?: boolean - Makes the row visible only on computer devices.
     *   largescreen?: boolean - Makes the row visible only on largescreen devices.
     *   equallyDivided?: boolean - Makes each column of the row equal in width.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props, content) } }, content);
    }
    Row.render = render;
    function getClassname(props, content) {
        var className = "ui";
        if (props.stretched) {
            className += " stretched";
        }
        if (props.mobile) {
            className += " mobile only";
        }
        if (props.tablet) {
            className += " tablet only";
        }
        if (props.computer) {
            className += " computer only";
        }
        if (props.largescreen) {
            className += " largescreen only";
        }
        if (props.equallyDivided) {
            className += utils_1.numToText(content.length ? content.length : 1) + " column";
        }
        className += " row";
        return className;
    }
})(Row = exports.Row || (exports.Row = {}));


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(183));
__export(__webpack_require__(187));
__export(__webpack_require__(190));
__export(__webpack_require__(59));
__export(__webpack_require__(193));
__export(__webpack_require__(194));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var icon_1 = __webpack_require__(23);
var transition_1 = __webpack_require__(13);
var Message;
(function (Message) {
    /**
     * A message component to present messages to users.
     * Accepts the following properties in props$:
     *   on$?: Stream<boolean> - When to show/hide the message.
     *   closeable?: boolean - Provides a close icon for the message for dismissal.
     *   icon?: boolean - Formats the message to support an icon.
     *   floating?: boolean - Formats the message to float above related content.
     *   compact?: boolean - Formats a message to only occupy width needed by its content.
     *   attached?: boolean - Formats the message to appear attached to other content.
     *   size?: Size - The size of the message.
     *   color?: Color - The color of the message.
     * Expects the following type of content in content$: {}
     *   icon?: String|VNode - A message can have an icon signifying the type of message.
     *   header?: String|VNode - A message can have a header text.
     *   body?: String|VNode - A message can have additionaly body content.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var icon = icon_1.Icon.run({ DOM: sources.DOM, props$: xstream_1.default.of({ type: "close" }) });
            var close$ = icon.Events("click").mapTo(false);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, icon.DOM)
                .map(function (_a) {
                var props = _a[0], content = _a[1], closeIcon = _a[2];
                return dom_1.div({ props: { className: getClassname(props) } }, [
                    content.icon,
                    props.closeable ? closeIcon : "",
                    dom_1.div({ props: { className: "content" } }, [].concat(content.header ? dom_1.div({ props: { className: "header" } }, content.header) : "", content.body))
                ]);
            });
            var on$ = sources.props$.map(function (props) { return props.on$ ? props.on$ : xstream_1.default.of(true); }).flatten();
            var active$ = xstream_1.default.merge(on$, close$);
            var transition$ = active$.fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? { animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out }
                : { animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out }; }, { animation: enums_1.Animation.None, direction: enums_1.Direction.None });
            var animatedVTree$ = transition_1.Transition.run({ DOM: sources.DOM, target$: vTree$, args$: transition$ }).DOM;
            return {
                DOM: animatedVTree$,
                Events: function (type) { return sources.DOM.select(".message").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Message.run = run;
    /**
     * A message component to present messages to users.
     * Accepts the following properties:
     *   on$?: Stream<boolean> - When to show/hide the message.
     *   closeable?: boolean - Provides a close icon for the message for dismissal.
     *   icon?: boolean - Formats the message to support an icon.
     *   floating?: boolean - Formats the message to float above related content.
     *   compact?: boolean - Formats a message to only occupy width needed by its content.
     *   attached?: boolean - Formats the message to appear attached to other content.
     *   size?: Size - The size of the message.
     *   color?: Color - The color of the message.
     * Expects the following type of content: {}
     *   icon?: String|VNode - A message can have an icon signifying the type of message.
     *   header?: String|VNode - A message can have a header text.
     *   body?: String|VNode - A message can have additionaly body content.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = {}; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var closeIcon = icon_1.Icon.render({}, enums_1.IconType.Close);
        return dom_1.div({ props: { className: getClassname(props) } }, [
            content.icon ? icon_1.Icon.render(content.icon) : "",
            props.closeable ? closeIcon : "",
            dom_1.div({ props: { className: "content" } }, [].concat(content.header ? dom_1.div({ props: { className: "header" } }, content.header) : "", content.body))
        ]);
    }
    Message.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.icon) {
            className += " icon";
        }
        if (props.floating) {
            className += " floating";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.attached) {
            className += " attached";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " message";
        return className;
    }
    function isContent(content) {
        return content !== undefined && (interfaces_1.isDOMContent(content.icon) || interfaces_1.isDOMContent(content.header) || interfaces_1.isDOMContent(content.body));
    }
})(Message = exports.Message || (exports.Message = {}));


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Table;
(function (Table) {
    /**
     * A table component to show content in a table.
     * Accepts the following properties in props$:
     *   singleline?: boolean - Formats the content of the table to fit on a single line.
     *   fixed?: boolean - Stops resizing of table cells based on content.
     *   selectable?: boolean - Styles the rows of the table to be selectable.
     *   striped?: boolean - Styles the rows of the table to alternate colors.
     *   celled?: boolean - Divides each row into seperate cells.
     *   basic?: boolean - Reduces the complexity of the table.
     *   verybasic?: boolean - Reduces the complexity of the table by a lot.
     *   collapsing?: boolean - Makes the table only take up as much space as needed.
     *   padded?: boolean - Adds extra padding to the table content.
     *   verypadded?: boolean - Adds a lot of extra padding to the table content.
     *   compact?: boolean - Styles the table content to be more compact, to allow for more rows.
     *   verycompact?: boolean - Styles the table content to be greatly compacted.
     *   size?: Size - The size of the table content.
     *   color?: Color - The colour of the table.
     * Expects the following type of content in content$: {} of
     * 	headers: [DOMContent]
     * 	body: [[DomContent]]
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of({ body: [] });
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".table").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Table.run = run;
    /**
     * A table component to show content in a table.
     * Accepts the following properties in props$:
     *   singleline?: boolean - Formats the content of the table to fit on a single line.
     *   fixed?: boolean - Stops resizing of table cells based on content.
     *   selectable?: boolean - Styles the rows of the table to be selectable.
     *   striped?: boolean - Styles the rows of the table to alternate colors.
     *   celled?: boolean - Divides each row into seperate cells.
     *   basic?: boolean - Reduces the complexity of the table.
     *   verybasic?: boolean - Reduces the complexity of the table by a lot.
     *   collapsing?: boolean - Makes the table only take up as much space as needed.
     *   padded?: boolean - Adds extra padding to the table content.
     *   verypadded?: boolean - Adds a lot of extra padding to the table content.
     *   compact?: boolean - Styles the table content to be more compact, to allow for more rows.
     *   verycompact?: boolean - Styles the table content to be greatly compacted.
     *   size?: Size - The size of the table content.
     *   color?: Color - The colour of the table.
     * Expects the following type of content in content$: {} of
     * 	headers: [DOMContent]
     * 	body: [[DomContent]]
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = { body: [] }; }
        var props = isContent(pOrC) ? {} : pOrC;
        var content = isContent(pOrC) ? pOrC : c;
        var header = content.header ? dom_1.thead([dom_1.tr(content.header.map(function (h) { return dom_1.th(h); }))]) : "";
        var footer;
        if (interfaces_1.isDOMContent(content.footer)) {
            footer = dom_1.tfoot(content.footer);
        }
        else {
            footer = content.footer ? dom_1.tfoot([dom_1.tr(content.footer.map(function (f) { return dom_1.th(f); }))]) : "";
        }
        return dom_1.table({ props: { className: getClassname(props) } }, [
            header,
            dom_1.tbody(content.body.map(function (r) { return dom_1.tr(r.map(function (c) { return dom_1.td(c); })); })),
            footer
        ]);
    }
    Table.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.singleline) {
            className += " single line";
        }
        if (props.fixed) {
            className += " fixed";
        }
        if (props.selectable) {
            className += " selectable";
        }
        if (props.striped) {
            className += " striped";
        }
        if (props.celled) {
            className += " celled";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.verybasic) {
            className += " very basic";
        }
        if (props.collapsing) {
            className += " collapsing";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.verypadded) {
            className += " very padded";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.verycompact) {
            className += " very compact";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " table";
        return className;
    }
    function isContent(content) {
        return content !== undefined && (content.body !== undefined &&
            (content.header !== undefined ||
                content.footer !== undefined));
    }
})(Table = exports.Table || (exports.Table = {}));


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Button;
(function (Button) {
    /**
     * An interactive button component for user interaction through clicking.
     * Accepts the following type of properties in props$:
     *   animated? : boolean - Allows for an animation in the button to show hidden content.
     *   verticalAnimated?: boolean - See animated. This animation is vertical.
     *   labeled?: boolean - Adds styling for labeled buttons.
     *   icon?: boolean - Adds styling for buttons with an icon.
     *   basic?: boolean - Styles the button to appear simpler.
     *   inverted?: boolean - Styles the button to appear on dark backgrounds.
     *   active?: boolean - Sets the button to the active state.
     *   disabled?: boolean - Styles the button to appear disabled.
     *   loading?: boolean - Styles the button show that it is loading / working.
     *   compact?: boolean - Styles the button for a tight fit.
     *   circular?: boolean - Styles the button to appear circular.
     *   fluid?: boolean - Styles the button to be as wide as possible.
     *   href?: string - Outputs the button as a link to to the href.
     *   attachment?: Attachment - Where the button should be attached to.
     *   size?: Size - The size of the button.
     *   float?: Float - The left or right float of the button.
     *   color?: Color - The color of the button.
     * Expects the following type of content in content$: {} of
     *   body?: DOMContent - The body content to display on the button.
     *   hidden?: DOMContent - The hidden content to display for animated buttons.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vtree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vtree$,
                Events: function (type) { return sources.DOM.select(".ui.button").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Button.run = run;
    /**
     * A static button component for user interaction through clicking.
     * Accepts the following type of properties:
     *   animated? : boolean - Allows for an animation in the button to show hidden content.
     *   verticalAnimated?: boolean - See animated. This animation is vertical.
     *   labeled?: boolean - Adds styling for labeled buttons.
     *   icon?: boolean - Adds styling for buttons with an icon.
     *   basic?: boolean - Styles the button to appear simpler.
     *   inverted?: boolean - Styles the button to appear on dark backgrounds.
     *   active?: boolean - Sets the button to the active state.
     *   disabled?: boolean - Styles the button to appear disabled.
     *   loading?: boolean - Styles the button show that it is loading / working.
     *   compact?: boolean - Styles the button for a tight fit.
     *   circular?: boolean - Styles the button to appear circular.
     *   fluid?: boolean - Styles the button to be as wide as possible.
     *   href?: string - Outputs the button as a link to to the href.
     *   attachment?: Attachment - Where the button should be attached to.
     *   size?: Size - The size of the button.
     *   float?: Float - The left or right float of the button.
     *   color?: Color - The color of the button.
     * Expects the following type of content: {} of
     *   body?: DOMContent - The body content to display on the button.
     *   hidden?: DOMContent - The hidden content to display for animated buttons.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var extra = interfaces_1.isDOMContent(pOrC) ? (c !== "") ? c : e : e;
        var children = extra
            ? [dom_1.div({ props: { className: "visible content" } }, content),
                dom_1.div({ props: { className: "hidden content" } }, extra)]
            : content;
        return props.href
            ? dom_1.a({ props: { href: props.href, className: getClassname(props) } }, children)
            : dom_1.div({ props: { className: getClassname(props) } }, children);
    }
    Button.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.animated) {
            className += " animated";
        }
        if (props.verticalAnimated) {
            className += " vertical.animated";
        }
        if (props.labeled) {
            className += " labeled";
        }
        if (props.rightlabeled) {
            className += " right labeled";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.active) {
            className += " active";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.fluid) {
            className += " fluid";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " button";
        return className;
    }
})(Button = exports.Button || (exports.Button = {}));


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Container;
(function (Container) {
    /**
    * A responsive container component to host other content.
    * Does not accept any properties in props$.
    * Expects the following type of content in content$: DOMContent
    */
    function run(sources) {
        function main(sources) {
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = sources.content$.map(function (content) { return render(content); });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".container").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Container.run = run;
    /**
    * A responsive container component to host other content.
    * Does not accept any properties.
    * Expects the following type of content: DOMContent
    */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        // let props = isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: "ui container" } }, content);
    }
    Container.render = render;
})(Container = exports.Container || (exports.Container = {}));


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Divider;
(function (Divider) {
    /**
     * Creates a divider element to seperate content on page.
     * Accepts the following properties in props$:
     * 	content?: VNode - The content to add to the divider.
     * 	horizontal?: boolean - Needed to render text horizontally in the divider.
     * 	vertical?: boolean - Determines vertical/horizontal orientation of the divider.
     * 	inverted?: boolean - For dark backgrounds.
     * 	fitted?: boolean - Minimizes the space between divided content.
     * 	hidden?: boolean - Creates an invisible divider that divides the content.
     * 	section?: boolean - Provides greater margins for between divided content.
     * 	clearing?: boolean - Clears floated content.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".divider").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Divider.run = run;
    /**
     * Creates a divider element to seperate content on page.
     * Accepts the following properties:
     * 	content?: VNode - The content to add to the divider.
     * 	horizontal?: boolean - Needed to render text horizontally in the divider.
     * 	vertical?: boolean - Determines vertical/horizontal orientation of the divider.
     * 	inverted?: boolean - For dark backgrounds.
     * 	fitted?: boolean - Minimizes the space between divided content.
     * 	hidden?: boolean - Creates an invisible divider that divides the content.
     * 	section?: boolean - Provides greater margins for between divided content.
     * 	clearing?: boolean - Clears floated content.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassName(props, content) } }, content);
    }
    Divider.render = render;
    function getClassName(props, content) {
        var className = "ui";
        if (props.vertical) {
            className += " vertical";
        }
        else if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.hidden) {
            className += " hidden";
        }
        if (props.section) {
            className += " section";
        }
        if (props.clearing) {
            className += " clearing";
        }
        if (props.header) {
            className += " header";
        }
        className += " divider";
        return className;
    }
})(Divider = exports.Divider || (exports.Divider = {}));


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Header;
(function (Header) {
    /**
     * Creates a header for important text.
     * Accepts the following properties in props$:
     *   icon?: boolean - Adds styling for icon headers.
     *   divider?: boolean - Adds styling for headers to seperate content.
     *   block?: boolean - Wraps header in a block.
     *   disabled?: boolean - Styling for disabled content.
     *   inverted?: boolean - Styling for dark backgrounds.
     *   attachment?: Attachment - Styling for headers attached to other content.
     *   float?: Float - Floats the header to the left or right.
     *   textAlignment?: TextAlignment - Text alignment of the header text.
     *   size?: Size - Determines the size of the header.
     *   color?: Color - The color of the header.
     * Expects the following type of content in content$: {} of
     *   text: DOMContent - The header text.
     *   subtext?: DOMContent- An optional sub-header to accompany the header.
     *   icon?: DOMContent - Optional image/icon content for the header.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of({});
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".header").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Header.run = run;
    /**
     * Creates a header for important text.
     * Accepts the following properties:
     *   icon?: boolean - Adds styling for icon headers.
     *   divider?: boolean - Adds styling for headers to seperate content.
     *   block?: boolean - Wraps header in a block.
     *   disabled?: boolean - Styling for disabled content.
     *   inverted?: boolean - Styling for dark backgrounds.
     *   attachment?: Attachment - Styling for headers attached to other content.
     *   float?: Float - Floats the header to the left or right.
     *   textAlignment?: TextAlignment - Text alignment of the header text.
     *   size?: Size - Determines the size of the header.
     *   color?: Color - The color of the header.
     * Expects the following type of content: {} of
     *   text: DOMContent - The header text.
     *   subtext?: DOMContent- An optional sub-header to accompany the header.
     *   icon?: DOMContent - Optional image/icon content for the header.
     */
    function render(pOrCorE, cOrE, e) {
        if (pOrCorE === void 0) { pOrCorE = {}; }
        if (cOrE === void 0) { cOrE = {}; }
        if (e === void 0) { e = {}; }
        var props = interfaces_1.isDOMContent(pOrCorE) ? {} : isExtras(pOrCorE) ? {} : pOrCorE;
        var content = interfaces_1.isDOMContent(pOrCorE) ? pOrCorE : interfaces_1.isDOMContent(cOrE) ? cOrE : "";
        var extras = isExtras(pOrCorE) ? pOrCorE : isExtras(cOrE) ? cOrE : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            extras.icon ? extras.icon : "",
            dom_1.div({ props: { className: "content" } }, [].concat(content, extras.subtext ? dom_1.div({ props: { className: "sub header" } }, extras.subtext) : ""))
        ]);
    }
    Header.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.icon) {
            className += " icon";
        }
        if (props.dividing) {
            className += " dividing";
        }
        if (props.divider) {
            className += " divider";
        }
        if (props.block) {
            className += " block";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " header";
        return className;
    }
    function isExtras(extra) {
        return extra !== undefined && (extra.subtext !== undefined
            || (extra.icon !== undefined && typeof (extra.icon) !== "boolean"));
    }
})(Header = exports.Header || (exports.Header = {}));


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var Image;
(function (Image) {
    /**
     * An image component for displaying images.
     * Accepts the following properties in props$:
     *   href?: string - Styles the image as a link towards the location.
     *   hidden?: boolean - Hides the image.
     *   disabled?: boolean - Styles the image to appear disabled.
     *   avatar?: boolean - Styles the image for usage as an avatar.
     *   bordered?: boolean - Styles the image with a border.
     *   spaced?: boolean - Styles the image with extra spacing to seperate it from nearby content.
     *   circular?: boolean - Styles the image to be circular.
     *   rounded?: boolean - Styles the image to have rounded edges.
     *   float?: Float - The float orientation of the image.
     *   size?: Size - The size of the image.
     *   verticalAlignment?: VerticalAlignment - The vertical alignment of text nearby the image.
     * Expects the following type of content in content$: string - The src url.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".image").events(type); },
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Image.run = run;
    /**
     * An image component for displaying images.
     * Accepts the following properties:
     *   link?: boolean - Styles the image as a link.
     *   hidden?: boolean - Hides the image.
     *   disabled?: boolean - Styles the image to appear disabled.
     *   avatar?: boolean - Styles the image for usage as an avatar.
     *   bordered?: boolean - Styles the image with a border.
     *   spaced?: boolean - Styles the image with extra spacing to seperate it from nearby content.
     *   circular?: boolean - Styles the image to be circular.
     *   rounded?: boolean - Styles the image to have rounded edges.
     *   float?: Float - The float orientation of the image.
     *   size?: Size - The size of the image.
     *   verticalAlignment?: VerticalAlignment - The vertical alignment of text nearby the image.
     * Expects the following type of content: string - The src url.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = typeof (pOrC) === "string" ? {} : pOrC;
        var content = typeof (pOrC) === "string" ? pOrC : c;
        var image = dom_1.img({ props: { className: getClassname(props), src: content } });
        return props.href ? dom_1.a({ props: { href: props.href } }, image) : image;
    }
    Image.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.href) {
            className += " link";
        }
        if (props.hidden) {
            className += " hidden";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.avatar) {
            className += " avatar";
        }
        if (props.bordered) {
            className += " bordered";
        }
        if (props.spaced) {
            className += " spaced";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.rounded) {
            className += " rounded";
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.verticalAlignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.verticalAlignment);
        }
        return className + " image";
    }
})(Image = exports.Image || (exports.Image = {}));


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(195));
__export(__webpack_require__(196));
__export(__webpack_require__(197));
__export(__webpack_require__(198));
__export(__webpack_require__(23));
__export(__webpack_require__(199));
__export(__webpack_require__(201));
__export(__webpack_require__(202));
__export(__webpack_require__(203));
__export(__webpack_require__(204));
__export(__webpack_require__(205));
__export(__webpack_require__(206));


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Label;
(function (Label) {
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties in props$:
     *   circular?: boolean - Styles the label to be circular.
     *   empty?: boolean - Styles the label for empty content.
     *   pointing?: boolean - Styles the label to be pointing towards nearby content.
     *   basic?: boolean - Styles the label to be minimalistic.
     *   leftCorner?: boolean - Attaches the label to the top-left corner of nearby content.
     *   rightCorner?: boolean - Attaches the label to the top-right corner of nearby content.
     *   tag?: boolean - Styles the label to look like a tag.
     *   ribbon?: boolean - Styles the label to look like a ribbon over the left side of content.
     *   invRibbon?: boolean - Styles the label to look like a ribbon over the right side of content.
     *   horizontal?: boolean - Styles the label for horizontal content.
     *   floating?: boolean - Styles the label to be floating over nearby content.
     *   attachment?: Attachment - Where the label should be attached to.
     *   size?: Size - The size of the label.
     *   color?: Color - The color of the label.
     * Expects the following type of content and extras: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$, sources.extras$).map(function (_a) {
                var props = _a[0], content = _a[1], extras = _a[2];
                return render(props, content, extras);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".label").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Label.run = run;
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties:
     *   circular?: boolean - Styles the label to be circular.
     *   empty?: boolean - Styles the label for empty content.
     *   pointing?: boolean - Styles the label to be pointing towards nearby content.
     *   basic?: boolean - Styles the label to be minimalistic.
     *   leftCorner?: boolean - Attaches the label to the top-left corner of nearby content.
     *   rightCorner?: boolean - Attaches the label to the top-right corner of nearby content.
     *   tag?: boolean - Styles the label to look like a tag.
     *   ribbon?: boolean - Styles the label to look like a ribbon over the left side of content.
     *   invRibbon?: boolean - Styles the label to look like a ribbon over the right side of content.
     *   horizontal?: boolean - Styles the label for horizontal content.
     *   floating?: boolean - Styles the label to be floating over nearby content.
     *   attachment?: Attachment - Where the label should be attached to.
     *   size?: Size - The size of the label.
     *   color?: Color - The color of the label.
     * Expects the following type of content and extras: DOMContent
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var detail = interfaces_1.isDOMContent(pOrC) ? c : e;
        if (content instanceof Array) {
            content = content.concat(detail ? dom_1.div({ props: { className: "detail" } }, detail) : "");
        }
        else {
            content = [
                content,
                detail ? dom_1.div({ props: { className: "detail" } }, detail) : ""
            ];
        }
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Label.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.circular) {
            className += " circular";
        }
        if (props.empty) {
            className += " empty";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (props.basic) {
            className += " basic";
        }
        if (props.leftCorner) {
            className += " left corner";
        }
        if (props.rightCorner) {
            className += " right corner";
        }
        if (props.tag) {
            className += " tag";
        }
        if (props.ribbon) {
            className += " ribbon";
        }
        if (props.invRibbon) {
            className += " right ribbon";
        }
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.floating) {
            className += " floating ";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " label";
        return className;
    }
})(Label = exports.Label || (exports.Label = {}));


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var List;
(function (List) {
    /**
     * Creates a List component for showing lists of content.
     * Accepts the following properties in props$:
     *   bulleted?: boolean - Displays list as a bulleted list.
     *   ordered?: boolean - Displays list as an ordered list.
     *   link?: boolean - Styling for lists with links.
     *   horizontal?: boolean - Displays list horizontally.
     *   inverted?: boolean - Styling for lists on dark backgrounds.
     *   selection?: boolean - Styling for lists meant to display a selection.
     *   animated?: boolean - Adds an animation to display currently selected item.
     *   relaxed?: boolean - Adds more negative space arround the list.
     *   divided?: boolean - Adds horizontal dividers between content of list.
     *   celled?: boolean - Wraps content of list in cells.
     *   size?: Size - The size of the list and its content.
     *   alignment?: VerticalAlignment - The vertical alignment of list's content.
     *   float?: Float - Wether the list should be left or right floating.
     * Expects the following type of content: Array of {}
     *   left?: DOMContent - Left floated content for the item.
     *   body?: DOMContent - Body content for the item.
     *   right?: DOMContent - Right floated content for the item.
     *   header?: DOMContent - Name of the list item
     *   description?: DOMContent - Description of the list item.
     *   href?: string - Link for link lists
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".list").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    List.run = run;
    /**
     * Creates a List component for showing lists of content.
     * Accepts the following properties in props$:
     *   bulleted?: boolean - Displays list as a bulleted list.
     *   ordered?: boolean - Displays list as an ordered list.
     *   link?: boolean - Styling for lists with links.
     *   horizontal?: boolean - Displays list horizontally.
     *   inverted?: boolean - Styling for lists on dark backgrounds.
     *   selection?: boolean - Styling for lists meant to display a selection.
     *   animated?: boolean - Adds an animation to display currently selected item.
     *   relaxed?: boolean - Adds more negative space arround the list.
     *   divided?: boolean - Adds horizontal dividers between content of list.
     *   celled?: boolean - Wraps content of list in cells.
     *   size?: Size - The size of the list and its content.
     *   alignment?: VerticalAlignment - The vertical alignment of list's content.
     *   float?: Float - Wether the list should be left or right floating.
     * Expects the following type of content: Array of {}
     *   left?: DOMContent - Left floated content for the item.
     *   body?: DOMContent - Body content for the item.
     *   right?: DOMContent - Right floated content for the item.
     *   header?: DOMContent - Name of the list item
     *   description?: DOMContent - Description of the list item.
     *   href?: string - Link for link lists
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content.map(function (_a) {
            var header = _a.header, icon = _a.icon, content = _a.content, description = _a.description, href = _a.href, left = _a.left, right = _a.right;
            var l = left ? dom_1.div({ props: { className: "left floated content" } }, left) : undefined;
            var r = right ? dom_1.div({ props: { className: "right floated content" } }, right) : undefined;
            var h = header ? dom_1.div({ props: { className: "header" } }, header) : undefined;
            var d = description ? dom_1.div({ props: { className: "description" } }, description) : undefined;
            var i = icon ? icon : "";
            var c = dom_1.div({ props: { className: "content" } }, [].concat(h, d, content));
            var children = [].concat(l, i, c, r);
            return href
                ? dom_1.a({ props: { className: "item" } }, { props: { href: href } }, children)
                : dom_1.div({ props: { className: "item" } }, children);
        }));
    }
    List.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.bulleted) {
            className += " bulleted";
        }
        if (props.ordered) {
            className += " ordered";
        }
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.selection) {
            className += " selection";
        }
        if (props.animated) {
            className += " animated";
        }
        if (props.relaxed) {
            className += " relaxed";
        }
        if (props.divided) {
            className += " divided";
        }
        if (props.celled) {
            className += " celled";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.alignment) !== "undefined") {
            className += enums_1.VerticalAlignment.ToClassname(props.alignment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        className += " list";
        return className;
    }
})(List = exports.List || (exports.List = {}));


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var dimmer_1 = __webpack_require__(37);
var Loader;
(function (Loader) {
    /**
     * A loader component to show that certain content or a page is loading.
     * Accepts the following properties in props$:
     *   type: LoaderType - The type of loader to use. See exported enum.
     *   element?: Stream<VNode> - The element to mark as loaded. (Only used for type.Content)
     *   on$: Stream<boolean> - When to show/hide the loader. (Not used for inline, add disabled property instead.)
     *   centered?: boolean - Centers the loader spinner in its parent component.
     *   active?: boolean - Always shows the loader.
     *   disabled?: boolean - Always hides the loader.
     *   indeterminate?: boolean - Makes the loader spin indicate its unsure of how long a task will take.
     *   text?: boolean - Positions the loader to leave space for text.
     *   size?: Size - The size of the loader.
     * Expects the following type of content in content$ of: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ type: LoaderType.Inline });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var props$ = sources.props$.remember();
            var vTree$ = xstream_1.default.combine(props$, sources.content$)
                .map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            var on$ = props$.map(function (props) { return props.on$; }).flatten();
            var target$ = props$.map(function (props) { return props.type === LoaderType.Page ? xstream_1.default.of("page") : props.element; }).flatten();
            var dimmer = dimmer_1.Dimmer.run({ DOM: sources.DOM, args$: on$, target$: target$, content$: vTree$ }, props$.map(function (props) { return props.inverted; }));
            var result$ = props$.map(function (props) { return props.type === LoaderType.Inline ? vTree$ : dimmer.DOM; }).flatten();
            return {
                DOM: result$,
                Events: function (type) { return sources.DOM.select(".loader").events(type); },
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Loader.run = run;
    /**
     * A loader component to show that certain content or a page is loading.
     * Accepts the following properties:
     *   type: LoaderType - The type of loader to use. See exported enum.
     *   element?: Stream<VNode> - The element to mark as loaded. (Only used for type.Content)
     *   on$: Stream<boolean> - When to show/hide the loader. (Not used for inline, add disabled property instead.)
     *   centered?: boolean - Centers the loader spinner in its parent component.
     *   active?: boolean - Always shows the loader.
     *   disabled?: boolean - Always hides the loader.
     *   indeterminate?: boolean - Makes the loader spin indicate its unsure of how long a task will take.
     *   text?: boolean - Positions the loader to leave space for text.
     *   size?: Size - The size of the loader.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = { type: LoaderType.Page }; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? { type: LoaderType.Page } : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return [dom_1.div({ props: { className: getClassname(props) } }, content)];
    }
    Loader.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.active) {
            className += " active";
        }
        if (props.centered) {
            className += " centered";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.indeterminate) {
            className += " indeterminate";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.text) {
            className += " text";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += LoaderType.ToClassname(props.type);
        return className;
    }
    var LoaderType;
    (function (LoaderType) {
        LoaderType[LoaderType["Inline"] = 0] = "Inline";
        LoaderType[LoaderType["Page"] = 1] = "Page";
        LoaderType[LoaderType["Content"] = 2] = "Content";
    })(LoaderType = Loader.LoaderType || (Loader.LoaderType = {}));
    (function (LoaderType) {
        function ToClassname(type) {
            switch (type) {
                case LoaderType.Inline: return " inline loader";
                case LoaderType.Page: return " loader";
                case LoaderType.Content: return " loader";
            }
        }
        LoaderType.ToClassname = ToClassname;
    })(LoaderType = Loader.LoaderType || (Loader.LoaderType = {}));
})(Loader = exports.Loader || (exports.Loader = {}));


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Segment;
(function (Segment) {
    /**
     * A segment component to divide up page content into segments.
     * Accepts the following properties in props$:
     *   raised?: boolean? - Styles the segment to appear floating above nearby content.
     *   stacked?: boolean? - Styles the segment to appear like a stack of papers.
     *   tallStacked?: boolean? - Styles the segment to appear like a tall stack of papers.
     *   piled?: boolean? - Styles the segment to appear like a pile of papers.
     *   vertical?: boolean? - Styles the segment content to be aligned as part of a vertical group.
     *   loading?: boolean? - Styles the segment with a loading icon.
     *   inverted?: boolean? - Styles the segment for dark content.
     *   padded?: boolean? - Increases the padding on the segment.
     *   veryPadded?: boolean - Increases the padding on the segment by a lot.
     *   compact?: boolean - Makes the segment take up only the space needed by its content.
     *   circular?: boolean - Styles the segment to be circular.
     *   clearing?: boolean - Clears floated content.
     *   basic?: boolean - Removes any special styling.
     *   color?: Color - The color of the segment.
     *   attachment?: Attachment - The attachment of the segment.
     *   float?: Float - Where the segment should float.
     *   textAlignment?: TextAlignment - The text alignment of the segment.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".segment").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Segment.run = run;
    /**
     * A segment component to divide up page content into segments.
     * Accepts the following properties:
     *   raised?: boolean? - Styles the segment to appear floating above nearby content.
     *   stacked?: boolean? - Styles the segment to appear like a stack of papers.
     *   tallStacked?: boolean? - Styles the segment to appear like a tall stack of papers.
     *   piled?: boolean? - Styles the segment to appear like a pile of papers.
     *   vertical?: boolean? - Styles the segment content to be aligned as part of a vertical group.
     *   loading?: boolean? - Styles the segment with a loading icon.
     *   inverted?: boolean? - Styles the segment for dark content.
     *   padded?: boolean? - Increases the padding on the segment.
     *   veryPadded?: boolean - Increases the padding on the segment by a lot.
     *   compact?: boolean - Makes the segment take up only the space needed by its content.
     *   circular?: boolean - Styles the segment to be circular.
     *   clearing?: boolean - Clears floated content.
     *   basic?: boolean - Removes any special styling.
     *   color?: Color - The color of the segment.
     *   attachment?: Attachment - The attachment of the segment.
     *   float?: Float - Where the segment should float.
     *   textAlignment?: TextAlignment - The text alignment of the segment.
     * Expects the following type of content : DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, content);
    }
    Segment.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.raised) {
            className += " raised";
        }
        if (props.stacked) {
            className += " stacked";
        }
        if (props.tallStacked) {
            className += " tall stacked";
        }
        if (props.piled) {
            className += " piled";
        }
        if (props.vertical) {
            className += " vertical";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.padded) {
            className += " padded";
        }
        if (props.veryPadded) {
            className += " very padded";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.circular) {
            className += " circular";
        }
        if (props.clearing) {
            className += " clearing";
        }
        if (props.basic) {
            className += " basic";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        if (typeof (props.textAlignment) !== "undefined") {
            className += enums_1.TextAlignment.ToClassname(props.textAlignment);
        }
        className += " segment";
        return className;
    }
})(Segment = exports.Segment || (exports.Segment = {}));


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(8);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Steps;
(function (Steps) {
    /**
     * A steps component to show the completion status of a series of activities.
     * Accepts the following properties in props$:
     *  link?: boolean - Styles to steps to display as a link.
     * 	vertical?: boolean - Styles the steps to align vertically.
     * 	stackable?: boolean - Lets the steps realign vertically on smaller screens.
     * 	evenlyDivided?: boolean - Arranges the steps to take up equal amount of width of their parent.
     * 	fluid?: boolean - Styles the steps to take up the full width of their parent.
     * 	size?: Size - The size of the steps.
     * 	attachment?: Attachment - Styles the steps to appear attached to nearby content.
     * Expects the following type of content in content$: Array of {}
     * 	icon?: DOMContent The icon to use for the step.
     * 	header?: DOMContent - The title for the step.
     * 	description?: DOMContent - The description for the step.
     * 	isCompleted?: boolean - Marks the step as completed.
     * 	isActive?: boolean - Marks the step as the current step.
     * 	isDisabled?: boolean - Marks the step as disabled.
     *  link?: boolean - Style the step to be clickable.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            var evt = function (type) { return sources.DOM.select(".step").events(type); };
            return {
                DOM: vTree$,
                Events: evt,
                value$: xstream_1.default.never()
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Steps.run = run;
    /**
     * A steps component to show the completion status of a series of activities.
     * Accepts the following properties:
     *  link?: boolean - Styles to steps to display as a link.
     * 	vertical?: boolean - Styles the steps to align vertically.
     * 	stackable?: boolean - Lets the steps realign vertically on smaller screens.
     * 	evenlyDivided?: boolean - Arranges the steps to take up equal amount of width of their parent.
     * 	fluid?: boolean - Styles the steps to take up the full width of their parent.
     * 	size?: Size - The size of the steps.
     * 	attachment?: Attachment - Styles the steps to appear attached to nearby content.
     * Expects the following type of content: Array of {}
     * 	icon?: DOMContent The icon to use for the step.
     * 	header?: DOMContent - The title for the step.
     * 	description?: DOMContent - The description for the step.
     * 	isCompleted?: boolean - Marks the step as completed.
     * 	isActive?: boolean - Marks the step as the current step.
     * 	isDisabled?: boolean - Marks the step as disabled.
     *  link?: boolean - Style the step to be clickable.
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = pOrC instanceof Array ? {} : pOrC;
        var content = pOrC instanceof Array ? pOrC : c;
        var children = content.map(function (_a, i) {
            var icon = _a.icon, header = _a.header, description = _a.description, isCompleted = _a.isCompleted, isActive = _a.isActive, isDisabled = _a.isDisabled, link = _a.link;
            return props.link
                ? dom_1.a({ props: { id: i, className: getStepClassname(isCompleted, isActive, isDisabled, link) } }, [
                    icon,
                    dom_1.div({ props: { className: "content" } }, [
                        dom_1.div({ props: { className: "title" } }, header),
                        dom_1.div({ props: { className: "description" } }, description)
                    ])
                ])
                : dom_1.div({ props: { id: i, className: getStepClassname(isCompleted, isActive, isDisabled, link) } }, [
                    icon,
                    dom_1.div({ props: { className: "content" } }, [
                        dom_1.div({ props: { className: "title" } }, header),
                        dom_1.div({ props: { className: "description" } }, description)
                    ])
                ]);
        });
        return dom_1.div({ props: { className: getClassname(props, content.length) } }, children);
    }
    Steps.render = render;
    function getStepClassname(isCompleted, isActive, isDisabled, link) {
        var className = "";
        if (isActive) {
            className += "active";
        }
        if (isCompleted) {
            className += " completed";
        }
        if (isDisabled) {
            className += " disabled";
        }
        if (link) {
            className += " link";
        }
        className += " step";
        return className;
    }
    function getClassname(props, length) {
        var className = "ui";
        if (props.vertical) {
            className += " vertical";
        }
        if (props.stackable) {
            className += " stackable";
        }
        if (props.fluid) {
            className += " fluid";
        }
        if (props.evenlyDivided) {
            className += utils_1.numToText(length);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        className += " steps";
        return className;
    }
})(Steps = exports.Steps || (exports.Steps = {}));


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Textbox;
(function (Textbox) {
    /**
     * A textbox component for capturing user input.
     * Accepts the following properties in props$:
     *   initial?: string - The initial value of the textbox.
     *   placeholder?: string - The placeholder text of the textbox.
     *   icon?: boolean - Styles the textbox for displaying an icon in the textbox.
     *   labeled?: boolean - Styles the textbox for displaying a label in the textbox.
     *   action?: boolean - Styles the textbox for displaying an action component in the textbox.
     *   leftContent?: boolean - Adds content to the left side of the textbox.
     *   rightContent?: boolean - Adds content to the right side of the textbox.
     *   transparent?: boolean - Styles the textbox to appear transparent.
     *   inverted?: boolean - Styles the textbox for darker backgrounds.
     *   focus?: boolean - Styles the textbox to show it has focus.
     *   loading?: boolean - Styles the textbox with a loading icon.
     *   disabled?: boolean - Styles the textbox to appear disabled.
     *   color?: Color - The color of the textbox.
     *   size?: Size - The size of the textbox.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var evt = function (type) { return sources.DOM.select(".input").events(type); };
            var props$ = sources.props$.remember();
            // const initialValue$ = props$.map(props => props.initial);
            var newValue$ = evt("input").map(function (ev) { return ev.target.value; }).remember();
            // const value$ = xs.merge(initialValue$, newValue$);
            var vtree$ = xstream_1.default.combine(props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vtree$,
                Events: evt,
                value$: newValue$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Textbox.run = run;
    /**
     * A textbox component for capturing user input.
     * Accepts the following properties:
     *   initial?: string - The initial value of the textbox.
     *   placeholder?: string - The placeholder text of the textbox.
     *   icon?: boolean - Styles the textbox for displaying an icon in the textbox.
     *   labeled?: boolean - Styles the textbox for displaying a label in the textbox.
     *   action?: boolean - Styles the textbox for displaying an action component in the textbox.
     *   leftContent?: boolean - Adds content to the left side of the textbox.
     *   rightContent?: boolean - Adds content to the right side of the textbox.
     *   transparent?: boolean - Styles the textbox to appear transparent.
     *   inverted?: boolean - Styles the textbox for darker backgrounds.
     *   focus?: boolean - Styles the textbox to show it has focus.
     *   loading?: boolean - Styles the textbox with a loading icon.
     *   disabled?: boolean - Styles the textbox to appear disabled.
     *   color?: Color - The color of the textbox.
     *   size?: Size - The size of the textbox.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var textbox = props.large
            ? dom_1.textarea({ props: { value: props.initial, placeholder: props.placeholder } })
            : dom_1.input({ props: { type: props.type ? props.type : "text", value: props.initial, placeholder: props.placeholder } });
        return props.rightContent
            ? dom_1.div({ props: { className: getClassname(props) } }, [
                textbox,
                content
            ])
            : dom_1.div({ props: { className: getClassname(props) } }, [
                content,
                textbox
            ]);
    }
    Textbox.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.leftContent) {
            className += " left";
        }
        if (props.rightContent) {
            className += " right";
        }
        if (props.icon) {
            className += " icon";
        }
        if (props.labeled) {
            className += " labeled";
        }
        if (props.action) {
            className += " action";
        }
        if (props.transparent) {
            className += " transparent";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (props.focus) {
            className += " focus";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += " input";
        return className;
    }
})(Textbox = exports.Textbox || (exports.Textbox = {}));


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IconType;
(function (IconType) {
    function ToClassname(type) {
        if (type < 0) {
            return "";
        }
        var name = IconType[type];
        return " " + name.match(/[A-Z][a-z]+/g).join(" ").toLowerCase();
    }
    IconType.ToClassname = ToClassname;
    function GetNames() {
        var names = [];
        for (var n in IconType) {
            if (typeof IconType[n] === "number") {
                names.push(n);
            }
        }
        return names;
    }
    IconType.GetNames = GetNames;
})(IconType = exports.IconType || (exports.IconType = {}));
(function (IconType) {
    IconType[IconType["Search"] = 0] = "Search";
    IconType[IconType["MailOutline"] = 1] = "MailOutline";
    IconType[IconType["External"] = 2] = "External";
    IconType[IconType["Signal"] = 3] = "Signal";
    IconType[IconType["Setting"] = 4] = "Setting";
    IconType[IconType["Home"] = 5] = "Home";
    IconType[IconType["Inbox"] = 6] = "Inbox";
    IconType[IconType["Browser"] = 7] = "Browser";
    IconType[IconType["Tag"] = 8] = "Tag";
    IconType[IconType["Tags"] = 9] = "Tags";
    IconType[IconType["Calendar"] = 10] = "Calendar";
    IconType[IconType["Comment"] = 11] = "Comment";
    IconType[IconType["Comments"] = 12] = "Comments";
    IconType[IconType["Shop"] = 13] = "Shop";
    IconType[IconType["Privacy"] = 14] = "Privacy";
    IconType[IconType["Settings"] = 15] = "Settings";
    IconType[IconType["Trophy"] = 16] = "Trophy";
    IconType[IconType["Payment"] = 17] = "Payment";
    IconType[IconType["Feed"] = 18] = "Feed";
    IconType[IconType["AlarmOutline"] = 19] = "AlarmOutline";
    IconType[IconType["Tasks"] = 20] = "Tasks";
    IconType[IconType["Cloud"] = 21] = "Cloud";
    IconType[IconType["Lab"] = 22] = "Lab";
    IconType[IconType["Mail"] = 23] = "Mail";
    IconType[IconType["Idea"] = 24] = "Idea";
    IconType[IconType["Dashboard"] = 25] = "Dashboard";
    IconType[IconType["Sitemap"] = 26] = "Sitemap";
    IconType[IconType["Alarm"] = 27] = "Alarm";
    IconType[IconType["Terminal"] = 28] = "Terminal";
    IconType[IconType["Code"] = 29] = "Code";
    IconType[IconType["Protect"] = 30] = "Protect";
    IconType[IconType["CalendarOutline"] = 31] = "CalendarOutline";
    IconType[IconType["Ticket"] = 32] = "Ticket";
    IconType[IconType["ExternalSquare"] = 33] = "ExternalSquare";
    IconType[IconType["Map"] = 34] = "Map";
    IconType[IconType["Bug"] = 35] = "Bug";
    IconType[IconType["MailSquare"] = 36] = "MailSquare";
    IconType[IconType["History"] = 37] = "History";
    IconType[IconType["Options"] = 38] = "Options";
    IconType[IconType["CommentOutline"] = 39] = "CommentOutline";
    IconType[IconType["CommentsOutline"] = 40] = "CommentsOutline";
    IconType[IconType["TextTelephone"] = 41] = "TextTelephone";
    IconType[IconType["Find"] = 42] = "Find";
    IconType[IconType["Wifi"] = 43] = "Wifi";
    IconType[IconType["AlarmSlash"] = 44] = "AlarmSlash";
    IconType[IconType["AlarmSlashOutline"] = 45] = "AlarmSlashOutline";
    IconType[IconType["Copyright"] = 46] = "Copyright";
    IconType[IconType["At"] = 47] = "At";
    IconType[IconType["Eyedropper"] = 48] = "Eyedropper";
    IconType[IconType["PaintBrush"] = 49] = "PaintBrush";
    IconType[IconType["Heartbeat"] = 50] = "Heartbeat";
    IconType[IconType["Download"] = 51] = "Download";
    IconType[IconType["Repeat"] = 52] = "Repeat";
    IconType[IconType["Refresh"] = 53] = "Refresh";
    IconType[IconType["Lock"] = 54] = "Lock";
    IconType[IconType["Bookmark"] = 55] = "Bookmark";
    IconType[IconType["Print"] = 56] = "Print";
    IconType[IconType["Write"] = 57] = "Write";
    IconType[IconType["Theme"] = 58] = "Theme";
    IconType[IconType["Adjust"] = 59] = "Adjust";
    IconType[IconType["Edit"] = 60] = "Edit";
    IconType[IconType["ExternalShare"] = 61] = "ExternalShare";
    IconType[IconType["Ban"] = 62] = "Ban";
    IconType[IconType["MailForward"] = 63] = "MailForward";
    IconType[IconType["Share"] = 64] = "Share";
    IconType[IconType["Expand"] = 65] = "Expand";
    IconType[IconType["Compress"] = 66] = "Compress";
    IconType[IconType["Unhide"] = 67] = "Unhide";
    IconType[IconType["Hide"] = 68] = "Hide";
    IconType[IconType["Random"] = 69] = "Random";
    IconType[IconType["Retweet"] = 70] = "Retweet";
    IconType[IconType["SignOut"] = 71] = "SignOut";
    IconType[IconType["Pin"] = 72] = "Pin";
    IconType[IconType["SignIn"] = 73] = "SignIn";
    IconType[IconType["Upload"] = 74] = "Upload";
    IconType[IconType["Call"] = 75] = "Call";
    IconType[IconType["CallSquare"] = 76] = "CallSquare";
    IconType[IconType["RemoveBookmark"] = 77] = "RemoveBookmark";
    IconType[IconType["Unlock"] = 78] = "Unlock";
    IconType[IconType["Configure"] = 79] = "Configure";
    IconType[IconType["Filter"] = 80] = "Filter";
    IconType[IconType["Wizard"] = 81] = "Wizard";
    IconType[IconType["Undo"] = 82] = "Undo";
    IconType[IconType["Exchange"] = 83] = "Exchange";
    IconType[IconType["CloudDownload"] = 84] = "CloudDownload";
    IconType[IconType["CloudUpload"] = 85] = "CloudUpload";
    IconType[IconType["Reply"] = 86] = "Reply";
    IconType[IconType["ReplyAll"] = 87] = "ReplyAll";
    IconType[IconType["Erase"] = 88] = "Erase";
    IconType[IconType["UnlockAlternate"] = 89] = "UnlockAlternate";
    IconType[IconType["Archive"] = 90] = "Archive";
    IconType[IconType["Translate"] = 91] = "Translate";
    IconType[IconType["Recycle"] = 92] = "Recycle";
    IconType[IconType["Send"] = 93] = "Send";
    IconType[IconType["SendOutline"] = 94] = "SendOutline";
    IconType[IconType["ShareAlternate"] = 95] = "ShareAlternate";
    IconType[IconType["ShareAlternateSquare"] = 96] = "ShareAlternateSquare";
    IconType[IconType["Wait"] = 97] = "Wait";
    IconType[IconType["WriteSquare"] = 98] = "WriteSquare";
    IconType[IconType["ShareSquare"] = 99] = "ShareSquare";
    IconType[IconType["AddToCart"] = 100] = "AddToCart";
    IconType[IconType["InCart"] = 101] = "InCart";
    IconType[IconType["AddUser"] = 102] = "AddUser";
    IconType[IconType["RemoveUser"] = 103] = "RemoveUser";
    IconType[IconType["HelpCircle"] = 104] = "HelpCircle";
    IconType[IconType["InfoCircle"] = 105] = "InfoCircle";
    IconType[IconType["Warning"] = 106] = "Warning";
    IconType[IconType["WarningCircle"] = 107] = "WarningCircle";
    IconType[IconType["WarningSign"] = 108] = "WarningSign";
    IconType[IconType["Help"] = 109] = "Help";
    IconType[IconType["Info"] = 110] = "Info";
    IconType[IconType["Announcement"] = 111] = "Announcement";
    IconType[IconType["Birthday"] = 112] = "Birthday";
    IconType[IconType["Users"] = 113] = "Users";
    IconType[IconType["Doctor"] = 114] = "Doctor";
    IconType[IconType["Child"] = 115] = "Child";
    IconType[IconType["User"] = 116] = "User";
    IconType[IconType["Handicap"] = 117] = "Handicap";
    IconType[IconType["Student"] = 118] = "Student";
    IconType[IconType["Spy"] = 119] = "Spy";
    IconType[IconType["GridLayout"] = 120] = "GridLayout";
    IconType[IconType["ListLayout"] = 121] = "ListLayout";
    IconType[IconType["BlockLayout"] = 122] = "BlockLayout";
    IconType[IconType["Zoom"] = 123] = "Zoom";
    IconType[IconType["ZoomOut"] = 124] = "ZoomOut";
    IconType[IconType["ResizeVertical"] = 125] = "ResizeVertical";
    IconType[IconType["ResizeHorizontal"] = 126] = "ResizeHorizontal";
    IconType[IconType["Maximize"] = 127] = "Maximize";
    IconType[IconType["Crop"] = 128] = "Crop";
    IconType[IconType["Female"] = 129] = "Female";
    IconType[IconType["Male"] = 130] = "Male";
    IconType[IconType["Woman"] = 131] = "Woman";
    IconType[IconType["Man"] = 132] = "Man";
    IconType[IconType["NonBinaryTransgender"] = 133] = "NonBinaryTransgender";
    IconType[IconType["Intergender"] = 134] = "Intergender";
    IconType[IconType["Transgender"] = 135] = "Transgender";
    IconType[IconType["Lesbian"] = 136] = "Lesbian";
    IconType[IconType["Gay"] = 137] = "Gay";
    IconType[IconType["Heterosexual"] = 138] = "Heterosexual";
    IconType[IconType["OtherGender"] = 139] = "OtherGender";
    IconType[IconType["OtherGenderVertical"] = 140] = "OtherGenderVertical";
    IconType[IconType["OtherGenderHorizontal"] = 141] = "OtherGenderHorizontal";
    IconType[IconType["Neuter"] = 142] = "Neuter";
    IconType[IconType["Cocktail"] = 143] = "Cocktail";
    IconType[IconType["Road"] = 144] = "Road";
    IconType[IconType["Flag"] = 145] = "Flag";
    IconType[IconType["Book"] = 146] = "Book";
    IconType[IconType["Gift"] = 147] = "Gift";
    IconType[IconType["Leaf"] = 148] = "Leaf";
    IconType[IconType["Fire"] = 149] = "Fire";
    IconType[IconType["Plane"] = 150] = "Plane";
    IconType[IconType["Magnet"] = 151] = "Magnet";
    IconType[IconType["Legal"] = 152] = "Legal";
    IconType[IconType["Lemon"] = 153] = "Lemon";
    IconType[IconType["World"] = 154] = "World";
    IconType[IconType["Travel"] = 155] = "Travel";
    IconType[IconType["Shipping"] = 156] = "Shipping";
    IconType[IconType["Money"] = 157] = "Money";
    IconType[IconType["Lightning"] = 158] = "Lightning";
    IconType[IconType["Rain"] = 159] = "Rain";
    IconType[IconType["Treatment"] = 160] = "Treatment";
    IconType[IconType["Suitcase"] = 161] = "Suitcase";
    IconType[IconType["Bar"] = 162] = "Bar";
    IconType[IconType["FlagOutline"] = 163] = "FlagOutline";
    IconType[IconType["FlagCheckered"] = 164] = "FlagCheckered";
    IconType[IconType["Puzzle"] = 165] = "Puzzle";
    IconType[IconType["FireExtinguisher"] = 166] = "FireExtinguisher";
    IconType[IconType["Rocket"] = 167] = "Rocket";
    IconType[IconType["Anchor"] = 168] = "Anchor";
    IconType[IconType["Bullseye"] = 169] = "Bullseye";
    IconType[IconType["Sun"] = 170] = "Sun";
    IconType[IconType["Moon"] = 171] = "Moon";
    IconType[IconType["Fax"] = 172] = "Fax";
    IconType[IconType["LifeRing"] = 173] = "LifeRing";
    IconType[IconType["Bomb"] = 174] = "Bomb";
    IconType[IconType["Soccer"] = 175] = "Soccer";
    IconType[IconType["Calculator"] = 176] = "Calculator";
    IconType[IconType["Diamond"] = 177] = "Diamond";
    IconType[IconType["Crosshairs"] = 178] = "Crosshairs";
    IconType[IconType["Asterisk"] = 179] = "Asterisk";
    IconType[IconType["Certificate"] = 180] = "Certificate";
    IconType[IconType["Circle"] = 181] = "Circle";
    IconType[IconType["QuoteLeft"] = 182] = "QuoteLeft";
    IconType[IconType["QuoteRight"] = 183] = "QuoteRight";
    IconType[IconType["EllipsisHorizontal"] = 184] = "EllipsisHorizontal";
    IconType[IconType["EllipsisVertical"] = 185] = "EllipsisVertical";
    IconType[IconType["Cube"] = 186] = "Cube";
    IconType[IconType["Cubes"] = 187] = "Cubes";
    IconType[IconType["CircleNotched"] = 188] = "CircleNotched";
    IconType[IconType["CircleThin"] = 189] = "CircleThin";
    IconType[IconType["SquareOutline"] = 190] = "SquareOutline";
    IconType[IconType["Square"] = 191] = "Square";
    IconType[IconType["Checkmark"] = 192] = "Checkmark";
    IconType[IconType["Remove"] = 193] = "Remove";
    IconType[IconType["CheckmarkBox"] = 194] = "CheckmarkBox";
    IconType[IconType["Move"] = 195] = "Move";
    IconType[IconType["AddCircle"] = 196] = "AddCircle";
    IconType[IconType["MinusCircle"] = 197] = "MinusCircle";
    IconType[IconType["RemoveCircle"] = 198] = "RemoveCircle";
    IconType[IconType["CheckCircle"] = 199] = "CheckCircle";
    IconType[IconType["RemoveCircleOutline"] = 200] = "RemoveCircleOutline";
    IconType[IconType["CheckCircleOutline"] = 201] = "CheckCircleOutline";
    IconType[IconType["Plus"] = 202] = "Plus";
    IconType[IconType["Minus"] = 203] = "Minus";
    IconType[IconType["AddSquare"] = 204] = "AddSquare";
    IconType[IconType["Radio"] = 205] = "Radio";
    IconType[IconType["SelectedRadio"] = 206] = "SelectedRadio";
    IconType[IconType["MinusSquare"] = 207] = "MinusSquare";
    IconType[IconType["MinusSquareOutline"] = 208] = "MinusSquareOutline";
    IconType[IconType["CheckSquare"] = 209] = "CheckSquare";
    IconType[IconType["PlusSquareOutline"] = 210] = "PlusSquareOutline";
    IconType[IconType["ToggleOff"] = 211] = "ToggleOff";
    IconType[IconType["ToggleOn"] = 212] = "ToggleOn";
    IconType[IconType["Film"] = 213] = "Film";
    IconType[IconType["Sound"] = 214] = "Sound";
    IconType[IconType["Photo"] = 215] = "Photo";
    IconType[IconType["BarChart"] = 216] = "BarChart";
    IconType[IconType["CameraRetro"] = 217] = "CameraRetro";
    IconType[IconType["Newspaper"] = 218] = "Newspaper";
    IconType[IconType["AreaChart"] = 219] = "AreaChart";
    IconType[IconType["PieChart"] = 220] = "PieChart";
    IconType[IconType["LineChart"] = 221] = "LineChart";
    IconType[IconType["ArrowCircleOutlineDown"] = 222] = "ArrowCircleOutlineDown";
    IconType[IconType["ArrowCircleOutlineUp"] = 223] = "ArrowCircleOutlineUp";
    IconType[IconType["ChevronLeft"] = 224] = "ChevronLeft";
    IconType[IconType["ChevronRight"] = 225] = "ChevronRight";
    IconType[IconType["ArrowLeft"] = 226] = "ArrowLeft";
    IconType[IconType["ArrowRight"] = 227] = "ArrowRight";
    IconType[IconType["ArrowUp"] = 228] = "ArrowUp";
    IconType[IconType["ArrowDown"] = 229] = "ArrowDown";
    IconType[IconType["ChevronUp"] = 230] = "ChevronUp";
    IconType[IconType["ChevronDown"] = 231] = "ChevronDown";
    IconType[IconType["PointingRight"] = 232] = "PointingRight";
    IconType[IconType["PointingLeft"] = 233] = "PointingLeft";
    IconType[IconType["PointingUp"] = 234] = "PointingUp";
    IconType[IconType["PointingDown"] = 235] = "PointingDown";
    IconType[IconType["ArrowCircleLeft"] = 236] = "ArrowCircleLeft";
    IconType[IconType["ArrowCircleRight"] = 237] = "ArrowCircleRight";
    IconType[IconType["ArrowCircleUp"] = 238] = "ArrowCircleUp";
    IconType[IconType["ArrowCircleDown"] = 239] = "ArrowCircleDown";
    IconType[IconType["CaretDown"] = 240] = "CaretDown";
    IconType[IconType["CaretUp"] = 241] = "CaretUp";
    IconType[IconType["CaretLeft"] = 242] = "CaretLeft";
    IconType[IconType["CaretRight"] = 243] = "CaretRight";
    IconType[IconType["AngleDoubleLeft"] = 244] = "AngleDoubleLeft";
    IconType[IconType["AngleDoubleRight"] = 245] = "AngleDoubleRight";
    IconType[IconType["AngleDoubleUp"] = 246] = "AngleDoubleUp";
    IconType[IconType["AngleDoubleDown"] = 247] = "AngleDoubleDown";
    IconType[IconType["AngleLeft"] = 248] = "AngleLeft";
    IconType[IconType["AngleRight"] = 249] = "AngleRight";
    IconType[IconType["AngleUp"] = 250] = "AngleUp";
    IconType[IconType["AngleDown"] = 251] = "AngleDown";
    IconType[IconType["ChevronCircleLeft"] = 252] = "ChevronCircleLeft";
    IconType[IconType["ChevronCircleRight"] = 253] = "ChevronCircleRight";
    IconType[IconType["ChevronCircleUp"] = 254] = "ChevronCircleUp";
    IconType[IconType["ChevronCircleDown"] = 255] = "ChevronCircleDown";
    IconType[IconType["ToggleDown"] = 256] = "ToggleDown";
    IconType[IconType["ToggleUp"] = 257] = "ToggleUp";
    IconType[IconType["ToggleRight"] = 258] = "ToggleRight";
    IconType[IconType["LongArrowDown"] = 259] = "LongArrowDown";
    IconType[IconType["LongArrowUp"] = 260] = "LongArrowUp";
    IconType[IconType["LongArrowLeft"] = 261] = "LongArrowLeft";
    IconType[IconType["LongArrowRight"] = 262] = "LongArrowRight";
    IconType[IconType["ArrowCircleOutlineRight"] = 263] = "ArrowCircleOutlineRight";
    IconType[IconType["ArrowCircleOutlineLeft"] = 264] = "ArrowCircleOutlineLeft";
    IconType[IconType["ToggleLeft"] = 265] = "ToggleLeft";
    IconType[IconType["Power"] = 266] = "Power";
    IconType[IconType["Trash"] = 267] = "Trash";
    IconType[IconType["TrashOutline"] = 268] = "TrashOutline";
    IconType[IconType["DiskOutline"] = 269] = "DiskOutline";
    IconType[IconType["Desktop"] = 270] = "Desktop";
    IconType[IconType["Laptop"] = 271] = "Laptop";
    IconType[IconType["Tablet"] = 272] = "Tablet";
    IconType[IconType["Mobile"] = 273] = "Mobile";
    IconType[IconType["Game"] = 274] = "Game";
    IconType[IconType["Keyboard"] = 275] = "Keyboard";
    IconType[IconType["Plug"] = 276] = "Plug";
    IconType[IconType["Folder"] = 277] = "Folder";
    IconType[IconType["FolderOpen"] = 278] = "FolderOpen";
    IconType[IconType["LevelUp"] = 279] = "LevelUp";
    IconType[IconType["LevelDown"] = 280] = "LevelDown";
    IconType[IconType["File"] = 281] = "File";
    IconType[IconType["FileOutline"] = 282] = "FileOutline";
    IconType[IconType["FileText"] = 283] = "FileText";
    IconType[IconType["FileTextOutline"] = 284] = "FileTextOutline";
    IconType[IconType["FolderOutline"] = 285] = "FolderOutline";
    IconType[IconType["FolderOpenOutline"] = 286] = "FolderOpenOutline";
    IconType[IconType["FilePdfOutline"] = 287] = "FilePdfOutline";
    IconType[IconType["FileWordOutline"] = 288] = "FileWordOutline";
    IconType[IconType["FileExcelOutline"] = 289] = "FileExcelOutline";
    IconType[IconType["FilePowerpointOutline"] = 290] = "FilePowerpointOutline";
    IconType[IconType["FileImageOutline"] = 291] = "FileImageOutline";
    IconType[IconType["FileArchiveOutline"] = 292] = "FileArchiveOutline";
    IconType[IconType["FileAudioOutline"] = 293] = "FileAudioOutline";
    IconType[IconType["FileVideoOutline"] = 294] = "FileVideoOutline";
    IconType[IconType["FileCodeOutline"] = 295] = "FileCodeOutline";
    IconType[IconType["Barcode"] = 296] = "Barcode";
    IconType[IconType["Qrcode"] = 297] = "Qrcode";
    IconType[IconType["Fork"] = 298] = "Fork";
    IconType[IconType["Html5"] = 299] = "Html5";
    IconType[IconType["Css3"] = 300] = "Css3";
    IconType[IconType["Rss"] = 301] = "Rss";
    IconType[IconType["RssSquare"] = 302] = "RssSquare";
    IconType[IconType["Openid"] = 303] = "Openid";
    IconType[IconType["Database"] = 304] = "Database";
    IconType[IconType["Server"] = 305] = "Server";
    IconType[IconType["Heart"] = 306] = "Heart";
    IconType[IconType["Star"] = 307] = "Star";
    IconType[IconType["EmptyStar"] = 308] = "EmptyStar";
    IconType[IconType["ThumbsOutlineUp"] = 309] = "ThumbsOutlineUp";
    IconType[IconType["ThumbsOutlineDown"] = 310] = "ThumbsOutlineDown";
    IconType[IconType["StarHalf"] = 311] = "StarHalf";
    IconType[IconType["EmptyHeart"] = 312] = "EmptyHeart";
    IconType[IconType["Smile"] = 313] = "Smile";
    IconType[IconType["Frown"] = 314] = "Frown";
    IconType[IconType["Meh"] = 315] = "Meh";
    IconType[IconType["StarHalfEmpty"] = 316] = "StarHalfEmpty";
    IconType[IconType["ThumbsUp"] = 317] = "ThumbsUp";
    IconType[IconType["ThumbsDown"] = 318] = "ThumbsDown";
    IconType[IconType["Music"] = 319] = "Music";
    IconType[IconType["VideoPlayOutline"] = 320] = "VideoPlayOutline";
    IconType[IconType["VolumeOff"] = 321] = "VolumeOff";
    IconType[IconType["VolumeDown"] = 322] = "VolumeDown";
    IconType[IconType["VolumeUp"] = 323] = "VolumeUp";
    IconType[IconType["Record"] = 324] = "Record";
    IconType[IconType["StepBackward"] = 325] = "StepBackward";
    IconType[IconType["FastBackward"] = 326] = "FastBackward";
    IconType[IconType["Backward"] = 327] = "Backward";
    IconType[IconType["Play"] = 328] = "Play";
    IconType[IconType["Pause"] = 329] = "Pause";
    IconType[IconType["Stop"] = 330] = "Stop";
    IconType[IconType["Forward"] = 331] = "Forward";
    IconType[IconType["FastForward"] = 332] = "FastForward";
    IconType[IconType["StepForward"] = 333] = "StepForward";
    IconType[IconType["Eject"] = 334] = "Eject";
    IconType[IconType["Unmute"] = 335] = "Unmute";
    IconType[IconType["Mute"] = 336] = "Mute";
    IconType[IconType["VideoPlay"] = 337] = "VideoPlay";
    IconType[IconType["ClosedCaptioning"] = 338] = "ClosedCaptioning";
    IconType[IconType["Marker"] = 339] = "Marker";
    IconType[IconType["Coffee"] = 340] = "Coffee";
    IconType[IconType["Food"] = 341] = "Food";
    IconType[IconType["BuildingOutline"] = 342] = "BuildingOutline";
    IconType[IconType["Hospital"] = 343] = "Hospital";
    IconType[IconType["Emergency"] = 344] = "Emergency";
    IconType[IconType["FirstAid"] = 345] = "FirstAid";
    IconType[IconType["Military"] = 346] = "Military";
    IconType[IconType["H"] = 347] = "H";
    IconType[IconType["LocationArrow"] = 348] = "LocationArrow";
    IconType[IconType["SpaceShuttle"] = 349] = "SpaceShuttle";
    IconType[IconType["University"] = 350] = "University";
    IconType[IconType["Building"] = 351] = "Building";
    IconType[IconType["Paw"] = 352] = "Paw";
    IconType[IconType["Spoon"] = 353] = "Spoon";
    IconType[IconType["Car"] = 354] = "Car";
    IconType[IconType["Taxi"] = 355] = "Taxi";
    IconType[IconType["Tree"] = 356] = "Tree";
    IconType[IconType["Bicycle"] = 357] = "Bicycle";
    IconType[IconType["Bus"] = 358] = "Bus";
    IconType[IconType["Ship"] = 359] = "Ship";
    IconType[IconType["Motorcycle"] = 360] = "Motorcycle";
    IconType[IconType["StreetView"] = 361] = "StreetView";
    IconType[IconType["Hotel"] = 362] = "Hotel";
    IconType[IconType["Train"] = 363] = "Train";
    IconType[IconType["Subway"] = 364] = "Subway";
    IconType[IconType["Table"] = 365] = "Table";
    IconType[IconType["Columns"] = 366] = "Columns";
    IconType[IconType["Sort"] = 367] = "Sort";
    IconType[IconType["SortAscending"] = 368] = "SortAscending";
    IconType[IconType["SortDescending"] = 369] = "SortDescending";
    IconType[IconType["SortAlphabetAscending"] = 370] = "SortAlphabetAscending";
    IconType[IconType["SortAlphabetDescending"] = 371] = "SortAlphabetDescending";
    IconType[IconType["SortContentAscending"] = 372] = "SortContentAscending";
    IconType[IconType["SortContentDescending"] = 373] = "SortContentDescending";
    IconType[IconType["SortNumericAscending"] = 374] = "SortNumericAscending";
    IconType[IconType["SortNumericDescending"] = 375] = "SortNumericDescending";
    IconType[IconType["Font"] = 376] = "Font";
    IconType[IconType["Bold"] = 377] = "Bold";
    IconType[IconType["Italic"] = 378] = "Italic";
    IconType[IconType["TextHeight"] = 379] = "TextHeight";
    IconType[IconType["TextWidth"] = 380] = "TextWidth";
    IconType[IconType["AlignLeft"] = 381] = "AlignLeft";
    IconType[IconType["AlignCenter"] = 382] = "AlignCenter";
    IconType[IconType["AlignRight"] = 383] = "AlignRight";
    IconType[IconType["AlignJustify"] = 384] = "AlignJustify";
    IconType[IconType["List"] = 385] = "List";
    IconType[IconType["Outdent"] = 386] = "Outdent";
    IconType[IconType["Indent"] = 387] = "Indent";
    IconType[IconType["Linkify"] = 388] = "Linkify";
    IconType[IconType["Cut"] = 389] = "Cut";
    IconType[IconType["Copy"] = 390] = "Copy";
    IconType[IconType["Attach"] = 391] = "Attach";
    IconType[IconType["Save"] = 392] = "Save";
    IconType[IconType["Content"] = 393] = "Content";
    IconType[IconType["UnorderedList"] = 394] = "UnorderedList";
    IconType[IconType["OrderedList"] = 395] = "OrderedList";
    IconType[IconType["Strikethrough"] = 396] = "Strikethrough";
    IconType[IconType["Underline"] = 397] = "Underline";
    IconType[IconType["Paste"] = 398] = "Paste";
    IconType[IconType["Unlink"] = 399] = "Unlink";
    IconType[IconType["Superscript"] = 400] = "Superscript";
    IconType[IconType["Subscript"] = 401] = "Subscript";
    IconType[IconType["Header"] = 402] = "Header";
    IconType[IconType["Paragraph"] = 403] = "Paragraph";
    IconType[IconType["Euro"] = 404] = "Euro";
    IconType[IconType["Pound"] = 405] = "Pound";
    IconType[IconType["Dollar"] = 406] = "Dollar";
    IconType[IconType["Rupee"] = 407] = "Rupee";
    IconType[IconType["Yen"] = 408] = "Yen";
    IconType[IconType["Ruble"] = 409] = "Ruble";
    IconType[IconType["Won"] = 410] = "Won";
    IconType[IconType["Lira"] = 411] = "Lira";
    IconType[IconType["Shekel"] = 412] = "Shekel";
    IconType[IconType["Paypal"] = 413] = "Paypal";
    IconType[IconType["PaypalCard"] = 414] = "PaypalCard";
    IconType[IconType["GoogleWallet"] = 415] = "GoogleWallet";
    IconType[IconType["Visa"] = 416] = "Visa";
    IconType[IconType["Mastercard"] = 417] = "Mastercard";
    IconType[IconType["Discover"] = 418] = "Discover";
    IconType[IconType["AmericanExpress"] = 419] = "AmericanExpress";
    IconType[IconType["Stripe"] = 420] = "Stripe";
    IconType[IconType["TwitterSquare"] = 421] = "TwitterSquare";
    IconType[IconType["FacebookSquare"] = 422] = "FacebookSquare";
    IconType[IconType["LinkedinSquare"] = 423] = "LinkedinSquare";
    IconType[IconType["GithubSquare"] = 424] = "GithubSquare";
    IconType[IconType["Twitter"] = 425] = "Twitter";
    IconType[IconType["Facebook"] = 426] = "Facebook";
    IconType[IconType["Github"] = 427] = "Github";
    IconType[IconType["Pinterest"] = 428] = "Pinterest";
    IconType[IconType["PinterestSquare"] = 429] = "PinterestSquare";
    IconType[IconType["GooglePlusSquare"] = 430] = "GooglePlusSquare";
    IconType[IconType["GooglePlus"] = 431] = "GooglePlus";
    IconType[IconType["Linkedin"] = 432] = "Linkedin";
    IconType[IconType["GithubAlternate"] = 433] = "GithubAlternate";
    IconType[IconType["Maxcdn"] = 434] = "Maxcdn";
    IconType[IconType["Bitcoin"] = 435] = "Bitcoin";
    IconType[IconType["YoutubeSquare"] = 436] = "YoutubeSquare";
    IconType[IconType["Youtube"] = 437] = "Youtube";
    IconType[IconType["Xing"] = 438] = "Xing";
    IconType[IconType["XingSquare"] = 439] = "XingSquare";
    IconType[IconType["YoutubePlay"] = 440] = "YoutubePlay";
    IconType[IconType["Dropbox"] = 441] = "Dropbox";
    IconType[IconType["StackOverflow"] = 442] = "StackOverflow";
    IconType[IconType["Instagram"] = 443] = "Instagram";
    IconType[IconType["Flickr"] = 444] = "Flickr";
    IconType[IconType["Adn"] = 445] = "Adn";
    IconType[IconType["Bitbucket"] = 446] = "Bitbucket";
    IconType[IconType["BitbucketSquare"] = 447] = "BitbucketSquare";
    IconType[IconType["Tumblr"] = 448] = "Tumblr";
    IconType[IconType["TumblrSquare"] = 449] = "TumblrSquare";
    IconType[IconType["Apple"] = 450] = "Apple";
    IconType[IconType["Windows"] = 451] = "Windows";
    IconType[IconType["Android"] = 452] = "Android";
    IconType[IconType["Linux"] = 453] = "Linux";
    IconType[IconType["Dribbble"] = 454] = "Dribbble";
    IconType[IconType["Skype"] = 455] = "Skype";
    IconType[IconType["Foursquare"] = 456] = "Foursquare";
    IconType[IconType["Trello"] = 457] = "Trello";
    IconType[IconType["Gittip"] = 458] = "Gittip";
    IconType[IconType["Vk"] = 459] = "Vk";
    IconType[IconType["Weibo"] = 460] = "Weibo";
    IconType[IconType["Renren"] = 461] = "Renren";
    IconType[IconType["Pagelines"] = 462] = "Pagelines";
    IconType[IconType["StackExchange"] = 463] = "StackExchange";
    IconType[IconType["Vimeo"] = 464] = "Vimeo";
    IconType[IconType["Slack"] = 465] = "Slack";
    IconType[IconType["Wordpress"] = 466] = "Wordpress";
    IconType[IconType["Yahoo"] = 467] = "Yahoo";
    IconType[IconType["Google"] = 468] = "Google";
    IconType[IconType["Reddit"] = 469] = "Reddit";
    IconType[IconType["RedditSquare"] = 470] = "RedditSquare";
    IconType[IconType["StumbleuponCircle"] = 471] = "StumbleuponCircle";
    IconType[IconType["Stumbleupon"] = 472] = "Stumbleupon";
    IconType[IconType["Delicious"] = 473] = "Delicious";
    IconType[IconType["Digg"] = 474] = "Digg";
    IconType[IconType["PiedPiper"] = 475] = "PiedPiper";
    IconType[IconType["PiedPiperAlternate"] = 476] = "PiedPiperAlternate";
    IconType[IconType["Drupal"] = 477] = "Drupal";
    IconType[IconType["Joomla"] = 478] = "Joomla";
    IconType[IconType["Behance"] = 479] = "Behance";
    IconType[IconType["BehanceSquare"] = 480] = "BehanceSquare";
    IconType[IconType["Steam"] = 481] = "Steam";
    IconType[IconType["SteamSquare"] = 482] = "SteamSquare";
    IconType[IconType["Spotify"] = 483] = "Spotify";
    IconType[IconType["Deviantart"] = 484] = "Deviantart";
    IconType[IconType["Soundcloud"] = 485] = "Soundcloud";
    IconType[IconType["Vine"] = 486] = "Vine";
    IconType[IconType["Codepen"] = 487] = "Codepen";
    IconType[IconType["Jsfiddle"] = 488] = "Jsfiddle";
    IconType[IconType["Rebel"] = 489] = "Rebel";
    IconType[IconType["Empire"] = 490] = "Empire";
    IconType[IconType["GitSquare"] = 491] = "GitSquare";
    IconType[IconType["Git"] = 492] = "Git";
    IconType[IconType["HackerNews"] = 493] = "HackerNews";
    IconType[IconType["TencentWeibo"] = 494] = "TencentWeibo";
    IconType[IconType["Qq"] = 495] = "Qq";
    IconType[IconType["Wechat"] = 496] = "Wechat";
    IconType[IconType["Slideshare"] = 497] = "Slideshare";
    IconType[IconType["Twitch"] = 498] = "Twitch";
    IconType[IconType["Yelp"] = 499] = "Yelp";
    IconType[IconType["Lastfm"] = 500] = "Lastfm";
    IconType[IconType["LastfmSquare"] = 501] = "LastfmSquare";
    IconType[IconType["Ioxhost"] = 502] = "Ioxhost";
    IconType[IconType["Angellist"] = 503] = "Angellist";
    IconType[IconType["Meanpath"] = 504] = "Meanpath";
    IconType[IconType["Buysellads"] = 505] = "Buysellads";
    IconType[IconType["Connectdevelop"] = 506] = "Connectdevelop";
    IconType[IconType["Dashcube"] = 507] = "Dashcube";
    IconType[IconType["Forumbee"] = 508] = "Forumbee";
    IconType[IconType["Leanpub"] = 509] = "Leanpub";
    IconType[IconType["Sellsy"] = 510] = "Sellsy";
    IconType[IconType["Shirtsinbulk"] = 511] = "Shirtsinbulk";
    IconType[IconType["Simplybuilt"] = 512] = "Simplybuilt";
    IconType[IconType["Skyatlas"] = 513] = "Skyatlas";
    IconType[IconType["Whatsapp"] = 514] = "Whatsapp";
    IconType[IconType["Viacoin"] = 515] = "Viacoin";
    IconType[IconType["Medium"] = 516] = "Medium";
    IconType[IconType["Like"] = 517] = "Like";
    IconType[IconType["Favorite"] = 518] = "Favorite";
    IconType[IconType["Video"] = 519] = "Video";
    IconType[IconType["Check"] = 520] = "Check";
    IconType[IconType["Close"] = 521] = "Close";
    IconType[IconType["Cancel"] = 522] = "Cancel";
    IconType[IconType["Delete"] = 523] = "Delete";
    IconType[IconType["X"] = 524] = "X";
    IconType[IconType["UserTimes"] = 525] = "UserTimes";
    IconType[IconType["UserClose"] = 526] = "UserClose";
    IconType[IconType["UserCancel"] = 527] = "UserCancel";
    IconType[IconType["UserDelete"] = 528] = "UserDelete";
    IconType[IconType["UserX"] = 529] = "UserX";
    IconType[IconType["ZoomIn"] = 530] = "ZoomIn";
    IconType[IconType["Magnify"] = 531] = "Magnify";
    IconType[IconType["Shutdown"] = 532] = "Shutdown";
    IconType[IconType["Clock"] = 533] = "Clock";
    IconType[IconType["Time"] = 534] = "Time";
    IconType[IconType["PlayCircleOutline"] = 535] = "PlayCircleOutline";
    IconType[IconType["Headphone"] = 536] = "Headphone";
    IconType[IconType["Camera"] = 537] = "Camera";
    IconType[IconType["VideoCamera"] = 538] = "VideoCamera";
    IconType[IconType["Picture"] = 539] = "Picture";
    IconType[IconType["Pencil"] = 540] = "Pencil";
    IconType[IconType["Compose"] = 541] = "Compose";
    IconType[IconType["Point"] = 542] = "Point";
    IconType[IconType["Tint"] = 543] = "Tint";
    IconType[IconType["Signup"] = 544] = "Signup";
    IconType[IconType["PlusCircle"] = 545] = "PlusCircle";
    IconType[IconType["Dont"] = 546] = "Dont";
    IconType[IconType["Minimize"] = 547] = "Minimize";
    IconType[IconType["Add"] = 548] = "Add";
    IconType[IconType["Eye"] = 549] = "Eye";
    IconType[IconType["Attention"] = 550] = "Attention";
    IconType[IconType["Cart"] = 551] = "Cart";
    IconType[IconType["Shuffle"] = 552] = "Shuffle";
    IconType[IconType["Talk"] = 553] = "Talk";
    IconType[IconType["Chat"] = 554] = "Chat";
    IconType[IconType["ShoppingCart"] = 555] = "ShoppingCart";
    IconType[IconType["BarGraph"] = 556] = "BarGraph";
    IconType[IconType["AreaGraph"] = 557] = "AreaGraph";
    IconType[IconType["PieGraph"] = 558] = "PieGraph";
    IconType[IconType["LineGraph"] = 559] = "LineGraph";
    IconType[IconType["Key"] = 560] = "Key";
    IconType[IconType["Cogs"] = 561] = "Cogs";
    IconType[IconType["Discussions"] = 562] = "Discussions";
    IconType[IconType["LikeOutline"] = 563] = "LikeOutline";
    IconType[IconType["DislikeOutline"] = 564] = "DislikeOutline";
    IconType[IconType["HeartOutline"] = 565] = "HeartOutline";
    IconType[IconType["LogOut"] = 566] = "LogOut";
    IconType[IconType["ThumbTack"] = 567] = "ThumbTack";
    IconType[IconType["Winner"] = 568] = "Winner";
    IconType[IconType["BookmarkOutline"] = 569] = "BookmarkOutline";
    IconType[IconType["Phone"] = 570] = "Phone";
    IconType[IconType["PhoneSquare"] = 571] = "PhoneSquare";
    IconType[IconType["CreditCard"] = 572] = "CreditCard";
    IconType[IconType["HddOutline"] = 573] = "HddOutline";
    IconType[IconType["Bullhorn"] = 574] = "Bullhorn";
    IconType[IconType["Bell"] = 575] = "Bell";
    IconType[IconType["BellOutline"] = 576] = "BellOutline";
    IconType[IconType["BellSlash"] = 577] = "BellSlash";
    IconType[IconType["BellSlashOutline"] = 578] = "BellSlashOutline";
    IconType[IconType["HandOutlineRight"] = 579] = "HandOutlineRight";
    IconType[IconType["HandOutlineLeft"] = 580] = "HandOutlineLeft";
    IconType[IconType["HandOutlineUp"] = 581] = "HandOutlineUp";
    IconType[IconType["HandOutlineDown"] = 582] = "HandOutlineDown";
    IconType[IconType["Globe"] = 583] = "Globe";
    IconType[IconType["Wrench"] = 584] = "Wrench";
    IconType[IconType["Briefcase"] = 585] = "Briefcase";
    IconType[IconType["Group"] = 586] = "Group";
    IconType[IconType["Flask"] = 587] = "Flask";
    IconType[IconType["Sidebar"] = 588] = "Sidebar";
    IconType[IconType["Bars"] = 589] = "Bars";
    IconType[IconType["ListUl"] = 590] = "ListUl";
    IconType[IconType["ListOl"] = 591] = "ListOl";
    IconType[IconType["NumberedList"] = 592] = "NumberedList";
    IconType[IconType["Magic"] = 593] = "Magic";
    IconType[IconType["Truck"] = 594] = "Truck";
    IconType[IconType["Currency"] = 595] = "Currency";
    IconType[IconType["TriangleDown"] = 596] = "TriangleDown";
    IconType[IconType["Dropdown"] = 597] = "Dropdown";
    IconType[IconType["TriangleUp"] = 598] = "TriangleUp";
    IconType[IconType["TriangleLeft"] = 599] = "TriangleLeft";
    IconType[IconType["TriangleRight"] = 600] = "TriangleRight";
    IconType[IconType["Envelope"] = 601] = "Envelope";
    IconType[IconType["Conversation"] = 602] = "Conversation";
    IconType[IconType["Umbrella"] = 603] = "Umbrella";
    IconType[IconType["Clipboard"] = 604] = "Clipboard";
    IconType[IconType["Lightbulb"] = 605] = "Lightbulb";
    IconType[IconType["Ambulance"] = 606] = "Ambulance";
    IconType[IconType["Medkit"] = 607] = "Medkit";
    IconType[IconType["FighterJet"] = 608] = "FighterJet";
    IconType[IconType["Beer"] = 609] = "Beer";
    IconType[IconType["PlusSquare"] = 610] = "PlusSquare";
    IconType[IconType["Computer"] = 611] = "Computer";
    IconType[IconType["CircleOutline"] = 612] = "CircleOutline";
    IconType[IconType["Intersex"] = 613] = "Intersex";
    IconType[IconType["Asexual"] = 614] = "Asexual";
    IconType[IconType["Spinner"] = 615] = "Spinner";
    IconType[IconType["Gamepad"] = 616] = "Gamepad";
    IconType[IconType["StarHalfFull"] = 617] = "StarHalfFull";
    IconType[IconType["Question"] = 618] = "Question";
    IconType[IconType["Eraser"] = 619] = "Eraser";
    IconType[IconType["Microphone"] = 620] = "Microphone";
    IconType[IconType["MicrophoneSlash"] = 621] = "MicrophoneSlash";
    IconType[IconType["Shield"] = 622] = "Shield";
    IconType[IconType["Target"] = 623] = "Target";
    IconType[IconType["PlayCircle"] = 624] = "PlayCircle";
    IconType[IconType["PencilSquare"] = 625] = "PencilSquare";
    IconType[IconType["Compass"] = 626] = "Compass";
    IconType[IconType["Amex"] = 627] = "Amex";
    IconType[IconType["Eur"] = 628] = "Eur";
    IconType[IconType["Gbp"] = 629] = "Gbp";
    IconType[IconType["Usd"] = 630] = "Usd";
    IconType[IconType["Inr"] = 631] = "Inr";
    IconType[IconType["Cny"] = 632] = "Cny";
    IconType[IconType["Rmb"] = 633] = "Rmb";
    IconType[IconType["Jpy"] = 634] = "Jpy";
    IconType[IconType["Rouble"] = 635] = "Rouble";
    IconType[IconType["Rub"] = 636] = "Rub";
    IconType[IconType["Krw"] = 637] = "Krw";
    IconType[IconType["Btc"] = 638] = "Btc";
    IconType[IconType["Sheqel"] = 639] = "Sheqel";
    IconType[IconType["Ils"] = 640] = "Ils";
    IconType[IconType["Try"] = 641] = "Try";
    IconType[IconType["Zip"] = 642] = "Zip";
    IconType[IconType["DotCircleOutline"] = 643] = "DotCircleOutline";
    IconType[IconType["Sliders"] = 644] = "Sliders";
    IconType[IconType["Wi"] = 645] = "Wi";
    IconType[IconType["Graduation"] = 646] = "Graduation";
    IconType[IconType["Weixin"] = 647] = "Weixin";
    IconType[IconType["Binoculars"] = 648] = "Binoculars";
    IconType[IconType["Gratipay"] = 649] = "Gratipay";
    IconType[IconType["Genderless"] = 650] = "Genderless";
    IconType[IconType["Teletype"] = 651] = "Teletype";
    IconType[IconType["PowerCord"] = 652] = "PowerCord";
    IconType[IconType["Tty"] = 653] = "Tty";
    IconType[IconType["Cc"] = 654] = "Cc";
    IconType[IconType["PlusCart"] = 655] = "PlusCart";
    IconType[IconType["ArrowDownCart"] = 656] = "ArrowDownCart";
    IconType[IconType["Detective"] = 657] = "Detective";
    IconType[IconType["Venus"] = 658] = "Venus";
    IconType[IconType["Mars"] = 659] = "Mars";
    IconType[IconType["Mercury"] = 660] = "Mercury";
    IconType[IconType["VenusDouble"] = 661] = "VenusDouble";
    IconType[IconType["FemaleHomosexual"] = 662] = "FemaleHomosexual";
    IconType[IconType["MarsDouble"] = 663] = "MarsDouble";
    IconType[IconType["MaleHomosexual"] = 664] = "MaleHomosexual";
    IconType[IconType["VenusMars"] = 665] = "VenusMars";
    IconType[IconType["MarsStroke"] = 666] = "MarsStroke";
    IconType[IconType["MarsAlternate"] = 667] = "MarsAlternate";
    IconType[IconType["MarsVertical"] = 668] = "MarsVertical";
    IconType[IconType["MarsHorizontal"] = 669] = "MarsHorizontal";
    IconType[IconType["MarsStrokeVertical"] = 670] = "MarsStrokeVertical";
    IconType[IconType["MarsStrokeHorizontal"] = 671] = "MarsStrokeHorizontal";
    IconType[IconType["FacebookOfficial"] = 672] = "FacebookOfficial";
    IconType[IconType["PinterestOfficial"] = 673] = "PinterestOfficial";
    IconType[IconType["Bed"] = 674] = "Bed";
})(IconType = exports.IconType || (exports.IconType = {}));


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(192));
__export(__webpack_require__(200));
__export(__webpack_require__(211));
__export(__webpack_require__(215));
__export(__webpack_require__(4));
__export(__webpack_require__(3));


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Checkbox;
(function (Checkbox) {
    /**
    * Creates a checkbox element on the page.
    * Accepts the following properties in props$:
    *   readonly?: boolean - Styles the checkbox to appear read-only.
    *   checked?: boolean - Styles the checkbox to appear checked.
    *   disabled?: boolean - Styles the checkbox to appear disabled.
    *   fitted?: boolean - Styles the checkbox for tight fits with nearby content.
    *   radio?: string - Styles the checkbox to appear like a radio button belonging to the group.
    *   toggle?: boolean - Styles the checkbox to appear like a toggle.
    * Expects the following type of content in content$: DOMContent
    * @param {ComponentSources} sources The default component sources.
    */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var evt = function (type) { return sources.DOM.select("input").events(type); };
            var clicked$ = evt("click");
            var props$ = sources.props$.remember();
            var checked$ = props$.map(function (props) {
                return clicked$.fold(function (acc, evt) { return evt.srcElement.checked; }, props.checked ? true : false);
            }).flatten().remember();
            // const renderProps$ =  xs.combine(props$, checked$).map(
            //   ([props, checked]) => Object.assign({}, props, {checked})
            // );
            var vTree$ = xstream_1.default.combine(props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: evt,
                value$: checked$
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Checkbox.run = run;
    /**
    * Creates a checkbox element on the page.
    * Accepts the following properties in props$:
    *   readonly?: boolean - Styles the checkbox to appear read-only.
    *   checked?: boolean - Styles the checkbox to appear checked.
    *   disabled?: boolean - Styles the checkbox to appear disabled.
    *   fitted?: boolean - Styles the checkbox for tight fits with nearby content.
    *   radio?: string - Styles the checkbox to appear like a radio button belonging to the group.
    *   toggle?: boolean - Styles the checkbox to appear like a toggle.
    * Expects the following type of content in content$: DOMContent
    * @param {ComponentSources} sources The default component sources.
    */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassName(props) } }, [
            dom_1.input({ props: {
                    type: props.radio ? "radio" : "checkbox",
                    name: props.name,
                    checked: props.checked,
                    disabled: props.readonly || props.disabled
                } }),
            dom_1.label({ props: { for: props.name } }, props.fitted ? "" : content)
        ]);
    }
    Checkbox.render = render;
    function getClassName(props) {
        var className = "ui";
        if (props.readonly) {
            className += " read-only";
        }
        if (props.checked) {
            className += " checked";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.fitted) {
            className += " fitted";
        }
        if (props.radio) {
            className += " radio";
        }
        if (props.toggle) {
            className += " toggle";
        }
        return className + " checkbox";
    }
})(Checkbox = exports.Checkbox || (exports.Checkbox = {}));


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var dropRepeats_1 = __webpack_require__(63);
var debounce_1 = __webpack_require__(61);
var concat_1 = __webpack_require__(217);
var isolate_1 = __webpack_require__(2);
var delay_1 = __webpack_require__(62);
var dom_1 = __webpack_require__(1);
var menu_1 = __webpack_require__(59);
var icon_1 = __webpack_require__(23);
var transition_1 = __webpack_require__(13);
var Dropdown;
(function (Dropdown) {
    /**
     * A dropdown component for capturing user input.
     * Accepts the following properties in props$:
     *  active?: boolean,
     *  initial?: any
     *  default?: string
     *  selection?: boolean
     *  inline?: boolean
     *  floating?: boolean
     *  loading?: boolean
     *  disabled?: boolean
     *  scrolling?: boolean
     *  search?: boolean
     *  compact?: boolean
     *  size?: Size
     *  color?: Color
     * Expects the following type of content in content$: Array of {
     *  body: DOMContent,
     *  value: any,
     *  header?: boolean,
     *  fitted?: boolean,
     *  disabled?: boolean,
     *  active?: boolean
     * }
     */
    function run(sources) {
        function main(sources) {
            var evt = function (type) { return sources.DOM.select(".dropdown").events(type); };
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var props$ = sources.props$.remember();
            var itemClick$proxy = xstream_1.default.create();
            var value$proxy = xstream_1.default.create();
            var dropdownClick$ = evt("click")
                .filter(function (evt) { return !evt.srcElement.classList.contains("item"); })
                .mapTo(enums_1.Direction.In);
            var mouseleave$ = xstream_1.default.merge(evt("mouseleave").filter(function (evt) { return evt.srcElement.className.indexOf("icon") === -1; }), evt("mouseenter"))
                .map(function (evt) { return evt.type === "mouseenter" ? enums_1.Direction.In : enums_1.Direction.Out; })
                .compose(debounce_1.default(250))
                .filter(function (dir) { return dir === enums_1.Direction.Out; });
            var transition$ = xstream_1.default.merge(dropdownClick$, itemClick$proxy, mouseleave$)
                .startWith(enums_1.Direction.Out)
                .map(function (dir) { return ({
                animation: enums_1.Animation.Fade,
                direction: dir
            }); })
                .compose(dropRepeats_1.default(function (a, b) { return a.direction === b.direction
                && a.animation === b.animation; }))
                .drop(1)
                .startWith({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var filter$ = sources.DOM.select("input").events("keyup")
                .map(function (ev) { return ev.target.value; })
                .startWith("");
            var filteredContent$ = xstream_1.default.combine(sources.content$, filter$).map(function (_a) {
                var content = _a[0], filter = _a[1];
                return content.filter(function (c) { return filterContent(c, filter); });
            }).remember();
            var content$ = xstream_1.default.combine(filteredContent$, value$proxy).map(function (_a) {
                var content = _a[0], value = _a[1];
                return content.map(function (item) { return item.value === value ? Object.assign({}, item, { active: true }) : item; });
            }).remember();
            var menu = menu_1.Menu.run({ DOM: sources.DOM, content$: content$ });
            var transitionedMenu = transition_1.Transition.run({ DOM: sources.DOM, target$: menu.DOM, args$: transition$ });
            var itemClick$ = evt("click").filter(function (x) { return x.target.classList.contains("item"); }).remember();
            itemClick$proxy.imitate(itemClick$.mapTo(enums_1.Direction.Out));
            var clickedId$ = itemClick$
                .map(function (ev) { return parseInt(ev.target.id); })
                .filter(function (n) { return !isNaN(n) && typeof (n) !== "undefined"; });
            var emittedValue$ = clickedId$.map(function (id) { return filteredContent$.map(function (items) { return items[id].value; }).take(1); }).flatten().remember();
            var initialValue$ = props$.map(function (props) { return props.initial; }).remember();
            value$proxy.imitate(xstream_1.default.merge(initialValue$, emittedValue$));
            var icon = icon_1.Icon.render({}, enums_1.IconType.Dropdown);
            var active$ = xstream_1.default.merge(transition$.filter(function (x) { return x.direction === enums_1.Direction.In; }).mapTo(true), transition$.filter(function (x) { return x.direction === enums_1.Direction.Out; }).compose(delay_1.default(250)).mapTo(false));
            var streams = xstream_1.default.combine(props$, active$, transitionedMenu.DOM, content$.map(function (content) { return content.filter(function (item) { return item.active; })[0]; }));
            var vtree$ = streams.map(function (_a) {
                var props = _a[0], active = _a[1], menu = _a[2], item = _a[3];
                return dom_1.div({ props: { className: getClassName(props, active) } }, [
                    getText(item, props),
                    props.search ? dom_1.input({ props: { className: "search" } }) : "",
                    icon, menu
                ]);
            }).remember();
            //Todo find cleaner way to clear input using snabbdom hooks?
            emittedValue$.map(function (_) { return vtree$.take(1); }).flatten().addListener(new ExecuteListener(function (vnode) {
                function clear() {
                    if (typeof (vnode.elm) !== "undefined") {
                        var elm = vnode.elm.getElementsByTagName("input");
                        if (elm[0] && elm[0].value !== "") {
                            {
                                console.log("Sending next");
                            }
                            elm[0].value = "";
                            filter$.shamefullySendNext("");
                        }
                    }
                    else {
                        setTimeout(clear, 100);
                    }
                }
                clear();
            }));
            return {
                DOM: vtree$,
                Events: evt,
                value$: concat_1.default(initialValue$, emittedValue$)
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Dropdown.run = run;
    /**
     * A dropdown component for capturing user input.
     * Accepts the following properties:
     *  active?: boolean,
     *  initial?: any
     *  default?: string
     *  selection?: boolean
     *  inline?: boolean
     *  floating?: boolean
     *  loading?: boolean
     *  disabled?: boolean
     *  scrolling?: boolean
     *  search?: boolean
     *  compact?: boolean
     *  size?: Size
     *  color?: Color
     * Expects the following type of content: Array of {
     *  body: DOMContent,
     *  value: any,
     *  header?: boolean,
     *  fitted?: boolean,
     *  disabled?: boolean,
     *  active?: boolean
     * }
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = []; }
        var props = (pOrC instanceof Array) ? {} : pOrC;
        var content = (pOrC instanceof Array) ? pOrC : c;
        var icon = icon_1.Icon.render({}, enums_1.IconType.Dropdown);
        var menu = menu_1.Menu.render({}, content);
        var item = content.filter(function (item) { return item.active; })[0];
        return dom_1.div({ props: { className: getClassName(props) } }, [
            getText(item, props),
            props.search ? dom_1.input({ props: { className: "search" } }) : "",
            icon, menu
        ]);
    }
    Dropdown.render = render;
    function getClassName(props, active) {
        var className = "ui";
        if (props.rightAligned) {
            className += " right";
        }
        if (props.selection) {
            className += " selection";
        }
        if (props.inline) {
            className += " inline";
        }
        if (props.floating) {
            className += " floating";
        }
        if (props.loading) {
            className += " loading";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.scrolling) {
            className += " scrolling";
        }
        if (props.search) {
            className += " search";
        }
        if (props.compact) {
            className += " compact";
        }
        if (props.pointing) {
            className += " pointing";
        }
        if (active || props.active) {
            className += " active";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        return className + " dropdown";
    }
    function getText(item, props) {
        if (typeof (props.static) !== "undefined") {
            return dom_1.div({ props: { className: "text" } }, props.static);
        }
        if (item === null) {
            return dom_1.div({ props: { className: "default text" } }, props.default);
        }
        return dom_1.div({ props: { className: "text" } }, item.body);
    }
    function filterContent(item, filter) {
        function f(node) {
            if (node.text) {
                return node.text.indexOf(filter) !== -1 || !filter;
            }
            else {
                for (var c in node.children) {
                    if (f(c)) {
                        return true;
                    }
                }
                return false;
            }
        }
        if (typeof (item.body === "string")) {
            return item.body.indexOf(filter) !== -1 || !filter;
        }
        if (!item.body.push) {
            return f(item.body);
        }
        for (var c in item.body.children) {
            if (f(c)) {
                return true;
            }
        }
        return false;
    }
    var ExecuteListener = (function () {
        function ExecuteListener(f) {
            this.f = f;
        }
        ExecuteListener.prototype.next = function (i) { this.f(i); };
        ExecuteListener.prototype.error = function (i) { };
        ExecuteListener.prototype.complete = function () { };
        return ExecuteListener;
    }());
})(Dropdown = exports.Dropdown || (exports.Dropdown = {}));


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(209));
__export(__webpack_require__(37));
__export(__webpack_require__(210));
__export(__webpack_require__(212));
__export(__webpack_require__(213));
__export(__webpack_require__(214));
__export(__webpack_require__(13));


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var enums_1 = __webpack_require__(3);
var dimmer_1 = __webpack_require__(37);
var icon_1 = __webpack_require__(23);
var transition_1 = __webpack_require__(13);
var Modal;
(function (Modal) {
    /**
     * A modal component for displaying content in a modal.
     * Accepts the following type of properties in props$:
     *   header: String - The header text for the component.
     *   on$: Stream<Boolean> - When to display the modal.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ on$: xstream_1.default.of(false) });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.actions$ = sources.actions$ ? sources.actions$ : xstream_1.default.of("");
            sources.target$ = sources.target$ ? sources.target$ : xstream_1.default.of("page");
            var closeIcon = icon_1.Icon.run({ DOM: sources.DOM, props$: xstream_1.default.of({ link: true }), content$: xstream_1.default.of(enums_1.IconType.Close) });
            var close$ = closeIcon.Events("click").mapTo(false);
            /*** Render modal ***/
            var dimmerclick$proxy = xstream_1.default.create();
            var on$ = xstream_1.default.merge(sources.on$, dimmerclick$proxy, close$).remember();
            var content$ = xstream_1.default.combine(sources.props$, sources.content$, sources.actions$, closeIcon.DOM).map(function (_a) {
                var props = _a[0], content = _a[1], actions = _a[2], icon = _a[3];
                return dom_1.div({ props: { className: "ui scrolling active modal" } }, [
                    icon,
                    dom_1.div({ props: { className: "header" } }, props.header),
                    dom_1.div({ props: { className: "content" } }, content),
                    actions ? dom_1.div({ props: { className: "actions" } }, actions) : ""
                ]);
            }).remember();
            /*** Animation ***/
            var transition$ = on$
                .fold(function (prevAnim, active) { return prevAnim.direction === enums_1.Direction.None
                ? ({ animation: enums_1.Animation.None, direction: active ? enums_1.Direction.In : enums_1.Direction.Out })
                : {
                    animation: enums_1.Animation.Fade, direction: active ? enums_1.Direction.In : enums_1.Direction.Out
                }; }, ({ animation: enums_1.Animation.None, direction: enums_1.Direction.None }));
            var animatedContent = transition_1.Transition.run({ DOM: sources.DOM, target$: content$, args$: transition$ });
            /*** Activate dimmer ***/
            var dimmerContent$ = animatedContent.DOM.map(function (x) { return [x]; });
            var dimmer = dimmer_1.Dimmer.run({ DOM: sources.DOM, target$: sources.target$, args$: on$, content$: dimmerContent$ }, sources.props$.map(function (x) { return x.inverted; }));
            var dimmerclick$ = dimmer.Events("mousedown")
                .filter(function (evt) { return evt.srcElement === evt.currentTarget; })
                .mapTo(false);
            dimmerclick$proxy.imitate(dimmerclick$);
            var fadeOutEnd$ = on$.map(function (active) { return !active ? dimmer.Events("animationend") : xstream_1.default.never(); }).flatten().mapTo(false);
            // const active$ = xs.merge(sources.on$, fadeOutEnd$).remember();
            return {
                active$: xstream_1.default.merge(sources.on$, fadeOutEnd$),
                DOM: dimmer.DOM,
                Events: animatedContent.Events
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Modal.run = run;
})(Modal = exports.Modal || (exports.Modal = {}));


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var enums_1 = __webpack_require__(3);
var transition_1 = __webpack_require__(13);
var dom_1 = __webpack_require__(1);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var debounce_1 = __webpack_require__(61);
var dropRepeats_1 = __webpack_require__(63);
var delay_1 = __webpack_require__(62);
var Popup;
(function (Popup) {
    function run(sources) {
        function main(sources) {
            sources.args$ = sources.args$ ? sources.args$ : xstream_1.default.of({ active: false, attachment: PopupAttachment.BottomLeft });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            var args$ = sources.args$.remember();
            var vTree$ = xstream_1.default.combine(args$, sources.content$).map(function (_a) {
                var args = _a[0], content = _a[1];
                return render(args, content);
            });
            var mouseleave$proxy = xstream_1.default.create();
            var mouseenter$proxy = xstream_1.default.create();
            var active$ = args$.map(function (arg) { return arg.active ? enums_1.Direction.In : enums_1.Direction.Out; }).drop(1);
            var timer$ = active$.map(function (dir) { return dir === enums_1.Direction.Out ? xstream_1.default.of(enums_1.Direction.Out)
                : xstream_1.default.of(enums_1.Direction.Out).compose(delay_1.default(1000)).endWhen(mouseenter$proxy); }).flatten();
            var transition$ = xstream_1.default.merge(active$, mouseleave$proxy, timer$)
                .map(function (dir) { return ({
                animation: enums_1.Animation.Fade,
                direction: dir
            }); })
                .compose(dropRepeats_1.default(function (a, b) { return a.direction === b.direction
                && a.animation === b.animation; }))
                .startWith({ animation: enums_1.Animation.None, direction: enums_1.Direction.Out });
            var animatedPopup = transition_1.Transition.run({ DOM: sources.DOM, target$: vTree$, args$: transition$ });
            var mouseenter$ = animatedPopup.Events("mouseenter");
            var mouseleave$ = xstream_1.default.merge(animatedPopup.Events("mouseleave"), mouseenter$)
                .map(function (evt) { return evt.type === "mouseenter" ? enums_1.Direction.In : enums_1.Direction.Out; })
                .compose(debounce_1.default(200))
                .filter(function (dir) { return dir === enums_1.Direction.Out; });
            mouseleave$proxy.imitate(mouseleave$);
            mouseenter$proxy.imitate(mouseenter$);
            var popup$ = animatedPopup.DOM.remember();
            return {
                DOM: popup$,
                Events: animatedPopup.Events,
                tether: xstream_1.default.combine(popup$, sources.target$, args$)
                    .map(function (_a) {
                    var element = _a[0], target = _a[1], args = _a[2];
                    return ({ element: element, target: target, args: args });
                })
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Popup.run = run;
    function render(args, content) {
        if (args === void 0) { args = { active: true, attachment: PopupAttachment.BottomLeft }; }
        if (content === void 0) { content = ""; }
        return dom_1.div({ props: { className: getClassname(args) } }, [
            args.header ? dom_1.div({ props: { className: "header" } }, args.header) : "",
            content
        ]);
    }
    Popup.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.wide) {
            className += " wide";
        }
        if (props.veryWide) {
            className += " very wide";
        }
        if (props.flowing) {
            className += " flowing";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        className += PopupAttachment.ToClassname(props.attachment) + " popup";
        return className;
    }
    var PopupAttachment;
    (function (PopupAttachment) {
        PopupAttachment[PopupAttachment["TopLeft"] = 0] = "TopLeft";
        PopupAttachment[PopupAttachment["TopMiddle"] = 1] = "TopMiddle";
        PopupAttachment[PopupAttachment["TopRight"] = 2] = "TopRight";
        PopupAttachment[PopupAttachment["LeftCenter"] = 3] = "LeftCenter";
        PopupAttachment[PopupAttachment["RightCenter"] = 4] = "RightCenter";
        PopupAttachment[PopupAttachment["BottomLeft"] = 5] = "BottomLeft";
        PopupAttachment[PopupAttachment["BottomMiddle"] = 6] = "BottomMiddle";
        PopupAttachment[PopupAttachment["BottomRight"] = 7] = "BottomRight";
        PopupAttachment[PopupAttachment["Center"] = 8] = "Center";
    })(PopupAttachment = Popup.PopupAttachment || (Popup.PopupAttachment = {}));
    (function (PopupAttachment) {
        function ToClassname(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return " top left";
                case PopupAttachment.TopMiddle: return " top center";
                case PopupAttachment.TopRight: return " top right";
                case PopupAttachment.LeftCenter: return " left center";
                case PopupAttachment.RightCenter: return " right center";
                case PopupAttachment.BottomLeft: return " bottom left";
                case PopupAttachment.BottomMiddle: return " bottom center";
                case PopupAttachment.BottomRight: return " bottom right";
                case PopupAttachment.Center: return " center";
                default: return " bottom left";
            }
        }
        PopupAttachment.ToClassname = ToClassname;
        function ToTether(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return "top left";
                case PopupAttachment.TopMiddle: return "top center";
                case PopupAttachment.TopRight: return "top right";
                case PopupAttachment.LeftCenter: return "left middle";
                case PopupAttachment.RightCenter: return "right middle";
                case PopupAttachment.BottomLeft: return "bottom left";
                case PopupAttachment.BottomMiddle: return "bottom center";
                case PopupAttachment.BottomRight: return "bottom right";
                case PopupAttachment.Center: return "center";
                default: return "bottom left";
            }
        }
        PopupAttachment.ToTether = ToTether;
        function ToOppositeTether(attachment) {
            switch (attachment) {
                case PopupAttachment.TopLeft: return "bottom right";
                case PopupAttachment.TopMiddle: return "bottom center";
                case PopupAttachment.TopRight: return "bottom left";
                case PopupAttachment.LeftCenter: return "right middle";
                case PopupAttachment.RightCenter: return "left middle";
                case PopupAttachment.BottomLeft: return "top right";
                case PopupAttachment.BottomMiddle: return "top center";
                case PopupAttachment.BottomRight: return "top left";
                case PopupAttachment.Center: return "center";
                default: return "bottom left";
            }
        }
        PopupAttachment.ToOppositeTether = ToOppositeTether;
    })(PopupAttachment = Popup.PopupAttachment || (Popup.PopupAttachment = {}));
})(Popup = exports.Popup || (exports.Popup = {}));


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var ProgressBar;
(function (ProgressBar) {
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following properties in props$:
     *   progress: number - The % of progress the progress bar should reflect.
     *   active?: boolean - Styles the progress bar to reflect activitiy.
     *   disabled?: boolean - Styles the progress bar to appear disabled.
     *   inverted?: boolean - Styles the progress bar for dark backgrounds.
     *   attachment?: Attachment - Where the progress bar should be attached to.
     *   size?: Size - The size of the progress bar.
     *   color?: Color - The color of the progress bar.
     * Expects the following type of content in content$: DOMContent
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({ progress: 0 });
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of([]);
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".progress").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    ProgressBar.run = run;
    /**
     * Creates a Label component to add information to certain content.
     * Accepts the following propertiea:
     *   progress: number - The % of progress the progress bar should reflect.
     *   active?: boolean - Styles the progress bar to reflect activitiy.
     *   disabled?: boolean - Styles the progress bar to appear disabled.
     *   inverted?: boolean - Styles the progress bar for dark backgrounds.
     *   attachment?: Attachment - Where the progress bar should be attached to.
     *   size?: Size - The size of the progress bar.
     *   color?: Color - The color of the progress bar.
     * Expects the following type of content: DOMContent
     */
    function render(pOrC, c) {
        if (pOrC === void 0) { pOrC = { progress: 0 }; }
        if (c === void 0) { c = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? { progress: 0 } : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            dom_1.div({ props: { className: "bar" } }, { style: { width: props.progress + "%" } }, [
                dom_1.div({ props: { className: "progress" } }, [props.progress + "%"])
            ]),
            dom_1.div({ props: { className: "label" } }, content)
        ]);
    }
    ProgressBar.render = render;
    function getClassname(props) {
        var className = "ui";
        if (props.active) {
            className += " active";
        }
        if (props.disabled) {
            className += " disabled";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.attachment) !== "undefined") {
            className += enums_1.Attachment.ToClassname(props.attachment);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        className += " progress";
        return className;
    }
})(ProgressBar = exports.ProgressBar || (exports.ProgressBar = {}));


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(__webpack_require__(216));


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var interfaces_1 = __webpack_require__(4);
var enums_1 = __webpack_require__(3);
var xstream_1 = __webpack_require__(0);
var isolate_1 = __webpack_require__(2);
var dom_1 = __webpack_require__(1);
var Statistic;
(function (Statistic) {
    /**
     * A statistic component to show statistics.
     * Accepts the following properties in props$:
     *   horizontal?: boolean - Styles the statistic to display horizontally.
     *   inverted?: boolean - Styles the statistic for a dark background.
     *   color?: Color - The color of the statistic.
     *   size?: Size - The size of the statistic.
     *   float?: Float - Where to float the statistic.
     * Expects the following type of content in content$: {} of
     *   value: String|VNode - The value for the statistic.
     *   label: String|VNode - The label for the statistic.
     *   isText?: boolean - Formats the statistic value for text based values.
     */
    function run(sources) {
        function main(sources) {
            sources.props$ = sources.props$ ? sources.props$ : xstream_1.default.of({});
            sources.content$ = sources.content$ ? sources.content$ : xstream_1.default.of("");
            sources.extras$ = sources.extras$ ? sources.extras$ : xstream_1.default.of("");
            var vTree$ = xstream_1.default.combine(sources.props$, sources.content$).map(function (_a) {
                var props = _a[0], content = _a[1];
                return render(props, content);
            });
            return {
                DOM: vTree$,
                Events: function (type) { return sources.DOM.select(".statistic").events(type); }
            };
        }
        var isolatedMain = isolate_1.default(main);
        return isolatedMain(sources);
    }
    Statistic.run = run;
    /**
     * A statistic component to show statistics.
     * Accepts the following properties:
     *   horizontal?: boolean - Styles the statistic to display horizontally.
     *   inverted?: boolean - Styles the statistic for a dark background.
     *   color?: Color - The color of the statistic.
     *   size?: Size - The size of the statistic.
     *   float?: Float - Where to float the statistic.
     * Expects the following type of content: {} of
     *   value: String|VNode - The value for the statistic.
     *   label: String|VNode - The label for the statistic.
     *   isText?: boolean - Formats the statistic value for text based values.
     */
    function render(pOrC, c, e) {
        if (pOrC === void 0) { pOrC = {}; }
        if (c === void 0) { c = ""; }
        if (e === void 0) { e = ""; }
        var props = interfaces_1.isDOMContent(pOrC) ? {} : pOrC;
        var content = interfaces_1.isDOMContent(pOrC) ? pOrC : c;
        var label = interfaces_1.isDOMContent(pOrC) ? c : e;
        return dom_1.div({ props: { className: getClassname(props) } }, [
            dom_1.div({ props: { className: props.text ? "text value" : "value" } }, content),
            dom_1.div({ props: { className: "label" } }, label)
        ]);
    }
    Statistic.render = render;
    function getClassname(props) {
        var className = "ui ";
        if (props.horizontal) {
            className += " horizontal";
        }
        if (props.inverted) {
            className += " inverted";
        }
        if (typeof (props.color) !== "undefined") {
            className += enums_1.Color.ToClassname(props.color);
        }
        if (typeof (props.size) !== "undefined") {
            className += enums_1.Size.ToClassname(props.size);
        }
        if (typeof (props.float) !== "undefined") {
            className += enums_1.Float.ToClassname(props.float);
        }
        className += " statistic";
        return className;
    }
})(Statistic = exports.Statistic || (exports.Statistic = {}));


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var ConcatProducer = (function () {
    function ConcatProducer(streams) {
        this.streams = streams;
        this.type = 'concat';
        this.out = null;
        this.i = 0;
    }
    ConcatProducer.prototype._start = function (out) {
        this.out = out;
        this.streams[this.i]._add(this);
    };
    ConcatProducer.prototype._stop = function () {
        var streams = this.streams;
        if (this.i < streams.length) {
            streams[this.i]._remove(this);
        }
        this.i = 0;
        this.out = null;
    };
    ConcatProducer.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        u._n(t);
    };
    ConcatProducer.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    ConcatProducer.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        var streams = this.streams;
        streams[this.i]._remove(this);
        if (++this.i < streams.length) {
            streams[this.i]._add(this);
        }
        else {
            u._c();
        }
    };
    return ConcatProducer;
}());
/**
 * Puts one stream after the other. *concat* is a factory that takes multiple
 * streams as arguments, and starts the `n+1`-th stream only when the `n`-th
 * stream has completed. It concatenates those streams together.
 *
 * Marble diagram:
 *
 * ```text
 * --1--2---3---4-|
 * ...............--a-b-c--d-|
 *           concat
 * --1--2---3---4---a-b-c--d-|
 * ```
 *
 * Example:
 *
 * ```js
 * import concat from 'xstream/extra/concat'
 *
 * const streamA = xs.of('a', 'b', 'c')
 * const streamB = xs.of(10, 20, 30)
 * const streamC = xs.of('X', 'Y', 'Z')
 *
 * const outputStream = concat(streamA, streamB, streamC)
 *
 * outputStream.addListener({
 *   next: (x) => console.log(x),
 *   error: (err) => console.error(err),
 *   complete: () => console.log('concat completed'),
 * })
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to concatenate together with other streams.
 * @param {Stream} stream2 A stream to concatenate together with other streams. Two
 * or more streams may be given as arguments.
 * @return {Stream}
 */
function concat() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new index_1.Stream(new ConcatProducer(streams));
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var index_1 = __webpack_require__(0);
var FCIL = (function () {
    function FCIL(out, op) {
        this.out = out;
        this.op = op;
    }
    FCIL.prototype._n = function (t) {
        this.out._n(t);
    };
    FCIL.prototype._e = function (err) {
        this.out._e(err);
    };
    FCIL.prototype._c = function () {
        this.op.less();
    };
    return FCIL;
}());
var FlattenConcOperator = (function () {
    function FlattenConcOperator(ins) {
        this.ins = ins;
        this.type = 'flattenConcurrently';
        this.active = 1; // number of outers and inners that have not yet ended
        this.out = null;
    }
    FlattenConcOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    FlattenConcOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.active = 1;
        this.out = null;
    };
    FlattenConcOperator.prototype.less = function () {
        if (--this.active === 0) {
            var u = this.out;
            if (!u)
                return;
            u._c();
        }
    };
    FlattenConcOperator.prototype._n = function (s) {
        var u = this.out;
        if (!u)
            return;
        this.active++;
        s._add(new FCIL(u, this));
    };
    FlattenConcOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    FlattenConcOperator.prototype._c = function () {
        this.less();
    };
    return FlattenConcOperator;
}());
exports.FlattenConcOperator = FlattenConcOperator;
/**
 * Flattens a "stream of streams", handling multiple concurrent nested streams
 * simultaneously.
 *
 * If the input stream is a stream that emits streams, then this operator will
 * return an output stream which is a flat stream: emits regular events. The
 * flattening happens concurrently. It works like this: when the input stream
 * emits a nested stream, *flattenConcurrently* will start imitating that
 * nested one. When the next nested stream is emitted on the input stream,
 * *flattenConcurrently* will also imitate that new one, but will continue to
 * imitate the previous nested streams as well.
 *
 * Marble diagram:
 *
 * ```text
 * --+--------+---------------
 *   \        \
 *    \       ----1----2---3--
 *    --a--b----c----d--------
 *     flattenConcurrently
 * -----a--b----c-1--d-2---3--
 * ```
 *
 * @return {Stream}
 */
function flattenConcurrently(ins) {
    return new index_1.Stream(new FlattenConcOperator(ins));
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = flattenConcurrently;
//# sourceMappingURL=flattenConcurrently.js.map

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(65);
module.exports = __webpack_require__(64);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOTM3MTM2ZDQ4ZWY3NDg0MDc3YzQiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaXNvbGF0ZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9pbnRlcmZhY2VzL2luZGV4LnRzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL3hzdHJlYW0tYWRhcHRlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3RyYW5zaXRpb24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9pcy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy91aS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvaWNvbi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2Zyb21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2h5cGVyc2NyaXB0LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy9pcy1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtaXRlcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9Ccm93c2VyUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fcm9vdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21hdGNoZXMtc2VsZWN0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS92bm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9kaW1tZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL1Njb3BlQ2hlY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL3RyYW5zcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaGlzdG9yeS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvaGlzdG9yeS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXItc3BsaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L2FycmF5LyMvY2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2dldG5hdGl2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5lc2NhcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guZm9yb3duL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmlzYXJndW1lbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tc2VsZWN0b3IvbGliL3NlbGVjdG9yUGFyc2VyLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tdG8taHRtbC9saWIvcGFyc2Utc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL21lbnUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3hzdHJlYW0vZXh0cmEvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi94c3RyZWFtL2V4dHJhL2RlbGF5LmpzIiwid2VicGFjazovLy8uL34veHN0cmVhbS9leHRyYS9kcm9wUmVwZWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9kb2NzLmxlc3MiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvYXBwLnRzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvQm9keURPTVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL0RvY3VtZW50RE9NU291cmNlLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvRWxlbWVudEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL0V2ZW50RGVsZWdhdG9yLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvSFRNTFNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL01haW5ET01Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9WTm9kZVdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9oeXBlcnNjcmlwdC1oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvaXNvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9kb20vbGliL2lzb2xhdGVNb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9tYWtlRE9NRHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvbWFrZUhUTUxEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUvZG9tL2xpYi9tb2NrRE9NU291cmNlLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2RvbS9saWIvbW9kdWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi9jYXB0dXJlQ2xpY2tzLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2hpc3RvcnkvbGliL21ha2VIaXN0b3J5RHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL2hpc3RvcnkvbGliL3NlcnZlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AY3ljbGUveHN0cmVhbS1ydW4vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vQGN5Y2xlL3hzdHJlYW0tcnVuL34vQGN5Y2xlL2Jhc2UvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvUm91dGVyU291cmNlLmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jeWNsaWMtcm91dGVyL2xpYi9tYWtlUm91dGVyRHJpdmVyLmpzIiwid2VicGFjazovLy8uL34vY3ljbGljLXJvdXRlci9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2QvYXV0by1iaW5kLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L21hdGgvc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvbWF0aC9zaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9tYXRoL3NpZ24vc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvbnVtYmVyL3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L251bWJlci90by1wb3MtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L19pdGVyYXRlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9jb3B5LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvbWFwLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9wcmltaXRpdmUtc2V0LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1pdGVyYXRvci9mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtaXRlcmF0b3IvZ2V0LmpzIiwid2VicGFjazovLy8uL34vZXM2LWl0ZXJhdG9yL2lzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vZXM2LWl0ZXJhdG9yL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtbWFwL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1tYXAvbGliL2l0ZXJhdG9yLWtpbmRzLmpzIiwid2VicGFjazovLy8uL34vZXM2LW1hcC9saWIvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtbWFwL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL34vZXM2LXN5bWJvbC9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvaXMtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vZXM2LXN5bWJvbC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9IYXNoUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9SZWZyZXNoUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VCZWZvcmVVbmxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9iYXNlZmxhdHRlbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fYmFzZWZvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fYmFzZWluZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2Jhc2V1bmlxL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9iaW5kY2FsbGJhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guX2NhY2hlaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fY3JlYXRlY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2guZGVidXJyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLmtlYmFiY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLnJlc3RwYXJhbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC51bmlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC53b3Jkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9jbGFzc05hbWVGcm9tVk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9jb250YWluZXItZWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tLXRvLWh0bWwvbGliL2luaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL3N0eWxlLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20tdG8taHRtbC9saWIvdm9pZC1lbGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9odG1sZG9tYXBpLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9tb2R1bGVzL2hlcm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmFiYmRvbS9tb2R1bGVzL3Byb3BzLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vbW9kdWxlcy9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL3NuYWJiZG9tLmpzIiwid2VicGFjazovLy8uL34vc25hYmJkb20vdGh1bmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N3aXRjaC1wYXRoL2xpYi9lczIwMTUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zd2l0Y2gtcGF0aC9saWIvZXMyMDE1L3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9jb2xsZWN0aW9ucy9icmVhZGNydW1iLnRzIiwid2VicGFjazovLy8uL2RvY3Mtc3JjL2NvbGxlY3Rpb25zL2luZGV4LnRzIiwid2VicGFjazovLy8uL2RvY3Mtc3JjL2NvbXBvbmVudHMvZXhhbXBsZS50cyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9jb21wb25lbnRzL2luZGV4LnRzIiwid2VicGFjazovLy8uL2RvY3Mtc3JjL2luZGV4L2luZGV4LnRzIiwid2VicGFjazovLy8uL2RvY3Mtc3JjL2xheW91dC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9sYXlvdXQvc2lkZWJhci9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9kb2NzLXNyYy9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy1zcmMvcm91dGVzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9icmVhZGNydW1iL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9mb3JtL2ZpZWxkLnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9mb3JtL2ZpZWxkcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9mb3JtLnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9mb3JtL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9ncmlkL2NvbHVtbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9ncmlkLnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9ncmlkL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb2xsZWN0aW9ucy9ncmlkL3Jvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sbGVjdGlvbnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL21lc3NhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbGxlY3Rpb25zL3RhYmxlL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9idXR0b24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2NvbnRhaW5lci9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvZGl2aWRlci9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvaGVhZGVyL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9pbWFnZS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZWxlbWVudHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL2xhYmVsL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9saXN0L2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9lbGVtZW50cy9sb2FkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL3NlZ21lbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL3N0ZXAvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VsZW1lbnRzL3RleHRib3gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2ljb25UeXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9jaGVja2JveC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9kcm9wZG93bi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9tb2RhbC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9wb3B1cC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9wcm9ncmVzcy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3N0YXRpc3RpYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9+L3hzdHJlYW0vZXh0cmEvY29uY2F0LmpzIiwid2VicGFjazovLy8uL34veHN0cmVhbS9leHRyYS9mbGF0dGVuQ29uY3VycmVudGx5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxXQUFXLEVBQUU7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0Q0FBNEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ2pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QyxLQUFLLENBQUM7QUFDZixDQUFDO0FBaEJELG9DQWdCQzs7Ozs7OztBQ3pCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0IsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG1DOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsMEJBQTBCLG1DQUFtQyxFQUFFO0FBQy9ELENBQUM7Ozs7Ozs7O0FDcENEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvQkE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ1JEOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDBC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QkFBc0Isb0JBQW9COztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGOzs7Ozs7OztBQzFNQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ3BCQTs7QUFFQSw0RTs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUMsQ0FBQyxDQUFDO1lBQ3RCLFNBQVMsSUFBSSxlQUFlLENBQUM7UUFDL0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLFNBQVMsSUFBSSxRQUFRLENBQUM7UUFDeEIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25CLFNBQVMsSUFBSSxXQUFXLENBQUM7UUFDM0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLFNBQVMsSUFBSSxVQUFVLENBQUM7UUFDMUIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25CLFNBQVMsSUFBSSxXQUFXLENBQUM7UUFDM0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLFNBQVMsSUFBSSxTQUFTLENBQUM7UUFDekIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLFNBQVMsSUFBSSxjQUFjLENBQUM7UUFDOUIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLFNBQVMsSUFBSSxVQUFVLENBQUM7UUFDMUIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25CLFNBQVMsSUFBSSxXQUFXLENBQUM7UUFDM0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25CLFNBQVMsSUFBSSxXQUFXLENBQUM7UUFDM0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLFNBQVMsSUFBSSxR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QUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNsQixTQUFTLElBQUksVUFBVSxDQUFDO1FBQzFCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuQixTQUFTLElBQUksV0FBVyxDQUFDO1FBQzNCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUNwQixTQUFTLElBQUksWUFBWSxDQUFDO1FBQzVCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNqQixTQUFTLElBQUksU0FBUyxDQUFDO1FBQ3pCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNsQixTQUFTLElBQUksVUFBVSxDQUFDO1FBQzFCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuQixTQUFTLElBQUksV0FBVyxDQUFDO1FBQzNCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDM0IsU0FBUyxJQUFJLFNBQVMsQ0FBQztRQUN6QixDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLFNBQVMsSUFBSSxZQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QyxDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLFNBQVMsSUFBSSxhQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5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QSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrQzs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLCtDIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9jeWNsZS1zZW1hbnRpYy11aS9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMTkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDkzNzEzNmQ0OGVmNzQ4NDA3N2M0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBzeW1ib2xfb2JzZXJ2YWJsZV8xID0gcmVxdWlyZShcInN5bWJvbC1vYnNlcnZhYmxlXCIpO1xudmFyIE5PID0ge307XG5leHBvcnRzLk5PID0gTk87XG5mdW5jdGlvbiBub29wKCkgeyB9XG5mdW5jdGlvbiBjcChhKSB7XG4gICAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgICB2YXIgYiA9IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKVxuICAgICAgICBiW2ldID0gYVtpXTtcbiAgICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIGFuZChmMSwgZjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5kRm4odCkge1xuICAgICAgICByZXR1cm4gZjEodCkgJiYgZjIodCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF90cnkoYywgdCwgdSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjLmYodCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHUuX2UoZSk7XG4gICAgICAgIHJldHVybiBOTztcbiAgICB9XG59XG52YXIgTk9fSUwgPSB7XG4gICAgX246IG5vb3AsXG4gICAgX2U6IG5vb3AsXG4gICAgX2M6IG5vb3AsXG59O1xuZXhwb3J0cy5OT19JTCA9IE5PX0lMO1xuLy8gbXV0YXRlcyB0aGUgaW5wdXRcbmZ1bmN0aW9uIGludGVybmFsaXplUHJvZHVjZXIocHJvZHVjZXIpIHtcbiAgICBwcm9kdWNlci5fc3RhcnQgPSBmdW5jdGlvbiBfc3RhcnQoaWwpIHtcbiAgICAgICAgaWwubmV4dCA9IGlsLl9uO1xuICAgICAgICBpbC5lcnJvciA9IGlsLl9lO1xuICAgICAgICBpbC5jb21wbGV0ZSA9IGlsLl9jO1xuICAgICAgICB0aGlzLnN0YXJ0KGlsKTtcbiAgICB9O1xuICAgIHByb2R1Y2VyLl9zdG9wID0gcHJvZHVjZXIuc3RvcDtcbn1cbnZhciBTdHJlYW1TdWIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmVhbVN1Yihfc3RyZWFtLCBfbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtID0gX3N0cmVhbTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBfbGlzdGVuZXI7XG4gICAgfVxuICAgIFN0cmVhbVN1Yi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9saXN0ZW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gU3RyZWFtU3ViO1xufSgpKTtcbnZhciBPYnNlcnZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXIoX2xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gX2xpc3RlbmVyO1xuICAgIH1cbiAgICBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lci5fbih2YWx1ZSk7XG4gICAgfTtcbiAgICBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyLl9lKGVycik7XG4gICAgfTtcbiAgICBPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyLl9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZXI7XG59KCkpO1xudmFyIEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm9tT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmcm9tT2JzZXJ2YWJsZSc7XG4gICAgICAgIHRoaXMuaW5zID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgRnJvbU9ic2VydmFibGUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3ViID0gdGhpcy5pbnMuc3Vic2NyaWJlKG5ldyBPYnNlcnZlcihvdXQpKTtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHRoaXMuX3N1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgRnJvbU9ic2VydmFibGUucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc3ViKVxuICAgICAgICAgICAgdGhpcy5fc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbU9ic2VydmFibGU7XG59KCkpO1xudmFyIE1lcmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZShpbnNBcnIpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ21lcmdlJztcbiAgICAgICAgdGhpcy5pbnNBcnIgPSBpbnNBcnI7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuYWMgPSAwO1xuICAgIH1cbiAgICBNZXJnZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluc0FycjtcbiAgICAgICAgdmFyIEwgPSBzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hYyA9IEw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTDsgaSsrKVxuICAgICAgICAgICAgc1tpXS5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTWVyZ2UucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuaW5zQXJyO1xuICAgICAgICB2YXIgTCA9IHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgIHNbaV0uX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBNZXJnZS5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgtLXRoaXMuYWMgPD0gMCkge1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZTtcbn0oKSk7XG52YXIgQ29tYmluZUxpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21iaW5lTGlzdGVuZXIoaSwgb3V0LCBwKSB7XG4gICAgICAgIHRoaXMuaSA9IGk7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICBwLmlscy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBDb21iaW5lTGlzdGVuZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnAsIG91dCA9IHRoaXMub3V0O1xuICAgICAgICBpZiAob3V0ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHAudXAodCwgdGhpcy5pKSlcbiAgICAgICAgICAgIG91dC5fbihwLnZhbHMpO1xuICAgIH07XG4gICAgQ29tYmluZUxpc3RlbmVyLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMub3V0O1xuICAgICAgICBpZiAob3V0ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0Ll9lKGVycik7XG4gICAgfTtcbiAgICBDb21iaW5lTGlzdGVuZXIucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMucDtcbiAgICAgICAgaWYgKHAub3V0ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKC0tcC5OYyA9PT0gMClcbiAgICAgICAgICAgIHAub3V0Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tYmluZUxpc3RlbmVyO1xufSgpKTtcbnZhciBDb21iaW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21iaW5lKGluc0Fycikge1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29tYmluZSc7XG4gICAgICAgIHRoaXMuaW5zQXJyID0gaW5zQXJyO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmlscyA9IFtdO1xuICAgICAgICB0aGlzLk5jID0gdGhpcy5ObiA9IDA7XG4gICAgICAgIHRoaXMudmFscyA9IFtdO1xuICAgIH1cbiAgICBDb21iaW5lLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy52YWxzW2ldO1xuICAgICAgICB2YXIgTm4gPSAhdGhpcy5ObiA/IDAgOiB2ID09PSBOTyA/IC0tdGhpcy5ObiA6IHRoaXMuTm47XG4gICAgICAgIHRoaXMudmFsc1tpXSA9IHQ7XG4gICAgICAgIHJldHVybiBObiA9PT0gMDtcbiAgICB9O1xuICAgIENvbWJpbmUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbnNBcnI7XG4gICAgICAgIHZhciBuID0gdGhpcy5OYyA9IHRoaXMuTm4gPSBzLmxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHMgPSB0aGlzLnZhbHMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICBvdXQuX24oW10pO1xuICAgICAgICAgICAgb3V0Ll9jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHNbaV0gPSBOTztcbiAgICAgICAgICAgICAgICBzW2ldLl9hZGQobmV3IENvbWJpbmVMaXN0ZW5lcihpLCBvdXQsIHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbnNBcnI7XG4gICAgICAgIHZhciBuID0gcy5sZW5ndGg7XG4gICAgICAgIHZhciBpbHMgPSB0aGlzLmlscztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBzW2ldLl9yZW1vdmUoaWxzW2ldKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5pbHMgPSBbXTtcbiAgICAgICAgdGhpcy52YWxzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gQ29tYmluZTtcbn0oKSk7XG52YXIgRnJvbUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm9tQXJyYXkoYSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnJvbUFycmF5JztcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICB9XG4gICAgRnJvbUFycmF5LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGEubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgb3V0Ll9uKGFbaV0pO1xuICAgICAgICBvdXQuX2MoKTtcbiAgICB9O1xuICAgIEZyb21BcnJheS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbUFycmF5O1xufSgpKTtcbnZhciBGcm9tUHJvbWlzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJvbVByb21pc2UocCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZnJvbVByb21pc2UnO1xuICAgICAgICB0aGlzLm9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgfVxuICAgIEZyb21Qcm9taXNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHZhciBwcm9kID0gdGhpcztcbiAgICAgICAgdGhpcy5vbiA9IHRydWU7XG4gICAgICAgIHRoaXMucC50aGVuKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAocHJvZC5vbikge1xuICAgICAgICAgICAgICAgIG91dC5fbih2KTtcbiAgICAgICAgICAgICAgICBvdXQuX2MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG91dC5fZShlKTtcbiAgICAgICAgfSkudGhlbihub29wLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGcm9tUHJvbWlzZS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub24gPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tUHJvbWlzZTtcbn0oKSk7XG52YXIgUGVyaW9kaWMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlcmlvZGljKHBlcmlvZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAncGVyaW9kaWMnO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElEID0gLTE7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgfVxuICAgIFBlcmlvZGljLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJ2YWxIYW5kbGVyKCkgeyBvdXQuX24oc2VsZi5pKyspOyB9XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGludGVydmFsSGFuZGxlciwgdGhpcy5wZXJpb2QpO1xuICAgIH07XG4gICAgUGVyaW9kaWMucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElEICE9PSAtMSlcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElEKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElEID0gLTE7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gUGVyaW9kaWM7XG59KCkpO1xudmFyIERlYnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJ1ZyhpbnMsIGFyZykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVidWcnO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5zID0gbm9vcDtcbiAgICAgICAgdGhpcy5sID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRoaXMubCA9IGFyZztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRoaXMucyA9IGFyZztcbiAgICB9XG4gICAgRGVidWcucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBEZWJ1Zy5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICBEZWJ1Zy5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzID0gdGhpcy5zLCBsID0gdGhpcy5sO1xuICAgICAgICBpZiAocyAhPT0gbm9vcCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB1Ll9lKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhsICsgJzonLCB0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29uc29sZS5sb2codCk7XG4gICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBEZWJ1Zy5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRGVidWcucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJ1Zztcbn0oKSk7XG52YXIgRHJvcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcChtYXgsIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZHJvcCc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5kcm9wcGVkID0gMDtcbiAgICB9XG4gICAgRHJvcC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5kcm9wcGVkID0gMDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIERyb3AucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgRHJvcC5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRyb3BwZWQrKyA+PSB0aGlzLm1heClcbiAgICAgICAgICAgIHUuX24odCk7XG4gICAgfTtcbiAgICBEcm9wLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBEcm9wLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcDtcbn0oKSk7XG52YXIgRW5kV2hlbkxpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmRXaGVuTGlzdGVuZXIob3V0LCBvcCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICBFbmRXaGVuTGlzdGVuZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wLmVuZCgpO1xuICAgIH07XG4gICAgRW5kV2hlbkxpc3RlbmVyLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5vdXQuX2UoZXJyKTtcbiAgICB9O1xuICAgIEVuZFdoZW5MaXN0ZW5lci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3AuZW5kKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5kV2hlbkxpc3RlbmVyO1xufSgpKTtcbnZhciBFbmRXaGVuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmRXaGVuKG8sIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZW5kV2hlbic7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm8gPSBvO1xuICAgICAgICB0aGlzLm9pbCA9IE5PX0lMO1xuICAgIH1cbiAgICBFbmRXaGVuLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm8uX2FkZCh0aGlzLm9pbCA9IG5ldyBFbmRXaGVuTGlzdGVuZXIob3V0LCB0aGlzKSk7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBFbmRXaGVuLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vLl9yZW1vdmUodGhpcy5vaWwpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLm9pbCA9IE5PX0lMO1xuICAgIH07XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIEVuZFdoZW4ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9uKHQpO1xuICAgIH07XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRW5kV2hlbi5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5kV2hlbjtcbn0oKSk7XG52YXIgRmlsdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXIocGFzc2VzLCBpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZpbHRlcic7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmYgPSBwYXNzZXM7XG4gICAgfVxuICAgIEZpbHRlci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIEZpbHRlci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgciA9IF90cnkodGhpcywgdCwgdSk7XG4gICAgICAgIGlmIChyID09PSBOTyB8fCAhcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIEZpbHRlci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRmlsdGVyLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyO1xufSgpKTtcbnZhciBGbGF0dGVuTGlzdGVuZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZsYXR0ZW5MaXN0ZW5lcihvdXQsIG9wKSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIEZsYXR0ZW5MaXN0ZW5lci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLm91dC5fbih0KTtcbiAgICB9O1xuICAgIEZsYXR0ZW5MaXN0ZW5lci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMub3V0Ll9lKGVycik7XG4gICAgfTtcbiAgICBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wLmlubmVyID0gTk87XG4gICAgICAgIHRoaXMub3AubGVzcygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZsYXR0ZW5MaXN0ZW5lcjtcbn0oKSk7XG52YXIgRmxhdHRlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxhdHRlbihpbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZsYXR0ZW4nO1xuICAgICAgICB0aGlzLmlucyA9IGlucztcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgfVxuICAgIEZsYXR0ZW4ucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRmxhdHRlbi5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlubmVyICE9PSBOTylcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuX3JlbW92ZSh0aGlzLmlsKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgfTtcbiAgICBGbGF0dGVuLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5vcGVuICYmIHRoaXMuaW5uZXIgPT09IE5PKVxuICAgICAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgRmxhdHRlbi5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGlubmVyID0gX2EuaW5uZXIsIGlsID0gX2EuaWw7XG4gICAgICAgIGlmIChpbm5lciAhPT0gTk8gJiYgaWwgIT09IE5PX0lMKVxuICAgICAgICAgICAgaW5uZXIuX3JlbW92ZShpbCk7XG4gICAgICAgICh0aGlzLmlubmVyID0gcykuX2FkZCh0aGlzLmlsID0gbmV3IEZsYXR0ZW5MaXN0ZW5lcih1LCB0aGlzKSk7XG4gICAgfTtcbiAgICBGbGF0dGVuLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBGbGF0dGVuLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVzcygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZsYXR0ZW47XG59KCkpO1xudmFyIEZvbGQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvbGQoZiwgc2VlZCwgaW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmb2xkJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuZiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmKF90aGlzLmFjYywgdCk7IH07XG4gICAgICAgIHRoaXMuYWNjID0gdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgRm9sZC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5hY2MgPSB0aGlzLnNlZWQ7XG4gICAgICAgIG91dC5fbih0aGlzLmFjYyk7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5hY2MgPSB0aGlzLnNlZWQ7XG4gICAgfTtcbiAgICBGb2xkLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHIgPSBfdHJ5KHRoaXMsIHQsIHUpO1xuICAgICAgICBpZiAociA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX24odGhpcy5hY2MgPSByKTtcbiAgICB9O1xuICAgIEZvbGQucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIEZvbGQucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBGb2xkO1xufSgpKTtcbnZhciBMYXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXN0KGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnbGFzdCc7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgICAgICB0aGlzLmhhcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbCA9IE5PO1xuICAgIH1cbiAgICBMYXN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmhhcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTGFzdC5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMudmFsID0gTk87XG4gICAgfTtcbiAgICBMYXN0LnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuaGFzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWwgPSB0O1xuICAgIH07XG4gICAgTGFzdC5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgTGFzdC5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuaGFzKSB7XG4gICAgICAgICAgICB1Ll9uKHRoaXMudmFsKTtcbiAgICAgICAgICAgIHUuX2MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1Ll9lKG5ldyBFcnJvcignbGFzdCgpIGZhaWxlZCBiZWNhdXNlIGlucHV0IHN0cmVhbSBjb21wbGV0ZWQnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGFzdDtcbn0oKSk7XG52YXIgTWFwRmxhdHRlbkxpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBGbGF0dGVuTGlzdGVuZXIob3V0LCBvcCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICBNYXBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdGhpcy5vdXQuX24ocik7XG4gICAgfTtcbiAgICBNYXBGbGF0dGVuTGlzdGVuZXIucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLm91dC5fZShlcnIpO1xuICAgIH07XG4gICAgTWFwRmxhdHRlbkxpc3RlbmVyLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcC5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLm9wLmxlc3MoKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBGbGF0dGVuTGlzdGVuZXI7XG59KCkpO1xudmFyIE1hcEZsYXR0ZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcEZsYXR0ZW4obWFwT3ApIHtcbiAgICAgICAgdGhpcy50eXBlID0gbWFwT3AudHlwZSArIFwiK2ZsYXR0ZW5cIjtcbiAgICAgICAgdGhpcy5pbnMgPSBtYXBPcC5pbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMubWFwT3AgPSBtYXBPcDtcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgfVxuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBOTztcbiAgICAgICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcE9wLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTWFwRmxhdHRlbi5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwT3AuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlubmVyICE9PSBOTylcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuX3JlbW92ZSh0aGlzLmlsKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICAgICAgdGhpcy5pbm5lciA9IE5PO1xuICAgICAgICB0aGlzLmlsID0gTk9fSUw7XG4gICAgfTtcbiAgICBNYXBGbGF0dGVuLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMub3BlbiAmJiB0aGlzLmlubmVyID09PSBOTykge1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBpbm5lciA9IF9hLmlubmVyLCBpbCA9IF9hLmlsO1xuICAgICAgICB2YXIgcyA9IF90cnkodGhpcy5tYXBPcCwgdiwgdSk7XG4gICAgICAgIGlmIChzID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGlubmVyICE9PSBOTyAmJiBpbCAhPT0gTk9fSUwpXG4gICAgICAgICAgICBpbm5lci5fcmVtb3ZlKGlsKTtcbiAgICAgICAgKHRoaXMuaW5uZXIgPSBzKS5fYWRkKHRoaXMuaWwgPSBuZXcgTWFwRmxhdHRlbkxpc3RlbmVyKHUsIHRoaXMpKTtcbiAgICB9O1xuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIE1hcEZsYXR0ZW4ucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZXNzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwRmxhdHRlbjtcbn0oKSk7XG52YXIgTWFwT3AgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcE9wKHByb2plY3QsIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnbWFwJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuZiA9IHByb2plY3Q7XG4gICAgfVxuICAgIE1hcE9wLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgTWFwT3AucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgTWFwT3AucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgciA9IF90cnkodGhpcywgdCwgdSk7XG4gICAgICAgIGlmIChyID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbihyKTtcbiAgICB9O1xuICAgIE1hcE9wLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBNYXBPcC5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wO1xufSgpKTtcbnZhciBGaWx0ZXJNYXBGdXNpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXJNYXBGdXNpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyTWFwRnVzaW9uKHBhc3NlcywgcHJvamVjdCwgaW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb2plY3QsIGlucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdmaWx0ZXIrbWFwJztcbiAgICAgICAgX3RoaXMucGFzc2VzID0gcGFzc2VzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpbHRlck1hcEZ1c2lvbi5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAoIXRoaXMucGFzc2VzKHQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAodSA9PT0gTk8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByID0gX3RyeSh0aGlzLCB0LCB1KTtcbiAgICAgICAgaWYgKHIgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9uKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlck1hcEZ1c2lvbjtcbn0oTWFwT3ApKTtcbnZhciBSZW1lbWJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVtZW1iZXIoaW5zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdyZW1lbWJlcic7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH1cbiAgICBSZW1lbWJlci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZChvdXQpO1xuICAgIH07XG4gICAgUmVtZW1iZXIucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMub3V0KTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIHJldHVybiBSZW1lbWJlcjtcbn0oKSk7XG52YXIgUmVwbGFjZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBsYWNlRXJyb3IocmVwbGFjZXIsIGlucykge1xuICAgICAgICB0aGlzLnR5cGUgPSAncmVwbGFjZUVycm9yJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMuZiA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICBSZXBsYWNlRXJyb3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBSZXBsYWNlRXJyb3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IE5PO1xuICAgIH07XG4gICAgUmVwbGFjZUVycm9yLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIFJlcGxhY2VFcnJvci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICh1ID09PSBOTylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAodGhpcy5pbnMgPSB0aGlzLmYoZXJyKSkuX2FkZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdS5fZShlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwbGFjZUVycm9yLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwbGFjZUVycm9yO1xufSgpKTtcbnZhciBTdGFydFdpdGggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXJ0V2l0aChpbnMsIHZhbCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhcnRXaXRoJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgIH1cbiAgICBTdGFydFdpdGgucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3V0Ll9uKHRoaXMudmFsKTtcbiAgICAgICAgdGhpcy5pbnMuX2FkZChvdXQpO1xuICAgIH07XG4gICAgU3RhcnRXaXRoLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzLm91dCk7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgfTtcbiAgICByZXR1cm4gU3RhcnRXaXRoO1xufSgpKTtcbnZhciBUYWtlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlKG1heCwgaW5zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0YWtlJztcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMub3V0ID0gTk87XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB0aGlzLnRha2VuID0gMDtcbiAgICB9XG4gICAgVGFrZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy50YWtlbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1heCA8PSAwKVxuICAgICAgICAgICAgb3V0Ll9jKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBUYWtlLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBOTztcbiAgICB9O1xuICAgIFRha2UucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbSA9ICsrdGhpcy50YWtlbjtcbiAgICAgICAgaWYgKG0gPCB0aGlzLm1heClcbiAgICAgICAgICAgIHUuX24odCk7XG4gICAgICAgIGVsc2UgaWYgKG0gPT09IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB1Ll9uKHQpO1xuICAgICAgICAgICAgdS5fYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWtlLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBUYWtlLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKHUgPT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9jKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZTtcbn0oKSk7XG52YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJlYW0ocHJvZHVjZXIpIHtcbiAgICAgICAgdGhpcy5fcHJvZCA9IHByb2R1Y2VyIHx8IE5PO1xuICAgICAgICB0aGlzLl9pbHMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RvcElEID0gTk87XG4gICAgICAgIHRoaXMuX2RsID0gTk87XG4gICAgICAgIHRoaXMuX2QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gTk87XG4gICAgICAgIHRoaXMuX2VyciA9IE5PO1xuICAgIH1cbiAgICBTdHJlYW0ucHJvdG90eXBlLl9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9pbHM7XG4gICAgICAgIHZhciBMID0gYS5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9kKVxuICAgICAgICAgICAgdGhpcy5fZGwuX24odCk7XG4gICAgICAgIGlmIChMID09IDEpXG4gICAgICAgICAgICBhWzBdLl9uKHQpO1xuICAgICAgICBlbHNlIGlmIChMID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGIgPSBjcChhKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTDsgaSsrKVxuICAgICAgICAgICAgICAgIGJbaV0uX24odCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnIgIT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lcnIgPSBlcnI7XG4gICAgICAgIHZhciBhID0gdGhpcy5faWxzO1xuICAgICAgICB2YXIgTCA9IGEubGVuZ3RoO1xuICAgICAgICB0aGlzLl94KCk7XG4gICAgICAgIGlmICh0aGlzLl9kKVxuICAgICAgICAgICAgdGhpcy5fZGwuX2UoZXJyKTtcbiAgICAgICAgaWYgKEwgPT0gMSlcbiAgICAgICAgICAgIGFbMF0uX2UoZXJyKTtcbiAgICAgICAgZWxzZSBpZiAoTCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiID0gY3AoYSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgICAgICBiW2ldLl9lKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kICYmIEwgPT0gMClcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2VycjtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5faWxzO1xuICAgICAgICB2YXIgTCA9IGEubGVuZ3RoO1xuICAgICAgICB0aGlzLl94KCk7XG4gICAgICAgIGlmICh0aGlzLl9kKVxuICAgICAgICAgICAgdGhpcy5fZGwuX2MoKTtcbiAgICAgICAgaWYgKEwgPT0gMSlcbiAgICAgICAgICAgIGFbMF0uX2MoKTtcbiAgICAgICAgZWxzZSBpZiAoTCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiID0gY3AoYSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKylcbiAgICAgICAgICAgICAgICBiW2ldLl9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fcHJvZCAhPT0gTk8pXG4gICAgICAgICAgICB0aGlzLl9wcm9kLl9zdG9wKCk7XG4gICAgICAgIHRoaXMuX2VyciA9IE5PO1xuICAgICAgICB0aGlzLl9pbHMgPSBbXTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuX3N0b3BOb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdBUk5JTkc6IGNvZGUgdGhhdCBjYWxscyB0aGlzIG1ldGhvZCBzaG91bGRcbiAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgdGhpcy5fcHJvZCBpcyB2YWxpZCAobm90IGBOT2ApXG4gICAgICAgIHRoaXMuX3Byb2QuX3N0b3AoKTtcbiAgICAgICAgdGhpcy5fZXJyID0gTk87XG4gICAgICAgIHRoaXMuX3N0b3BJRCA9IE5PO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24gKGlsKSB7XG4gICAgICAgIHZhciB0YSA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgaWYgKHRhICE9PSBOTylcbiAgICAgICAgICAgIHJldHVybiB0YS5fYWRkKGlsKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9pbHM7XG4gICAgICAgIGEucHVzaChpbCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9zdG9wSUQgIT09IE5PKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcElEKTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BJRCA9IE5PO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9kO1xuICAgICAgICAgICAgaWYgKHAgIT09IE5PKVxuICAgICAgICAgICAgICAgIHAuX3N0YXJ0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAoaWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRhID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgICBpZiAodGEgIT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuIHRhLl9yZW1vdmUoaWwpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuX2lscztcbiAgICAgICAgdmFyIGkgPSBhLmluZGV4T2YoaWwpO1xuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9kICE9PSBOTyAmJiBhLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyID0gTk87XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc3RvcE5vdygpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJ1bmVDeWNsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgYWxsIHBhdGhzIHN0ZW1taW5nIGZyb20gYHRoaXNgIHN0cmVhbSBldmVudHVhbGx5IGVuZCBhdCBgdGhpc2BcbiAgICAvLyBzdHJlYW0sIHRoZW4gd2UgcmVtb3ZlIHRoZSBzaW5nbGUgbGlzdGVuZXIgb2YgYHRoaXNgIHN0cmVhbSwgdG9cbiAgICAvLyBmb3JjZSBpdCB0byBlbmQgaXRzIGV4ZWN1dGlvbiBhbmQgZGlzcG9zZSByZXNvdXJjZXMuIFRoaXMgbWV0aG9kXG4gICAgLy8gYXNzdW1lcyBhcyBhIHByZWNvbmRpdGlvbiB0aGF0IHRoaXMuX2lscyBoYXMganVzdCBvbmUgbGlzdGVuZXIuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5fcHJ1bmVDeWNsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNOb1NpbmtzKHRoaXMsIFtdKSlcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZSh0aGlzLl9pbHNbMF0pO1xuICAgIH07XG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgKnRoZXJlIGlzIG5vKiBwYXRoIHN0YXJ0aW5nIGZyb20gYHhgIHRoYXQgbGVhZHMgdG8gYW4gZW5kXG4gICAgLy8gbGlzdGVuZXIgKHNpbmspIGluIHRoZSBzdHJlYW0gZ3JhcGgsIGZvbGxvd2luZyBlZGdlcyBBLT5CIHdoZXJlIEIgaXMgYVxuICAgIC8vIGxpc3RlbmVyIG9mIEEuIFRoaXMgbWVhbnMgdGhlc2UgcGF0aHMgY29uc3RpdHV0ZSBhIGN5Y2xlIHNvbWVob3cuIElzIGdpdmVuXG4gICAgLy8gYSB0cmFjZSBvZiBhbGwgdmlzaXRlZCBub2RlcyBzbyBmYXIuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5faGFzTm9TaW5rcyA9IGZ1bmN0aW9uICh4LCB0cmFjZSkge1xuICAgICAgICBpZiAodHJhY2UuaW5kZXhPZih4KSAhPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoeC5vdXQgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoeC5vdXQgJiYgeC5vdXQgIT09IE5PKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc05vU2lua3MoeC5vdXQsIHRyYWNlLmNvbmNhdCh4KSk7XG4gICAgICAgIGVsc2UgaWYgKHguX2lscykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIE4gPSB4Ll9pbHMubGVuZ3RoOyBpIDwgTjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzTm9TaW5rcyh4Ll9pbHNbaV0sIHRyYWNlLmNvbmNhdCh4KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBNZW1vcnlTdHJlYW0gPyBNZW1vcnlTdHJlYW0gOiBTdHJlYW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgTGlzdGVuZXIgdG8gdGhlIFN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGlzdGVuZXJ9IGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lci5fbiA9IGxpc3RlbmVyLm5leHQgfHwgbm9vcDtcbiAgICAgICAgbGlzdGVuZXIuX2UgPSBsaXN0ZW5lci5lcnJvciB8fCBub29wO1xuICAgICAgICBsaXN0ZW5lci5fYyA9IGxpc3RlbmVyLmNvbXBsZXRlIHx8IG5vb3A7XG4gICAgICAgIHRoaXMuX2FkZChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgTGlzdGVuZXIgZnJvbSB0aGUgU3RyZWFtLCBhc3N1bWluZyB0aGUgTGlzdGVuZXIgd2FzIGFkZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMaXN0ZW5lcjxUPn0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgTGlzdGVuZXIgdG8gdGhlIFN0cmVhbSByZXR1cm5pbmcgYSBTdWJzY3JpcHRpb24gdG8gcmVtb3ZlIHRoYXRcbiAgICAgKiBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGlzdGVuZXJ9IGxpc3RlbmVyXG4gICAgICogQHJldHVybnMge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1TdWIodGhpcywgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGludGVyb3AgYmV0d2VlbiBtb3N0LmpzIGFuZCBSeEpTIDVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZVtzeW1ib2xfb2JzZXJ2YWJsZV8xLmRlZmF1bHRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RyZWFtIGdpdmVuIGEgUHJvZHVjZXIuXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtQcm9kdWNlcn0gcHJvZHVjZXIgQW4gb3B0aW9uYWwgUHJvZHVjZXIgdGhhdCBkaWN0YXRlcyBob3cgdG9cbiAgICAgKiBzdGFydCwgZ2VuZXJhdGUgZXZlbnRzLCBhbmQgc3RvcCB0aGUgU3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uY3JlYXRlID0gZnVuY3Rpb24gKHByb2R1Y2VyKSB7XG4gICAgICAgIGlmIChwcm9kdWNlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9kdWNlci5zdGFydCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgIHx8IHR5cGVvZiBwcm9kdWNlci5zdG9wICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZHVjZXIgcmVxdWlyZXMgYm90aCBzdGFydCBhbmQgc3RvcCBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIGludGVybmFsaXplUHJvZHVjZXIocHJvZHVjZXIpOyAvLyBtdXRhdGVzIHRoZSBpbnB1dFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKHByb2R1Y2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVtb3J5U3RyZWFtIGdpdmVuIGEgUHJvZHVjZXIuXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtQcm9kdWNlcn0gcHJvZHVjZXIgQW4gb3B0aW9uYWwgUHJvZHVjZXIgdGhhdCBkaWN0YXRlcyBob3cgdG9cbiAgICAgKiBzdGFydCwgZ2VuZXJhdGUgZXZlbnRzLCBhbmQgc3RvcCB0aGUgU3RyZWFtLlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uY3JlYXRlV2l0aE1lbW9yeSA9IGZ1bmN0aW9uIChwcm9kdWNlcikge1xuICAgICAgICBpZiAocHJvZHVjZXIpXG4gICAgICAgICAgICBpbnRlcm5hbGl6ZVByb2R1Y2VyKHByb2R1Y2VyKTsgLy8gbXV0YXRlcyB0aGUgaW5wdXRcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0ocHJvZHVjZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyB3aGVuIHN0YXJ0ZWQuIEl0IG5ldmVyIGVtaXRzIGFueSBldmVudC5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqICAgICAgICAgIG5ldmVyXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLm5ldmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbSh7IF9zdGFydDogbm9vcCwgX3N0b3A6IG5vb3AgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgZW1pdHMgdGhlIFwiY29tcGxldGVcIiBub3RpZmljYXRpb24gd2hlblxuICAgICAqIHN0YXJ0ZWQsIGFuZCB0aGF0J3MgaXQuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiBlbXB0eVxuICAgICAqIC18XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oe1xuICAgICAgICAgICAgX3N0YXJ0OiBmdW5jdGlvbiAoaWwpIHsgaWwuX2MoKTsgfSxcbiAgICAgICAgICAgIF9zdG9wOiBub29wLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTdHJlYW0gdGhhdCBpbW1lZGlhdGVseSBlbWl0cyBhbiBcImVycm9yXCIgbm90aWZpY2F0aW9uIHdpdGggdGhlXG4gICAgICogdmFsdWUgeW91IHBhc3NlZCBhcyB0aGUgYGVycm9yYCBhcmd1bWVudCB3aGVuIHRoZSBzdHJlYW0gc3RhcnRzLCBhbmQgdGhhdCdzXG4gICAgICogaXQuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiB0aHJvdyhYKVxuICAgICAqIC1YXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIGVycm9yIFRoZSBlcnJvciBldmVudCB0byBlbWl0IG9uIHRoZSBjcmVhdGVkIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKHtcbiAgICAgICAgICAgIF9zdGFydDogZnVuY3Rpb24gKGlsKSB7IGlsLl9lKGVycm9yKTsgfSxcbiAgICAgICAgICAgIF9zdG9wOiBub29wLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdHJlYW0gZnJvbSBhbiBBcnJheSwgUHJvbWlzZSwgb3IgYW4gT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fFByb21pc2V8T2JzZXJ2YWJsZX0gaW5wdXQgVGhlIGlucHV0IHRvIG1ha2UgYSBzdHJlYW0gZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLmZyb20gPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dFtzeW1ib2xfb2JzZXJ2YWJsZV8xLmRlZmF1bHRdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tT2JzZXJ2YWJsZShpbnB1dCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tUHJvbWlzZShpbnB1dCk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tQXJyYXkoaW5wdXQpO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZSBvZiBpbnB1dCB0byBmcm9tKCkgbXVzdCBiZSBhbiBBcnJheSwgUHJvbWlzZSwgb3IgT2JzZXJ2YWJsZVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTdHJlYW0gdGhhdCBpbW1lZGlhdGVseSBlbWl0cyB0aGUgYXJndW1lbnRzIHRoYXQgeW91IGdpdmUgdG9cbiAgICAgKiAqb2YqLCB0aGVuIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIG9mKDEsMiwzKVxuICAgICAqIDEyM3xcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgeW91IHdhbnQgdG8gZW1pdCBhcyBhbiBldmVudCBvbiB0aGUgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgeW91IHdhbnQgdG8gZW1pdCBhcyBhbiBldmVudCBvbiB0aGUgc3RyZWFtLiBPbmVcbiAgICAgKiBvciBtb3JlIG9mIHRoZXNlIHZhbHVlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyZWFtLmZyb21BcnJheShpdGVtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBhcnJheSB0byBhIHN0cmVhbS4gVGhlIHJldHVybmVkIHN0cmVhbSB3aWxsIGVtaXQgc3luY2hyb25vdXNseVxuICAgICAqIGFsbCB0aGUgaXRlbXMgaW4gdGhlIGFycmF5LCBhbmQgdGhlbiBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIGZyb21BcnJheShbMSwyLDNdKVxuICAgICAqIDEyM3xcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgY29udmVydGVkIGFzIGEgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0uZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBGcm9tQXJyYXkoYXJyYXkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcHJvbWlzZSB0byBhIHN0cmVhbS4gVGhlIHJldHVybmVkIHN0cmVhbSB3aWxsIGVtaXQgdGhlIHJlc29sdmVkXG4gICAgICogdmFsdWUgb2YgdGhlIHByb21pc2UsIGFuZCB0aGVuIGNvbXBsZXRlLiBIb3dldmVyLCBpZiB0aGUgcHJvbWlzZSBpc1xuICAgICAqIHJlamVjdGVkLCB0aGUgc3RyZWFtIHdpbGwgZW1pdCB0aGUgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIGZyb21Qcm9taXNlKCAtLS0tNDIgKVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tNDJ8XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIFRoZSBwcm9taXNlIHRvIGJlIGNvbnZlcnRlZCBhcyBhIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IEZyb21Qcm9taXNlKHByb21pc2UpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIE9ic2VydmFibGUgaW50byBhIFN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBmYWN0b3J5IHRydWVcbiAgICAgKiBAcGFyYW0ge2FueX0gb2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSB0byBiZSBjb252ZXJ0ZWQgYXMgYSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5mcm9tT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYnMpIHtcbiAgICAgICAgaWYgKG9icy5lbmRXaGVuKVxuICAgICAgICAgICAgcmV0dXJuIG9icztcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IEZyb21PYnNlcnZhYmxlKG9icykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmVhbSB0aGF0IHBlcmlvZGljYWxseSBlbWl0cyBpbmNyZW1lbnRhbCBudW1iZXJzLCBldmVyeVxuICAgICAqIGBwZXJpb2RgIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqICAgICBwZXJpb2RpYygxMDAwKVxuICAgICAqIC0tLTAtLS0xLS0tMi0tLTMtLS00LS0tLi4uXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZmFjdG9yeSB0cnVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZCBUaGUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIHVzZSBhcyBhIHJhdGUgb2ZcbiAgICAgKiBlbWlzc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnBlcmlvZGljID0gZnVuY3Rpb24gKHBlcmlvZCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgUGVyaW9kaWMocGVyaW9kKSk7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLl9tYXAgPSBmdW5jdGlvbiAocHJvamVjdCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuX3Byb2Q7XG4gICAgICAgIHZhciBjdG9yID0gdGhpcy5jdG9yKCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgRmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKG5ldyBGaWx0ZXJNYXBGdXNpb24ocC5mLCBwcm9qZWN0LCBwLmlucykpO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IobmV3IE1hcE9wKHByb2plY3QsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZWFjaCBldmVudCBmcm9tIHRoZSBpbnB1dCBTdHJlYW0gdGhyb3VnaCBhIGBwcm9qZWN0YCBmdW5jdGlvbixcbiAgICAgKiB0byBnZXQgYSBTdHJlYW0gdGhhdCBlbWl0cyB0aG9zZSB0cmFuc2Zvcm1lZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0zLS01LS0tLS03LS0tLS0tXG4gICAgICogICAgbWFwKGkgPT4gaSAqIDEwKVxuICAgICAqIC0tMTAtLTMwLTUwLS0tLTcwLS0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2plY3QgQSBmdW5jdGlvbiBvZiB0eXBlIGAodDogVCkgPT4gVWAgdGhhdCB0YWtlcyBldmVudFxuICAgICAqIGB0YCBvZiB0eXBlIGBUYCBmcm9tIHRoZSBpbnB1dCBTdHJlYW0gYW5kIHByb2R1Y2VzIGFuIGV2ZW50IG9mIHR5cGUgYFVgLCB0b1xuICAgICAqIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBTdHJlYW0uXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcChwcm9qZWN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0J3MgbGlrZSBgbWFwYCwgYnV0IHRyYW5zZm9ybXMgZWFjaCBpbnB1dCBldmVudCB0byBhbHdheXMgdGhlIHNhbWVcbiAgICAgKiBjb25zdGFudCB2YWx1ZSBvbiB0aGUgb3V0cHV0IFN0cmVhbS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tMS0tLTMtLTUtLS0tLTctLS0tLVxuICAgICAqICAgICAgIG1hcFRvKDEwKVxuICAgICAqIC0tMTAtLTEwLTEwLS0tLTEwLS0tLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHByb2plY3RlZFZhbHVlIEEgdmFsdWUgdG8gZW1pdCBvbiB0aGUgb3V0cHV0IFN0cmVhbSB3aGVuZXZlciB0aGVcbiAgICAgKiBpbnB1dCBTdHJlYW0gZW1pdHMgYW55IHZhbHVlLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLm1hcFRvID0gZnVuY3Rpb24gKHByb2plY3RlZFZhbHVlKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvamVjdGVkVmFsdWU7IH0pO1xuICAgICAgICB2YXIgb3AgPSBzLl9wcm9kO1xuICAgICAgICBvcC50eXBlID0gb3AudHlwZS5yZXBsYWNlKCdtYXAnLCAnbWFwVG8nKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmx5IGFsbG93cyBldmVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGdpdmVuIGJ5IHRoZSBgcGFzc2VzYCBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEVhY2ggZXZlbnQgZnJvbSB0aGUgaW5wdXQgc3RyZWFtIGlzIGdpdmVuIHRvIHRoZSBgcGFzc2VzYCBmdW5jdGlvbi4gSWYgdGhlXG4gICAgICogZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAsIHRoZSBldmVudCBpcyBmb3J3YXJkZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0sXG4gICAgICogb3RoZXJ3aXNlIGl0IGlzIGlnbm9yZWQgYW5kIG5vdCBmb3J3YXJkZWQuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0yLS0zLS0tLS00LS0tLS01LS0tNi0tNy04LS1cbiAgICAgKiAgICAgZmlsdGVyKGkgPT4gaSAlIDIgPT09IDApXG4gICAgICogLS0tLS0tMi0tLS0tLS0tNC0tLS0tLS0tLTYtLS0tOC0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXNzZXMgQSBmdW5jdGlvbiBvZiB0eXBlIGAodDogVCkgKz4gYm9vbGVhbmAgdGhhdCB0YWtlc1xuICAgICAqIGFuIGV2ZW50IGZyb20gdGhlIGlucHV0IHN0cmVhbSBhbmQgY2hlY2tzIGlmIGl0IHBhc3NlcywgYnkgcmV0dXJuaW5nIGFcbiAgICAgKiBib29sZWFuLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChwYXNzZXMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9kO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZWFtKG5ldyBGaWx0ZXIoYW5kKHAuZiwgcGFzc2VzKSwgcC5pbnMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IEZpbHRlcihwYXNzZXMsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExldHMgdGhlIGZpcnN0IGBhbW91bnRgIG1hbnkgZXZlbnRzIGZyb20gdGhlIGlucHV0IHN0cmVhbSBwYXNzIHRvIHRoZVxuICAgICAqIG91dHB1dCBzdHJlYW0sIHRoZW4gbWFrZXMgdGhlIG91dHB1dCBzdHJlYW0gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLWEtLS1iLS1jLS0tLWQtLS1lLS1cbiAgICAgKiAgICB0YWtlKDMpXG4gICAgICogLS1hLS0tYi0tY3xcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgSG93IG1hbnkgZXZlbnRzIHRvIGFsbG93IGZyb20gdGhlIGlucHV0IHN0cmVhbVxuICAgICAqIGJlZm9yZSBjb21wbGV0aW5nIHRoZSBvdXRwdXQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3RvcigpKShuZXcgVGFrZShhbW91bnQsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElnbm9yZXMgdGhlIGZpcnN0IGBhbW91bnRgIG1hbnkgZXZlbnRzIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgYW5kIHRoZW5cbiAgICAgKiBhZnRlciB0aGF0IHN0YXJ0cyBmb3J3YXJkaW5nIGV2ZW50cyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gdG8gdGhlIG91dHB1dFxuICAgICAqIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tYS0tLWItLWMtLS0tZC0tLWUtLVxuICAgICAqICAgICAgIGRyb3AoMylcbiAgICAgKiAtLS0tLS0tLS0tLS0tLWQtLS1lLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgSG93IG1hbnkgZXZlbnRzIHRvIGlnbm9yZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW1cbiAgICAgKiBiZWZvcmUgZm9yd2FyZGluZyBhbGwgZXZlbnRzIGZyb20gdGhlIGlucHV0IHN0cmVhbSB0byB0aGUgb3V0cHV0IHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgRHJvcChhbW91bnQsIHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGlucHV0IHN0cmVhbSBjb21wbGV0ZXMsIHRoZSBvdXRwdXQgc3RyZWFtIHdpbGwgZW1pdCB0aGUgbGFzdCBldmVudFxuICAgICAqIGVtaXR0ZWQgYnkgdGhlIGlucHV0IHN0cmVhbSwgYW5kIHRoZW4gd2lsbCBhbHNvIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS1hLS0tYi0tYy0tZC0tLS18XG4gICAgICogICAgICAgbGFzdCgpXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS1kfFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0obmV3IExhc3QodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJlcGVuZHMgdGhlIGdpdmVuIGBpbml0aWFsYCB2YWx1ZSB0byB0aGUgc2VxdWVuY2Ugb2YgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlXG4gICAgICogaW5wdXQgc3RyZWFtLiBUaGUgcmV0dXJuZWQgc3RyZWFtIGlzIGEgTWVtb3J5U3RyZWFtLCB3aGljaCBtZWFucyBpdCBpc1xuICAgICAqIGFscmVhZHkgYHJlbWVtYmVyKClgJ2QuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLS0xLS0tMi0tLS0tMy0tLVxuICAgICAqICAgc3RhcnRXaXRoKDApXG4gICAgICogMC0tMS0tLTItLS0tLTMtLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbml0aWFsIFRoZSB2YWx1ZSBvciBldmVudCB0byBwcmVwZW5kLlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uIChpbml0aWFsKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtKG5ldyBTdGFydFdpdGgodGhpcywgaW5pdGlhbCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlcyBhbm90aGVyIHN0cmVhbSB0byBkZXRlcm1pbmUgd2hlbiB0byBjb21wbGV0ZSB0aGUgY3VycmVudCBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBnaXZlbiBgb3RoZXJgIHN0cmVhbSBlbWl0cyBhbiBldmVudCBvciBjb21wbGV0ZXMsIHRoZSBvdXRwdXRcbiAgICAgKiBzdHJlYW0gd2lsbCBjb21wbGV0ZS4gQmVmb3JlIHRoYXQgaGFwcGVucywgdGhlIG91dHB1dCBzdHJlYW0gd2lsbCBiZWhhdmVzXG4gICAgICogbGlrZSB0aGUgaW5wdXQgc3RyZWFtLlxuICAgICAqXG4gICAgICogTWFyYmxlIGRpYWdyYW06XG4gICAgICpcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogLS0tMS0tLTItLS0tLTMtLTQtLS0tNS0tLS02LS0tXG4gICAgICogICBlbmRXaGVuKCAtLS0tLS0tLWEtLWItLXwgKVxuICAgICAqIC0tLTEtLS0yLS0tLS0zLS00LS18XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgU29tZSBvdGhlciBzdHJlYW0gdGhhdCBpcyB1c2VkIHRvIGtub3cgd2hlbiBzaG91bGQgdGhlIG91dHB1dFxuICAgICAqIHN0cmVhbSBvZiB0aGlzIG9wZXJhdG9yIGNvbXBsZXRlLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmVuZFdoZW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jdG9yKCkpKG5ldyBFbmRXaGVuKG90aGVyLCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcIkZvbGRzXCIgdGhlIHN0cmVhbSBvbnRvIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIENvbWJpbmVzIGV2ZW50cyBmcm9tIHRoZSBwYXN0IHRocm91Z2hvdXRcbiAgICAgKiB0aGUgZW50aXJlIGV4ZWN1dGlvbiBvZiB0aGUgaW5wdXQgc3RyZWFtLCBhbGxvd2luZyB5b3UgdG8gYWNjdW11bGF0ZSB0aGVtXG4gICAgICogdG9nZXRoZXIuIEl0J3MgZXNzZW50aWFsbHkgbGlrZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAuIFRoZSByZXR1cm5lZFxuICAgICAqIHN0cmVhbSBpcyBhIE1lbW9yeVN0cmVhbSwgd2hpY2ggbWVhbnMgaXQgaXMgYWxyZWFkeSBgcmVtZW1iZXIoKWAnZC5cbiAgICAgKlxuICAgICAqIFRoZSBvdXRwdXQgc3RyZWFtIHN0YXJ0cyBieSBlbWl0dGluZyB0aGUgYHNlZWRgIHdoaWNoIHlvdSBnaXZlIGFzIGFyZ3VtZW50LlxuICAgICAqIFRoZW4sIHdoZW4gYW4gZXZlbnQgaGFwcGVucyBvbiB0aGUgaW5wdXQgc3RyZWFtLCBpdCBpcyBjb21iaW5lZCB3aXRoIHRoYXRcbiAgICAgKiBzZWVkIHZhbHVlIHRocm91Z2ggdGhlIGBhY2N1bXVsYXRlYCBmdW5jdGlvbiwgYW5kIHRoZSBvdXRwdXQgdmFsdWUgaXNcbiAgICAgKiBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgc3RyZWFtLiBgZm9sZGAgcmVtZW1iZXJzIHRoYXQgb3V0cHV0IHZhbHVlIGFzIGBhY2NgXG4gICAgICogKFwiYWNjdW11bGF0b3JcIiksIGFuZCB0aGVuIHdoZW4gYSBuZXcgaW5wdXQgZXZlbnQgYHRgIGhhcHBlbnMsIGBhY2NgIHdpbGwgYmVcbiAgICAgKiBjb21iaW5lZCB3aXRoIHRoYXQgdG8gcHJvZHVjZSB0aGUgbmV3IGBhY2NgIGFuZCBzbyBmb3J0aC5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tLS0tLTEtLS0tLTEtLTItLS0tMS0tLS0xLS0tLS0tXG4gICAgICogICBmb2xkKChhY2MsIHgpID0+IGFjYyArIHgsIDMpXG4gICAgICogMy0tLS0tNC0tLS0tNS0tNy0tLS04LS0tLTktLS0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdGUgQSBmdW5jdGlvbiBvZiB0eXBlIGAoYWNjOiBSLCB0OiBUKSA9PiBSYCB0aGF0XG4gICAgICogdGFrZXMgdGhlIHByZXZpb3VzIGFjY3VtdWxhdGVkIHZhbHVlIGBhY2NgIGFuZCB0aGUgaW5jb21pbmcgZXZlbnQgZnJvbSB0aGVcbiAgICAgKiBpbnB1dCBzdHJlYW0gYW5kIHByb2R1Y2VzIHRoZSBuZXcgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIGluaXRpYWwgYWNjdW11bGF0ZWQgdmFsdWUsIG9mIHR5cGUgYFJgLlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiAoYWNjdW11bGF0ZSwgc2VlZCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVN0cmVhbShuZXcgRm9sZChhY2N1bXVsYXRlLCBzZWVkLCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbiBlcnJvciB3aXRoIGFub3RoZXIgc3RyZWFtLlxuICAgICAqXG4gICAgICogV2hlbiAoYW5kIGlmKSBhbiBlcnJvciBoYXBwZW5zIG9uIHRoZSBpbnB1dCBzdHJlYW0sIGluc3RlYWQgb2YgZm9yd2FyZGluZ1xuICAgICAqIHRoYXQgZXJyb3IgdG8gdGhlIG91dHB1dCBzdHJlYW0sICpyZXBsYWNlRXJyb3IqIHdpbGwgY2FsbCB0aGUgYHJlcGxhY2VgXG4gICAgICogZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgc3RyZWFtIHRoYXQgdGhlIG91dHB1dCBzdHJlYW0gd2lsbCByZXBsaWNhdGUuXG4gICAgICogQW5kLCBpbiBjYXNlIHRoYXQgbmV3IHN0cmVhbSBhbHNvIGVtaXRzIGFuIGVycm9yLCBgcmVwbGFjZWAgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhZ2FpbiB0byBnZXQgYW5vdGhlciBzdHJlYW0gdG8gc3RhcnQgcmVwbGljYXRpbmcuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLTEtLS0yLS0tLS0zLS00LS0tLS1YXG4gICAgICogICByZXBsYWNlRXJyb3IoICgpID0+IC0tMTAtLXwgKVxuICAgICAqIC0tMS0tLTItLS0tLTMtLTQtLS0tLS0tLTEwLS18XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXBsYWNlIEEgZnVuY3Rpb24gb2YgdHlwZSBgKGVycikgPT4gU3RyZWFtYCB0aGF0IHRha2VzXG4gICAgICogdGhlIGVycm9yIHRoYXQgb2NjdXJyZWQgb24gdGhlIGlucHV0IHN0cmVhbSBvciBvbiB0aGUgcHJldmlvdXMgcmVwbGFjZW1lbnRcbiAgICAgKiBzdHJlYW0gYW5kIHJldHVybnMgYSBuZXcgc3RyZWFtLiBUaGUgb3V0cHV0IHN0cmVhbSB3aWxsIGJlaGF2ZSBsaWtlIHRoZVxuICAgICAqIHN0cmVhbSB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5yZXBsYWNlRXJyb3IgPSBmdW5jdGlvbiAocmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmN0b3IoKSkobmV3IFJlcGxhY2VFcnJvcihyZXBsYWNlLCB0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIFwic3RyZWFtIG9mIHN0cmVhbXNcIiwgaGFuZGxpbmcgb25seSBvbmUgbmVzdGVkIHN0cmVhbSBhdCBhIHRpbWVcbiAgICAgKiAobm8gY29uY3VycmVuY3kpLlxuICAgICAqXG4gICAgICogSWYgdGhlIGlucHV0IHN0cmVhbSBpcyBhIHN0cmVhbSB0aGF0IGVtaXRzIHN0cmVhbXMsIHRoZW4gdGhpcyBvcGVyYXRvciB3aWxsXG4gICAgICogcmV0dXJuIGFuIG91dHB1dCBzdHJlYW0gd2hpY2ggaXMgYSBmbGF0IHN0cmVhbTogZW1pdHMgcmVndWxhciBldmVudHMuIFRoZVxuICAgICAqIGZsYXR0ZW5pbmcgaGFwcGVucyB3aXRob3V0IGNvbmN1cnJlbmN5LiBJdCB3b3JrcyBsaWtlIHRoaXM6IHdoZW4gdGhlIGlucHV0XG4gICAgICogc3RyZWFtIGVtaXRzIGEgbmVzdGVkIHN0cmVhbSwgKmZsYXR0ZW4qIHdpbGwgc3RhcnQgaW1pdGF0aW5nIHRoYXQgbmVzdGVkXG4gICAgICogb25lLiBIb3dldmVyLCBhcyBzb29uIGFzIHRoZSBuZXh0IG5lc3RlZCBzdHJlYW0gaXMgZW1pdHRlZCBvbiB0aGUgaW5wdXRcbiAgICAgKiBzdHJlYW0sICpmbGF0dGVuKiB3aWxsIGZvcmdldCB0aGUgcHJldmlvdXMgbmVzdGVkIG9uZSBpdCB3YXMgaW1pdGF0aW5nLCBhbmRcbiAgICAgKiB3aWxsIHN0YXJ0IGltaXRhdGluZyB0aGUgbmV3IG5lc3RlZCBvbmUuXG4gICAgICpcbiAgICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICAgKlxuICAgICAqIGBgYHRleHRcbiAgICAgKiAtLSstLS0tLS0tLSstLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgIFxcICAgICAgICBcXFxuICAgICAqICAgIFxcICAgICAgIC0tLS0xLS0tLTItLS0zLS1cbiAgICAgKiAgICAtLWEtLWItLS0tYy0tLS1kLS0tLS0tLS1cbiAgICAgKiAgICAgICAgICAgZmxhdHRlblxuICAgICAqIC0tLS0tYS0tYi0tLS0tLTEtLS0tMi0tLTMtLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyZWFtfVxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9kO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShwIGluc3RhbmNlb2YgTWFwT3AgJiYgIShwIGluc3RhbmNlb2YgRmlsdGVyTWFwRnVzaW9uKSA/XG4gICAgICAgICAgICBuZXcgTWFwRmxhdHRlbihwKSA6XG4gICAgICAgICAgICBuZXcgRmxhdHRlbih0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXNzZXMgdGhlIGlucHV0IHN0cmVhbSB0byBhIGN1c3RvbSBvcGVyYXRvciwgdG8gcHJvZHVjZSBhbiBvdXRwdXQgc3RyZWFtLlxuICAgICAqXG4gICAgICogKmNvbXBvc2UqIGlzIGEgaGFuZHkgd2F5IG9mIHVzaW5nIGFuIGV4aXN0aW5nIGZ1bmN0aW9uIGluIGEgY2hhaW5lZCBzdHlsZS5cbiAgICAgKiBJbnN0ZWFkIG9mIHdyaXRpbmcgYG91dFN0cmVhbSA9IGYoaW5TdHJlYW0pYCB5b3UgY2FuIHdyaXRlXG4gICAgICogYG91dFN0cmVhbSA9IGluU3RyZWFtLmNvbXBvc2UoZilgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3BlcmF0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyZWFtIGFzIGlucHV0IGFuZFxuICAgICAqIHJldHVybnMgYSBzdHJlYW0gYXMgd2VsbC5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5jb21wb3NlID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb3V0cHV0IHN0cmVhbSB0aGF0IGJlaGF2ZXMgbGlrZSB0aGUgaW5wdXQgc3RyZWFtLCBidXQgYWxzb1xuICAgICAqIHJlbWVtYmVycyB0aGUgbW9zdCByZWNlbnQgZXZlbnQgdGhhdCBoYXBwZW5zIG9uIHRoZSBpbnB1dCBzdHJlYW0sIHNvIHRoYXQgYVxuICAgICAqIG5ld2x5IGFkZGVkIGxpc3RlbmVyIHdpbGwgaW1tZWRpYXRlbHkgcmVjZWl2ZSB0aGF0IG1lbW9yaXNlZCBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01lbW9yeVN0cmVhbX1cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnJlbWVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVN0cmVhbShuZXcgUmVtZW1iZXIodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvdXRwdXQgc3RyZWFtIHRoYXQgaWRlbnRpY2FsbHkgYmVoYXZlcyBsaWtlIHRoZSBpbnB1dCBzdHJlYW0sXG4gICAgICogYnV0IGFsc28gcnVucyBhIGBzcHlgIGZ1bmN0aW9uIGZvIGVhY2ggZXZlbnQsIHRvIGhlbHAgeW91IGRlYnVnIHlvdXIgYXBwLlxuICAgICAqXG4gICAgICogKmRlYnVnKiB0YWtlcyBhIGBzcHlgIGZ1bmN0aW9uIGFzIGFyZ3VtZW50LCBhbmQgcnVucyB0aGF0IGZvciBlYWNoIGV2ZW50XG4gICAgICogaGFwcGVuaW5nIG9uIHRoZSBpbnB1dCBzdHJlYW0uIElmIHlvdSBkb24ndCBwcm92aWRlIHRoZSBgc3B5YCBhcmd1bWVudCxcbiAgICAgKiB0aGVuICpkZWJ1Zyogd2lsbCBqdXN0IGBjb25zb2xlLmxvZ2AgZWFjaCBldmVudC4gVGhpcyBoZWxwcyB5b3UgdG9cbiAgICAgKiB1bmRlcnN0YW5kIHRoZSBmbG93IG9mIGV2ZW50cyB0aHJvdWdoIHNvbWUgb3BlcmF0b3IgY2hhaW4uXG4gICAgICpcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGlmIHRoZSBvdXRwdXQgc3RyZWFtIGhhcyBubyBsaXN0ZW5lcnMsIHRoZW4gaXQgd2lsbCBub3RcbiAgICAgKiBzdGFydCwgd2hpY2ggbWVhbnMgYHNweWAgd2lsbCBuZXZlciBydW4gYmVjYXVzZSBubyBhY3R1YWwgZXZlbnQgaGFwcGVucyBpblxuICAgICAqIHRoYXQgY2FzZS5cbiAgICAgKlxuICAgICAqIE1hcmJsZSBkaWFncmFtOlxuICAgICAqXG4gICAgICogYGBgdGV4dFxuICAgICAqIC0tMS0tLS0yLS0tLS0zLS0tLS00LS1cbiAgICAgKiAgICAgICAgIGRlYnVnXG4gICAgICogLS0xLS0tLTItLS0tLTMtLS0tLTQtLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGFiZWxPclNweSBBIHN0cmluZyB0byB1c2UgYXMgdGhlIGxhYmVsIHdoZW4gcHJpbnRpbmdcbiAgICAgKiBkZWJ1ZyBpbmZvcm1hdGlvbiBvbiB0aGUgY29uc29sZSwgb3IgYSAnc3B5JyBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGV2ZW50XG4gICAgICogYXMgYXJndW1lbnQsIGFuZCBkb2VzIG5vdCBuZWVkIHRvIHJldHVybiBhbnl0aGluZy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChsYWJlbE9yU3B5KSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3RvcigpKShuZXcgRGVidWcodGhpcywgbGFiZWxPclNweSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogKmltaXRhdGUqIGNoYW5nZXMgdGhpcyBjdXJyZW50IFN0cmVhbSB0byBlbWl0IHRoZSBzYW1lIGV2ZW50cyB0aGF0IHRoZVxuICAgICAqIGBvdGhlcmAgZ2l2ZW4gU3RyZWFtIGRvZXMuIFRoaXMgbWV0aG9kIHJldHVybnMgbm90aGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyB0byBhbGxvdyBvbmUgdGhpbmc6ICoqY2lyY3VsYXIgZGVwZW5kZW5jeSBvZiBzdHJlYW1zKiouXG4gICAgICogRm9yIGluc3RhbmNlLCBsZXQncyBpbWFnaW5lIHRoYXQgZm9yIHNvbWUgcmVhc29uIHlvdSBuZWVkIHRvIGNyZWF0ZSBhXG4gICAgICogY2lyY3VsYXIgZGVwZW5kZW5jeSB3aGVyZSBzdHJlYW0gYGZpcnN0JGAgZGVwZW5kcyBvbiBzdHJlYW0gYHNlY29uZCRgXG4gICAgICogd2hpY2ggaW4gdHVybiBkZXBlbmRzIG9uIGBmaXJzdCRgOlxuICAgICAqXG4gICAgICogPCEtLSBza2lwLWV4YW1wbGUgLS0+XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgZGVsYXkgZnJvbSAneHN0cmVhbS9leHRyYS9kZWxheSdcbiAgICAgKlxuICAgICAqIHZhciBmaXJzdCQgPSBzZWNvbmQkLm1hcCh4ID0+IHggKiAxMCkudGFrZSgzKTtcbiAgICAgKiB2YXIgc2Vjb25kJCA9IGZpcnN0JC5tYXAoeCA9PiB4ICsgMSkuc3RhcnRXaXRoKDEpLmNvbXBvc2UoZGVsYXkoMTAwKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCB0aGF0IGlzIGludmFsaWQgSmF2YVNjcmlwdCwgYmVjYXVzZSBgc2Vjb25kJGAgaXMgdW5kZWZpbmVkXG4gICAgICogb24gdGhlIGZpcnN0IGxpbmUuIFRoaXMgaXMgaG93ICppbWl0YXRlKiBjYW4gaGVscCBzb2x2ZSBpdDpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IGRlbGF5IGZyb20gJ3hzdHJlYW0vZXh0cmEvZGVsYXknXG4gICAgICpcbiAgICAgKiB2YXIgc2Vjb25kUHJveHkkID0geHMuY3JlYXRlKCk7XG4gICAgICogdmFyIGZpcnN0JCA9IHNlY29uZFByb3h5JC5tYXAoeCA9PiB4ICogMTApLnRha2UoMyk7XG4gICAgICogdmFyIHNlY29uZCQgPSBmaXJzdCQubWFwKHggPT4geCArIDEpLnN0YXJ0V2l0aCgxKS5jb21wb3NlKGRlbGF5KDEwMCkpO1xuICAgICAqIHNlY29uZFByb3h5JC5pbWl0YXRlKHNlY29uZCQpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2UgY3JlYXRlIGBzZWNvbmRQcm94eSRgIGJlZm9yZSB0aGUgb3RoZXJzLCBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0aGVcbiAgICAgKiBkZWNsYXJhdGlvbiBvZiBgZmlyc3QkYC4gVGhlbiwgYWZ0ZXIgYm90aCBgZmlyc3QkYCBhbmQgYHNlY29uZCRgIGFyZVxuICAgICAqIGRlZmluZWQsIHdlIGhvb2sgYHNlY29uZFByb3h5JGAgd2l0aCBgc2Vjb25kJGAgd2l0aCBgaW1pdGF0ZSgpYCB0byB0ZWxsXG4gICAgICogdGhhdCB0aGV5IGFyZSBcInRoZSBzYW1lXCIuIGBpbWl0YXRlYCB3aWxsIG5vdCB0cmlnZ2VyIHRoZSBzdGFydCBvZiBhbnlcbiAgICAgKiBzdHJlYW0sIGl0IGp1c3QgYmluZHMgYHNlY29uZFByb3h5JGAgYW5kIGBzZWNvbmQkYCB0b2dldGhlci5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgYW4gZXhhbXBsZSB3aGVyZSBgaW1pdGF0ZSgpYCBpcyBpbXBvcnRhbnQgaW4gQ3ljbGUuanNcbiAgICAgKiBhcHBsaWNhdGlvbnMuIEEgcGFyZW50IGNvbXBvbmVudCBjb250YWlucyBzb21lIGNoaWxkIGNvbXBvbmVudHMuIEEgY2hpbGRcbiAgICAgKiBoYXMgYW4gYWN0aW9uIHN0cmVhbSB3aGljaCBpcyBnaXZlbiB0byB0aGUgcGFyZW50IHRvIGRlZmluZSBpdHMgc3RhdGU6XG4gICAgICpcbiAgICAgKiA8IS0tIHNraXAtZXhhbXBsZSAtLT5cbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGNoaWxkQWN0aW9uUHJveHkkID0geHMuY3JlYXRlKCk7XG4gICAgICogY29uc3QgcGFyZW50ID0gUGFyZW50KHsuLi5zb3VyY2VzLCBjaGlsZEFjdGlvbiQ6IGNoaWxkQWN0aW9uUHJveHkkfSk7XG4gICAgICogY29uc3QgY2hpbGRBY3Rpb24kID0gcGFyZW50LnN0YXRlJC5tYXAocyA9PiBzLmNoaWxkLmFjdGlvbiQpLmZsYXR0ZW4oKTtcbiAgICAgKiBjaGlsZEFjdGlvblByb3h5JC5pbWl0YXRlKGNoaWxkQWN0aW9uJCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aG91Z2gsIHRoYXQgKipgaW1pdGF0ZSgpYCBkb2VzIG5vdCBzdXBwb3J0IE1lbW9yeVN0cmVhbXMqKi4gSWYgd2VcbiAgICAgKiB3b3VsZCBhdHRlbXB0IHRvIGltaXRhdGUgYSBNZW1vcnlTdHJlYW0gaW4gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCB3ZSB3b3VsZFxuICAgICAqIGVpdGhlciBnZXQgYSByYWNlIGNvbmRpdGlvbiAod2hlcmUgdGhlIHN5bXB0b20gd291bGQgYmUgXCJub3RoaW5nIGhhcHBlbnNcIilcbiAgICAgKiBvciBhbiBpbmZpbml0ZSBjeWNsaWMgZW1pc3Npb24gb2YgdmFsdWVzLiBJdCdzIHVzZWZ1bCB0byB0aGluayBhYm91dFxuICAgICAqIE1lbW9yeVN0cmVhbXMgYXMgY2VsbHMgaW4gYSBzcHJlYWRzaGVldC4gSXQgZG9lc24ndCBtYWtlIGFueSBzZW5zZSB0b1xuICAgICAqIGRlZmluZSBhIHNwcmVhZHNoZWV0IGNlbGwgYEExYCB3aXRoIGEgZm9ybXVsYSB0aGF0IGRlcGVuZHMgb24gYEIxYCBhbmRcbiAgICAgKiBjZWxsIGBCMWAgZGVmaW5lZCB3aXRoIGEgZm9ybXVsYSB0aGF0IGRlcGVuZHMgb24gYEExYC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBmaW5kIHlvdXJzZWxmIHdhbnRpbmcgdG8gdXNlIGBpbWl0YXRlKClgIHdpdGggYVxuICAgICAqIE1lbW9yeVN0cmVhbSwgeW91IHNob3VsZCByZXdvcmsgeW91ciBjb2RlIGFyb3VuZCBgaW1pdGF0ZSgpYCB0byB1c2UgYVxuICAgICAqIFN0cmVhbSBpbnN0ZWFkLiBMb29rIGZvciB0aGUgc3RyZWFtIGluIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5IHRoYXRcbiAgICAgKiByZXByZXNlbnRzIGFuIGV2ZW50IHN0cmVhbSwgYW5kIHRoYXQgd291bGQgYmUgYSBjYW5kaWRhdGUgZm9yIGNyZWF0aW5nIGFcbiAgICAgKiBwcm94eSBTdHJlYW0gd2hpY2ggdGhlbiBpbWl0YXRlcyB0aGUgdGFyZ2V0IFN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSB0YXJnZXQgVGhlIG90aGVyIHN0cmVhbSB0byBpbWl0YXRlIG9uIHRoZSBjdXJyZW50IG9uZS4gTXVzdFxuICAgICAqIG5vdCBiZSBhIE1lbW9yeVN0cmVhbS5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLmltaXRhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNZW1vcnlTdHJlYW0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgTWVtb3J5U3RyZWFtIHdhcyBnaXZlbiB0byBpbWl0YXRlKCksIGJ1dCBpdCBvbmx5ICcgK1xuICAgICAgICAgICAgICAgICdzdXBwb3J0cyBhIFN0cmVhbS4gUmVhZCBtb3JlIGFib3V0IHRoaXMgcmVzdHJpY3Rpb24gaGVyZTogJyArXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9zdGFsdHoveHN0cmVhbSNmYXEnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBmb3IgKHZhciBpbHMgPSB0aGlzLl9pbHMsIE4gPSBpbHMubGVuZ3RoLCBpID0gMDsgaSA8IE47IGkrKylcbiAgICAgICAgICAgIHRhcmdldC5fYWRkKGlsc1tpXSk7XG4gICAgICAgIHRoaXMuX2lscyA9IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBTdHJlYW0gdG8gZW1pdCB0aGUgZ2l2ZW4gdmFsdWUgdG8gaXRzIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEFzIHRoZSBuYW1lIGluZGljYXRlcywgaWYgeW91IHVzZSB0aGlzLCB5b3UgYXJlIG1vc3QgbGlrZWx5IGRvaW5nIHNvbWV0aGluZ1xuICAgICAqIFRoZSBXcm9uZyBXYXkuIFBsZWFzZSB0cnkgdG8gdW5kZXJzdGFuZCB0aGUgcmVhY3RpdmUgd2F5IGJlZm9yZSB1c2luZyB0aGlzXG4gICAgICogbWV0aG9kLiBVc2UgaXQgb25seSB3aGVuIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgXCJuZXh0XCIgdmFsdWUgeW91IHdhbnQgdG8gYnJvYWRjYXN0IHRvIGFsbCBsaXN0ZW5lcnMgb2ZcbiAgICAgKiB0aGlzIFN0cmVhbS5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnNoYW1lZnVsbHlTZW5kTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9uKHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgU3RyZWFtIHRvIGVtaXQgdGhlIGdpdmVuIGVycm9yIHRvIGl0cyBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBBcyB0aGUgbmFtZSBpbmRpY2F0ZXMsIGlmIHlvdSB1c2UgdGhpcywgeW91IGFyZSBtb3N0IGxpa2VseSBkb2luZyBzb21ldGhpbmdcbiAgICAgKiBUaGUgV3JvbmcgV2F5LiBQbGVhc2UgdHJ5IHRvIHVuZGVyc3RhbmQgdGhlIHJlYWN0aXZlIHdheSBiZWZvcmUgdXNpbmcgdGhpc1xuICAgICAqIG1ldGhvZC4gVXNlIGl0IG9ubHkgd2hlbiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gZXJyb3IgVGhlIGVycm9yIHlvdSB3YW50IHRvIGJyb2FkY2FzdCB0byBhbGwgdGhlIGxpc3RlbmVycyBvZlxuICAgICAqIHRoaXMgU3RyZWFtLlxuICAgICAqL1xuICAgIFN0cmVhbS5wcm90b3R5cGUuc2hhbWVmdWxseVNlbmRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLl9lKGVycm9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgU3RyZWFtIHRvIGVtaXQgdGhlIFwiY29tcGxldGVkXCIgZXZlbnQgdG8gaXRzIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEFzIHRoZSBuYW1lIGluZGljYXRlcywgaWYgeW91IHVzZSB0aGlzLCB5b3UgYXJlIG1vc3QgbGlrZWx5IGRvaW5nIHNvbWV0aGluZ1xuICAgICAqIFRoZSBXcm9uZyBXYXkuIFBsZWFzZSB0cnkgdG8gdW5kZXJzdGFuZCB0aGUgcmVhY3RpdmUgd2F5IGJlZm9yZSB1c2luZyB0aGlzXG4gICAgICogbWV0aG9kLiBVc2UgaXQgb25seSB3aGVuIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICBTdHJlYW0ucHJvdG90eXBlLnNoYW1lZnVsbHlTZW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2MoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBcImRlYnVnXCIgbGlzdGVuZXIgdG8gdGhlIHN0cmVhbS4gVGhlcmUgY2FuIG9ubHkgYmUgb25lIGRlYnVnXG4gICAgICogbGlzdGVuZXIsIHRoYXQncyB3aHkgdGhpcyBpcyAnc2V0RGVidWdMaXN0ZW5lcicuIFRvIHJlbW92ZSB0aGUgZGVidWdcbiAgICAgKiBsaXN0ZW5lciwganVzdCBjYWxsIHNldERlYnVnTGlzdGVuZXIobnVsbCkuXG4gICAgICpcbiAgICAgKiBBIGRlYnVnIGxpc3RlbmVyIGlzIGxpa2UgYW55IG90aGVyIGxpc3RlbmVyLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgYVxuICAgICAqIGRlYnVnIGxpc3RlbmVyIGlzIFwic3RlYWx0aHlcIjogaXRzIHByZXNlbmNlL2Fic2VuY2UgZG9lcyBub3QgdHJpZ2dlciB0aGVcbiAgICAgKiBzdGFydC9zdG9wIG9mIHRoZSBzdHJlYW0gKG9yIHRoZSBwcm9kdWNlciBpbnNpZGUgdGhlIHN0cmVhbSkuIFRoaXMgaXNcbiAgICAgKiB1c2VmdWwgc28geW91IGNhbiBpbnNwZWN0IHdoYXQgaXMgZ29pbmcgb24gd2l0aG91dCBjaGFuZ2luZyB0aGUgYmVoYXZpb3JcbiAgICAgKiBvZiB0aGUgcHJvZ3JhbS4gSWYgeW91IGhhdmUgYW4gaWRsZSBzdHJlYW0gYW5kIHlvdSBhZGQgYSBub3JtYWwgbGlzdGVuZXIgdG9cbiAgICAgKiBpdCwgdGhlIHN0cmVhbSB3aWxsIHN0YXJ0IGV4ZWN1dGluZy4gQnV0IGlmIHlvdSBzZXQgYSBkZWJ1ZyBsaXN0ZW5lciBvbiBhblxuICAgICAqIGlkbGUgc3RyZWFtLCBpdCB3b24ndCBzdGFydCBleGVjdXRpbmcgKG5vdCB1bnRpbCB0aGUgZmlyc3Qgbm9ybWFsIGxpc3RlbmVyXG4gICAgICogaXMgYWRkZWQpLlxuICAgICAqXG4gICAgICogQXMgdGhlIG5hbWUgaW5kaWNhdGVzLCB3ZSBkb24ndCByZWNvbW1lbmQgdXNpbmcgdGhpcyBtZXRob2QgdG8gYnVpbGQgYXBwXG4gICAgICogbG9naWMuIEluIGZhY3QsIGluIG1vc3QgY2FzZXMgdGhlIGRlYnVnIG9wZXJhdG9yIHdvcmtzIGp1c3QgZmluZS4gT25seSB1c2VcbiAgICAgKiB0aGlzIG9uZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGlzdGVuZXI8VD59IGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5zZXREZWJ1Z0xpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RsID0gTk87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLl9uID0gbGlzdGVuZXIubmV4dCB8fCBub29wO1xuICAgICAgICAgICAgbGlzdGVuZXIuX2UgPSBsaXN0ZW5lci5lcnJvciB8fCBub29wO1xuICAgICAgICAgICAgbGlzdGVuZXIuX2MgPSBsaXN0ZW5lci5jb21wbGV0ZSB8fCBub29wO1xuICAgICAgICAgICAgdGhpcy5fZGwgPSBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0cmVhbTtcbn0oKSk7XG4vKipcbiAqIEJsZW5kcyBtdWx0aXBsZSBzdHJlYW1zIHRvZ2V0aGVyLCBlbWl0dGluZyBldmVudHMgZnJvbSBhbGwgb2YgdGhlbVxuICogY29uY3VycmVudGx5LlxuICpcbiAqICptZXJnZSogdGFrZXMgbXVsdGlwbGUgc3RyZWFtcyBhcyBhcmd1bWVudHMsIGFuZCBjcmVhdGVzIGEgc3RyZWFtIHRoYXRcbiAqIGJlaGF2ZXMgbGlrZSBlYWNoIG9mIHRoZSBhcmd1bWVudCBzdHJlYW1zLCBpbiBwYXJhbGxlbC5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLS0tMi0tLS0tMy0tLS0tLS0tNC0tLVxuICogLS0tLWEtLS0tLWItLS0tYy0tLWQtLS0tLS1cbiAqICAgICAgICAgICAgbWVyZ2VcbiAqIC0tMS1hLS0yLS1iLS0zLWMtLS1kLS00LS0tXG4gKiBgYGBcbiAqXG4gKiBAZmFjdG9yeSB0cnVlXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMSBBIHN0cmVhbSB0byBtZXJnZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMiBBIHN0cmVhbSB0byBtZXJnZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuIFR3b1xuICogb3IgbW9yZSBzdHJlYW1zIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cblN0cmVhbS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBzdHJlYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3RyZWFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgTWVyZ2Uoc3RyZWFtcykpO1xufTtcbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgaW5wdXQgc3RyZWFtcyB0b2dldGhlciB0byByZXR1cm4gYSBzdHJlYW0gd2hvc2UgZXZlbnRzXG4gKiBhcmUgYXJyYXlzIHRoYXQgY29sbGVjdCB0aGUgbGF0ZXN0IGV2ZW50cyBmcm9tIGVhY2ggaW5wdXQgc3RyZWFtLlxuICpcbiAqICpjb21iaW5lKiBpbnRlcm5hbGx5IHJlbWVtYmVycyB0aGUgbW9zdCByZWNlbnQgZXZlbnQgZnJvbSBlYWNoIG9mIHRoZSBpbnB1dFxuICogc3RyZWFtcy4gV2hlbiBhbnkgb2YgdGhlIGlucHV0IHN0cmVhbXMgZW1pdHMgYW4gZXZlbnQsIHRoYXQgZXZlbnQgdG9nZXRoZXJcbiAqIHdpdGggYWxsIHRoZSBvdGhlciBzYXZlZCBldmVudHMgYXJlIGNvbWJpbmVkIGludG8gYW4gYXJyYXkuIFRoYXQgYXJyYXkgd2lsbFxuICogYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IHN0cmVhbS4gSXQncyBlc3NlbnRpYWxseSBhIHdheSBvZiBqb2luaW5nIHRvZ2V0aGVyXG4gKiB0aGUgZXZlbnRzIGZyb20gbXVsdGlwbGUgc3RyZWFtcy5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLS0tMi0tLS0tMy0tLS0tLS0tNC0tLVxuICogLS0tLWEtLS0tLWItLS0tLWMtLWQtLS0tLS1cbiAqICAgICAgICAgIGNvbWJpbmVcbiAqIC0tLS0xYS0yYS0yYi0zYi0zYy0zZC00ZC0tXG4gKiBgYGBcbiAqXG4gKiBOb3RlOiB0byBtaW5pbWl6ZSBnYXJiYWdlIGNvbGxlY3Rpb24sICpjb21iaW5lKiB1c2VzIHRoZSBzYW1lIGFycmF5XG4gKiBpbnN0YW5jZSBmb3IgZWFjaCBlbWlzc2lvbi4gIElmIHlvdSBuZWVkIHRvIGNvbXBhcmUgZW1pc3Npb25zIG92ZXIgdGltZSxcbiAqIGNhY2hlIHRoZSB2YWx1ZXMgd2l0aCBgbWFwYCBmaXJzdDpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHBhaXJ3aXNlIGZyb20gJ3hzdHJlYW0vZXh0cmEvcGFpcndpc2UnXG4gKlxuICogY29uc3Qgc3RyZWFtMSA9IHhzLm9mKDEpO1xuICogY29uc3Qgc3RyZWFtMiA9IHhzLm9mKDIpO1xuICpcbiAqIHhzLmNvbWJpbmUoc3RyZWFtMSwgc3RyZWFtMikubWFwKFxuICogICBjb21iaW5lZEVtaXNzaW9ucyA9PiAoWyAuLi5jb21iaW5lZEVtaXNzaW9ucyBdKVxuICogKS5jb21wb3NlKHBhaXJ3aXNlKVxuICogYGBgXG4gKlxuICogQGZhY3RvcnkgdHJ1ZVxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTEgQSBzdHJlYW0gdG8gY29tYmluZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMiBBIHN0cmVhbSB0byBjb21iaW5lIHRvZ2V0aGVyIHdpdGggb3RoZXIgc3RyZWFtcy5cbiAqIE11bHRpcGxlIHN0cmVhbXMsIG5vdCBqdXN0IHR3bywgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50cy5cbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqL1xuU3RyZWFtLmNvbWJpbmUgPSBmdW5jdGlvbiBjb21iaW5lKCkge1xuICAgIHZhciBzdHJlYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3RyZWFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbShuZXcgQ29tYmluZShzdHJlYW1zKSk7XG59O1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG52YXIgTWVtb3J5U3RyZWFtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVtb3J5U3RyZWFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbW9yeVN0cmVhbShwcm9kdWNlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9kdWNlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2hhcyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLl92ID0geDtcbiAgICAgICAgdGhpcy5faGFzID0gdHJ1ZTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fbi5jYWxsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24gKGlsKSB7XG4gICAgICAgIHZhciB0YSA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgaWYgKHRhICE9PSBOTylcbiAgICAgICAgICAgIHJldHVybiB0YS5fYWRkKGlsKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9pbHM7XG4gICAgICAgIGEucHVzaChpbCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXMpXG4gICAgICAgICAgICAgICAgaWwuX24odGhpcy5fdik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0b3BJRCAhPT0gTk8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXMpXG4gICAgICAgICAgICAgICAgaWwuX24odGhpcy5fdik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcElEKTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BJRCA9IE5PO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2hhcylcbiAgICAgICAgICAgIGlsLl9uKHRoaXMuX3YpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5fcHJvZDtcbiAgICAgICAgICAgIGlmIChwICE9PSBOTylcbiAgICAgICAgICAgICAgICBwLl9zdGFydCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5fc3RvcE5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzID0gZmFsc2U7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0b3BOb3cuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuX3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhcyA9IGZhbHNlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl94LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAocHJvamVjdCk7XG4gICAgfTtcbiAgICBNZW1vcnlTdHJlYW0ucHJvdG90eXBlLm1hcFRvID0gZnVuY3Rpb24gKHByb2plY3RlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLm1hcFRvLmNhbGwodGhpcywgcHJvamVjdGVkVmFsdWUpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS50YWtlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50YWtlLmNhbGwodGhpcywgYW1vdW50KTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUuZW5kV2hlbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbmRXaGVuLmNhbGwodGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5yZXBsYWNlRXJyb3IgPSBmdW5jdGlvbiAocmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZXBsYWNlRXJyb3IuY2FsbCh0aGlzLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIE1lbW9yeVN0cmVhbS5wcm90b3R5cGUucmVtZW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWVtb3J5U3RyZWFtLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChsYWJlbE9yU3B5KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlYnVnLmNhbGwodGhpcywgbGFiZWxPclNweSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVtb3J5U3RyZWFtO1xufShTdHJlYW0pKTtcbmV4cG9ydHMuTWVtb3J5U3RyZWFtID0gTWVtb3J5U3RyZWFtO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3hzdHJlYW0vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdGh1bmsgPSByZXF1aXJlKCdzbmFiYmRvbS90aHVuaycpO1xuZXhwb3J0cy50aHVuayA9IHRodW5rO1xuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIHRoZSBET00gZHJpdmVyIGZ1bmN0aW9uLlxuICpcbiAqIFRha2VzIGEgYGNvbnRhaW5lcmAgdG8gZGVmaW5lIHRoZSB0YXJnZXQgb24gdGhlIGV4aXN0aW5nIERPTSB3aGljaCB0aGlzXG4gKiBkcml2ZXIgd2lsbCBvcGVyYXRlIG9uLCBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBUaGVcbiAqIGlucHV0IHRvIHRoaXMgZHJpdmVyIGlzIGEgc3RyZWFtIG9mIHZpcnR1YWwgRE9NIG9iamVjdHMsIG9yIGluIG90aGVyIHdvcmRzLFxuICogU25hYmJkb20gXCJWTm9kZVwiIG9iamVjdHMuIFRoZSBvdXRwdXQgb2YgdGhpcyBkcml2ZXIgaXMgYSBcIkRPTVNvdXJjZVwiOiBhXG4gKiBjb2xsZWN0aW9uIG9mIE9ic2VydmFibGVzIHF1ZXJpZWQgd2l0aCB0aGUgbWV0aG9kcyBgc2VsZWN0KClgIGFuZCBgZXZlbnRzKClgLlxuICpcbiAqIGBET01Tb3VyY2Uuc2VsZWN0KHNlbGVjdG9yKWAgcmV0dXJucyBhIG5ldyBET01Tb3VyY2Ugd2l0aCBzY29wZSByZXN0cmljdGVkIHRvXG4gKiB0aGUgZWxlbWVudChzKSB0aGF0IG1hdGNoZXMgdGhlIENTUyBgc2VsZWN0b3JgIGdpdmVuLlxuICpcbiAqIGBET01Tb3VyY2UuZXZlbnRzKGV2ZW50VHlwZSwgb3B0aW9ucylgIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIG9mXG4gKiBgZXZlbnRUeXBlYCBoYXBwZW5pbmcgb24gdGhlIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGN1cnJlbnQgRE9NU291cmNlLiBUaGVcbiAqIGV2ZW50IG9iamVjdCBjb250YWlucyB0aGUgYG93bmVyVGFyZ2V0YCBwcm9wZXJ0eSB0aGF0IGJlaGF2ZXMgZXhhY3RseSBsaWtlXG4gKiBgY3VycmVudFRhcmdldGAuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBzb21lIGJyb3dzZXJzIGRvZXNuJ3QgYWxsb3dcbiAqIGBjdXJyZW50VGFyZ2V0YCBwcm9wZXJ0eSB0byBiZSBtdXRhdGVkLCBoZW5jZSBhIG5ldyBwcm9wZXJ0eSBpcyBjcmVhdGVkLiBUaGVcbiAqIHJldHVybmVkIHN0cmVhbSBpcyBhbiAqeHN0cmVhbSogU3RyZWFtIGlmIHlvdSB1c2UgYEBjeWNsZS94c3RyZWFtLXJ1bmAgdG8gcnVuXG4gKiB5b3VyIGFwcCB3aXRoIHRoaXMgZHJpdmVyLCBvciBpdCBpcyBhbiBSeEpTIE9ic2VydmFibGUgaWYgeW91IHVzZVxuICogYEBjeWNsZS9yeGpzLXJ1bmAsIGFuZCBzbyBmb3J0aC4gVGhlIGBvcHRpb25zYCBwYXJhbWV0ZXIgY2FuIGhhdmUgdGhlXG4gKiBwcm9wZXJ0eSBgdXNlQ2FwdHVyZWAsIHdoaWNoIGlzIGJ5IGRlZmF1bHQgYGZhbHNlYCwgZXhjZXB0IGl0IGlzIGB0cnVlYCBmb3JcbiAqIGV2ZW50IHR5cGVzIHRoYXQgZG8gbm90IGJ1YmJsZS4gUmVhZCBtb3JlIGhlcmVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyXG4gKiBhYm91dCB0aGUgYHVzZUNhcHR1cmVgIGFuZCBpdHMgcHVycG9zZS5cbiAqXG4gKiBgRE9NU291cmNlLmVsZW1lbnRzKClgIHJldHVybnMgYSBzdHJlYW0gb2YgdGhlIERPTSBlbGVtZW50KHMpIG1hdGNoZWQgYnkgdGhlXG4gKiBzZWxlY3RvcnMgaW4gdGhlIERPTVNvdXJjZS4gQWxzbywgYERPTVNvdXJjZS5zZWxlY3QoJzpyb290JykuZWxlbWVudHMoKWBcbiAqIHJldHVybnMgYSBzdHJlYW0gb2YgRE9NIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCAob3IgY29udGFpbmVyKSBvZlxuICogdGhlIGFwcCBvbiB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xIVE1MRWxlbWVudCl9IGNvbnRhaW5lciB0aGUgRE9NIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudFxuICogKG9yIHRoZSBlbGVtZW50IGl0c2VsZikgdG8gY29udGFpbiB0aGUgcmVuZGVyaW5nIG9mIHRoZSBWVHJlZXMuXG4gKiBAcGFyYW0ge0RPTURyaXZlck9wdGlvbnN9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggdHdvIG9wdGlvbmFsIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBtb2R1bGVzOiBhcnJheWAgb3ZlcnJpZGVzIGBAY3ljbGUvZG9tYCdzIGRlZmF1bHQgU25hYmJkb20gbW9kdWxlcyBhc1xuICogICAgIGFzIGRlZmluZWQgaW4gW2BzcmMvbW9kdWxlcy50c2BdKC4vc3JjL21vZHVsZXMudHMpLlxuICogICAtIGB0cmFuc3Bvc2l0aW9uOiBib29sZWFuYCBlbmFibGVzL2Rpc2FibGVzIHRyYW5zcG9zaXRpb24gb2YgaW5uZXIgc3RyZWFtc1xuICogICAgIGluIHRoZSB2aXJ0dWFsIERPTSB0cmVlLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBET00gZHJpdmVyIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gZXhwZWN0cyBhIHN0cmVhbSBvZlxuICogVk5vZGUgYXMgaW5wdXQsIGFuZCBvdXRwdXRzIHRoZSBET01Tb3VyY2Ugb2JqZWN0LlxuICogQGZ1bmN0aW9uIG1ha2VET01Ecml2ZXJcbiAqL1xudmFyIG1ha2VET01Ecml2ZXJfMSA9IHJlcXVpcmUoJy4vbWFrZURPTURyaXZlcicpO1xuZXhwb3J0cy5tYWtlRE9NRHJpdmVyID0gbWFrZURPTURyaXZlcl8xLm1ha2VET01Ecml2ZXI7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgdGhlIEhUTUwgZHJpdmVyIGZ1bmN0aW9uLlxuICpcbiAqIFRha2VzIGFuIGBlZmZlY3RgIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0IGFzIGFyZ3VtZW50cy4gVGhlXG4gKiBpbnB1dCB0byB0aGlzIGRyaXZlciBpcyBhIHN0cmVhbSBvZiB2aXJ0dWFsIERPTSBvYmplY3RzLCBvciBpbiBvdGhlciB3b3JkcyxcbiAqIFNuYWJiZG9tIFwiVk5vZGVcIiBvYmplY3RzLiBUaGUgb3V0cHV0IG9mIHRoaXMgZHJpdmVyIGlzIGEgXCJET01Tb3VyY2VcIjogYVxuICogY29sbGVjdGlvbiBvZiBPYnNlcnZhYmxlcyBxdWVyaWVkIHdpdGggdGhlIG1ldGhvZHMgYHNlbGVjdCgpYCBhbmQgYGV2ZW50cygpYC5cbiAqXG4gKiBUaGUgSFRNTCBEcml2ZXIgaXMgc3VwcGxlbWVudGFyeSB0byB0aGUgRE9NIERyaXZlci4gSW5zdGVhZCBvZiBwcm9kdWNpbmdcbiAqIGVsZW1lbnRzIG9uIHRoZSBET00sIGl0IGdlbmVyYXRlcyBIVE1MIGFzIHN0cmluZ3MgYW5kIGRvZXMgYSBzaWRlIGVmZmVjdCBvblxuICogdGhvc2UgSFRNTCBzdHJpbmdzLiBUaGF0IHNpZGUgZWZmZWN0IGlzIGRlc2NyaWJlZCBieSB0aGUgYGVmZmVjdGAgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBTbywgaWYgeW91IHdhbnQgdG8gdXNlIHRoZSBIVE1MIERyaXZlciBvbiB0aGUgc2VydmVyLXNpZGUgdG8gcmVuZGVyXG4gKiB5b3VyIGFwcGxpY2F0aW9uIGFzIEhUTUwgYW5kIHNlbmQgYXMgYSByZXNwb25zZSAod2hpY2ggaXMgdGhlIHR5cGljYWwgdXNlXG4gKiBjYXNlIGZvciB0aGUgSFRNTCBEcml2ZXIpLCB5b3UgbmVlZCB0byBwYXNzIHNvbWV0aGluZyBsaWtlIHRoZVxuICogYGh0bWwgPT4gcmVzcG9uc2Uuc2VuZChodG1sKWAgZnVuY3Rpb24gYXMgdGhlIGBlZmZlY3RgIGFyZ3VtZW50LiBUaGlzIHdheSxcbiAqIHRoZSBkcml2ZXIga25vd3Mgd2hhdCBzaWRlIGVmZmVjdCB0byBjYXVzZSBiYXNlZCBvbiB0aGUgSFRNTCBzdHJpbmcgaXQganVzdFxuICogcmVuZGVyZWQuXG4gKlxuICogVGhlIEhUTUwgZHJpdmVyIGlzIHVzZWZ1bCBvbmx5IGZvciB0aGF0IHNpZGUgZWZmZWN0IGluIHRoZSBgZWZmZWN0YCBjYWxsYmFjay5cbiAqIEl0IGNhbiBiZSBjb25zaWRlcmVkIGEgc2luay1vbmx5IGRyaXZlci4gSG93ZXZlciwgaW4gb3JkZXIgdG8gc2VydmUgYXMgYVxuICogdHJhbnNwYXJlbnQgcmVwbGFjZW1lbnQgdG8gdGhlIERPTSBEcml2ZXIgd2hlbiByZW5kZXJpbmcgZnJvbSB0aGUgc2VydmVyLCB0aGVcbiAqIEhUTUwgZHJpdmVyIHJldHVybnMgYSBzb3VyY2Ugb2JqZWN0IHRoYXQgYmVoYXZlcyBqdXN0IGxpa2UgdGhlIERPTVNvdXJjZS5cbiAqIFRoaXMgaGVscHMgcmV1c2UgdGhlIHNhbWUgYXBwbGljYXRpb24gdGhhdCBpcyB3cml0dGVuIGZvciB0aGUgRE9NIERyaXZlci5cbiAqIFRoaXMgZmFrZSBET01Tb3VyY2UgcmV0dXJucyBlbXB0eSBzdHJlYW1zIHdoZW4geW91IHF1ZXJ5IGl0LCBiZWNhdXNlIHRoZXJlXG4gKiBhcmUgbm8gdXNlciBldmVudHMgb24gdGhlIHNlcnZlci5cbiAqXG4gKiBgRE9NU291cmNlLnNlbGVjdChzZWxlY3RvcilgIHJldHVybnMgYSBuZXcgRE9NU291cmNlIHdpdGggc2NvcGUgcmVzdHJpY3RlZCB0b1xuICogdGhlIGVsZW1lbnQocykgdGhhdCBtYXRjaGVzIHRoZSBDU1MgYHNlbGVjdG9yYCBnaXZlbi5cbiAqXG4gKiBgRE9NU291cmNlLmV2ZW50cyhldmVudFR5cGUsIG9wdGlvbnMpYCByZXR1cm5zIGFuIGVtcHR5IHN0cmVhbS4gVGhlIHJldHVybmVkXG4gKiBzdHJlYW0gaXMgYW4gKnhzdHJlYW0qIFN0cmVhbSBpZiB5b3UgdXNlIGBAY3ljbGUveHN0cmVhbS1ydW5gIHRvIHJ1biB5b3VyIGFwcFxuICogd2l0aCB0aGlzIGRyaXZlciwgb3IgaXQgaXMgYW4gUnhKUyBPYnNlcnZhYmxlIGlmIHlvdSB1c2UgYEBjeWNsZS9yeGpzLXJ1bmAsXG4gKiBhbmQgc28gZm9ydGguXG4gKlxuICogYERPTVNvdXJjZS5lbGVtZW50cygpYCByZXR1cm5zIHRoZSBzdHJlYW0gb2YgSFRNTCBzdHJpbmcgcmVuZGVyZWQgZnJvbSB5b3VyXG4gKiBzaW5rIHZpcnR1YWwgRE9NIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlZmZlY3QgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyaW5nIG9mIHJlbmRlcmVkXG4gKiBIVE1MIGFzIGlucHV0IGFuZCBzaG91bGQgcnVuIGEgc2lkZSBlZmZlY3QsIHJldHVybmluZyBub3RoaW5nLlxuICogQHBhcmFtIHtIVE1MRHJpdmVyT3B0aW9uc30gb3B0aW9ucyBhbiBvYmplY3Qgd2l0aCBvbmUgb3B0aW9uYWwgcHJvcGVydHk6XG4gKiBgdHJhbnNwb3NpdGlvbjogYm9vbGVhbmAgZW5hYmxlcy9kaXNhYmxlcyB0cmFuc3Bvc2l0aW9uIG9mIGlubmVyIHN0cmVhbXMgaW5cbiAqIHRoZSB2aXJ0dWFsIERPTSB0cmVlLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBIVE1MIGRyaXZlciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIGV4cGVjdHMgYSBzdHJlYW0gb2ZcbiAqIFZOb2RlIGFzIGlucHV0LCBhbmQgb3V0cHV0cyB0aGUgRE9NU291cmNlIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBtYWtlSFRNTERyaXZlclxuICovXG52YXIgbWFrZUhUTUxEcml2ZXJfMSA9IHJlcXVpcmUoJy4vbWFrZUhUTUxEcml2ZXInKTtcbmV4cG9ydHMubWFrZUhUTUxEcml2ZXIgPSBtYWtlSFRNTERyaXZlcl8xLm1ha2VIVE1MRHJpdmVyO1xuLyoqXG4gKiBBIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2tlZCBET01Tb3VyY2Ugb2JqZWN0cywgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogVGFrZXMgYSBgc3RyZWFtQWRhcHRlcmAgYW5kIGEgYG1vY2tDb25maWdgIG9iamVjdCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zXG4gKiBhIERPTVNvdXJjZSB0aGF0IGNhbiBiZSBnaXZlbiB0byBhbnkgQ3ljbGUuanMgYXBwIHRoYXQgZXhwZWN0cyBhIERPTVNvdXJjZSBpblxuICogdGhlIHNvdXJjZXMsIGZvciB0ZXN0aW5nLlxuICpcbiAqIFRoZSBgc3RyZWFtQWRhcHRlcmAgcGFyYW1ldGVyIGlzIGEgcGFja2FnZSBzdWNoIGFzIGBAY3ljbGUveHN0cmVhbS1hZGFwdGVyYCxcbiAqIGBAY3ljbGUvcnhqcy1hZGFwdGVyYCwgZXRjLiBJbXBvcnQgaXQgYXMgYGltcG9ydCBhIGZyb20gJ0BjeWNsZS9yeC1hZGFwdGVyYCxcbiAqIHRoZW4gcHJvdmlkZSBpdCB0byBgbW9ja0RPTVNvdXJjZS4gVGhpcyBpcyBpbXBvcnRhbnQgc28gdGhlIERPTVNvdXJjZSBjcmVhdGVkXG4gKiBrbm93cyB3aGljaCBzdHJlYW0gbGlicmFyeSBzaG91bGQgaXQgdXNlIHRvIGV4cG9ydCBpdHMgc3RyZWFtcyB3aGVuIHlvdSBjYWxsXG4gKiBgRE9NU291cmNlLmV2ZW50cygpYCBmb3IgaW5zdGFuY2UuXG4gKlxuICogVGhlIGBtb2NrQ29uZmlnYCBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHNwZWNpZnlpbmcgc2VsZWN0b3JzLCBldmVudFR5cGVzIGFuZFxuICogdGhlaXIgc3RyZWFtcy4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZG9tU291cmNlID0gbW9ja0RPTVNvdXJjZShSeEFkYXB0ZXIsIHtcbiAqICAgJy5mb28nOiB7XG4gKiAgICAgJ2NsaWNrJzogUnguT2JzZXJ2YWJsZS5vZih7dGFyZ2V0OiB7fX0pLFxuICogICAgICdtb3VzZW92ZXInOiBSeC5PYnNlcnZhYmxlLm9mKHt0YXJnZXQ6IHt9fSksXG4gKiAgIH0sXG4gKiAgICcuYmFyJzoge1xuICogICAgICdzY3JvbGwnOiBSeC5PYnNlcnZhYmxlLm9mKHt0YXJnZXQ6IHt9fSksXG4gKiAgICAgZWxlbWVudHM6IFJ4Lk9ic2VydmFibGUub2Yoe3RhZ05hbWU6ICdkaXYnfSksXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzYWdlXG4gKiBjb25zdCBjbGljayQgPSBkb21Tb3VyY2Uuc2VsZWN0KCcuZm9vJykuZXZlbnRzKCdjbGljaycpO1xuICogY29uc3QgZWxlbWVudCQgPSBkb21Tb3VyY2Uuc2VsZWN0KCcuYmFyJykuZWxlbWVudHMoKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBtb2NrZWQgRE9NIFNvdXJjZSBzdXBwb3J0cyBpc29sYXRpb24uIEl0IGhhcyB0aGUgZnVuY3Rpb25zIGBpc29sYXRlU2lua2BcbiAqIGFuZCBgaXNvbGF0ZVNvdXJjZWAgYXR0YWNoZWQgdG8gaXQsIGFuZCBwZXJmb3JtcyBzaW1wbGUgaXNvbGF0aW9uIHVzaW5nXG4gKiBjbGFzc05hbWVzLiAqaXNvbGF0ZVNpbmsqIHdpdGggc2NvcGUgYGZvb2Agd2lsbCBhcHBlbmQgdGhlIGNsYXNzIGBfX19mb29gIHRvXG4gKiB0aGUgc3RyZWFtIG9mIHZpcnR1YWwgRE9NIG5vZGVzLCBhbmQgKmlzb2xhdGVTb3VyY2UqIHdpdGggc2NvcGUgYGZvb2Agd2lsbFxuICogcGVyZm9ybSBhIGNvbnZlbnRpb25hbCBgbW9ja2VkRE9NU291cmNlLnNlbGVjdCgnLl9fZm9vJylgIGNhbGwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vY2tDb25maWcgYW4gb2JqZWN0IHdoZXJlIGtleXMgYXJlIHNlbGVjdG9yIHN0cmluZ3NcbiAqIGFuZCB2YWx1ZXMgYXJlIG9iamVjdHMuIFRob3NlIG5lc3RlZCBvYmplY3RzIGhhdmUgYGV2ZW50VHlwZWAgc3RyaW5ncyBhcyBrZXlzXG4gKiBhbmQgdmFsdWVzIGFyZSBzdHJlYW1zIHlvdSBjcmVhdGVkLlxuICogQHJldHVybiB7T2JqZWN0fSBmYWtlIERPTSBzb3VyY2Ugb2JqZWN0LCB3aXRoIGFuIEFQSSBjb250YWluaW5nIGBzZWxlY3QoKWBcbiAqIGFuZCBgZXZlbnRzKClgIGFuZCBgZWxlbWVudHMoKWAgd2hpY2ggY2FuIGJlIHVzZWQganVzdCBsaWtlIHRoZSBET00gRHJpdmVyJ3NcbiAqIERPTVNvdXJjZS5cbiAqXG4gKiBAZnVuY3Rpb24gbW9ja0RPTVNvdXJjZVxuICovXG52YXIgbW9ja0RPTVNvdXJjZV8xID0gcmVxdWlyZSgnLi9tb2NrRE9NU291cmNlJyk7XG5leHBvcnRzLm1vY2tET01Tb3VyY2UgPSBtb2NrRE9NU291cmNlXzEubW9ja0RPTVNvdXJjZTtcbi8qKlxuICogVGhlIGh5cGVyc2NyaXB0IGZ1bmN0aW9uIGBoKClgIGlzIGEgZnVuY3Rpb24gdG8gY3JlYXRlIHZpcnR1YWwgRE9NIG9iamVjdHMsXG4gKiBhbHNvIGtub3duIGFzIFZOb2Rlcy4gQ2FsbFxuICpcbiAqIGBgYGpzXG4gKiBoKCdkaXYubXlDbGFzcycsIHtzdHlsZToge2NvbG9yOiAncmVkJ319LCBbXSlcbiAqIGBgYFxuICpcbiAqIHRvIGNyZWF0ZSBhIFZOb2RlIHRoYXQgcmVwcmVzZW50cyBhIGBESVZgIGVsZW1lbnQgd2l0aCBjbGFzc05hbWUgYG15Q2xhc3NgLFxuICogc3R5bGVkIHdpdGggcmVkIGNvbG9yLCBhbmQgbm8gY2hpbGRyZW4gYmVjYXVzZSB0aGUgYFtdYCBhcnJheSB3YXMgcGFzc2VkLiBUaGVcbiAqIEFQSSBpcyBgaCh0YWdPclNlbGVjdG9yLCBvcHRpb25hbERhdGEsIG9wdGlvbmFsQ2hpbGRyZW5PclRleHQpYC5cbiAqXG4gKiBIb3dldmVyLCB1c3VhbGx5IHlvdSBzaG91bGQgdXNlIFwiaHlwZXJzY3JpcHQgaGVscGVyc1wiLCB3aGljaCBhcmUgc2hvcnRjdXRcbiAqIGZ1bmN0aW9ucyBiYXNlZCBvbiBoeXBlcnNjcmlwdC4gVGhlcmUgaXMgb25lIGh5cGVyc2NyaXB0IGhlbHBlciBmdW5jdGlvbiBmb3JcbiAqIGVhY2ggRE9NIHRhZ05hbWUsIHN1Y2ggYXMgYGgxKClgLCBgaDIoKWAsIGBkaXYoKWAsIGBzcGFuKClgLCBgbGFiZWwoKWAsXG4gKiBgaW5wdXQoKWAuIEZvciBpbnN0YW5jZSwgdGhlIHByZXZpb3VzIGV4YW1wbGUgY291bGQgaGF2ZSBiZWVuIHdyaXR0ZW5cbiAqIGFzOlxuICpcbiAqIGBgYGpzXG4gKiBkaXYoJy5teUNsYXNzJywge3N0eWxlOiB7Y29sb3I6ICdyZWQnfX0sIFtdKVxuICogYGBgXG4gKlxuICogVGhlcmUgYXJlIGFsc28gU1ZHIGhlbHBlciBmdW5jdGlvbnMsIHdoaWNoIGFwcGx5IHRoZSBhcHByb3ByaWF0ZSBTVkdcbiAqIG5hbWVzcGFjZSB0byB0aGUgcmVzdWx0aW5nIGVsZW1lbnRzLiBgc3ZnKClgIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIHRvcC1tb3N0XG4gKiBTVkcgZWxlbWVudCwgYW5kIGBzdmcuZ2AsIGBzdmcucG9seWdvbmAsIGBzdmcuY2lyY2xlYCwgYHN2Zy5wYXRoYCBhcmUgZm9yXG4gKiBTVkctc3BlY2lmaWMgY2hpbGQgZWxlbWVudHMuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHN2Zyh7d2lkdGg6IDE1MCwgaGVpZ2h0OiAxNTB9LCBbXG4gKiAgIHN2Zy5wb2x5Z29uKHtcbiAqICAgICBhdHRyczoge1xuICogICAgICAgY2xhc3M6ICd0cmlhbmdsZScsXG4gKiAgICAgICBwb2ludHM6ICcyMCAwIDIwIDE1MCAxNTAgMjAnXG4gKiAgICAgfVxuICogICB9KVxuICogXSlcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvbiBoXG4gKi9cbnZhciBoeXBlcnNjcmlwdF8xID0gcmVxdWlyZSgnLi9oeXBlcnNjcmlwdCcpO1xuZXhwb3J0cy5oID0gaHlwZXJzY3JpcHRfMS5oO1xudmFyIGh5cGVyc2NyaXB0X2hlbHBlcnNfMSA9IHJlcXVpcmUoJy4vaHlwZXJzY3JpcHQtaGVscGVycycpO1xuZXhwb3J0cy5zdmcgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdmc7XG5leHBvcnRzLmEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hO1xuZXhwb3J0cy5hYmJyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYWJicjtcbmV4cG9ydHMuYWRkcmVzcyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmFkZHJlc3M7XG5leHBvcnRzLmFyZWEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hcmVhO1xuZXhwb3J0cy5hcnRpY2xlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYXJ0aWNsZTtcbmV4cG9ydHMuYXNpZGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hc2lkZTtcbmV4cG9ydHMuYXVkaW8gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hdWRpbztcbmV4cG9ydHMuYiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmI7XG5leHBvcnRzLmJhc2UgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iYXNlO1xuZXhwb3J0cy5iZGkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iZGk7XG5leHBvcnRzLmJkbyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJkbztcbmV4cG9ydHMuYmxvY2txdW90ZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJsb2NrcXVvdGU7XG5leHBvcnRzLmJvZHkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ib2R5O1xuZXhwb3J0cy5iciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJyO1xuZXhwb3J0cy5idXR0b24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5idXR0b247XG5leHBvcnRzLmNhbnZhcyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNhbnZhcztcbmV4cG9ydHMuY2FwdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNhcHRpb247XG5leHBvcnRzLmNpdGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5jaXRlO1xuZXhwb3J0cy5jb2RlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuY29kZTtcbmV4cG9ydHMuY29sID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuY29sO1xuZXhwb3J0cy5jb2xncm91cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNvbGdyb3VwO1xuZXhwb3J0cy5kZCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRkO1xuZXhwb3J0cy5kZWwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kZWw7XG5leHBvcnRzLmRmbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRmbjtcbmV4cG9ydHMuZGlyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGlyO1xuZXhwb3J0cy5kaXYgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kaXY7XG5leHBvcnRzLmRsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGw7XG5leHBvcnRzLmR0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZHQ7XG5leHBvcnRzLmVtID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZW07XG5leHBvcnRzLmVtYmVkID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZW1iZWQ7XG5leHBvcnRzLmZpZWxkc2V0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZmllbGRzZXQ7XG5leHBvcnRzLmZpZ2NhcHRpb24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5maWdjYXB0aW9uO1xuZXhwb3J0cy5maWd1cmUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5maWd1cmU7XG5leHBvcnRzLmZvb3RlciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmZvb3RlcjtcbmV4cG9ydHMuZm9ybSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmZvcm07XG5leHBvcnRzLmgxID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDE7XG5leHBvcnRzLmgyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDI7XG5leHBvcnRzLmgzID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDM7XG5leHBvcnRzLmg0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDQ7XG5leHBvcnRzLmg1ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDU7XG5leHBvcnRzLmg2ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDY7XG5leHBvcnRzLmhlYWQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5oZWFkO1xuZXhwb3J0cy5oZWFkZXIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5oZWFkZXI7XG5leHBvcnRzLmhncm91cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmhncm91cDtcbmV4cG9ydHMuaHIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ocjtcbmV4cG9ydHMuaHRtbCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmh0bWw7XG5leHBvcnRzLmkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pO1xuZXhwb3J0cy5pZnJhbWUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pZnJhbWU7XG5leHBvcnRzLmltZyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmltZztcbmV4cG9ydHMuaW5wdXQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pbnB1dDtcbmV4cG9ydHMuaW5zID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaW5zO1xuZXhwb3J0cy5rYmQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5rYmQ7XG5leHBvcnRzLmtleWdlbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmtleWdlbjtcbmV4cG9ydHMubGFiZWwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5sYWJlbDtcbmV4cG9ydHMubGVnZW5kID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubGVnZW5kO1xuZXhwb3J0cy5saSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmxpO1xuZXhwb3J0cy5saW5rID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubGluaztcbmV4cG9ydHMubWFpbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1haW47XG5leHBvcnRzLm1hcCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1hcDtcbmV4cG9ydHMubWFyayA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1hcms7XG5leHBvcnRzLm1lbnUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5tZW51O1xuZXhwb3J0cy5tZXRhID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubWV0YTtcbmV4cG9ydHMubmF2ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubmF2O1xuZXhwb3J0cy5ub3NjcmlwdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm5vc2NyaXB0O1xuZXhwb3J0cy5vYmplY3QgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5vYmplY3Q7XG5leHBvcnRzLm9sID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQub2w7XG5leHBvcnRzLm9wdGdyb3VwID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQub3B0Z3JvdXA7XG5leHBvcnRzLm9wdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm9wdGlvbjtcbmV4cG9ydHMucCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnA7XG5leHBvcnRzLnBhcmFtID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucGFyYW07XG5leHBvcnRzLnByZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnByZTtcbmV4cG9ydHMucHJvZ3Jlc3MgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5wcm9ncmVzcztcbmV4cG9ydHMucSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnE7XG5leHBvcnRzLnJwID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucnA7XG5leHBvcnRzLnJ0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucnQ7XG5leHBvcnRzLnJ1YnkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ydWJ5O1xuZXhwb3J0cy5zID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucztcbmV4cG9ydHMuc2FtcCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNhbXA7XG5leHBvcnRzLnNjcmlwdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNjcmlwdDtcbmV4cG9ydHMuc2VjdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNlY3Rpb247XG5leHBvcnRzLnNlbGVjdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNlbGVjdDtcbmV4cG9ydHMuc21hbGwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zbWFsbDtcbmV4cG9ydHMuc291cmNlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc291cmNlO1xuZXhwb3J0cy5zcGFuID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3BhbjtcbmV4cG9ydHMuc3Ryb25nID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3Ryb25nO1xuZXhwb3J0cy5zdHlsZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnN0eWxlO1xuZXhwb3J0cy5zdWIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdWI7XG5leHBvcnRzLnN1cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnN1cDtcbmV4cG9ydHMudGFibGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50YWJsZTtcbmV4cG9ydHMudGJvZHkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50Ym9keTtcbmV4cG9ydHMudGQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50ZDtcbmV4cG9ydHMudGV4dGFyZWEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50ZXh0YXJlYTtcbmV4cG9ydHMudGZvb3QgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50Zm9vdDtcbmV4cG9ydHMudGggPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aDtcbmV4cG9ydHMudGhlYWQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aGVhZDtcbmV4cG9ydHMudGl0bGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aXRsZTtcbmV4cG9ydHMudHIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50cjtcbmV4cG9ydHMudSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnU7XG5leHBvcnRzLnVsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudWw7XG5leHBvcnRzLnZpZGVvID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudmlkZW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXdTY29wZSgpIHtcbiAgICByZXR1cm4gXCJjeWNsZVwiICsgKytjb3VudGVyO1xufVxuZnVuY3Rpb24gY2hlY2tJc29sYXRlQXJncyhkYXRhZmxvd0NvbXBvbmVudCwgc2NvcGUpIHtcbiAgICBpZiAodHlwZW9mIGRhdGFmbG93Q29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gaXNvbGF0ZSgpIG11c3QgYmUgYSBcIiArXG4gICAgICAgICAgICBcIidkYXRhZmxvd0NvbXBvbmVudCcgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGlmIChzY29wZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgZ2l2ZW4gdG8gaXNvbGF0ZSgpIG11c3Qgbm90IGJlIG51bGxcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNvbGF0ZUFsbFNvdXJjZXMoc291cmNlcywgc2NvcGUpIHtcbiAgICB2YXIgc2NvcGVkU291cmNlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2VzKSB7XG4gICAgICAgIGlmIChzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkgJiYgc291cmNlc1trZXldXG4gICAgICAgICAgICAmJiB0eXBlb2Ygc291cmNlc1trZXldLmlzb2xhdGVTb3VyY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2NvcGVkU291cmNlc1trZXldID0gc291cmNlc1trZXldLmlzb2xhdGVTb3VyY2Uoc291cmNlc1trZXldLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBzY29wZWRTb3VyY2VzW2tleV0gPSBzb3VyY2VzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNvdXJjZXM7XG59XG5mdW5jdGlvbiBpc29sYXRlQWxsU2lua3Moc291cmNlcywgc2lua3MsIHNjb3BlKSB7XG4gICAgdmFyIHNjb3BlZFNpbmtzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHNpbmtzKSB7XG4gICAgICAgIGlmIChzaW5rcy5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAmJiBzb3VyY2VzW2tleV1cbiAgICAgICAgICAgICYmIHR5cGVvZiBzb3VyY2VzW2tleV0uaXNvbGF0ZVNpbmsgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2NvcGVkU2lua3Nba2V5XSA9IHNvdXJjZXNba2V5XS5pc29sYXRlU2luayhzaW5rc1trZXldLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2lua3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgc2NvcGVkU2lua3Nba2V5XSA9IHNpbmtzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNpbmtzO1xufVxuLyoqXG4gKiBUYWtlcyBhIGBkYXRhZmxvd0NvbXBvbmVudGAgZnVuY3Rpb24gYW5kIGFuIG9wdGlvbmFsIGBzY29wZWAgc3RyaW5nLCBhbmRcbiAqIHJldHVybnMgYSBzY29wZWQgdmVyc2lvbiBvZiB0aGUgYGRhdGFmbG93Q29tcG9uZW50YCBmdW5jdGlvbi5cbiAqXG4gKiBXaGVuIHRoZSBzY29wZWQgZGF0YWZsb3cgY29tcG9uZW50IGlzIGludm9rZWQsIGVhY2ggc291cmNlIHByb3ZpZGVkIHRvIHRoZVxuICogc2NvcGVkIGRhdGFmbG93Q29tcG9uZW50IGlzIGlzb2xhdGVkIHRvIHRoZSBzY29wZSB1c2luZ1xuICogYHNvdXJjZS5pc29sYXRlU291cmNlKHNvdXJjZSwgc2NvcGUpYCwgaWYgcG9zc2libGUuIExpa2V3aXNlLCB0aGUgc2lua3NcbiAqIHJldHVybmVkIGZyb20gdGhlIHNjb3BlZCBkYXRhZmxvdyBjb21wb25lbnQgYXJlIGlzb2xhdGUgdG8gdGhlIHNjb3BlIHVzaW5nXG4gKiBgc291cmNlLmlzb2xhdGVTaW5rKHNpbmssIHNjb3BlKWAuXG4gKlxuICogSWYgdGhlIGBzY29wZWAgaXMgbm90IHByb3ZpZGVkLCBhIG5ldyBzY29wZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZC5cbiAqIFRoaXMgbWVhbnMgdGhhdCB3aGlsZSAqKmBpc29sYXRlKGRhdGFmbG93Q29tcG9uZW50LCBzY29wZSlgIGlzIHB1cmUqKlxuICogKHJlZmVyZW50aWFsbHkgdHJhbnNwYXJlbnQpLCAqKmBpc29sYXRlKGRhdGFmbG93Q29tcG9uZW50KWAgaXMgaW1wdXJlKipcbiAqIChub3QgcmVmZXJlbnRpYWxseSB0cmFuc3BhcmVudCkuIFR3byBjYWxscyB0byBgaXNvbGF0ZShGb28sIGJhcilgIHdpbGxcbiAqIGdlbmVyYXRlIHR3byBpbmRpc3RpbmN0IGRhdGFmbG93IGNvbXBvbmVudHMuIEJ1dCwgdHdvIGNhbGxzIHRvIGBpc29sYXRlKEZvbylgXG4gKiB3aWxsIGdlbmVyYXRlIHR3byBkaXN0aW5jdCBkYXRhZmxvdyBjb21wb25lbnRzLlxuICpcbiAqIE5vdGUgdGhhdCBib3RoIGBpc29sYXRlU291cmNlKClgIGFuZCBgaXNvbGF0ZVNpbmsoKWAgYXJlIHN0YXRpYyBtZW1iZXJzIG9mXG4gKiBgc291cmNlYC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IGRyaXZlcnMgcHJvZHVjZSBgc291cmNlYCB3aGlsZSB0aGVcbiAqIGFwcGxpY2F0aW9uIHByb2R1Y2VzIGBzaW5rYCwgYW5kIGl0J3MgdGhlIGRyaXZlcidzIHJlc3BvbnNpYmlsaXR5IHRvXG4gKiBpbXBsZW1lbnQgYGlzb2xhdGVTb3VyY2UoKWAgYW5kIGBpc29sYXRlU2luaygpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkYXRhZmxvd0NvbXBvbmVudCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYHNvdXJjZXNgIGFzIGlucHV0XG4gKiBhbmQgb3V0cHV0cyBhIGNvbGxlY3Rpb24gb2YgYHNpbmtzYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzY29wZSBhbiBvcHRpb25hbCBzdHJpbmcgdGhhdCBpcyB1c2VkIHRvIGlzb2xhdGUgZWFjaFxuICogYHNvdXJjZXNgIGFuZCBgc2lua3NgIHdoZW4gdGhlIHJldHVybmVkIHNjb3BlZCBkYXRhZmxvdyBjb21wb25lbnQgaXMgaW52b2tlZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgc2NvcGVkIGRhdGFmbG93IGNvbXBvbmVudCBmdW5jdGlvbiB0aGF0LCBhcyB0aGVcbiAqIG9yaWdpbmFsIGBkYXRhZmxvd0NvbXBvbmVudGAgZnVuY3Rpb24sIHRha2VzIGBzb3VyY2VzYCBhbmQgcmV0dXJucyBgc2lua3NgLlxuICogQGZ1bmN0aW9uIGlzb2xhdGVcbiAqL1xuZnVuY3Rpb24gaXNvbGF0ZShjb21wb25lbnQsIHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBuZXdTY29wZSgpOyB9XG4gICAgY2hlY2tJc29sYXRlQXJncyhjb21wb25lbnQsIHNjb3BlKTtcbiAgICB2YXIgY29udmVydGVkU2NvcGUgPSB0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnID8gc2NvcGUgOiBzY29wZS50b1N0cmluZygpO1xuICAgIHJldHVybiBmdW5jdGlvbiBzY29wZWRDb21wb25lbnQoc291cmNlcykge1xuICAgICAgICB2YXIgcmVzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcmVzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcGVkU291cmNlcyA9IGlzb2xhdGVBbGxTb3VyY2VzKHNvdXJjZXMsIGNvbnZlcnRlZFNjb3BlKTtcbiAgICAgICAgdmFyIHNpbmtzID0gY29tcG9uZW50LmFwcGx5KHZvaWQgMCwgW3Njb3BlZFNvdXJjZXNdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIHZhciBzY29wZWRTaW5rcyA9IGlzb2xhdGVBbGxTaW5rcyhzb3VyY2VzLCBzaW5rcywgY29udmVydGVkU2NvcGUpO1xuICAgICAgICByZXR1cm4gc2NvcGVkU2lua3M7XG4gICAgfTtcbn1cbmlzb2xhdGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudGVyID0gMDsgfTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzb2xhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2lzb2xhdGUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7Y2FwaXRhbGl6ZX0gZnJvbSBcIi4uL3V0aWxzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pY29uVHlwZVwiO1xuXG5cbmV4cG9ydCBlbnVtIFNpemUge1xuICBNaW5pLCBUaW55LCBTbWFsbCwgTWVkaXVtLCBMYXJnZSwgQmlnLCBIdWdlLCBNYXNzaXZlLCBGbHVpZFxufVxuZXhwb3J0IHR5cGUgU2l6ZVN0cmluZyA9IFwibWluaVwifFwidGlueVwifFwic21hbGxcInxcIm1lZGl1bVwifFwibGFyZ2VcInxcImJpZ1wifFwiaHVnZVwifFwibWFzc2l2ZVwifFwiZmx1aWRcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBTaXplIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvRW51bShzaXplT3JTdHJpbmc6IFNpemV8U2l6ZVN0cmluZykgOiBTaXplIHtcbiAgICByZXR1cm4gdHlwZW9mKHNpemVPclN0cmluZykgPT09IFwibnVtYmVyXCIgXG4gICAgICA/IHNpemVPclN0cmluZyBcbiAgICAgIDogU2l6ZVtjYXBpdGFsaXplKHNpemVPclN0cmluZyldO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShzaXplOiBTaXplfFNpemVTdHJpbmcpIHtcbiAgICBzaXplID0gVG9FbnVtKHNpemUpO1xuICAgIHN3aXRjaChzaXplKSB7XG4gICAgICBjYXNlIFNpemUuTWluaTogcmV0dXJuIFwiIG1pbmlcIjtcbiAgICAgIGNhc2UgU2l6ZS5UaW55OiByZXR1cm4gXCIgdGlueVwiO1xuICAgICAgY2FzZSBTaXplLlNtYWxsOiByZXR1cm4gXCIgc21hbGxcIjtcbiAgICAgIGNhc2UgU2l6ZS5NZWRpdW06IHJldHVybiBcIiBtZWRpdW1cIjtcbiAgICAgIGNhc2UgU2l6ZS5MYXJnZTogcmV0dXJuIFwiIGxhcmdlXCI7XG4gICAgICBjYXNlIFNpemUuQmlnOiByZXR1cm4gXCIgYmlnXCI7XG4gICAgICBjYXNlIFNpemUuSHVnZTogcmV0dXJuIFwiIGh1Z2VcIjtcbiAgICAgIGNhc2UgU2l6ZS5NYXNzaXZlOiByZXR1cm4gXCIgbWFzc2l2ZVwiO1xuICAgICAgY2FzZSBTaXplLkZsdWlkOiByZXR1cm4gXCIgZmx1aWRcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBWZXJ0aWNhbEFsaWdubWVudCB7XG4gIFRvcCwgTWlkZGxlLCBCb3R0b21cbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZXJ0aWNhbEFsaWdubWVudCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShhbGlnbm1lbnQ6IFZlcnRpY2FsQWxpZ25tZW50KSB7XG4gICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuVG9wOiByZXR1cm4gXCIgdG9wIGFsaWduZWRcIjtcbiAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuTWlkZGxlOiByZXR1cm4gXCIgbWlkZGxlIGFsaWduZWRcIjtcbiAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOiByZXR1cm4gXCIgYm90dG9tIGFsaWduZWRcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBUZXh0QWxpZ25tZW50IHtcbiAgTGVmdCwgUmlnaHQsIENlbnRlciwgSnVzdGlmaWVkXG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGV4dEFsaWdubWVudCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZShhbGlnbm1lbnQ6IFRleHRBbGlnbm1lbnQpIHtcbiAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgY2FzZSBUZXh0QWxpZ25tZW50LkxlZnQ6IHJldHVybiBcIiBsZWZ0IGFsaWduZWQuXCI7XG4gICAgICBjYXNlIFRleHRBbGlnbm1lbnQuUmlnaHQ6IHJldHVybiBcIiByaWdodCBhbGlnbmVkLlwiO1xuICAgICAgY2FzZSBUZXh0QWxpZ25tZW50LkNlbnRlcjogcmV0dXJuIFwiIGNlbnRlciBhbGlnbmVkXCI7XG4gICAgICBjYXNlIFRleHRBbGlnbm1lbnQuSnVzdGlmaWVkOiByZXR1cm4gXCIganVzdGlmaWVkXCI7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gRmxvYXQge1xuICBOb25lLCBSaWdodCwgTGVmdFxufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZsb2F0IHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGZsb2F0OiBGbG9hdCkge1xuICAgIHN3aXRjaCAoZmxvYXQpXG4gICAge1xuICAgICAgY2FzZSBGbG9hdC5MZWZ0OiByZXR1cm4gXCIgbGVmdCBmbG9hdGVkXCI7XG4gICAgICBjYXNlIEZsb2F0LlJpZ2h0OiByZXR1cm4gXCIgcmlnaHQgZmxvYXRlZFwiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBlbnVtIEF0dGFjaG1lbnQge1xuTm9uZSwgVG9wLCBUb3BSaWdodCwgVG9wTGVmdCwgQm90dG9tLCBCb3R0b21MZWZ0LCBCb3R0b21SaWdodCwgUmlnaHQsIExlZnRcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQpIHtcbiAgICBzd2l0Y2ggKGF0dGFjaG1lbnQpIHtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Ob25lOiByZXR1cm4gXCIgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Ub3A6IHJldHVybiBcIiB0b3AgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Cb3R0b206IHJldHVybiBcIiBib3R0b20gYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5MZWZ0OiByZXR1cm4gXCIgbGVmdCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LlJpZ2h0OiByZXR1cm4gXCIgcmlnaHQgYXR0YWNoZWRcIjtcbiAgICAgIGNhc2UgQXR0YWNobWVudC5Ub3BSaWdodDogcmV0dXJuIFwiIHRvcCByaWdodCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LlRvcExlZnQ6IHJldHVybiBcIiB0b3AgbGVmdCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LkJvdHRvbUxlZnQ6IHJldHVybiBcIiBib3R0b20gbGVmdCBhdHRhY2hlZFwiO1xuICAgICAgY2FzZSBBdHRhY2htZW50LkJvdHRvbVJpZ2h0OiByZXR1cm4gXCIgYm90dG9tIHJpZ2h0IGF0dGFjaGVkXCI7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gQ29sb3Ige1xuICBOb25lLCBQcmltYXJ5LCBTZWNvbmRhcnksIFN1Y2Nlc3MsIEluZm8sIFdhcm5pbmcsIEVycm9yXG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29sb3Ige1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUoY29sb3I6IENvbG9yKSB7XG4gICAgc3dpdGNoIChjb2xvcikge1xuICAgICAgY2FzZSBDb2xvci5QcmltYXJ5OiByZXR1cm4gXCIgcHJpbWFyeUNvbG9yZWRcIjtcbiAgICAgIGNhc2UgQ29sb3IuU2Vjb25kYXJ5OiByZXR1cm4gXCIgc2Vjb25kYXJ5Q29sb3JlZFwiO1xuICAgICAgY2FzZSBDb2xvci5TdWNjZXNzOiByZXR1cm4gXCIgc3VjY2Vzc0NvbG9yZWRcIjtcbiAgICAgIGNhc2UgQ29sb3IuSW5mbzogcmV0dXJuIFwiIGluZm9Db2xvcmVkXCI7XG4gICAgICBjYXNlIENvbG9yLldhcm5pbmc6IHJldHVybiBcIiB3YXJuaW5nQ29sb3JlZFwiO1xuICAgICAgY2FzZSBDb2xvci5FcnJvcjogcmV0dXJuIFwiIGVycm9yQ29sb3JlZCBcIjtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBBbmltYXRpb24ge1xuICBCcm93c2UsIERyb3AsIEZhZGUsIEZsaXAsIFNjYWxlLCBGbHksIFNsaWRlLCBTd2luZyxcbiAgRmxhc2gsIFNoYWtlLCBCb3VuY2UsIFRhZGEsIFB1bHNlLCBKaWdnbGUsXG4gIE5vbmVcbn1cbmV4cG9ydCBuYW1lc3BhY2UgQW5pbWF0aW9uIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGFuaW06IEFuaW1hdGlvbikge1xuICAgIHN3aXRjaCAoYW5pbSlcbiAgICB7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5Ccm93c2U6IHJldHVybiBcIiBicm93c2VcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkRyb3A6IHJldHVybiBcIiBkcm9wXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5GYWRlOiByZXR1cm4gXCIgZmFkZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uRmxpcDogcmV0dXJuIFwiIGZsaXBcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLlNjYWxlOiByZXR1cm4gXCIgc2NhbGVcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uLkZseTogcmV0dXJuIFwiIGZseVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uU2xpZGU6IHJldHVybiBcIiBzbGlkZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uU3dpbmc6IHJldHVybiBcIiBzd2luZ1wiO1xuICAgICAgY2FzZSBBbmltYXRpb24uRmxhc2g6IHJldHVybiBcIiBmbGFzaFwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uU2hha2U6IHJldHVybiBcIiBzaGFrZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uQm91bmNlOiByZXR1cm4gXCIgYm91bmNlXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbi5UYWRhOiByZXR1cm4gXCIgdGFkYVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uUHVsc2U6IHJldHVybiBcIiBwdWxzZVwiO1xuICAgICAgY2FzZSBBbmltYXRpb24uSmlnZ2xlOiByZXR1cm4gXCIgamlnZ2xlXCI7XG4gICAgfVxuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBpc1N0YXRpYyhhbmltOiBBbmltYXRpb24pOiBCb29sZWFuIHtcbiAgICBjb25zdCBzdGF0aWNBbmltYXRpb25zID0gW0FuaW1hdGlvbi5GbGFzaCwgQW5pbWF0aW9uLlNoYWtlLFxuICAgICAgQW5pbWF0aW9uLkJvdW5jZSwgQW5pbWF0aW9uLlRhZGEsIEFuaW1hdGlvbi5QdWxzZSwgQW5pbWF0aW9uLkppZ2dsZV07XG4gICAgcmV0dXJuIHN0YXRpY0FuaW1hdGlvbnMuaW5kZXhPZihhbmltKSAhPT0gLTE7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIGlzRGlyZWN0aW9uYWwoYW5pbTogQW5pbWF0aW9uKTogQm9vbGVhbiB7XG4gICAgY29uc3QgZGlyZWN0aW9uQW5pbWF0aW9ucyA9IFtBbmltYXRpb24uQnJvd3NlLCBBbmltYXRpb24uRmFkZSxcbiAgICAgIEFuaW1hdGlvbi5GbHksIEFuaW1hdGlvbi5TbGlkZSwgQW5pbWF0aW9uLlN3aW5nXTtcbiAgICByZXR1cm4gZGlyZWN0aW9uQW5pbWF0aW9ucy5pbmRleE9mKGFuaW0pICE9PSAtMTtcbiAgfVxufVxuXG5leHBvcnQgZW51bSBEaXJlY3Rpb24ge1xuICBJbiwgT3V0LCBOb25lXG59XG5leHBvcnQgbmFtZXNwYWNlIERpcmVjdGlvbiB7XG4gIGV4cG9ydCBmdW5jdGlvbiBUb0NsYXNzbmFtZSAoZGlyZWN0aW9uOiBEaXJlY3Rpb24pe1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5JbiA/IFwiIGluXCIgOiBcIiBvdXRcIjtcbiAgfVxufVxuXG5leHBvcnQgZW51bSBBbmltYXRpb25EaXJlY3Rpb24ge1xuICBVcCwgRG93biwgTGVmdCwgUmlnaHRcbn1cbmV4cG9ydCBuYW1lc3BhY2UgQW5pbWF0aW9uRGlyZWN0aW9uIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGRpcjogQW5pbWF0aW9uRGlyZWN0aW9uKSB7XG4gICAgc3dpdGNoIChkaXIpIHtcbiAgICAgIGNhc2UgQW5pbWF0aW9uRGlyZWN0aW9uLlVwOiByZXR1cm4gXCIgdXBcIjtcbiAgICAgIGNhc2UgQW5pbWF0aW9uRGlyZWN0aW9uLkRvd246IHJldHVybiBcIiBkb3duXCI7XG4gICAgICBjYXNlIEFuaW1hdGlvbkRpcmVjdGlvbi5MZWZ0OiByZXR1cm4gXCIgbGVmdFwiO1xuICAgICAgY2FzZSBBbmltYXRpb25EaXJlY3Rpb24uUmlnaHQ6IHJldHVybiBcIiByaWdodFwiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZW51bXMvaW5kZXgudHMiLCJpbXBvcnQge0RPTVNvdXJjZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmV4cG9ydCB7RE9NU291cmNlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHtWTm9kZX0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmV4cG9ydCB7Vk5vZGV9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMsIHtTdHJlYW19IGZyb20gXCJ4c3RyZWFtXCI7XG5cbmV4cG9ydCB0eXBlIERPTUNvbnRlbnQgPSBTdHJpbmcgfCBWTm9kZVtdO1xuZXhwb3J0IHR5cGUgRXZlbnRTZWxlY3RvciA9ICh0eXBlOnN0cmluZykgPT4gU3RyZWFtPEV2ZW50PjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRE9NQ29udGVudChjb250ZW50KSA6IGNvbnRlbnQgaXMgRE9NQ29udGVudCB7XG4gIGlmICghY29udGVudCl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YoY29udGVudCkgPT09IFwic3RyaW5nXCIpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YoQXJyYXkpKSB7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZW50WzBdLnNlbCAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UCxDPiB7XG4gIERPTTogRE9NU291cmNlO1xuICBwcm9wcyQ/OiB4czxQPjtcbiAgY29udGVudCQ/OiB4czxDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UCxDLEU+IHtcbiAgRE9NOiBET01Tb3VyY2U7XG4gIHByb3BzJD86IHhzPFA+O1xuICBjb250ZW50JD86IHhzPEM+O1xuICBleHRyYXMkPzogeHM8RT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFQsQSxDPiB7XG4gIERPTTogRE9NU291cmNlO1xuICB0YXJnZXQkOiB4czxUPjtcbiAgYXJncyQ/OiB4czxBPjtcbiAgY29udGVudCQ/OiB4czxDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gIERPTTogeHM8Vk5vZGU+O1xuICBFdmVudHM6IEV2ZW50U2VsZWN0b3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZhbHVlQ29tcG9uZW50U2lua3M8Vj4gZXh0ZW5kcyBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gIHZhbHVlJDogeHM8Vj47XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW50ZXJmYWNlcy9pbmRleC50cyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciBYU3RyZWFtQWRhcHRlciA9IHtcbiAgICBhZGFwdDogZnVuY3Rpb24gKG9yaWdpblN0cmVhbSwgb3JpZ2luU3RyZWFtU3Vic2NyaWJlKSB7XG4gICAgICAgIGlmIChYU3RyZWFtQWRhcHRlci5pc1ZhbGlkU3RyZWFtKG9yaWdpblN0cmVhbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5TdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB2YXIgZGlzcG9zZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdC5jcmVhdGUoe1xuICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBvdXQ7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSA9IG9yaWdpblN0cmVhbVN1YnNjcmliZShvcmlnaW5TdHJlYW0sIG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1ha2VTdWJqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSB4c3RyZWFtXzEuZGVmYXVsdC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHgpIHsgc3RyZWFtLnNoYW1lZnVsbHlTZW5kTmV4dCh4KTsgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHN0cmVhbS5zaGFtZWZ1bGx5U2VuZEVycm9yKGVycik7IH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyBzdHJlYW0uc2hhbWVmdWxseVNlbmRDb21wbGV0ZSgpOyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBvYnNlcnZlcjogb2JzZXJ2ZXIsIHN0cmVhbTogc3RyZWFtIH07XG4gICAgfSxcbiAgICByZW1lbWJlcjogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnJlbWVtYmVyKCk7XG4gICAgfSxcbiAgICBpc1ZhbGlkU3RyZWFtOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHN0cmVhbS5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHN0cmVhbS5zaGFtZWZ1bGx5U2VuZE5leHQgPT09ICdmdW5jdGlvbicpO1xuICAgIH0sXG4gICAgc3RyZWFtU3Vic2NyaWJlOiBmdW5jdGlvbiAoc3RyZWFtLCBvYnNlcnZlcikge1xuICAgICAgICBzdHJlYW0uYWRkTGlzdGVuZXIob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyZWFtLnJlbW92ZUxpc3RlbmVyKG9ic2VydmVyKTsgfTtcbiAgICB9LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFhTdHJlYW1BZGFwdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS94c3RyZWFtLWFkYXB0ZXIvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7Vk5vZGV9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMsIHtTdHJlYW19IGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgZmxhdHRlbkNvbmN1cnJlbnRseSBmcm9tIFwieHN0cmVhbS9leHRyYS9mbGF0dGVuQ29uY3VycmVudGx5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZzogc3RyaW5nKSA6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENsYXNzTGlzdCh0YXJnZXQ6IFZOb2RlLCBjbGFzc2VzOiBzdHJpbmdbXSwgY2xhc3Nlc1RvQWRkOiBzdHJpbmcpIHtcbiAgbGV0IGNsYXNzTmFtZSA9IFwiXCI7XG4gIGlmICh0YXJnZXQuZGF0YSkge1xuICAgIGxldCBwcm9wcyA9IHRhcmdldC5kYXRhLnByb3BzID8gdGFyZ2V0LmRhdGEucHJvcHMgOiB7IGNsYXNzTmFtZTogdGFyZ2V0LnNlbC5zcGxpdChcIi5cIikuam9pbihcIiBcIil9O1xuICAgIGxldCBjbGFzc0xpc3QgPSBwcm9wcy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpIGFzIEFycmF5PHN0cmluZz47XG4gICAgY2xhc3NMaXN0LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICBjbGFzc05hbWUgKz0gaXRlbSArIFwiIFwiO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsYXNzTmFtZSArPSBjbGFzc2VzVG9BZGQ7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZGF0YSwge1xuICAgIFwicHJvcHNcIjoge1xuICAgICAgY2xhc3NOYW1lXG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBBZGRzIG9uZSBWTm9kZSB0byBhbm90aGVyIGFuZCBoYW5kbGVzIHVwZGF0ZXMgZm9yIHN0cmVhbSBieSByZXBsYWNpbmcgYmFzZWQgb24gdGhlIGlkZW50aWZpZXIgY2xhc3MuXG4gKiBAcGFyYW0gIHtWTm9kZX0gIGVsZW1lbnQgICAgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQuXG4gKiBAcGFyYW0gIHtWTm9kZX0gIHRhcmdldCAgICAgVGhlIHRhcmdldCBmb3IgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZnlpbmcgY2xhc3MgZm9yIHRoZSBlbGVtZW50IHRvIGJlIGFkZGVkLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSB0YXJnZXQgZWxlbWVudCdzIGNoaWxkcmVuIHdpdGggdGhlIGVsZW1lbnQgYWRkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFbGVtZW50KGVsZW1lbnQ6IFZOb2RlLCB0YXJnZXQ6IFZOb2RlLCBpZGVudGlmaWVyOiBzdHJpbmcpOiBBcnJheTxWTm9kZT4ge1xuICBsZXQgYyA9IFtdO1xuICBpZiAodGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgYyA9IHRhcmdldC5jaGlsZHJlbjtcbiAgfVxuICBpZiAodGFyZ2V0LnRleHQpIHtcbiAgICBjLnB1c2godGFyZ2V0LnRleHQpO1xuICB9XG4gIGZvcihsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoaWxkID0gY1tpXTtcbiAgICBsZXQgY1Byb3BzID0gY2hpbGQuZGF0YSA/IGNoaWxkLmRhdGEucHJvcHMgPyBjaGlsZC5kYXRhLnByb3BzIDoge30gOiB7fTtcbiAgICBpZiAodHlwZW9mKGNoaWxkKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YoY1Byb3BzLmNsYXNzTmFtZSkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAge1xuICAgICAgbGV0IGNsYXNzTGlzdCA9IGNoaWxkLmRhdGEucHJvcHMuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSBhcyBBcnJheTxzdHJpbmc+O1xuICAgICAgZm9yIChsZXQgcyBvZiBjbGFzc0xpc3QpIHtcbiAgICAgICAgaWYgKHMgPT09IGlkZW50aWZpZXIpXG4gICAgICAgIHtcbiAgICAgICAgICBjLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjLnB1c2goZWxlbWVudCk7XG4gIHJldHVybiBjO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFueXRoaW5nIHRvIGEgc3RyZWFtXG4gKiBAcGFyYW0gIHthbnl9IG9iaiAtIFRoZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtTdHJlYW08YW55Pn0gVGhlIG9iamVjdCBhcyBhIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyZWFtKG9iaik6IFN0cmVhbTxhbnk+IHtcbiAgaWYgKHR5cGVvZihvYmopICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZihvYmouYWRkTGlzdGVuZXIpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKXtcbiAgICAgICAgbGV0IGlzU3RyZWFtcyA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHN1Ym9iaiBvZiBvYmopIHtcbiAgICAgICAgICBpZiAodHlwZW9mKHN1Ym9iai5hZGRMaXN0ZW5lcikgIT09IFwiZnVuY3Rpb25cIil7XG4gICAgICAgICAgICBpc1N0cmVhbXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyZWFtcykge1xuICAgICAgICAgIHJldHVybiB4cy5jb21iaW5lLmFwcGx5KHRoaXMsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzLm9mKG9iaik7XG4gIH1cbiAgcmV0dXJuIHhzLm9mKFwiXCIpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9mIG9iamVjdHMgdG8gYSBzdHJlYW0gb2YgYW4gQXJyYXkuXG4gKiBAcGFyYW0gIHthbnl9IC4uLm9ianMgICBUaGUgb2JqZWN0cyB0byBpbmNsdWRlIGluIHRoZSBzdHJlYW1cbiAqIEByZXR1cm4ge1N0cmVhbTxhbnlbXT59IFRoZSBvYmplY3RzIGFzIGEgc3RyZWFtIG9mIGFuIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheVN0cmVhbSguLi5vYmpzKSA6IFN0cmVhbTxhbnlbXT4ge1xuICBsZXQgc3RyZWFtcyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgc3RyZWFtcyA9IHN0cmVhbXMubWFwKG9iaiA9PiBhc1N0cmVhbShvYmopKTtcbiAgcmV0dXJuIHhzLmNvbWJpbmUuYXBwbHkodGhpcywgc3RyZWFtcyk7XG59XG5cbi8qKlxuICogRmxhdHRlbnMgYSBzdHJlYW0gb2YgYW4gYXJyYXkgb2Ygc3RyZWFtcyBpbnRvIGEgc3RyZWFtIG9mIGFuIGFycmF5LlxuICogQHBhcmFtICB7U3RyZWFtPFN0cmVhbTxhbnk+W10+fSBzdHJlYW0gVGhlIHN0cmVhbSB0byBmbGF0dGVuXG4gKiBAcmV0dXJuIHtTdHJlYW08YW55W10+fSAgICAgICAgICAgICAgICBUaGUgZmxhdHRlbmVkIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5TdHJlYW1BcnJheShzdHJlYW06IFN0cmVhbTxTdHJlYW08YW55PltdPikgOiBTdHJlYW08YW55W10+IHtcbiAgcmV0dXJuIGZsYXR0ZW5Db25jdXJyZW50bHkoXG4gICAgc3RyZWFtLm1hcChjaGlsZHJlbiA9PiB4cy5jb21iaW5lLmFwcGx5KHRoaXMsIGNoaWxkcmVuKVxuICApXG4gICkgYXMgU3RyZWFtPGFueVtdPjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIG5hdHVyYWwgbnVtYmVyIGJldHdlZW4gMS0xNiB0byB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybiB7c3RyaW5nfSAgICAgVGhhdCBudW1iZXIgYXMgdGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bVRvVGV4dChudW06IG51bWJlcikgOiBzdHJpbmcge1xuICBzd2l0Y2gobnVtKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gXCIgb25lXCI7XG4gICAgY2FzZSAyOiByZXR1cm4gXCIgdHdvXCI7XG4gICAgY2FzZSAzOiByZXR1cm4gXCIgdGhyZWVcIjtcbiAgICBjYXNlIDQ6IHJldHVybiBcIiBmb3VyXCI7XG4gICAgY2FzZSA1OiByZXR1cm4gXCIgZml2ZVwiO1xuICAgIGNhc2UgNjogcmV0dXJuIFwiIHNpeFwiO1xuICAgIGNhc2UgNzogcmV0dXJuIFwiIHNldmVuXCI7XG4gICAgY2FzZSA4OiByZXR1cm4gXCIgZWlnaHRcIjtcbiAgICBjYXNlIDk6IHJldHVybiBcIiBuaW5lXCI7XG4gICAgY2FzZSAxMDogcmV0dXJuIFwiIHRlblwiO1xuICAgIGNhc2UgMTE6IHJldHVybiBcIiBlbGV2ZW5cIjtcbiAgICBjYXNlIDEyOiByZXR1cm4gXCIgdHdlbHZlXCI7XG4gICAgY2FzZSAxMzogcmV0dXJuIFwiIHRoaXJ0ZWVuXCI7XG4gICAgY2FzZSAxNDogcmV0dXJuIFwiIGZvdXJ0ZWVuXCI7XG4gICAgY2FzZSAxNTogcmV0dXJuIFwiIGZpZnRlZW5cIjtcbiAgICBjYXNlIDE2OiByZXR1cm4gXCIgc2l4dGVlblwiO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaW5kZXgudHMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZVBhdGggPSBleHBvcnRzLnBhcnNlUGF0aCA9IGV4cG9ydHMuZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5zdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCA9IGV4cG9ydHMuaXNBYnNvbHV0ZVBhdGggPSB1bmRlZmluZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaXNBYnNvbHV0ZVBhdGggPSBleHBvcnRzLmlzQWJzb2x1dGVQYXRoID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgocGF0aCkge1xuICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG52YXIgYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCA9IGV4cG9ydHMuYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCA9IGZ1bmN0aW9uIGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwga2V5LCB2YWx1ZSkge1xuICB2YXIgX3BhcnNlUGF0aCA9IHBhcnNlUGF0aChwYXRoKTtcblxuICB2YXIgcGF0aG5hbWUgPSBfcGFyc2VQYXRoLnBhdGhuYW1lO1xuICB2YXIgc2VhcmNoID0gX3BhcnNlUGF0aC5zZWFyY2g7XG4gIHZhciBoYXNoID0gX3BhcnNlUGF0aC5oYXNoO1xuXG5cbiAgcmV0dXJuIGNyZWF0ZVBhdGgoe1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCArIChzZWFyY2guaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBrZXkgKyAnPScgKyB2YWx1ZSxcbiAgICBoYXNoOiBoYXNoXG4gIH0pO1xufTtcblxudmFyIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5zdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgX3BhcnNlUGF0aDIgPSBwYXJzZVBhdGgocGF0aCk7XG5cbiAgdmFyIHBhdGhuYW1lID0gX3BhcnNlUGF0aDIucGF0aG5hbWU7XG4gIHZhciBzZWFyY2ggPSBfcGFyc2VQYXRoMi5zZWFyY2g7XG4gIHZhciBoYXNoID0gX3BhcnNlUGF0aDIuaGFzaDtcblxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gucmVwbGFjZShuZXcgUmVnRXhwKCcoWz8mXSknICsga2V5ICsgJz1bYS16QS1aMC05XSsoJj8pJyksIGZ1bmN0aW9uIChtYXRjaCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBwcmVmaXggPT09ICc/JyA/IHByZWZpeCA6IHN1ZmZpeDtcbiAgICB9KSxcbiAgICBoYXNoOiBoYXNoXG4gIH0pO1xufTtcblxudmFyIGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZnVuY3Rpb24gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgX3BhcnNlUGF0aDMgPSBwYXJzZVBhdGgocGF0aCk7XG5cbiAgdmFyIHNlYXJjaCA9IF9wYXJzZVBhdGgzLnNlYXJjaDtcblxuICB2YXIgbWF0Y2ggPSBzZWFyY2gubWF0Y2gobmV3IFJlZ0V4cCgnWz8mXScgKyBrZXkgKyAnPShbYS16QS1aMC05XSspJykpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59O1xuXG52YXIgZXh0cmFjdFBhdGggPSBmdW5jdGlvbiBleHRyYWN0UGF0aChzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eKGh0dHBzPzopP1xcL1xcL1teXFwvXSovKTtcbiAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBzdHJpbmcgOiBzdHJpbmcuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG59O1xuXG52YXIgcGFyc2VQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBleHRyYWN0UGF0aChwYXRoKTtcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHBhdGggPT09IHBhdGhuYW1lLCAnQSBwYXRoIG11c3QgYmUgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoIG9ubHksIG5vdCBhIGZ1bGwgVVJMIGxpa2UgXCIlc1wiJywgcGF0aCkgOiB2b2lkIDA7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgaWYgKHBhdGhuYW1lID09PSAnJykgcGF0aG5hbWUgPSAnLyc7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaFxuICB9O1xufTtcblxudmFyIGNyZWF0ZVBhdGggPSBleHBvcnRzLmNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIGlmIChsb2NhdGlvbiA9PSBudWxsIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBsb2NhdGlvbjtcblxuICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZTtcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaDtcblxuICBpZiAoaGFzaCkgcGF0aCArPSBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9hc3NpZ24nKVxuICAsIG5vcm1hbGl6ZU9wdHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucycpXG4gICwgaXNDYWxsYWJsZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlJylcbiAgLCBjb250YWlucyAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucycpXG5cbiAgLCBkO1xuXG5kID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZHNjciwgdmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCB3LCBvcHRpb25zLCBkZXNjO1xuXHRpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB8fCAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSkge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHcgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ3cnKTtcblx0fVxuXG5cdGRlc2MgPSB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlLCB3cml0YWJsZTogdyB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuZC5ncyA9IGZ1bmN0aW9uIChkc2NyLCBnZXQsIHNldC8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IGdldDtcblx0XHRnZXQgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbM107XG5cdH1cblx0aWYgKGdldCA9PSBudWxsKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKGdldCkpIHtcblx0XHRvcHRpb25zID0gZ2V0O1xuXHRcdGdldCA9IHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChzZXQgPT0gbnVsbCkge1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdH1cblxuXHRkZXNjID0geyBnZXQ6IGdldCwgc2V0OiBzZXQsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMuc3RhdGVzQXJlRXF1YWwgPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVRdWVyeSA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVRdWVyeSA9IGV4cG9ydHMuY3JlYXRlUXVlcnkgPSBmdW5jdGlvbiBjcmVhdGVRdWVyeShwcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoT2JqZWN0LmNyZWF0ZShudWxsKSwgcHJvcHMpO1xufTtcblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKCkge1xuICB2YXIgaW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnLycgOiBhcmd1bWVudHNbMF07XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBvYmplY3QgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShpbnB1dCkgOiBpbnB1dDtcblxuICB2YXIgcGF0aG5hbWUgPSBvYmplY3QucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gb2JqZWN0LnNlYXJjaCB8fCAnJztcbiAgdmFyIGhhc2ggPSBvYmplY3QuaGFzaCB8fCAnJztcbiAgdmFyIHN0YXRlID0gb2JqZWN0LnN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGtleToga2V5XG4gIH07XG59O1xuXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gaXNEYXRlKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnZhciBzdGF0ZXNBcmVFcXVhbCA9IGV4cG9ydHMuc3RhdGVzQXJlRXF1YWwgPSBmdW5jdGlvbiBzdGF0ZXNBcmVFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgdHlwZW9mQSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKTtcbiAgdmFyIHR5cGVvZkIgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKHR5cGVvZkEgIT09IHR5cGVvZkIpIHJldHVybiBmYWxzZTtcblxuICAhKHR5cGVvZkEgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBtdXN0IG5vdCBzdG9yZSBmdW5jdGlvbnMgaW4gbG9jYXRpb24gc3RhdGUnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gTm90IHRoZSBzYW1lIG9iamVjdCwgYnV0IHNhbWUgdHlwZS5cbiAgaWYgKHR5cGVvZkEgPT09ICdvYmplY3QnKSB7XG4gICAgISEoaXNEYXRlKGEpICYmIGlzRGF0ZShiKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IG11c3Qgbm90IHN0b3JlIERhdGUgb2JqZWN0cyBpbiBsb2NhdGlvbiBzdGF0ZScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkgcmV0dXJuIE9iamVjdC5rZXlzKGEpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBzdGF0ZXNBcmVFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBzdGF0ZXNBcmVFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBBbGwgb3RoZXIgc2VyaWFsaXphYmxlIHR5cGVzIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbilcbiAgLy8gc2hvdWxkIGJlIHN0cmljdCBlcXVhbC5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEua2V5ID09PSBiLmtleSAmJlxuICAvLyBhLmFjdGlvbiA9PT0gYi5hY3Rpb24gJiYgLy8gRGlmZmVyZW50IGFjdGlvbiAhPT0gbG9jYXRpb24gY2hhbmdlLlxuICBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBzdGF0ZXNBcmVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0xvY2F0aW9uVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFZOb2RlLCBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IEFuaW1hdGlvbiwgQW5pbWF0aW9uRGlyZWN0aW9uLCBEaXJlY3Rpb24gfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBUcmFuc2l0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2l0aW9uIHtcbiAgICBhbmltYXRpb246IEFuaW1hdGlvbjtcbiAgICBkaXJlY3Rpb24/OiBEaXJlY3Rpb247XG4gICAgYW5pbWF0aW9uRGlyZWN0aW9uPzogQW5pbWF0aW9uRGlyZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdHJhbnNpdGlvbiB3cmFwcGVyIGZvciBhbmltYXRpbmcgZG9tIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyB0YXJnZXRzOiBWTm9kZVxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOiB7fSBvZlxuICAgKiAgIGFuaW1hdGlvbjogQW5pbWF0aW9uIC0gVGhlIGFuaW1hdGlvbiB0byB1c2UuXG4gICAqICAgZGlyZWN0aW9uPzogRGlyZWN0aW9uIC0gV2V0aGVyIHRvIGFuaW1hdGUgdG8gdmlzaWJsZSBvciBpbnZpc2libGUuXG4gICAqICAgYW5pbWF0aW9uRGlyZWN0aW9uPzogQW5pbWF0aW9uRGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICogRGlzcmVnYXJkcyBhbnkgY29udGVudC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFZOb2RlLCBUcmFuc2l0aW9uLCBhbnk+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSVRhcmdldHRpbmdDb21wb25lbnRTb3VyY2VzPFZOb2RlLCBUcmFuc2l0aW9uLCBhbnk+KSB7XG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnRyYW5zaXRpb25cIikuZXZlbnRzKHR5cGUpO1xuICAgICAgc291cmNlcy5hcmdzJCA9IHNvdXJjZXMuYXJncyQgPyBzb3VyY2VzLmFyZ3MkIDogeHMub2YoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IERpcmVjdGlvbi5PdXQgfSk7XG5cbiAgICAgIGxldCBhbmltYXRpb25FbmQkID0gZXZ0KFwiYW5pbWF0aW9uZW5kXCIpLm1hcChldnQgPT4gKHtcbiAgICAgICAgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSxcbiAgICAgICAgZGlyZWN0aW9uOiAoZXZ0LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQpLmNsYXNzTGlzdC5jb250YWlucyhcIm91dFwiKSA/IERpcmVjdGlvbi5PdXQgOiBEaXJlY3Rpb24uSW5cbiAgICAgIH0pKSBhcyBTdHJlYW08VHJhbnNpdGlvbj47XG4gICAgICBsZXQgYW5pbWF0aW9uJCA9IHhzLm1lcmdlKHNvdXJjZXMuYXJncyQsIGFuaW1hdGlvbkVuZCQpO1xuXG4gICAgICBsZXQgdlRyZWUkID0geHMuY29tYmluZShhbmltYXRpb24kLCBzb3VyY2VzLnRhcmdldCQpLm1hcChcbiAgICAgICAgKFt0cmFuc2l0aW9uLCB0YXJnZXRdKSA9PiByZW5kZXIodGFyZ2V0LCB0cmFuc2l0aW9uKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIudHJhbnNpdGlvblwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHRyYW5zaXRpb24gd3JhcHBlciBmb3IgYW5pbWF0aW5nIGRvbSBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdGFyZ2V0czogVk5vZGVcbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czoge30gb2ZcbiAgICogICBhbmltYXRpb246IEFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdG8gdXNlLlxuICAgKiAgIGRpcmVjdGlvbj86IERpcmVjdGlvbiAtIFdldGhlciB0byBhbmltYXRlIHRvIHZpc2libGUgb3IgaW52aXNpYmxlLlxuICAgKiAgIGFuaW1hdGlvbkRpcmVjdGlvbj86IEFuaW1hdGlvbkRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gZm9yIHRoZSBhbmltYXRpb24uXG4gICAqIERpc3JlZ2FyZHMgYW55IGNvbnRlbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHRhcmdldDogVk5vZGUsIGFyZ3M6IFRyYW5zaXRpb24gPSB7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUgfSk6IFZOb2RlIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJcIiwgYztcbiAgICBpZiAodGFyZ2V0LmRhdGEpIHtcbiAgICAgIGxldCBjbGFzc0xpc3QgPSB0YXJnZXQuZGF0YS5wcm9wcy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpIGFzIEFycmF5PHN0cmluZz47XG4gICAgICBjbGFzc0xpc3QuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKFtcImhpZGRlblwiLCBcInZpc2libGVcIiwgXCJhbmltYXRpbmdcIiwgXCJ0cmFuc2l0aW9uXCJdLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgY2xhc3NOYW1lICs9IGl0ZW0gKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBnZXRDbGFzc05hbWUoYXJncyk7XG4gICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5kYXRhLCB7XG4gICAgICBcInByb3BzXCI6IHtcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhcmdldC5jaGlsZHJlbikge1xuICAgICAgYyA9IHRhcmdldC5jaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKHRhcmdldC50ZXh0KSB7XG4gICAgICBjID0gdGFyZ2V0LnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBoKHRhcmdldC5zZWwsIGRhdGEsIGMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZSh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKTogc3RyaW5nIHtcbiAgICBpZiAodHJhbnNpdGlvbi5hbmltYXRpb24gPT09IEFuaW1hdGlvbi5Ob25lKSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbi5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5PdXQgPyBcInRyYW5zaXRpb24gaGlkZGVuXCIgOiBcInRyYW5zaXRpb24gdmlzaWJsZVwiO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uID0gQW5pbWF0aW9uLlRvQ2xhc3NuYW1lKHRyYW5zaXRpb24uYW5pbWF0aW9uKTtcbiAgICBpZiAoQW5pbWF0aW9uLmlzU3RhdGljKHRyYW5zaXRpb24uYW5pbWF0aW9uKSkge1xuICAgICAgcmV0dXJuIFwidmlzaWJsZSBhbmltYXRpbmcgdHJhbnNpdGlvbiBcIiArIGFuaW1hdGlvbjtcbiAgICB9XG4gICAgbGV0IGRpcmVjdGlvbiA9IERpcmVjdGlvbi5Ub0NsYXNzbmFtZSh0cmFuc2l0aW9uLmRpcmVjdGlvbik7XG4gICAgaWYgKEFuaW1hdGlvbi5pc0RpcmVjdGlvbmFsKHRyYW5zaXRpb24uYW5pbWF0aW9uKSkge1xuICAgICAgYW5pbWF0aW9uICs9IEFuaW1hdGlvbkRpcmVjdGlvbi5Ub0NsYXNzbmFtZSh0cmFuc2l0aW9uLmFuaW1hdGlvbkRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBcInZpc2libGUgdHJhbnNpdGlvbiBhbmltYXRpbmcgXCIgKyBkaXJlY3Rpb24gKyBhbmltYXRpb247XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL3RyYW5zaXRpb24vaW5kZXgudHMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwib2JqZWN0XCIgP1xuICAgICAgICBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBvYmogaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IDpcbiAgICAgICAgb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmXG4gICAgICAgICAgICAob2JqLm5vZGVUeXBlID09PSAxIHx8IG9iai5ub2RlVHlwZSA9PT0gMTEpICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLm5vZGVOYW1lID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0cy5TQ09QRV9QUkVGSVggPSBcIiQkQ1lDTEVET00kJC1cIjtcbmZ1bmN0aW9uIGdldEVsZW1lbnQoc2VsZWN0b3JzKSB7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSB0eXBlb2Ygc2VsZWN0b3JzID09PSAnc3RyaW5nJyA/XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKSA6XG4gICAgICAgIHNlbGVjdG9ycztcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9ycyA9PT0gJ3N0cmluZycgJiYgZG9tRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVuZGVyIGludG8gdW5rbm93biBlbGVtZW50IGBcIiArIHNlbGVjdG9ycyArIFwiYFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQgbmVpdGhlciBhIFwiICtcbiAgICAgICAgICAgIFwic2VsZWN0b3Igc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5leHBvcnRzLmdldEVsZW1lbnQgPSBnZXRFbGVtZW50O1xuZnVuY3Rpb24gZ2V0U2NvcGUobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIG5hbWVzcGFjZVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmluZGV4T2YoZXhwb3J0cy5TQ09QRV9QUkVGSVgpID4gLTE7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVwbGFjZShleHBvcnRzLlNDT1BFX1BSRUZJWCwgJycpOyB9KVxuICAgICAgICAuam9pbihcIi1cIik7XG59XG5leHBvcnRzLmdldFNjb3BlID0gZ2V0U2NvcGU7XG5mdW5jdGlvbiBnZXRTZWxlY3RvcnMobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIG5hbWVzcGFjZS5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuaW5kZXhPZihleHBvcnRzLlNDT1BFX1BSRUZJWCkgPT09IC0xOyB9KS5qb2luKFwiIFwiKTtcbn1cbmV4cG9ydHMuZ2V0U2VsZWN0b3JzID0gZ2V0U2VsZWN0b3JzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKCkgPyBTeW1ib2wgOiByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXN5bWJvbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG52YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBleHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW52YXJpYW50L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnB1c2guXG4gKi9cbnZhciBQVVNIID0gZXhwb3J0cy5QVVNIID0gJ1BVU0gnO1xuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5yZXBsYWNlLlxuICovXG52YXIgUkVQTEFDRSA9IGV4cG9ydHMuUkVQTEFDRSA9ICdSRVBMQUNFJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gZXhwb3J0cy5QT1AgPSAnUE9QJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvQWN0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5OiBBcnJheS5pc0FycmF5LFxuICBwcmltaXRpdmU6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcyA9PT0gJ251bWJlcic7IH0sXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL2lzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgKiBmcm9tIFwiLi4vc3JjXCI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy91aS50cyIsImltcG9ydCB7IFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgU2l6ZSwgSWNvblR5cGUgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBpIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBJY29uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgYnV0dG9uPzogYm9vbGVhbjtcbiAgICBib3JkZXJlZD86IGJvb2xlYW47XG4gICAgY2lyY3VsYXI/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgICBmaXR0ZWQ/OiBib29sZWFuO1xuICAgIGxpbms/OiBib29sZWFuO1xuICAgIGZsaXBwZWQ/OiBib29sZWFuO1xuICAgIHJvdGF0ZWQ/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBjb2xvcj86IENvbG9yO1xuICAgIHNpemU/OiBTaXplO1xuICB9XG4gIC8qKlxuICAgKiBBbiBpY29uIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBpY29ucy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgYnV0dG9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBkaXNwbGF5IHdlbGwgb24gYnV0dG9uc1xuICAgKiBcdGJvcmRlcmVkPzogYm9vbGVhbiAtIEFkZHMgYSBib3JkZXIgYXJvdW5kIHRoZSBpY29uLlxuICAgKiBcdGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgY2lyY3VsYXIuXG4gICAqIFx0ZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogXHRsb2FkaW5nPzogYm9vbGVhbiAtIFJvdGF0ZXMgdGhlIGljb24gdG8gYWxsb3cgaXQgdG8gYmUgdXNlZCBmb3IgbG9hZGVycy5cbiAgICogXHRmaXR0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIGZvciB0aWdodCBmaXRzLlxuICAgKiBcdGxpbms/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBjbGlja2FibGUuXG4gICAqIFx0ZmxpcHBlZD86IGJvb2xlYW4gLSBGbGlwcyB0aGUgaWNvbi5cbiAgICogXHRyb3RhdGVkPzogYm9vbGVhbiAtIFJvdGF0ZXMgdGhlIGljb24uXG4gICAqIFx0aW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBvbiBkYXJrIGJhY2tncm91bmQuXG4gICAqIFx0Y29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaWNvbi5cbiAgICogXHRzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBpY29uLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBJY29uVHlwZVxuICAgKiBAcGFyYW0gIHtDb21wb25lbnRTb3VyY2VzfSBzb3VyY2VzIC0gVGhlIGNvbXBvbmVudCdzIHNvdXJjZXMuXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudFNpbmtzfSBUaGUgSWNvbiBjb21wb25lbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIEljb25UeXBlPik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIEljb25UeXBlPikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2YoeyB0eXBlOiBcIlwiIH0pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoMCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogeHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JClcbiAgICAgICAgICAubWFwKChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpKSxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmljb25cIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQW4gaWNvbiBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgaWNvbnMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgYnV0dG9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBkaXNwbGF5IHdlbGwgb24gYnV0dG9uc1xuICAgKiBcdGJvcmRlcmVkPzogYm9vbGVhbiAtIEFkZHMgYSBib3JkZXIgYXJvdW5kIHRoZSBpY29uLlxuICAgKiBcdGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaWNvbiB0byBhcHBlYXIgY2lyY3VsYXIuXG4gICAqIFx0ZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogXHRsb2FkaW5nPzogYm9vbGVhbiAtIFJvdGF0ZXMgdGhlIGljb24gdG8gYWxsb3cgaXQgdG8gYmUgdXNlZCBmb3IgbG9hZGVycy5cbiAgICogXHRmaXR0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIGZvciB0aWdodCBmaXRzLlxuICAgKiBcdGxpbms/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBjbGlja2FibGUuXG4gICAqIFx0ZmxpcHBlZD86IGJvb2xlYW4gLSBGbGlwcyB0aGUgaWNvbi5cbiAgICogXHRyb3RhdGVkPzogYm9vbGVhbiAtIFJvdGF0ZXMgdGhlIGljb24uXG4gICAqIFx0aW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpY29uIHRvIGFwcGVhciBvbiBkYXJrIGJhY2tncm91bmQuXG4gICAqIFx0Y29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaWNvbi5cbiAgICogXHRzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBpY29uLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBJY29uVHlwZVxuICAgKiBAcGFyYW0gIHtDb21wb25lbnRTb3VyY2VzfSBzb3VyY2VzIC0gVGhlIGNvbXBvbmVudCdzIHNvdXJjZXMuXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudFNpbmtzfSBUaGUgSWNvbiBjb21wb25lbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgSWNvblR5cGUgPSB7fSwgYzogSWNvblR5cGUgPSAtMSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc1Byb3BzKHBPckMpID8gcE9yQyA6IHt9O1xuICAgIGxldCBjb250ZW50ID0gaXNQcm9wcyhwT3JDKSA/IGMgOiBwT3JDO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGdldENsYXNzbmFtZShwcm9wcywgY29udGVudCk7XG4gICAgcmV0dXJuIGNsYXNzTmFtZSAhPT0gXCJ1aSBpY29uXCIgPyBpKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSB9KSA6IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcywgY29udGVudDogSWNvblR5cGUpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmJ1dHRvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJ1dHRvblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYm9yZGVyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBib3JkZXJlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2lyY3VsYXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjaXJjdWxhclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubG9hZGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxvYWRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZpdHRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZpdHRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubGluaykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxpbmtcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZsaXBwZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbGlwcGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yb3RhdGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcm90YXRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IEljb25UeXBlLlRvQ2xhc3NuYW1lKGNvbnRlbnQpO1xuICAgIHJldHVybiBjbGFzc05hbWUgKyBcIiBpY29uXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Byb3BzKHByb3BzKTogcHJvcHMgaXMgUHJvcHMge1xuICAgIHJldHVybiB0eXBlb2YgKHByb3BzKSA9PT0gXCJvYmplY3RcIjtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2ljb24vaW5kZXgudHMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG5mdW5jdGlvbiBmcm9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCB1c2VDYXB0dXJlKSB7XG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHZvaWQgMCkgeyB1c2VDYXB0dXJlID0gZmFsc2U7IH1cbiAgICByZXR1cm4geHN0cmVhbV8xLlN0cmVhbS5jcmVhdGUoe1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IGZ1bmN0aW9uIG5leHQoZXZlbnQpIHsgbGlzdGVuZXIubmV4dChldmVudCk7IH07XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMubmV4dCwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMubmV4dCwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmZyb21FdmVudCA9IGZyb21FdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21FdmVudC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvZnJvbUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpcyA9IHJlcXVpcmUoJ3NuYWJiZG9tL2lzJyk7XG52YXIgdm5vZGUgPSByZXF1aXJlKCdzbmFiYmRvbS92bm9kZScpO1xuZnVuY3Rpb24gaXNHZW5lcmljU3RyZWFtKHgpIHtcbiAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoeCkgJiYgdHlwZW9mIHgubWFwID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBtdXRhdGVTdHJlYW1XaXRoTlModk5vZGUpIHtcbiAgICBhZGROUyh2Tm9kZS5kYXRhLCB2Tm9kZS5jaGlsZHJlbiwgdk5vZGUuc2VsKTtcbiAgICByZXR1cm4gdk5vZGU7XG59XG5mdW5jdGlvbiBhZGROUyhkYXRhLCBjaGlsZHJlbiwgc2VsZWN0b3IpIHtcbiAgICBkYXRhLm5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIGlmIChzZWxlY3RvciAhPT0gXCJ0ZXh0XCIgJiYgc2VsZWN0b3IgIT09IFwiZm9yZWlnbk9iamVjdFwiICYmXG4gICAgICAgIHR5cGVvZiBjaGlsZHJlbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpc0dlbmVyaWNTdHJlYW0oY2hpbGRyZW5baV0pKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSBjaGlsZHJlbltpXS5tYXAobXV0YXRlU3RyZWFtV2l0aE5TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZE5TKGNoaWxkcmVuW2ldLmRhdGEsIGNoaWxkcmVuW2ldLmNoaWxkcmVuLCBjaGlsZHJlbltpXS5zZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaChzZWwsIGIsIGMpIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciBjaGlsZHJlbjtcbiAgICB2YXIgdGV4dDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBkYXRhID0gYjtcbiAgICAgICAgaWYgKGlzLmFycmF5KGMpKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGMpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmIChpcy5hcnJheShiKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShiKSkge1xuICAgICAgICAgICAgdGV4dCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGlzLnByaW1pdGl2ZShjaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IHZub2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsWzBdID09PSAncycgJiYgc2VsWzFdID09PSAndicgJiYgc2VsWzJdID09PSAnZycpIHtcbiAgICAgICAgYWRkTlMoZGF0YSwgY2hpbGRyZW4sIHNlbCk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZShzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCB1bmRlZmluZWQpO1xufVxuZXhwb3J0cy5oID0gaDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh5cGVyc2NyaXB0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9oeXBlcnNjcmlwdC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbiAgLCBpZCA9IHRvU3RyaW5nLmNhbGwoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuICh0b1N0cmluZy5jYWxsKHgpID09PSBpZCk7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5hc3NpZ25cblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4gICwgaWQgPSB0b1N0cmluZy5jYWxsKCcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4gKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgfHwgKHggJiYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JykgJiZcblx0XHQoKHggaW5zdGFuY2VvZiBTdHJpbmcpIHx8ICh0b1N0cmluZy5jYWxsKHgpID09PSBpZCkpKSB8fCBmYWxzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbGVhciAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9jbGVhcicpXG4gICwgYXNzaWduICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9hc3NpZ24nKVxuICAsIGNhbGxhYmxlID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbHVlICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuICAsIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgYXV0b0JpbmQgPSByZXF1aXJlKCdkL2F1dG8tYmluZCcpXG4gICwgU3ltYm9sICAgPSByZXF1aXJlKCdlczYtc3ltYm9sJylcblxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgSXRlcmF0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlcmF0b3IgPSBmdW5jdGlvbiAobGlzdCwgY29udGV4dCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgSXRlcmF0b3IpKSByZXR1cm4gbmV3IEl0ZXJhdG9yKGxpc3QsIGNvbnRleHQpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2xpc3RfXzogZCgndycsIHZhbHVlKGxpc3QpKSxcblx0XHRfX2NvbnRleHRfXzogZCgndycsIGNvbnRleHQpLFxuXHRcdF9fbmV4dEluZGV4X186IGQoJ3cnLCAwKVxuXHR9KTtcblx0aWYgKCFjb250ZXh0KSByZXR1cm47XG5cdGNhbGxhYmxlKGNvbnRleHQub24pO1xuXHRjb250ZXh0Lm9uKCdfYWRkJywgdGhpcy5fb25BZGQpO1xuXHRjb250ZXh0Lm9uKCdfZGVsZXRlJywgdGhpcy5fb25EZWxldGUpO1xuXHRjb250ZXh0Lm9uKCdfY2xlYXInLCB0aGlzLl9vbkNsZWFyKTtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoSXRlcmF0b3IucHJvdG90eXBlLCBhc3NpZ24oe1xuXHRjb25zdHJ1Y3RvcjogZChJdGVyYXRvciksXG5cdF9uZXh0OiBkKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaTtcblx0XHRpZiAoIXRoaXMuX19saXN0X18pIHJldHVybjtcblx0XHRpZiAodGhpcy5fX3JlZG9fXykge1xuXHRcdFx0aSA9IHRoaXMuX19yZWRvX18uc2hpZnQoKTtcblx0XHRcdGlmIChpICE9PSB1bmRlZmluZWQpIHJldHVybiBpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fIDwgdGhpcy5fX2xpc3RfXy5sZW5ndGgpIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHR0aGlzLl91bkJpbmQoKTtcblx0fSksXG5cdG5leHQ6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3JlYXRlUmVzdWx0KHRoaXMuX25leHQoKSk7IH0pLFxuXHRfY3JlYXRlUmVzdWx0OiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuXHRcdHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGhpcy5fcmVzb2x2ZShpKSB9O1xuXHR9KSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuX19saXN0X19baV07IH0pLFxuXHRfdW5CaW5kOiBkKGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9fbGlzdF9fID0gbnVsbDtcblx0XHRkZWxldGUgdGhpcy5fX3JlZG9fXztcblx0XHRpZiAoIXRoaXMuX19jb250ZXh0X18pIHJldHVybjtcblx0XHR0aGlzLl9fY29udGV4dF9fLm9mZignX2FkZCcsIHRoaXMuX29uQWRkKTtcblx0XHR0aGlzLl9fY29udGV4dF9fLm9mZignX2RlbGV0ZScsIHRoaXMuX29uRGVsZXRlKTtcblx0XHR0aGlzLl9fY29udGV4dF9fLm9mZignX2NsZWFyJywgdGhpcy5fb25DbGVhcik7XG5cdFx0dGhpcy5fX2NvbnRleHRfXyA9IG51bGw7XG5cdH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBJdGVyYXRvcl0nOyB9KVxufSwgYXV0b0JpbmQoe1xuXHRfb25BZGQ6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0aWYgKGluZGV4ID49IHRoaXMuX19uZXh0SW5kZXhfXykgcmV0dXJuO1xuXHRcdCsrdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdGlmICghdGhpcy5fX3JlZG9fXykge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fcmVkb19fJywgZCgnYycsIFtpbmRleF0pKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBpKSB7XG5cdFx0XHRpZiAocmVkbyA+PSBpbmRleCkgdGhpcy5fX3JlZG9fX1tpXSA9ICsrcmVkbztcblx0XHR9LCB0aGlzKTtcblx0XHR0aGlzLl9fcmVkb19fLnB1c2goaW5kZXgpO1xuXHR9KSxcblx0X29uRGVsZXRlOiBkKGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdHZhciBpO1xuXHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHQtLXRoaXMuX19uZXh0SW5kZXhfXztcblx0XHRpZiAoIXRoaXMuX19yZWRvX18pIHJldHVybjtcblx0XHRpID0gdGhpcy5fX3JlZG9fXy5pbmRleE9mKGluZGV4KTtcblx0XHRpZiAoaSAhPT0gLTEpIHRoaXMuX19yZWRvX18uc3BsaWNlKGksIDEpO1xuXHRcdHRoaXMuX19yZWRvX18uZm9yRWFjaChmdW5jdGlvbiAocmVkbywgaSkge1xuXHRcdFx0aWYgKHJlZG8gPiBpbmRleCkgdGhpcy5fX3JlZG9fX1tpXSA9IC0tcmVkbztcblx0XHR9LCB0aGlzKTtcblx0fSksXG5cdF9vbkNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fX3JlZG9fXykgY2xlYXIuY2FsbCh0aGlzLl9fcmVkb19fKTtcblx0XHR0aGlzLl9fbmV4dEluZGV4X18gPSAwO1xuXHR9KVxufSkpKTtcblxuZGVmaW5lUHJvcGVydHkoSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIGQoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKTtcbmRlZmluZVByb3BlcnR5KEl0ZXJhdG9yLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkKCcnLCAnSXRlcmF0b3InKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LWl0ZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdvID0gZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGV4cG9ydHMuc3RhcnRMaXN0ZW5lciA9IGV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWFsZXJ0ICovXG5cblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xuXG52YXIgX2NyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gX2NyZWF0ZUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICB2YXIga2V5ID0gaGlzdG9yeVN0YXRlICYmIGhpc3RvcnlTdGF0ZS5rZXk7XG5cbiAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoe1xuICAgIHBhdGhuYW1lOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgc2VhcmNoOiB3aW5kb3cubG9jYXRpb24uc2VhcmNoLFxuICAgIGhhc2g6IHdpbmRvdy5sb2NhdGlvbi5oYXNoLFxuICAgIHN0YXRlOiBrZXkgPyAoMCwgX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUpKGtleSkgOiB1bmRlZmluZWRcbiAgfSwgdW5kZWZpbmVkLCBrZXkpO1xufTtcblxudmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICB2YXIgaGlzdG9yeVN0YXRlID0gdm9pZCAwO1xuICB0cnkge1xuICAgIGhpc3RvcnlTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21qYWNrc29uL2hpc3RvcnkvcHVsbC8yODlcbiAgICBoaXN0b3J5U3RhdGUgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlTG9jYXRpb24oaGlzdG9yeVN0YXRlKTtcbn07XG5cbnZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZnVuY3Rpb24gZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTtcblxudmFyIHN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIHZhciBoYW5kbGVQb3BTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnN0YXRlICE9PSB1bmRlZmluZWQpIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXRcbiAgICAgIGxpc3RlbmVyKF9jcmVhdGVMb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9O1xuXG4gICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcbiAgfTtcbn07XG5cbnZhciB1cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB1cGRhdGVTdGF0ZSkge1xuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuXG4gIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSAoMCwgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUpKGtleSwgc3RhdGUpO1xuXG4gIHVwZGF0ZVN0YXRlKHsga2V5OiBrZXkgfSwgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbn07XG5cbnZhciBwdXNoTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIG51bGwsIHBhdGgpO1xuICB9KTtcbn07XG5cbnZhciByZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIG51bGwsIHBhdGgpO1xuICB9KTtcbn07XG5cbnZhciBnbyA9IGV4cG9ydHMuZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gIGlmIChuKSB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0Jyb3dzZXJQcm90b2NvbC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBjcmVhdGVIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IG9wdGlvbnMuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IG9wdGlvbnMuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgdmFyIHB1c2hMb2NhdGlvbiA9IG9wdGlvbnMucHVzaExvY2F0aW9uO1xuICB2YXIgcmVwbGFjZUxvY2F0aW9uID0gb3B0aW9ucy5yZXBsYWNlTG9jYXRpb247XG4gIHZhciBnbyA9IG9wdGlvbnMuZ287XG4gIHZhciBrZXlMZW5ndGggPSBvcHRpb25zLmtleUxlbmd0aDtcblxuXG4gIHZhciBjdXJyZW50TG9jYXRpb24gPSB2b2lkIDA7XG4gIHZhciBwZW5kaW5nTG9jYXRpb24gPSB2b2lkIDA7XG4gIHZhciBiZWZvcmVMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgYWxsS2V5cyA9IFtdO1xuXG4gIHZhciBnZXRDdXJyZW50SW5kZXggPSBmdW5jdGlvbiBnZXRDdXJyZW50SW5kZXgoKSB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAmJiBwZW5kaW5nTG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybiBhbGxLZXlzLmluZGV4T2YocGVuZGluZ0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoY3VycmVudExvY2F0aW9uKSByZXR1cm4gYWxsS2V5cy5pbmRleE9mKGN1cnJlbnRMb2NhdGlvbi5rZXkpO1xuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIHZhciB1cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbikge1xuICAgIGN1cnJlbnRMb2NhdGlvbiA9IG5leHRMb2NhdGlvbjtcblxuICAgIHZhciBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcblxuICAgIGlmIChjdXJyZW50TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBhbGxLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbGxLZXlzLnNsaWNlKDAsIGN1cnJlbnRJbmRleCArIDEpKSwgW2N1cnJlbnRMb2NhdGlvbi5rZXldKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudEluZGV4XSA9IGN1cnJlbnRMb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIoY3VycmVudExvY2F0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgYmVmb3JlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiZWZvcmVMaXN0ZW5lcnMgPSBiZWZvcmVMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShiZWZvcmVMaXN0ZW5lcnMubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICAgICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGJlZm9yZUxpc3RlbmVyc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IGRvbmUocmVzdWx0KSA6IG5leHQoKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sob2sgIT09IGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhtZXNzYWdlICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24pIHtcbiAgICBpZiAoY3VycmVudExvY2F0aW9uICYmICgwLCBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbCkoY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24pIHx8IHBlbmRpbmdMb2NhdGlvbiAmJiAoMCwgX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWwpKHBlbmRpbmdMb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXG5cbiAgICBwZW5kaW5nTG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG5cbiAgICBjb25maXJtVHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAocGVuZGluZ0xvY2F0aW9uICE9PSBuZXh0TG9jYXRpb24pIHJldHVybjsgLy8gVHJhbnNpdGlvbiB3YXMgaW50ZXJydXB0ZWQgZHVyaW5nIGNvbmZpcm1hdGlvblxuXG4gICAgICBwZW5kaW5nTG9jYXRpb24gPSBudWxsO1xuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gVHJlYXQgUFVTSCB0byBzYW1lIHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgICAgdmFyIG5leHRQYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgKDAsIF9Mb2NhdGlvblV0aWxzLnN0YXRlc0FyZUVxdWFsKShjdXJyZW50TG9jYXRpb24uc3RhdGUsIG5leHRMb2NhdGlvbi5zdGF0ZSkpIG5leHRMb2NhdGlvbi5hY3Rpb24gPSBfQWN0aW9ucy5SRVBMQUNFO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgICAgIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIGlmIChwdXNoTG9jYXRpb24obmV4dExvY2F0aW9uKSAhPT0gZmFsc2UpIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUkVQTEFDRSkge1xuICAgICAgICAgIGlmIChyZXBsYWNlTG9jYXRpb24obmV4dExvY2F0aW9uKSAhPT0gZmFsc2UpIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudExvY2F0aW9uICYmIG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGN1cnJlbnRMb2NhdGlvbi5rZXkpO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gYWxsS2V5cy5pbmRleE9mKG5leHRMb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xICYmIG5leHRJbmRleCAhPT0gLTEpIGdvKHByZXZJbmRleCAtIG5leHRJbmRleCk7IC8vIFJlc3RvcmUgdGhlIFVSTFxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChpbnB1dCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24oaW5wdXQsIF9BY3Rpb25zLlBVU0gpKTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UoaW5wdXQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGlucHV0LCBfQWN0aW9ucy5SRVBMQUNFKSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGggfHwgNik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGNyZWF0ZUtleSgpIDogYXJndW1lbnRzWzJdO1xuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGxvY2F0aW9uLCBhY3Rpb24sIGtleSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICB0cmFuc2l0aW9uVG86IHRyYW5zaXRpb25UbyxcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNyZWF0ZUtleTogY3JlYXRlS2V5LFxuICAgIGNyZWF0ZVBhdGg6IF9QYXRoVXRpbHMuY3JlYXRlUGF0aCxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvblxuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHJ1blRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2soaG9vaywgbG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHQgPSBob29rKGxvY2F0aW9uLCBjYWxsYmFjayk7XG5cbiAgaWYgKGhvb2subGVuZ3RoIDwgMikge1xuICAgIC8vIEFzc3VtZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHkgYW5kIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgY2FsbGJhY2socmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyAnICsgJ2NhbGwgdGhlIGNhbGxiYWNrIGluc3RlYWQnKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL3J1blRyYW5zaXRpb25Ib29rLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xudmFyIG9iamVjdFR5cGVzID0ge1xuICAnZnVuY3Rpb24nOiB0cnVlLFxuICAnb2JqZWN0JzogdHJ1ZVxufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSlcbiAgPyBleHBvcnRzXG4gIDogdW5kZWZpbmVkO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSlcbiAgPyBtb2R1bGVcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHdpbmRvd2AuICovXG52YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG5cbi8qKiBEZXRlY3QgYHRoaXNgIGFzIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG5cbi8qKlxuICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBUaGUgYHRoaXNgIHZhbHVlIGlzIHVzZWQgaWYgaXQncyB0aGUgZ2xvYmFsIG9iamVjdCB0byBhdm9pZCBHcmVhc2Vtb25rZXknc1xuICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fFxuICAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHxcbiAgICBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBnbG9iYWwgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyBgdmFsdWVgIGlmIGl0J3MgYSBnbG9iYWwgb2JqZWN0LCBlbHNlIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX3Jvb3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG52YXIgdmVuZG9yID0gcHJvdG8ubWF0Y2hlc1xuICB8fCBwcm90by5tYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1vek1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tc01hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5vTWF0Y2hlc1NlbGVjdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoO1xuXG4vKipcbiAqIE1hdGNoIGBlbGAgdG8gYHNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGVsLCBzZWxlY3Rvcikge1xuICBpZiAodmVuZG9yKSByZXR1cm4gdmVuZG9yLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgdmFyIG5vZGVzID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXSA9PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYXRjaGVzLXNlbGVjdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIGVsbSkge1xuICB2YXIga2V5ID0gZGF0YSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZGF0YS5rZXk7XG4gIHJldHVybiB7c2VsOiBzZWwsIGRhdGE6IGRhdGEsIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LCBlbG06IGVsbSwga2V5OiBrZXl9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS92bm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtET01Db250ZW50LCBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBWTm9kZSwgRXZlbnRTZWxlY3Rvcn0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQge0FuaW1hdGlvbiwgRGlyZWN0aW9ufSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB7aCwgZGl2fSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi4vLi4vbW9kdWxlcy90cmFuc2l0aW9uXCI7XG5pbXBvcnQge3BhdGNoQ2xhc3NMaXN0LCBhZGRFbGVtZW50fSBmcm9tIFwiLi4vLi4vdXRpbHNcIjtcbjtcblxuZXhwb3J0IG5hbWVzcGFjZSBEaW1tZXIge1xuICAvKipcbiAgICogQSBkaW1tZXIgd3JhcHBlciB0byBzaG93IGV4dHJhIGhpZGRlbiBjb250ZW50IG9uIGFuIGVsZW1lbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIHRhcmdldDpcbiAgICogICBWTm9kZSAtIFRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgZGltbWVyIHRvLlxuICAgKiAgIFwiUGFnZVwiIC0gQ3JlYXRlcyBhIGRpbW1lciBmb3IgdGhlIGVudGlyZSBwYWdlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBhcmdzOiBCb29sZWFuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICogQHBhcmFtICB7Q29tcG9uZW50U291cmNlc30gc291cmNlcyBUaGUgQ29tcG9uZW50J3Mgc291cmNlcy5cbiAgICogQHJldHVybiB7Q29tcG9uZW50U2lua3N9IFRoZSBEaW1tZXIgQ29tcG9uZW50LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXM8U3RyaW5nfFZOb2RlLCBib29sZWFuLCBET01Db250ZW50PiwgaW52ZXJ0JCA9IHhzLm9mKGZhbHNlKSlcbiAgICA6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlczxTdHJpbmd8Vk5vZGUsIGJvb2xlYW4sIERPTUNvbnRlbnQ+KSB7XG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmRpbW1hYmxlXCIpLmV2ZW50cyh0eXBlKTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuICAgICAgc291cmNlcy5hcmdzJCA9IHNvdXJjZXMuYXJncyQgPyBzb3VyY2VzLmFyZ3MkIDogb25Ib3ZlcihldnQpO1xuXG4gICAgICBjb25zdCB0YXJnZXQkID0gc291cmNlcy50YXJnZXQkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCBhY3RpdmUkID0gc291cmNlcy5hcmdzJC5yZW1lbWJlcigpO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiQgPSBhY3RpdmUkXG4gICAgICAgIC5mb2xkKChwcmV2QW5pbSwgYWN0aXZlKSA9PiBwcmV2QW5pbS5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5Ob25lXG4gICAgICAgICAgPyAoeyBhbmltYXRpb246IEFuaW1hdGlvbi5Ob25lLCBkaXJlY3Rpb246IGFjdGl2ZSA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXR9KVxuICAgICAgICAgIDogeyBhbmltYXRpb246IEFuaW1hdGlvbi5GYWRlLCBkaXJlY3Rpb246IGFjdGl2ZSA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXRcbiAgICAgICAgICB9XG4gICAgICAgICwgKHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uTm9uZSB9KSk7XG4gICAgICBjb25zdCBjb250ZW50JCA9IHhzLmNvbWJpbmUoc291cmNlcy5jb250ZW50JCwgdGFyZ2V0JCwgaW52ZXJ0JClcbiAgICAgICAgLm1hcCgoW2NvbnRlbnQsIHRhcmdldCwgaW52ZXJ0ZWRdKSA9PiByZW5kZXIoY29udGVudCwgdGFyZ2V0LCBpbnZlcnRlZCkpO1xuICAgICAgY29uc3QgYW5pbWF0ZWRDb250ZW50ID0gVHJhbnNpdGlvbi5ydW4oe0RPTTogc291cmNlcy5ET00sIGFyZ3MkOiB0cmFuc2l0aW9uJCwgdGFyZ2V0JDogY29udGVudCR9KTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZSh0YXJnZXQkLCBhbmltYXRlZENvbnRlbnQuRE9NLCBhY3RpdmUkKVxuICAgICAgICAubWFwKChbdGFyZ2V0LCBjb250ZW50LCBhY3RpdmVdKSA9PiBkaW1FbGVtZW50KHRhcmdldCwgY29udGVudCwgYWN0aXZlKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiBhbmltYXRlZENvbnRlbnQuRXZlbnRzLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihjb250ZW50OiBET01Db250ZW50ID0gXCJcIiwgdGFyZ2V0OiBTdHJpbmd8Vk5vZGUgPSBcInBhZ2VcIiwgaW52ZXJ0ZWQgPSBmYWxzZSkgOiBWTm9kZSB7XG4gICAgcmV0dXJuIHRhcmdldCA9PT0gXCJwYWdlXCJcbiAgICAgID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInVpIFwiICsgKGludmVydGVkID8gXCJpbnZlcnRlZCBcIiA6IFwiXCIpICsgIFwiZGltbWVyIG1vZGFscyBwYWdlIGRpbW1lclwifX0sIGNvbnRlbnQpXG4gICAgICA6IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ1aSBcIiArIChpbnZlcnRlZCA/IFwiaW52ZXJ0ZWQgXCIgOiBcIlwiKSArIFwidGFyZ2V0dGVkIGRpbW1lclwifX0sIFtcbiAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY29udGVudFwifX0sIFtcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjZW50ZXJcIn19LCBcbiAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pXG4gICAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSG92ZXIoZXZlbnRzOiBFdmVudFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHhzLm1lcmdlKGV2ZW50cyhcIm1vdXNlZW50ZXJcIiksIGV2ZW50cyhcIm1vdXNlbGVhdmVcIikpXG4gICAgICAubWFwKGV2dCA9PiAoZXZ0IGFzIE1vdXNlRXZlbnQpLnR5cGUgPT09IFwibW91c2VlbnRlclwiKS5zdGFydFdpdGgoZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGRpbUVsZW1lbnQodGFyZ2V0T3JTdHJpbmc6IFZOb2RlIHwgc3RyaW5nLCBjb250ZW50OiBWTm9kZSwgYWN0aXZlOiBib29sZWFuKSB7XG4gICAgY29uc3QgaXNQYWdlID0gdHlwZW9mKHRhcmdldE9yU3RyaW5nKSA9PT0gXCJzdHJpbmdcIjtcbiAgICBsZXQgdGFyZ2V0ID0gaXNQYWdlID8gY29udGVudCA6IHRhcmdldE9yU3RyaW5nIGFzIFZOb2RlO1xuICAgIGxldCBjbGFzc05hbWUgPSBpc1BhZ2UgPyBcIlwiIDogXCJkaW1tYWJsZVwiLCBjO1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBpc1BhZ2UgPyBcImFjdGl2ZVwiOiBcIiBkaW1tZWRcIjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHBhdGNoQ2xhc3NMaXN0KHRhcmdldCwgW1wiZGltbWFibGVcIiwgXCJkaW1tZWRcIiwgXCJpbnZlcnRlZFwiLCBcImFjdGl2ZVwiXSwgY2xhc3NOYW1lKTtcbiAgICBpZiAoaXNQYWdlKSB7XG4gICAgICBpZiAodGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgICAgIGMgPSB0YXJnZXQuY2hpbGRyZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0YXJnZXQudGV4dCkge1xuICAgICAgICBjID0gdGFyZ2V0LnRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYyA9IGFkZEVsZW1lbnQoY29udGVudCwgdGFyZ2V0LCBcInRhcmdldHRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGgodGFyZ2V0LnNlbCwgZGF0YSwgYyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2RpbW1lci9pbmRleC50cyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU2NvcGVDaGVja2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY29wZUNoZWNrZXIoc2NvcGUsIGlzb2xhdGVNb2R1bGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmlzb2xhdGVNb2R1bGUgPSBpc29sYXRlTW9kdWxlO1xuICAgIH1cbiAgICBTY29wZUNoZWNrZXIucHJvdG90eXBlLmlzU3RyaWN0bHlJblJvb3RTY29wZSA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgIGZvciAodmFyIGVsID0gbGVhZjsgZWw7IGVsID0gZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5pc29sYXRlTW9kdWxlLmlzSXNvbGF0ZWRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGlmIChzY29wZSAmJiBzY29wZSAhPT0gdGhpcy5zY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFNjb3BlQ2hlY2tlcjtcbn0oKSk7XG5leHBvcnRzLlNjb3BlQ2hlY2tlciA9IFNjb3BlQ2hlY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjb3BlQ2hlY2tlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvU2NvcGVDaGVja2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG5mdW5jdGlvbiBjcmVhdGVWVHJlZSh2bm9kZSwgY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWw6IHZub2RlLnNlbCxcbiAgICAgICAgZGF0YTogdm5vZGUuZGF0YSxcbiAgICAgICAgdGV4dDogdm5vZGUudGV4dCxcbiAgICAgICAgZWxtOiB2bm9kZS5lbG0sXG4gICAgICAgIGtleTogdm5vZGUua2V5LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VUcmFuc3Bvc2VWTm9kZShydW5TdHJlYW1BZGFwdGVyKSB7XG4gICAgZnVuY3Rpb24gaW50ZXJuYWxUcmFuc3Bvc2VWTm9kZSh2bm9kZSkge1xuICAgICAgICBpZiAoIXZub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2bm9kZSAmJiB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuc3RhdGljKSB7XG4gICAgICAgICAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQub2Yodm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1blN0cmVhbUFkYXB0ZXIuaXNWYWxpZFN0cmVhbSh2bm9kZSkpIHtcbiAgICAgICAgICAgIHZhciB4c1N0cmVhbSA9IHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuYWRhcHQodm5vZGUsIHJ1blN0cmVhbUFkYXB0ZXIuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgICAgIHJldHVybiB4c1N0cmVhbS5tYXAoaW50ZXJuYWxUcmFuc3Bvc2VWTm9kZSkuZmxhdHRlbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2bm9kZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKCF2bm9kZS5jaGlsZHJlbiB8fCB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQub2Yodm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZub2RlQ2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgICAgIC5tYXAoaW50ZXJuYWxUcmFuc3Bvc2VWTm9kZSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSBudWxsOyB9KTtcbiAgICAgICAgICAgIGlmICh2bm9kZUNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdC5vZihjcmVhdGVWVHJlZSh2bm9kZSwgW10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdC5jb21iaW5lLmFwcGx5KHhzdHJlYW1fMS5kZWZhdWx0LCB2bm9kZUNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjaGlsZHJlbikgeyByZXR1cm4gY3JlYXRlVlRyZWUodm5vZGUsIGNoaWxkcmVuLnNsaWNlKCkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaGFuZGxlZCB2VHJlZSBWYWx1ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyYW5zcG9zZVZOb2RlKHZub2RlKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbFRyYW5zcG9zZVZOb2RlKHZub2RlKTtcbiAgICB9O1xufVxuZXhwb3J0cy5tYWtlVHJhbnNwb3NlVk5vZGUgPSBtYWtlVHJhbnNwb3NlVk5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3Bvc2l0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi90cmFuc3Bvc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSGlzdG9yeSBkcml2ZXIgZmFjdG9yeVxuICpcbiAqIFRoaXMgaXMgYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBjYWxsZWQsIHJldHVybnMgYSBIaXN0b3J5IERyaXZlciBmb3IgQ3ljbGUuanNcbiAqIGFwcHMuIFRoZSBkcml2ZXIgaXMgYWxzbyBhIGZ1bmN0aW9uLCBhbmQgaXQgdGFrZXMgYSBzdHJlYW0gb2YgbmV3IGxvY2F0aW9uc1xuICogKHN0cmluZ3MgcmVwcmVzZW50aW5nIHBhdGhuYW1lcyBvciBsb2NhdGlvbiBvYmplY3RzKSBhcyBpbnB1dCwgYW5kIG91dHB1dHNcbiAqIGFub3RoZXIgc3RyZWFtIG9mIGxvY2F0aW9ucyB0aGF0IHdlcmUgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0ge0hpc3Rvcnl9IGhpc3RvcnkgdGhlIEhpc3Rvcnkgb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS5cbiAqIFRoaXMgb2JqZWN0IGlzIHVzdWFsbHkgY3JlYXRlZCB0aHJvdWdoIGBjcmVhdGVCcm93c2VySGlzdG9yeSgpYCBvclxuICogYGNyZWF0ZUhhc2hIaXN0b3J5KClgIG9yIGBjcmVhdGVNZW1vcnlIaXN0b3J5KClgIGZyb20gdGhlIGBoaXN0b3J5YCBsaWJyYXJ5LlxuICogQWx0ZXJuYXRpdmVseSwgeW91IG1heSB1c2UgYGNyZWF0ZVNlcnZlckhpc3RvcnlgIGZyb20gdGhpcyBsaWJyYXJ5LlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggc29tZSBvcHRpb25zIHNwZWNpZmljIHRvIHRoaXMgZHJpdmVyLlxuICogT3B0aW9ucyBtYXkgYmU6IGBjYXB0dXJlYCwgYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIGRyaXZlciBzaG91bGRcbiAqIGludGVyY2VwdCBhbmQgaGFuZGxlIGFueSBjbGljayBldmVudCB0aGF0IGxlYWRzIHRvIGEgbGluaywgbGlrZSBvbiBhbiBgPGE+YFxuICogZWxlbWVudDsgYG9uRXJyb3JgLCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZXJyb3IgYXMgYXJndW1lbnQgYW5kXG4gKiBoYW5kbGVzIGl0LCB1c2UgdGhpcyB0byBjb25maWd1cmUgd2hhdCB0byBkbyB3aXRoIGRyaXZlciBlcnJvcnMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIEhpc3RvcnkgRHJpdmVyIGZ1bmN0aW9uXG4gKiBAZnVuY3Rpb24gbWFrZUhpc3RvcnlEcml2ZXJcbiAqL1xudmFyIG1ha2VIaXN0b3J5RHJpdmVyXzEgPSByZXF1aXJlKCcuL21ha2VIaXN0b3J5RHJpdmVyJyk7XG5leHBvcnRzLm1ha2VIaXN0b3J5RHJpdmVyID0gbWFrZUhpc3RvcnlEcml2ZXJfMS5tYWtlSGlzdG9yeURyaXZlcjtcbi8qKlxuICogQ3JlYXRlcyBhIFwiU2VydmVySGlzdG9yeVwiIG9iamVjdCBzaW1pbGFyIHRvIHRoZSBIaXN0b3J5IG9iamVjdHMgdGhhdCB0aGVcbiAqIGBoaXN0b3J5YCBsaWJyYXJ5IGNhbiBjcmVhdGUuIFVzZSB0aGlzIHdoZW4geW91IHdhbnQgdG8gc3VwcG9ydCBzZXJ2ZXItc2lkZVxuICogcmVuZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbG9jYXRpb24gdGhpcyBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGVcbiAqIHBhdGhuYW1lLCBvciBhIGxvY2F0aW9uIG9iamVjdCB3aXRoIGZpZWxkcyBsaWtlIGBwYXRobmFtZWAsIGBzZWFyY2hgLFxuICogYHF1ZXJ5YCwgYHN0YXRlYCwgYGFjdGlvbmAsIGBrZXlgLCBgaGFzaGAsIGV0Yy5cbiAqIEByZXR1cm4ge29iamVjdH0gYSBIaXN0b3J5IG9iamVjdC5cbiAqIEBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJIaXN0b3J5XG4gKi9cbnZhciBzZXJ2ZXJIaXN0b3J5XzEgPSByZXF1aXJlKCcuL3NlcnZlckhpc3RvcnknKTtcbmV4cG9ydHMuY3JlYXRlU2VydmVySGlzdG9yeSA9IHNlcnZlckhpc3RvcnlfMS5jcmVhdGVTZXJ2ZXJIaXN0b3J5O1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSB1dGlsXzEuc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IHV0aWxfMS5jcmVhdGVMb2NhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvaGlzdG9yeS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbmZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fFxuICAgICAgICB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcbiAgICAgICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgICAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICAgICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBzdXBwb3J0c0hpc3Rvcnk7XG52YXIgbG9jYXRpb25EZWZhdWx0cyA9IHtcbiAgICBwYXRobmFtZTogJy8nLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgaGFzaDogJycsXG4gICAgc2VhcmNoOiAnJyxcbiAgICBzdGF0ZTogdW5kZWZpbmVkLFxuICAgIGtleTogbnVsbCxcbiAgICBxdWVyeTogbnVsbCxcbn07XG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RBc3NpZ24oe30sIGxvY2F0aW9uRGVmYXVsdHMsIHsgcGF0aG5hbWU6IGxvY2F0aW9uIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0QXNzaWduKHt9LCBsb2NhdGlvbkRlZmF1bHRzLCBsb2NhdGlvbik7XG59XG5leHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvaGlzdG9yeS9saWIvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBDcm9zcy1Ccm93c2VyIFNwbGl0IDEuMS4xXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQsIHVuaWZvcm0gY3Jvc3MtYnJvd3NlciBzcGxpdCBtZXRob2RcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gKiBjYXB0dXJpbmcgZ3JvdXBzLCBiYWNrcmVmZXJlbmNlcyBhcmUgc3BsaWNlZCBpbnRvIHRoZSByZXN1bHQgZWFjaCB0aW1lIGBzZXBhcmF0b3JgIGlzIG1hdGNoZWQuXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XG4gKiBjcm9zcy1icm93c2VyLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAqXG4gKiAvLyBXaXRoIGxpbWl0XG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gKiAvLyAtPiBbJ2EnLCAnYiddXG4gKlxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gKiBzcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnICcsICd3b3JkJywgJzInLCAnLi4nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBzcGxpdCh1bmRlZikge1xuXG4gIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYyhcIlwiKVsxXSA9PT0gdW5kZWYsXG4gICAgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICBzZWxmO1xuXG4gIHNlbGYgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgLy8gRmlyZWZveCAzK1xuICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzZXBhcmF0b3Iuc291cmNlICsgXCIkKD8hXFxcXHMpXCIsIGZsYWdzKTtcbiAgICB9XG4gICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAqL1xuICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXItc3BsaXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEluc3BpcmVkIGJ5IEdvb2dsZSBDbG9zdXJlOlxuLy8gaHR0cDovL2Nsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9zdm4vZG9jcy9cbi8vIGNsb3N1cmVfZ29vZ19hcnJheV9hcnJheS5qcy5odG1sI2dvb2cuYXJyYXkuY2xlYXJcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhbHVlKHRoaXMpLmxlbmd0aCA9IDA7XG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L2FycmF5LyMvY2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICwgeCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKmN1c3RvbUNyZWF0ZSovKSB7XG5cdHZhciBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuXHQgICwgY3VzdG9tQ3JlYXRlID0gYXJndW1lbnRzWzBdIHx8IGNyZWF0ZTtcblx0aWYgKHR5cGVvZiBzZXRQcm90b3R5cGVPZiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gZ2V0UHJvdG90eXBlT2Yoc2V0UHJvdG90eXBlT2YoY3VzdG9tQ3JlYXRlKG51bGwpLCB4KSkgPT09IHg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEJpZyB0aGFua3MgdG8gQFdlYlJlZmxlY3Rpb24gZm9yIHNvcnRpbmcgdGhpcyBvdXRcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vNTU5MzU1NFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCAgICAgID0gcmVxdWlyZSgnLi4vaXMtb2JqZWN0JylcbiAgLCB2YWx1ZSAgICAgICAgID0gcmVxdWlyZSgnLi4vdmFsaWQtdmFsdWUnKVxuXG4gICwgaXNQcm90b3R5cGVPZiA9IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZlxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgbnVsbERlc2MgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLFxuXHRcdHZhbHVlOiB1bmRlZmluZWQgfVxuICAsIHZhbGlkYXRlO1xuXG52YWxpZGF0ZSA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHR2YWx1ZShvYmopO1xuXHRpZiAoKHByb3RvdHlwZSA9PT0gbnVsbCkgfHwgaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIG9iajtcblx0dGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdG90eXBlIG11c3QgYmUgbnVsbCBvciBhbiBvYmplY3QnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0dmFyIGZuLCBzZXQ7XG5cdGlmICghc3RhdHVzKSByZXR1cm4gbnVsbDtcblx0aWYgKHN0YXR1cy5sZXZlbCA9PT0gMikge1xuXHRcdGlmIChzdGF0dXMuc2V0KSB7XG5cdFx0XHRzZXQgPSBzdGF0dXMuc2V0O1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0c2V0LmNhbGwodmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLCBwcm90b3R5cGUpO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0dmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuID0gZnVuY3Rpb24gc2VsZihvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0dmFyIGlzTnVsbEJhc2U7XG5cdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSk7XG5cdFx0XHRpc051bGxCYXNlID0gaXNQcm90b3R5cGVPZi5jYWxsKHNlbGYubnVsbFBvbHlmaWxsLCBvYmopO1xuXHRcdFx0aWYgKGlzTnVsbEJhc2UpIGRlbGV0ZSBzZWxmLm51bGxQb2x5ZmlsbC5fX3Byb3RvX187XG5cdFx0XHRpZiAocHJvdG90eXBlID09PSBudWxsKSBwcm90b3R5cGUgPSBzZWxmLm51bGxQb2x5ZmlsbDtcblx0XHRcdG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVmaW5lUHJvcGVydHkoc2VsZi5udWxsUG9seWZpbGwsICdfX3Byb3RvX18nLCBudWxsRGVzYyk7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2xldmVsJywgeyBjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBzdGF0dXMubGV2ZWwgfSk7XG59KChmdW5jdGlvbiAoKSB7XG5cdHZhciB4ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgeSA9IHt9LCBzZXRcblx0ICAsIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKTtcblxuXHRpZiAoZGVzYykge1xuXHRcdHRyeSB7XG5cdFx0XHRzZXQgPSBkZXNjLnNldDsgLy8gT3BlcmEgY3Jhc2hlcyBhdCB0aGlzIHBvaW50XG5cdFx0XHRzZXQuY2FsbCh4LCB5KTtcblx0XHR9IGNhdGNoIChpZ25vcmUpIHsgfVxuXHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkgPT09IHkpIHJldHVybiB7IHNldDogc2V0LCBsZXZlbDogMiB9O1xuXHR9XG5cblx0eC5fX3Byb3RvX18gPSB5O1xuXHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID09PSB5KSByZXR1cm4geyBsZXZlbDogMiB9O1xuXG5cdHggPSB7fTtcblx0eC5fX3Byb3RvX18gPSB5O1xuXHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID09PSB5KSByZXR1cm4geyBsZXZlbDogMSB9O1xuXG5cdHJldHVybiBmYWxzZTtcbn0oKSkpKTtcblxucmVxdWlyZSgnLi4vY3JlYXRlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBTdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNJdGVyYWJsZSA9IHJlcXVpcmUoJy4vaXMtaXRlcmFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCBpdGVyYWJsZVwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtaXRlcmF0b3IvdmFsaWQtaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKSA/IE1hcCA6IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtbWFwL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlYWRTdGF0ZSA9IGV4cG9ydHMuc2F2ZVN0YXRlID0gdW5kZWZpbmVkO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSBbJ1F1b3RhRXhjZWVkZWRFcnJvcicsICdRVU9UQV9FWENFRURFRF9FUlInXTsgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cblxuXG52YXIgU2VjdXJpdHlFcnJvciA9ICdTZWN1cml0eUVycm9yJztcbnZhciBLZXlQcmVmaXggPSAnQEBIaXN0b3J5Lyc7XG5cbnZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoa2V5KSB7XG4gIHJldHVybiBLZXlQcmVmaXggKyBrZXk7XG59O1xuXG52YXIgc2F2ZVN0YXRlID0gZXhwb3J0cy5zYXZlU3RhdGUgPSBmdW5jdGlvbiBzYXZlU3RhdGUoa2V5LCBzdGF0ZSkge1xuICBpZiAoIXdpbmRvdy5zZXNzaW9uU3RvcmFnZSkge1xuICAgIC8vIFNlc3Npb24gc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIG9yIGhpZGRlbi5cbiAgICAvLyBzZXNzaW9uU3RvcmFnZSBpcyB1bmRlZmluZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgd2hlbiBzZXJ2ZWQgdmlhIGZpbGUgcHJvdG9jb2wuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUnKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChzdGF0ZSA9PSBudWxsKSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShjcmVhdGVLZXkoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGNyZWF0ZUtleShrZXkpLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gU2VjdXJpdHlFcnJvcikge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChRdW90YUV4Y2VlZGVkRXJyb3JzLmluZGV4T2YoZXJyb3IubmFtZSkgPj0gMCAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBTYWZhcmkgXCJwcml2YXRlIG1vZGVcIiB0aHJvd3MgUXVvdGFFeGNlZWRlZEVycm9yLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gU2FmYXJpIHByaXZhdGUgbW9kZScpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbnZhciByZWFkU3RhdGUgPSBleHBvcnRzLnJlYWRTdGF0ZSA9IGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgdmFyIGpzb24gPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAganNvbiA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gU2VjdXJpdHlFcnJvcikge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gcmVhZCBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBpZiAoanNvbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWdub3JlIGludmFsaWQgSlNPTi5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjkuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guX2dldG5hdGl2ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4yLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIHJvb3QgPSByZXF1aXJlKCdsb2Rhc2guX3Jvb3QnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIidgXS9nLFxuICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJ2AnOiAnJiM5NjsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKGNocikge1xuICByZXR1cm4gaHRtbEVzY2FwZXNbY2hyXTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IFN5bWJvbCA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAqIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBTeW1ib2wgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBcIidcIiwgYW5kIFwiXFxgXCIgaW4gYHN0cmluZ2AgdG9cbiAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIFNlZSBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBCYWNrdGlja3MgYXJlIGVzY2FwZWQgYmVjYXVzZSBpbiBJRSA8IDksIHRoZXkgY2FuIGJyZWFrIG91dCBvZlxuICogYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyM1OV0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzU5KSxcbiAqIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSwgWyMxMDhdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDgpLCBhbmRcbiAqIFsjMTMzXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTMzKSBvZiB0aGUgW0hUTUw1IFNlY3VyaXR5IENoZWF0c2hlZXRdKGh0dHBzOi8vaHRtbDVzZWMub3JnLylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5cyBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpXG4gKiB0byByZWR1Y2UgWFNTIHZlY3RvcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5lc2NhcGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMC4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUZvciA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWZvcicpLFxuICAgIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJ2xvZGFzaC5fYmluZGNhbGxiYWNrJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JPd25gIG9yIGBfLmZvck93blJpZ2h0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvck93bihvYmplY3RGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0RnVuYyhvYmplY3QsIGl0ZXJhdGVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcbiAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IGxvZ3MgJ2EnIGFuZCAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xudmFyIGZvck93biA9IGNyZWF0ZUZvck93bihiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JPd247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLmZvcm93bi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLmlzYXJndW1lbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjAuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5VGFnO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNlbGVjdG9yUGFyc2VyO1xuXG52YXIgX2Jyb3dzZXJTcGxpdCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3BsaXQnKTtcblxudmFyIF9icm93c2VyU3BsaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3NlclNwbGl0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNsYXNzSWRTcGxpdCA9IC8oW1xcLiNdP1thLXpBLVowLTlcXHUwMDdGLVxcdUZGRkZfOi1dKykvO1xudmFyIG5vdENsYXNzSWQgPSAvXlxcLnwjLztcblxuZnVuY3Rpb24gc2VsZWN0b3JQYXJzZXIoKSB7XG4gIHZhciBzZWxlY3RvciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciB0YWdOYW1lID0gdm9pZCAwO1xuICB2YXIgaWQgPSAnJztcbiAgdmFyIGNsYXNzZXMgPSBbXTtcblxuICB2YXIgdGFnUGFydHMgPSAoMCwgX2Jyb3dzZXJTcGxpdDIuZGVmYXVsdCkoc2VsZWN0b3IsIGNsYXNzSWRTcGxpdCk7XG5cbiAgaWYgKG5vdENsYXNzSWQudGVzdCh0YWdQYXJ0c1sxXSkgfHwgc2VsZWN0b3IgPT09ICcnKSB7XG4gICAgdGFnTmFtZSA9ICdkaXYnO1xuICB9XG5cbiAgdmFyIHBhcnQgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICB2YXIgaSA9IHZvaWQgMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGFnUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0ID0gdGFnUGFydHNbaV07XG5cbiAgICBpZiAoIXBhcnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSBwYXJ0LmNoYXJBdCgwKTtcblxuICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgdGFnTmFtZSA9IHBhcnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnLicpIHtcbiAgICAgIGNsYXNzZXMucHVzaChwYXJ0LnN1YnN0cmluZygxLCBwYXJ0Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJyMnKSB7XG4gICAgICBpZCA9IHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5qb2luKCcgJylcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tc2VsZWN0b3IvbGliL3NlbGVjdG9yUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0LUVzY2gvdmlydHVhbC1kb20vYmxvYi9tYXN0ZXIvdmlydHVhbC1oeXBlcnNjcmlwdC9wYXJzZS10YWcuanNcblxudmFyIHNwbGl0ID0gcmVxdWlyZSgnYnJvd3Nlci1zcGxpdCcpO1xuXG52YXIgY2xhc3NJZFNwbGl0ID0gLyhbXFwuI10/W2EtekEtWjAtOVxcdTAwN0YtXFx1RkZGRl86LV0rKS87XG52YXIgbm90Q2xhc3NJZCA9IC9eXFwufCMvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlU2VsZWN0b3Ioc2VsZWN0b3IsIHVwcGVyKSB7XG4gIHNlbGVjdG9yID0gc2VsZWN0b3IgfHwgJyc7XG4gIHZhciB0YWdOYW1lO1xuICB2YXIgaWQgPSAnJztcbiAgdmFyIGNsYXNzZXMgPSBbXTtcblxuICB2YXIgdGFnUGFydHMgPSBzcGxpdChzZWxlY3RvciwgY2xhc3NJZFNwbGl0KTtcblxuICBpZiAobm90Q2xhc3NJZC50ZXN0KHRhZ1BhcnRzWzFdKSB8fCBzZWxlY3RvciA9PT0gJycpIHtcbiAgICB0YWdOYW1lID0gJ2Rpdic7XG4gIH1cblxuICB2YXIgcGFydCwgdHlwZSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGFnUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0ID0gdGFnUGFydHNbaV07XG5cbiAgICBpZiAoIXBhcnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSBwYXJ0LmNoYXJBdCgwKTtcblxuICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgdGFnTmFtZSA9IHBhcnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnLicpIHtcbiAgICAgIGNsYXNzZXMucHVzaChwYXJ0LnN1YnN0cmluZygxLCBwYXJ0Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJyMnKSB7XG4gICAgICBpZCA9IHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZ05hbWU6IHVwcGVyID09PSB0cnVlID8gdGFnTmFtZS50b1VwcGVyQ2FzZSgpIDogdGFnTmFtZSxcbiAgICBpZDogaWQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oJyAnKVxuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tdG8taHRtbC9saWIvcGFyc2Utc2VsZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJVmFsdWVDb21wb25lbnRTaW5rcyB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgU2l6ZSwgQXR0YWNobWVudCwgRmxvYXQgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYsIGEgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVudSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHN1Ym1lbnU/OiBib29sZWFuO1xuICAgIHNlY29uZGFyeT86IGJvb2xlYW47XG4gICAgcG9pbnRpbmc/OiBib29sZWFuO1xuICAgIHRhYnVsYXI/OiBib29sZWFuO1xuICAgIHRleHQ/OiBib29sZWFuO1xuICAgIHZlcnRpY2FsPzogYm9vbGVhbjtcbiAgICBwYWdpbmF0aW9uPzogYm9vbGVhbjtcbiAgICBmaXhlZD86IGJvb2xlYW47XG4gICAgc3RhY2thYmxlPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgaWNvbj86IGJvb2xlYW47XG4gICAgbGFiZWxsZWQ/OiBib29sZWFuO1xuICAgIGNvbXBhY3Q/OiBib29sZWFuO1xuICAgIGV2ZW5seURpdmlkZWQ/OiBib29sZWFuO1xuICAgIGJvcmRlcmxlc3M/OiBib29sZWFuO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cbiAgZXhwb3J0IHR5cGUgQ29udGVudCA9IEFycmF5PE1lbnVJdGVtPjtcbiAgZXhwb3J0IGludGVyZmFjZSBNZW51SXRlbSB7XG4gICAgbGluaz86IGJvb2xlYW47XG4gICAgZG93bj86IGJvb2xlYW47XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgaGVhZGVyPzogYm9vbGVhbjtcbiAgICBmaXR0ZWQ/OiBib29sZWFuO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgICBocmVmPzogc3RyaW5nO1xuICAgIGJvZHk6IERPTUNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWVudSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgYW4gYXNzb3J0bWVudCBvZiBpdGVtcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIFx0c2Vjb25kYXJ5PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBkZS1lbXBoYXNpemUgaXRzIGNvbnRlbnQuXG4gICAqIFx0cG9pbnRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGJlIHBvaW50aW5nIHRvIG5lYXJieSBjb250ZW50LlxuICAgKiBcdHRhYnVsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHRvIGJlIHN1aXRlZCBmb3IgdGFicy5cbiAgICogXHR0ZXh0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBmb3IgdGV4dCBjb250ZW50LlxuICAgKiBcdHZlcnRpY2FsPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBkaXNwbGF5IGl0cyBjb250ZW50IHZlcnRpY2FsbHkuXG4gICAqIFx0cGFnaW5hdGlvbj86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZW51IGNvbnRlbnQgdG8gcHJlc2VudCBsaW5rcyB0byBwYWdlcyBvZiBjb250ZW50LlxuICAgKiBcdGZpeGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBhcHBlYXIgZml4ZWQgdG8gaXRzIGNvbnRleHQuXG4gICAqIFx0c3RhY2thYmxlPzogYm9vbGVhbiAtIEVuc3VyZXMgdGhlIG1lbnUgY29udGVudCBzdGFja3Mgb24gbW9iaWxlIHJlc29sdXRpb25zLlxuICAgKiBcdGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBoYXZlIGl0cyBjb2xvcnMgaW52ZXJ0ZWQuXG4gICAqIFx0aWNvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgZm9yIGljb24gY29udGVudC5cbiAgICogXHRsYWJlbGxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgZm9yIGxhYmVsbGVkIGljb24gY29udGVudC5cbiAgICogXHRjb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBzbyB0aGF0IGl0IHRha2VzIG9ubHkgdGhlIGFtb3VudCBvZiBzcGFjZSBuZWNjZXNhcnkuXG4gICAqIFx0ZXZlbmx5RGl2aWRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCBpdHMgY29udGVudCBpcyBldmVubHkgZGl2aWRlZC5cbiAgICogXHRib3JkZXJsZXNzPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSBzbyB0aGF0IHRoZXJlIGFyZSBubyBib3JkZXJzIGJldHdlZW4gaXRzIGNvbnRlbnQuXG4gICAqIFx0Y29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbWVudS5cbiAgICogXHRhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFRoZSBhdHRhY2htZW50IG9mIHRoZSBtZW51LlxuICAgKiBcdHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIG1lbnUuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEFycmF5IG9mIHt9XG4gICAqIFx0bGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYXBwZWFyIGNsaWNrYWJsZS5cbiAgICogXHRkb3duPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0byBhcHBlYXIgcHJlc3NlZC5cbiAgICogXHRhY3RpdmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGJlIG1vcmUgcHJvbm91bmNlZC5cbiAgICogXHRkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiBcdGhlYWRlcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdGV4dCB0byBiZSBtb3JlIHByb25vdW5jZWQuXG4gICAqIFx0Zml0dGVkPzogYm9vbGVhbiAtIFJlbW92ZXMgdGhlIHBhZGRpbmcgb2YgdGhlIGl0ZW0uXG4gICAqICAgICAgICAgaWNvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gZm9yIGljb24gY29udGVudC5cbiAgICogXHRjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBpdGVtLlxuICAgKiBcdGZsb2F0PyBGbG9hdCAtIFRoZSBhbGlnbm1lbnQgb2YgdGhlIGl0ZW0uXG4gICAqIFx0aHJlZj86IHN0cmluZyAtIFRoZSBsaW5rIGZvciB0aGUgaXRlbS5cbiAgICogXHRib2R5OiBET01Db250ZW50IC0gVGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KTogSVZhbHVlQ29tcG9uZW50U2lua3M8Q29udGVudD4ge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcblxuICAgICAgY29uc3QgY2xpY2skID0gc291cmNlcy5ET00uc2VsZWN0KFwiLnVpLm1lbnUgPiAuaXRlbVwiKS5ldmVudHMoXCJjbGlja1wiKTtcbiAgICAgIGNvbnN0IGl0ZW1zJCA9IHNvdXJjZXMuY29udGVudCQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IGNsaWNrZWRJZCQgPSBjbGljayQubWFwKGV2ID0+IHBhcnNlSW50KChldiBhcyBhbnkpLmN1cnJlbnRUYXJnZXQuaWQpKVxuICAgICAgICAuZmlsdGVyKG4gPT4gIWlzTmFOKG4pICYmIHR5cGVvZiAobikgIT09IFwidW5kZWZpbmVkXCIpO1xuICAgICAgY29uc3QgY2xpY2tlZEl0ZW0kID0gaXRlbXMkLm1hcChpdGVtcyA9PiBjbGlja2VkSWQkLm1hcChpZCA9PiBpdGVtc1tpZF0pKS5mbGF0dGVuKClcbiAgICAgICAgLmZpbHRlcihpdGVtID0+ICFpdGVtLmRpc2FibGVkKTtcblxuICAgICAgY29uc3QgdnRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgaXRlbXMkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2dHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5tZW51XCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgICAgdmFsdWUkOiBjbGlja2VkSXRlbSRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1lbnUgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGFuIGFzc29ydG1lbnQgb2YgaXRlbXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiBcdHNlY29uZGFyeT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gZGUtZW1waGFzaXplIGl0cyBjb250ZW50LlxuICAgKiBcdHBvaW50aW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBiZSBwb2ludGluZyB0byBuZWFyYnkgY29udGVudC5cbiAgICogXHR0YWJ1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbWVudSB0byBiZSBzdWl0ZWQgZm9yIHRhYnMuXG4gICAqIFx0dGV4dD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgZm9yIHRleHQgY29udGVudC5cbiAgICogXHR2ZXJ0aWNhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gZGlzcGxheSBpdHMgY29udGVudCB2ZXJ0aWNhbGx5LlxuICAgKiBcdHBhZ2luYXRpb24/OiBib29sZWFuIC0gRm9ybWF0cyB0aGUgbWVudSBjb250ZW50IHRvIHByZXNlbnQgbGlua3MgdG8gcGFnZXMgb2YgY29udGVudC5cbiAgICogXHRmaXhlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gYXBwZWFyIGZpeGVkIHRvIGl0cyBjb250ZXh0LlxuICAgKiBcdHN0YWNrYWJsZT86IGJvb2xlYW4gLSBFbnN1cmVzIHRoZSBtZW51IGNvbnRlbnQgc3RhY2tzIG9uIG1vYmlsZSByZXNvbHV0aW9ucy5cbiAgICogXHRpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgdG8gaGF2ZSBpdHMgY29sb3JzIGludmVydGVkLlxuICAgKiBcdGljb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IGZvciBpY29uIGNvbnRlbnQuXG4gICAqIFx0bGFiZWxsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IGZvciBsYWJlbGxlZCBpY29uIGNvbnRlbnQuXG4gICAqIFx0Y29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCBpdCB0YWtlcyBvbmx5IHRoZSBhbW91bnQgb2Ygc3BhY2UgbmVjY2VzYXJ5LlxuICAgKiBcdGV2ZW5seURpdmlkZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBtZW51IHNvIHRoYXQgaXRzIGNvbnRlbnQgaXMgZXZlbmx5IGRpdmlkZWQuXG4gICAqIFx0Ym9yZGVybGVzcz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIG1lbnUgc28gdGhhdCB0aGVyZSBhcmUgbm8gYm9yZGVycyBiZXR3ZWVuIGl0cyBjb250ZW50LlxuICAgKiBcdGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIG1lbnUuXG4gICAqIFx0YXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBUaGUgYXR0YWNobWVudCBvZiB0aGUgbWVudS5cbiAgICogXHRzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBtZW51LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiBcdGxpbms/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGFwcGVhciBjbGlja2FibGUuXG4gICAqIFx0ZG93bj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gdG8gYXBwZWFyIHByZXNzZWQuXG4gICAqIFx0YWN0aXZlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaXRlbSB0byBiZSBtb3JlIHByb25vdW5jZWQuXG4gICAqIFx0ZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogXHRoZWFkZXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpdGVtIHRleHQgdG8gYmUgbW9yZSBwcm9ub3VuY2VkLlxuICAgKiBcdGZpdHRlZD86IGJvb2xlYW4gLSBSZW1vdmVzIHRoZSBwYWRkaW5nIG9mIHRoZSBpdGVtLlxuICAgKiAgaWNvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGl0ZW0gZm9yIGljb24gY29udGVudC5cbiAgICogXHRjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBpdGVtLlxuICAgKiBcdGZsb2F0PyBGbG9hdCAtIFRoZSBhbGlnbm1lbnQgb2YgdGhlIGl0ZW0uXG4gICAqIFx0aHJlZj86IHN0cmluZyAtIFRoZSBsaW5rIGZvciB0aGUgaXRlbS5cbiAgICogXHRib2R5OiBET01Db250ZW50IC0gVGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgQ29udGVudCA9IHt9LCBjOiBDb250ZW50ID0gW10pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gKHBPckMgaW5zdGFuY2VvZiBBcnJheSkgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSAocE9yQyBpbnN0YW5jZW9mIEFycmF5KSA/IHBPckMgOiBjO1xuICAgIGxldCBpdGVtcyA9IGNvbnRlbnQubWFwKGl0ZW0gPT4gaXRlbS5ocmVmXG4gICAgICA/IGEoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldEl0ZW1DbGFzc25hbWUoaXRlbSksIGlkOiBjb250ZW50LmluZGV4T2YoaXRlbSksIGhyZWY6IGl0ZW0uaHJlZiB9IH0sIGl0ZW0uYm9keSlcbiAgICAgIDogZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRJdGVtQ2xhc3NuYW1lKGl0ZW0pLCBpZDogY29udGVudC5pbmRleE9mKGl0ZW0pIH0gfSwgaXRlbS5ib2R5KVxuICAgICk7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzLCBjb250ZW50Lmxlbmd0aCkgfSB9LCBpdGVtcyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcywgbGVuZ3RoOiBudW1iZXIpIHtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmICghcHJvcHMuc3VibWVudSkge1xuICAgICAgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2Vjb25kYXJ5KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2Vjb25kYXJ5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wb2ludGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHBvaW50aW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWJ1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdGFidWxhclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGV4dCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRleHRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBhZ2luYXRpb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwYWdpbmF0aW9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5maXhlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZpeGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zdGFja2FibGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzdGFja2FibGVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmljb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpY29uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5sYWJlbGxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxhYmVsbGVkIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXBhY3QpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb21wYWN0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ib3JkZXJsZXNzKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYm9yZGVybGVzc1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZXZlbmx5RGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChsZW5ndGgpICsgXCIgaXRlbVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmF0dGFjaG1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQXR0YWNobWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hdHRhY2htZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgbWVudVwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SXRlbUNsYXNzbmFtZShpdGVtOiBNZW51SXRlbSkge1xuICAgIGxldCBjbGFzc05hbWUgPSBcIlwiO1xuICAgIGlmIChpdGVtLmRvd24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkb3duXCI7XG4gICAgfVxuICAgIGlmIChpdGVtLmFjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuICAgIH1cbiAgICBpZiAoaXRlbS5oZWFkZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBoZWFkZXJcIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uZml0dGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxseSBmaXR0ZWRcIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0ubGluaykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxpbmtcIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChpdGVtLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKGl0ZW0uZmxvYXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChpdGVtLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKGl0ZW0uY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgaXRlbVwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9tZW51L2luZGV4LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIERlYm91bmNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYm91bmNlT3BlcmF0b3IoZHQsIGlucykge1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVib3VuY2UnO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIH1cbiAgICBEZWJvdW5jZU9wZXJhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgfTtcbiAgICBEZWJvdW5jZU9wZXJhdG9yLnByb3RvdHlwZS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLmlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICAgICAgdS5fbih0KTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZU9wZXJhdG9yLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICAgIHUuX2MoKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogRGVsYXlzIGV2ZW50cyB1bnRpbCBhIGNlcnRhaW4gYW1vdW50IG9mIHNpbGVuY2UgaGFzIHBhc3NlZC4gSWYgdGhhdCB0aW1lc3BhblxuICogb2Ygc2lsZW5jZSBpcyBub3QgbWV0IHRoZSBldmVudCBpcyBkcm9wcGVkLlxuICpcbiAqIE1hcmJsZSBkaWFncmFtOlxuICpcbiAqIGBgYHRleHRcbiAqIC0tMS0tLS0yLS0zLS00LS0tLTV8XG4gKiAgICAgZGVib3VuY2UoNjApXG4gKiAtLS0tLTEtLS0tLS0tLS0tNC0tfFxuICogYGBgXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IGZyb21EaWFncmFtIGZyb20gJ3hzdHJlYW0vZXh0cmEvZnJvbURpYWdyYW0nXG4gKiBpbXBvcnQgZGVib3VuY2UgZnJvbSAneHN0cmVhbS9leHRyYS9kZWJvdW5jZSdcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSBmcm9tRGlhZ3JhbSgnLS0xLS0tLTItLTMtLTQtLS0tNXwnKVxuICogIC5jb21wb3NlKGRlYm91bmNlKDYwKSlcbiAqXG4gKiBzdHJlYW0uYWRkTGlzdGVuZXIoe1xuICogICBuZXh0OiBpID0+IGNvbnNvbGUubG9nKGkpLFxuICogICBlcnJvcjogZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdjb21wbGV0ZWQnKVxuICogfSlcbiAqIGBgYFxuICpcbiAqIGBgYHRleHRcbiAqID4gMVxuICogPiA0XG4gKiA+IGNvbXBsZXRlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZCBUaGUgYW1vdW50IG9mIHNpbGVuY2UgcmVxdWlyZWQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShwZXJpb2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVib3VuY2VPcGVyYXRvcihpbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlN0cmVhbShuZXcgRGVib3VuY2VPcGVyYXRvcihwZXJpb2QsIGlucykpO1xuICAgIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWJvdW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2V4dHJhL2RlYm91bmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIERlbGF5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5T3BlcmF0b3IoZHQsIGlucykge1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgIHRoaXMuaW5zID0gaW5zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVsYXknO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgfVxuICAgIERlbGF5T3BlcmF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgIH07XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuX24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHUuX24odCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1Ll9lKGVycik7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSwgdGhpcy5kdCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIERlbGF5cyBwZXJpb2RpYyBldmVudHMgYnkgYSBnaXZlbiB0aW1lIHBlcmlvZC5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAxLS0tLTItLTMtLTQtLS0tNXxcbiAqICAgICBkZWxheSg2MClcbiAqIC0tLTEtLS0tMi0tMy0tNC0tLS01fFxuICogYGBgXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IGZyb21EaWFncmFtIGZyb20gJ3hzdHJlYW0vZXh0cmEvZnJvbURpYWdyYW0nXG4gKiBpbXBvcnQgZGVsYXkgZnJvbSAneHN0cmVhbS9leHRyYS9kZWxheSdcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSBmcm9tRGlhZ3JhbSgnMS0tLS0yLS0zLS00LS0tLTV8JylcbiAqICAuY29tcG9zZShkZWxheSg2MCkpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IDEgIChhZnRlciA2MCBtcylcbiAqID4gMiAgKGFmdGVyIDE2MCBtcylcbiAqID4gMyAgKGFmdGVyIDIyMCBtcylcbiAqID4gNCAgKGFmdGVyIDI4MCBtcylcbiAqID4gNSAgKGFmdGVyIDM4MCBtcylcbiAqID4gY29tcGxldGVkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIFRoZSBhbW91bnQgb2Ygc2lsZW5jZSByZXF1aXJlZCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGRlbGF5KHBlcmlvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheU9wZXJhdG9yKGlucykge1xuICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU3RyZWFtKG5ldyBEZWxheU9wZXJhdG9yKHBlcmlvZCwgaW5zKSk7XG4gICAgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3hzdHJlYW0vZXh0cmEvZGVsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG52YXIgZW1wdHkgPSB7fTtcbnZhciBEcm9wUmVwZWF0c09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcm9wUmVwZWF0c09wZXJhdG9yKGlucywgZm4pIHtcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Ryb3BSZXBlYXRzJztcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnYgPSBlbXB0eTtcbiAgICB9XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKG91dCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgICB9O1xuICAgIERyb3BSZXBlYXRzT3BlcmF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLm91dCA9IG51bGw7XG4gICAgICAgIHRoaXMudiA9IGVtcHR5O1xuICAgIH07XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuaXNFcSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZuID8gdGhpcy5mbih4LCB5KSA6IHggPT09IHk7XG4gICAgfTtcbiAgICBEcm9wUmVwZWF0c09wZXJhdG9yLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnY7XG4gICAgICAgIGlmICh2ICE9PSBlbXB0eSAmJiB0aGlzLmlzRXEodCwgdikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudiA9IEFycmF5LmlzQXJyYXkodCkgPyB0LnNsaWNlKCkgOiB0O1xuICAgICAgICB1Ll9uKHQpO1xuICAgIH07XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fZShlcnIpO1xuICAgIH07XG4gICAgRHJvcFJlcGVhdHNPcGVyYXRvci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fYygpO1xuICAgIH07XG4gICAgcmV0dXJuIERyb3BSZXBlYXRzT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5Ecm9wUmVwZWF0c09wZXJhdG9yID0gRHJvcFJlcGVhdHNPcGVyYXRvcjtcbi8qKlxuICogRHJvcHMgY29uc2VjdXRpdmUgZHVwbGljYXRlIHZhbHVlcyBpbiBhIHN0cmVhbS5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLTItLTEtLTEtLTEtLTItLTMtLTQtLTMtLTN8XG4gKiAgICAgZHJvcFJlcGVhdHNcbiAqIC0tMS0tMi0tMS0tLS0tLS0tMi0tMy0tNC0tMy0tLXxcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBkcm9wUmVwZWF0cyBmcm9tICd4c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzJ1xuICpcbiAqIGNvbnN0IHN0cmVhbSA9IHhzLm9mKDEsIDIsIDEsIDEsIDEsIDIsIDMsIDQsIDMsIDMpXG4gKiAgIC5jb21wb3NlKGRyb3BSZXBlYXRzKCkpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IDFcbiAqID4gMlxuICogPiAxXG4gKiA+IDJcbiAqID4gM1xuICogPiA0XG4gKiA+IDNcbiAqID4gY29tcGxldGVkXG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlIHdpdGggYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbjpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IGRyb3BSZXBlYXRzIGZyb20gJ3hzdHJlYW0vZXh0cmEvZHJvcFJlcGVhdHMnXG4gKlxuICogY29uc3Qgc3RyZWFtID0geHMub2YoJ2EnLCAnYicsICdhJywgJ0EnLCAnQicsICdiJylcbiAqICAgLmNvbXBvc2UoZHJvcFJlcGVhdHMoKHgsIHkpID0+IHgudG9Mb3dlckNhc2UoKSA9PT0geS50b0xvd2VyQ2FzZSgpKSlcbiAqXG4gKiBzdHJlYW0uYWRkTGlzdGVuZXIoe1xuICogICBuZXh0OiBpID0+IGNvbnNvbGUubG9nKGkpLFxuICogICBlcnJvcjogZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdjb21wbGV0ZWQnKVxuICogfSlcbiAqIGBgYFxuICpcbiAqIGBgYHRleHRcbiAqID4gYVxuICogPiBiXG4gKiA+IGFcbiAqID4gQlxuICogPiBjb21wbGV0ZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGlzRXF1YWwgQW4gb3B0aW9uYWwgZnVuY3Rpb24gb2YgdHlwZVxuICogYCh4OiBULCB5OiBUKSA9PiBib29sZWFuYCB0aGF0IHRha2VzIGFuIGV2ZW50IGZyb20gdGhlIGlucHV0IHN0cmVhbSBhbmRcbiAqIGNoZWNrcyBpZiBpdCBpcyBlcXVhbCB0byBwcmV2aW91cyBldmVudCwgYnkgcmV0dXJuaW5nIGEgYm9vbGVhbi5cbiAqIEByZXR1cm4ge1N0cmVhbX1cbiAqL1xuZnVuY3Rpb24gZHJvcFJlcGVhdHMoaXNFcXVhbCkge1xuICAgIGlmIChpc0VxdWFsID09PSB2b2lkIDApIHsgaXNFcXVhbCA9IHZvaWQgMDsgfVxuICAgIHJldHVybiBmdW5jdGlvbiBkcm9wUmVwZWF0c09wZXJhdG9yKGlucykge1xuICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuU3RyZWFtKG5ldyBEcm9wUmVwZWF0c09wZXJhdG9yKGlucywgaXNFcXVhbCkpO1xuICAgIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkcm9wUmVwZWF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3BSZXBlYXRzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9jcy1zcmMvZG9jcy5sZXNzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBydW4gfSBmcm9tIFwiQGN5Y2xlL3hzdHJlYW0tcnVuXCI7XG5pbXBvcnQgeyBtYWtlRE9NRHJpdmVyIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7IG1ha2VSb3V0ZXJEcml2ZXIsIHN1cHBvcnRzSGlzdG9yeSB9IGZyb20gXCJjeWNsaWMtcm91dGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBzd2l0Y2hQYXRoIGZyb20gXCJzd2l0Y2gtcGF0aFwiO1xuXG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL3JvdXRlclwiO1xuaW1wb3J0IHJvdXRlcyBmcm9tIFwiLi9yb3V0ZXNcIjtcbmltcG9ydCB7TGF5b3V0fSBmcm9tIFwiLi9sYXlvdXRcIjtcblxuY29uc3QgaGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeSgpXG4gID8gW2NyZWF0ZUhpc3RvcnkoKSwgc3dpdGNoUGF0aCwge2NhcHR1cmU6IHRydWV9XVxuICA6IFtjcmVhdGVIYXNoSGlzdG9yeSgpLCBzd2l0Y2hQYXRoLCB7Y2FwdHVyZTogdHJ1ZX1dO1xuXG5mdW5jdGlvbiBhcHAoZHJpdmVycykge1xuICBjb25zdCBwYWdlID0gUm91dGVyKE9iamVjdC5hc3NpZ24oe30sIGRyaXZlcnMsIHtyb3V0ZXN9KSk7XG4gIGNvbnN0IGxheW91dCA9IExheW91dC5ydW4oZHJpdmVycywgcGFnZSk7XG4gIGNvbnN0IHNpbmtzID0ge1xuICAgIERPTTogbGF5b3V0LkRPTSxcbiAgICByb3V0ZXI6IHhzLm1lcmdlKHBhZ2Uucm91dGVyLCBsYXlvdXQucm91dGVyKSxcbiAgfTtcbiAgcmV0dXJuIHNpbmtzO1xufVxuXG5ydW4oYXBwLCB7XG4gIERPTTogbWFrZURPTURyaXZlcihcIi5hcHBcIiksXG4gIHJvdXRlcjogbWFrZVJvdXRlckRyaXZlci5hcHBseShudWxsLCBoaXN0b3J5KSxcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvYXBwLnRzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIGZyb21FdmVudF8xID0gcmVxdWlyZSgnLi9mcm9tRXZlbnQnKTtcbnZhciBCb2R5RE9NU291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb2R5RE9NU291cmNlKF9ydW5TdHJlYW1BZGFwdGVyLCBfbmFtZSkge1xuICAgICAgICB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyID0gX3J1blN0cmVhbUFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICB9XG4gICAgQm9keURPTVNvdXJjZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBzdGlsbCB1bmRlZmluZWQvdW5kZWNpZGVkLlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJvZHlET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnVuU0EgPSB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyO1xuICAgICAgICB2YXIgb3V0ID0gcnVuU0EucmVtZW1iZXIocnVuU0EuYWRhcHQoeHN0cmVhbV8xLmRlZmF1bHQub2YoZG9jdW1lbnQuYm9keSksIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBCb2R5RE9NU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnVzZUNhcHR1cmUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3RyZWFtID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50KGRvY3VtZW50LmJvZHksIGV2ZW50VHlwZSwgb3B0aW9ucy51c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IGZyb21FdmVudF8xLmZyb21FdmVudChkb2N1bWVudC5ib2R5LCBldmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyLmFkYXB0KHN0cmVhbSwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIEJvZHlET01Tb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5Cb2R5RE9NU291cmNlID0gQm9keURPTVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvZHlET01Tb3VyY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL0JvZHlET01Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciB4c3RyZWFtX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJ0BjeWNsZS94c3RyZWFtLWFkYXB0ZXInKTtcbnZhciBmcm9tRXZlbnRfMSA9IHJlcXVpcmUoJy4vZnJvbUV2ZW50Jyk7XG52YXIgRG9jdW1lbnRET01Tb3VyY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvY3VtZW50RE9NU291cmNlKF9ydW5TdHJlYW1BZGFwdGVyLCBfbmFtZSkge1xuICAgICAgICB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyID0gX3J1blN0cmVhbUFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICB9XG4gICAgRG9jdW1lbnRET01Tb3VyY2UucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgc3RpbGwgdW5kZWZpbmVkL3VuZGVjaWRlZC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEb2N1bWVudERPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydW5TQSA9IHRoaXMuX3J1blN0cmVhbUFkYXB0ZXI7XG4gICAgICAgIHZhciBvdXQgPSBydW5TQS5yZW1lbWJlcihydW5TQS5hZGFwdCh4c3RyZWFtXzEuZGVmYXVsdC5vZihkb2N1bWVudCksIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBEb2N1bWVudERPTVNvdXJjZS5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgc3RyZWFtO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy51c2VDYXB0dXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IGZyb21FdmVudF8xLmZyb21FdmVudChkb2N1bWVudCwgZXZlbnRUeXBlLCBvcHRpb25zLnVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50KGRvY3VtZW50LCBldmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyLmFkYXB0KHN0cmVhbSwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIERvY3VtZW50RE9NU291cmNlO1xufSgpKTtcbmV4cG9ydHMuRG9jdW1lbnRET01Tb3VyY2UgPSBEb2N1bWVudERPTVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURvY3VtZW50RE9NU291cmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9Eb2N1bWVudERPTVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU2NvcGVDaGVja2VyXzEgPSByZXF1aXJlKCcuL1Njb3BlQ2hlY2tlcicpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbWF0Y2hlc1NlbGVjdG9yO1xudHJ5IHtcbiAgICBtYXRjaGVzU2VsZWN0b3IgPSByZXF1aXJlKFwibWF0Y2hlcy1zZWxlY3RvclwiKTtcbn1cbmNhdGNoIChlKSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yID0gRnVuY3Rpb24ucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gdG9FbEFycmF5KGlucHV0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGlucHV0KTtcbn1cbnZhciBFbGVtZW50RmluZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50RmluZGVyKG5hbWVzcGFjZSwgaXNvbGF0ZU1vZHVsZSkge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5pc29sYXRlTW9kdWxlID0gaXNvbGF0ZU1vZHVsZTtcbiAgICB9XG4gICAgRWxlbWVudEZpbmRlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgICAgIGlmIChuYW1lc3BhY2Uuam9pbihcIlwiKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY29wZSA9IHV0aWxzXzEuZ2V0U2NvcGUobmFtZXNwYWNlKTtcbiAgICAgICAgdmFyIHNjb3BlQ2hlY2tlciA9IG5ldyBTY29wZUNoZWNrZXJfMS5TY29wZUNoZWNrZXIoc2NvcGUsIHRoaXMuaXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHV0aWxzXzEuZ2V0U2VsZWN0b3JzKG5hbWVzcGFjZSk7XG4gICAgICAgIHZhciB0b3BOb2RlID0gcm9vdEVsZW1lbnQ7XG4gICAgICAgIHZhciB0b3BOb2RlTWF0Y2hlcyA9IFtdO1xuICAgICAgICBpZiAoc2NvcGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9wTm9kZSA9IHRoaXMuaXNvbGF0ZU1vZHVsZS5nZXRJc29sYXRlZEVsZW1lbnQoc2NvcGUpIHx8IHJvb3RFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yICYmIG1hdGNoZXNTZWxlY3Rvcih0b3BOb2RlLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICB0b3BOb2RlTWF0Y2hlcy5wdXNoKHRvcE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0VsQXJyYXkodG9wTm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAgICAgICAgIC5maWx0ZXIoc2NvcGVDaGVja2VyLmlzU3RyaWN0bHlJblJvb3RTY29wZSwgc2NvcGVDaGVja2VyKVxuICAgICAgICAgICAgLmNvbmNhdCh0b3BOb2RlTWF0Y2hlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudEZpbmRlcjtcbn0oKSk7XG5leHBvcnRzLkVsZW1lbnRGaW5kZXIgPSBFbGVtZW50RmluZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxlbWVudEZpbmRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvRWxlbWVudEZpbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU2NvcGVDaGVja2VyXzEgPSByZXF1aXJlKCcuL1Njb3BlQ2hlY2tlcicpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbWF0Y2hlc1NlbGVjdG9yO1xudHJ5IHtcbiAgICBtYXRjaGVzU2VsZWN0b3IgPSByZXF1aXJlKFwibWF0Y2hlcy1zZWxlY3RvclwiKTtcbn1cbmNhdGNoIChlKSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yID0gRnVuY3Rpb24ucHJvdG90eXBlO1xufVxudmFyIGdEZXN0aW5hdGlvbklkID0gMDtcbmZ1bmN0aW9uIGZpbmREZXN0aW5hdGlvbklkKGFyciwgc2VhcmNoSWQpIHtcbiAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgIHZhciBtYXhJbmRleCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHZhciBjdXJyZW50SW5kZXg7XG4gICAgdmFyIGN1cnJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIGN1cnJlbnRFbGVtZW50ID0gYXJyW2N1cnJlbnRJbmRleF07XG4gICAgICAgIHZhciBjdXJyZW50SWQgPSBjdXJyZW50RWxlbWVudC5kZXN0aW5hdGlvbklkO1xuICAgICAgICBpZiAoY3VycmVudElkIDwgc2VhcmNoSWQpIHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50SWQgPiBzZWFyY2hJZCkge1xuICAgICAgICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vKipcbiAqIEF0dGFjaGVzIGFuIGFjdHVhbCBldmVudCBsaXN0ZW5lciB0byB0aGUgRE9NIHJvb3QgZWxlbWVudCxcbiAqIGhhbmRsZXMgXCJkZXN0aW5hdGlvbnNcIiAoaW50ZXJlc3RlZCBET01Tb3VyY2Ugb3V0cHV0IHN1YmplY3RzKSwgYW5kIGJ1YmJsaW5nLlxuICovXG52YXIgRXZlbnREZWxlZ2F0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50RGVsZWdhdG9yKHRvcEVsZW1lbnQsIGV2ZW50VHlwZSwgdXNlQ2FwdHVyZSwgaXNvbGF0ZU1vZHVsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRvcEVsZW1lbnQgPSB0b3BFbGVtZW50O1xuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgdGhpcy51c2VDYXB0dXJlID0gdXNlQ2FwdHVyZTtcbiAgICAgICAgdGhpcy5pc29sYXRlTW9kdWxlID0gaXNvbGF0ZU1vZHVsZTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5yb29mID0gdG9wRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAodXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5kb21MaXN0ZW5lciA9IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMuY2FwdHVyZShldik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvbUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5idWJibGUoZXYpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHRvcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHRoaXMuZG9tTGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgIH1cbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gKHJhd0V2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy50b3BFbGVtZW50LmNvbnRhaW5zKHJhd0V2ZW50LmN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ID0gdGhpcy5wYXRjaEV2ZW50KHJhd0V2ZW50KTtcbiAgICAgICAgZm9yICh2YXIgZWwgPSBldi50YXJnZXQ7IGVsICYmIGVsICE9PSB0aGlzLnJvb2Y7IGVsID0gZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRvcEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXYucHJvcGFnYXRpb25IYXNCZWVuU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWF0Y2hFdmVudEFnYWluc3REZXN0aW5hdGlvbnMoZWwsIGV2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLm1hdGNoRXZlbnRBZ2FpbnN0RGVzdGluYXRpb25zID0gZnVuY3Rpb24gKGVsLCBldikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuZGVzdGluYXRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlc3QgPSB0aGlzLmRlc3RpbmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmICghZGVzdC5zY29wZUNoZWNrZXIuaXNTdHJpY3RseUluUm9vdFNjb3BlKGVsKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3RvcihlbCwgZGVzdC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZUV2ZW50Q3VycmVudFRhcmdldChldiwgZWwpO1xuICAgICAgICAgICAgICAgIGRlc3Quc3ViamVjdC5fbihldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5jYXB0dXJlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5kZXN0aW5hdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHRoaXMuZGVzdGluYXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3Rvcihldi50YXJnZXQsIGRlc3Quc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgZGVzdC5zdWJqZWN0Ll9uKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLmFkZERlc3RpbmF0aW9uID0gZnVuY3Rpb24gKHN1YmplY3QsIG5hbWVzcGFjZSwgZGVzdGluYXRpb25JZCkge1xuICAgICAgICB2YXIgc2NvcGUgPSB1dGlsc18xLmdldFNjb3BlKG5hbWVzcGFjZSk7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHV0aWxzXzEuZ2V0U2VsZWN0b3JzKG5hbWVzcGFjZSk7XG4gICAgICAgIHZhciBzY29wZUNoZWNrZXIgPSBuZXcgU2NvcGVDaGVja2VyXzEuU2NvcGVDaGVja2VyKHNjb3BlLCB0aGlzLmlzb2xhdGVNb2R1bGUpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9ucy5wdXNoKHsgc3ViamVjdDogc3ViamVjdCwgc2NvcGVDaGVja2VyOiBzY29wZUNoZWNrZXIsIHNlbGVjdG9yOiBzZWxlY3RvciwgZGVzdGluYXRpb25JZDogZGVzdGluYXRpb25JZCB9KTtcbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5jcmVhdGVEZXN0aW5hdGlvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ0Rlc3RpbmF0aW9uSWQrKztcbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5yZW1vdmVEZXN0aW5hdGlvbklkID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uSWQpIHtcbiAgICAgICAgdmFyIGkgPSBmaW5kRGVzdGluYXRpb25JZCh0aGlzLmRlc3RpbmF0aW9ucywgZGVzdGluYXRpb25JZCk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLnBhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBFdmVudCA9IGV2ZW50O1xuICAgICAgICBwRXZlbnQucHJvcGFnYXRpb25IYXNCZWVuU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgb2xkU3RvcFByb3BhZ2F0aW9uID0gcEV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgcEV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgIG9sZFN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGlvbkhhc0JlZW5TdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBFdmVudDtcbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5tdXRhdGVFdmVudEN1cnJlbnRUYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQsIGN1cnJlbnRUYXJnZXRFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRUYXJnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGxlYXNlIHVzZSBldmVudC5vd25lclRhcmdldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5vd25lclRhcmdldCA9IGN1cnJlbnRUYXJnZXRFbGVtZW50O1xuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLnVwZGF0ZVRvcEVsZW1lbnQgPSBmdW5jdGlvbiAobmV3VG9wRWxlbWVudCkge1xuICAgICAgICB0aGlzLnRvcEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50VHlwZSwgdGhpcy5kb21MaXN0ZW5lciwgdGhpcy51c2VDYXB0dXJlKTtcbiAgICAgICAgbmV3VG9wRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRUeXBlLCB0aGlzLmRvbUxpc3RlbmVyLCB0aGlzLnVzZUNhcHR1cmUpO1xuICAgICAgICB0aGlzLnRvcEVsZW1lbnQgPSBuZXdUb3BFbGVtZW50O1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RGVsZWdhdG9yO1xufSgpKTtcbmV4cG9ydHMuRXZlbnREZWxlZ2F0b3IgPSBFdmVudERlbGVnYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50RGVsZWdhdG9yLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9FdmVudERlbGVnYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZSgneHN0cmVhbScpO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIEhUTUxTb3VyY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhUTUxTb3VyY2UoaHRtbCQsIHJ1blNBLCBfbmFtZSkge1xuICAgICAgICB0aGlzLnJ1blNBID0gcnVuU0E7XG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICAgICAgdGhpcy5faHRtbCQgPSBodG1sJDtcbiAgICAgICAgdGhpcy5fZW1wdHkkID0gcnVuU0EuYWRhcHQoeHN0cmVhbV8xLmRlZmF1bHQuZW1wdHkoKSwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpO1xuICAgIH1cbiAgICBIVE1MU291cmNlLnByb3RvdHlwZS5lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMucnVuU0EuYWRhcHQodGhpcy5faHRtbCQsIHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQuc3RyZWFtU3Vic2NyaWJlKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIEhUTUxTb3VyY2UucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IEhUTUxTb3VyY2UoeHN0cmVhbV8xLmRlZmF1bHQuZW1wdHkoKSwgdGhpcy5ydW5TQSwgdGhpcy5fbmFtZSk7XG4gICAgfTtcbiAgICBIVE1MU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9lbXB0eSQ7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICByZXR1cm4gSFRNTFNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLkhUTUxTb3VyY2UgPSBIVE1MU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFNvdXJjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvSFRNTFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgRG9jdW1lbnRET01Tb3VyY2VfMSA9IHJlcXVpcmUoJy4vRG9jdW1lbnRET01Tb3VyY2UnKTtcbnZhciBCb2R5RE9NU291cmNlXzEgPSByZXF1aXJlKCcuL0JvZHlET01Tb3VyY2UnKTtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG52YXIgRWxlbWVudEZpbmRlcl8xID0gcmVxdWlyZSgnLi9FbGVtZW50RmluZGVyJyk7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKCcuL2Zyb21FdmVudCcpO1xudmFyIGlzb2xhdGVfMSA9IHJlcXVpcmUoJy4vaXNvbGF0ZScpO1xudmFyIEV2ZW50RGVsZWdhdG9yXzEgPSByZXF1aXJlKCcuL0V2ZW50RGVsZWdhdG9yJyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBtYXRjaGVzU2VsZWN0b3I7XG50cnkge1xuICAgIG1hdGNoZXNTZWxlY3RvciA9IHJlcXVpcmUoXCJtYXRjaGVzLXNlbGVjdG9yXCIpO1xufVxuY2F0Y2ggKGUpIHtcbiAgICBtYXRjaGVzU2VsZWN0b3IgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG59XG52YXIgZXZlbnRUeXBlc1RoYXREb250QnViYmxlID0gW1xuICAgIFwiYmx1clwiLFxuICAgIFwiY2FucGxheVwiLFxuICAgIFwiY2FucGxheXRocm91Z2hcIixcbiAgICBcImNoYW5nZVwiLFxuICAgIFwiZHVyYXRpb25jaGFuZ2VcIixcbiAgICBcImVtcHRpZWRcIixcbiAgICBcImVuZGVkXCIsXG4gICAgXCJmb2N1c1wiLFxuICAgIFwibG9hZFwiLFxuICAgIFwibG9hZGVkZGF0YVwiLFxuICAgIFwibG9hZGVkbWV0YWRhdGFcIixcbiAgICBcIm1vdXNlZW50ZXJcIixcbiAgICBcIm1vdXNlbGVhdmVcIixcbiAgICBcInBhdXNlXCIsXG4gICAgXCJwbGF5XCIsXG4gICAgXCJwbGF5aW5nXCIsXG4gICAgXCJyYXRlY2hhbmdlXCIsXG4gICAgXCJyZXNldFwiLFxuICAgIFwic2Nyb2xsXCIsXG4gICAgXCJzZWVrZWRcIixcbiAgICBcInNlZWtpbmdcIixcbiAgICBcInN0YWxsZWRcIixcbiAgICBcInN1Ym1pdFwiLFxuICAgIFwic3VzcGVuZFwiLFxuICAgIFwidGltZXVwZGF0ZVwiLFxuICAgIFwidW5sb2FkXCIsXG4gICAgXCJ2b2x1bWVjaGFuZ2VcIixcbiAgICBcIndhaXRpbmdcIixcbl07XG5mdW5jdGlvbiBkZXRlcm1pbmVVc2VDYXB0dXJlKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudXNlQ2FwdHVyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJlc3VsdCA9IG9wdGlvbnMudXNlQ2FwdHVyZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VHlwZXNUaGF0RG9udEJ1YmJsZS5pbmRleE9mKGV2ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJCYXNlZE9uSXNvbGF0aW9uKGRvbVNvdXJjZSwgc2NvcGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmlsdGVyQmFzZWRPbklzb2xhdGlvbk9wZXJhdG9yKHJvb3RFbGVtZW50JCkge1xuICAgICAgICByZXR1cm4gcm9vdEVsZW1lbnQkXG4gICAgICAgICAgICAuZm9sZChmdW5jdGlvbiBzaG91bGRQYXNzKHN0YXRlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFzSXNvbGF0ZWQgPSAhIWRvbVNvdXJjZS5faXNvbGF0ZU1vZHVsZS5nZXRJc29sYXRlZEVsZW1lbnQoc2NvcGUpO1xuICAgICAgICAgICAgdmFyIHNob3VsZFBhc3MgPSBoYXNJc29sYXRlZCAmJiAhc3RhdGUuaGFkSXNvbGF0ZWRNdXRhYmxlO1xuICAgICAgICAgICAgcmV0dXJuIHsgaGFkSXNvbGF0ZWRNdXRhYmxlOiBoYXNJc29sYXRlZCwgc2hvdWxkUGFzczogc2hvdWxkUGFzcywgZWxlbWVudDogZWxlbWVudCB9O1xuICAgICAgICB9LCB7IGhhZElzb2xhdGVkTXV0YWJsZTogZmFsc2UsIHNob3VsZFBhc3M6IGZhbHNlLCBlbGVtZW50OiBudWxsIH0pXG4gICAgICAgICAgICAuZHJvcCgxKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zaG91bGRQYXNzOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5lbGVtZW50OyB9KTtcbiAgICB9O1xufVxudmFyIE1haW5ET01Tb3VyY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1haW5ET01Tb3VyY2UoX3Jvb3RFbGVtZW50JCwgX3Nhbml0YXRpb24kLCBfcnVuU3RyZWFtQWRhcHRlciwgX25hbWVzcGFjZSwgX2lzb2xhdGVNb2R1bGUsIF9kZWxlZ2F0b3JzLCBfbmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoX25hbWVzcGFjZSA9PT0gdm9pZCAwKSB7IF9uYW1lc3BhY2UgPSBbXTsgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudCQgPSBfcm9vdEVsZW1lbnQkO1xuICAgICAgICB0aGlzLl9zYW5pdGF0aW9uJCA9IF9zYW5pdGF0aW9uJDtcbiAgICAgICAgdGhpcy5fcnVuU3RyZWFtQWRhcHRlciA9IF9ydW5TdHJlYW1BZGFwdGVyO1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBfbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLl9pc29sYXRlTW9kdWxlID0gX2lzb2xhdGVNb2R1bGU7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRvcnMgPSBfZGVsZWdhdG9ycztcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICAgICAgICB0aGlzLl9fSkFOSV9FVkFLQUxMSU9fV0VfV0lMTF9NSVNTX1lPVV9QTEVBU0VfQ09NRV9CQUNLX0VWRU5UVUFMTFkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX0pBTklfRVZBS0FMTElPX1dFX1dJTExfTUlTU19ZT1VfUExFQVNFX0NPTUVfQkFDS19FVkVOVFVBTExZID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc29sYXRlU291cmNlID0gaXNvbGF0ZV8xLmlzb2xhdGVTb3VyY2U7XG4gICAgICAgIHRoaXMuaXNvbGF0ZVNpbmsgPSBmdW5jdGlvbiAoc2luaywgc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1Njb3BlID0gdXRpbHNfMS5nZXRTY29wZShfdGhpcy5fbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIHZhciBkZWVwZXJTY29wZSA9IFtleGlzdGluZ1Njb3BlLCBzY29wZV0uZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAhIXg7IH0pLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIHJldHVybiBpc29sYXRlXzEuaXNvbGF0ZVNpbmsoc2luaywgZGVlcGVyU2NvcGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBNYWluRE9NU291cmNlLnByb3RvdHlwZS5lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dHB1dCQ7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lc3BhY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBvdXRwdXQkID0gdGhpcy5fcm9vdEVsZW1lbnQkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRGaW5kZXJfMSA9IG5ldyBFbGVtZW50RmluZGVyXzEuRWxlbWVudEZpbmRlcih0aGlzLl9uYW1lc3BhY2UsIHRoaXMuX2lzb2xhdGVNb2R1bGUpO1xuICAgICAgICAgICAgb3V0cHV0JCA9IHRoaXMuX3Jvb3RFbGVtZW50JC5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbGVtZW50RmluZGVyXzEuY2FsbChlbCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydW5TQSA9IHRoaXMuX3J1blN0cmVhbUFkYXB0ZXI7XG4gICAgICAgIHZhciBvdXQgPSBydW5TQS5yZW1lbWJlcihydW5TQS5hZGFwdChvdXRwdXQkLCB4c3RyZWFtX2FkYXB0ZXJfMS5kZWZhdWx0LnN0cmVhbVN1YnNjcmliZSkpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1haW5ET01Tb3VyY2UucHJvdG90eXBlLCBcIm5hbWVzcGFjZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVzcGFjZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJET00gZHJpdmVyJ3Mgc2VsZWN0KCkgZXhwZWN0cyB0aGUgYXJndW1lbnQgdG8gYmUgYSBcIiArXG4gICAgICAgICAgICAgICAgXCJzdHJpbmcgYXMgYSBDU1Mgc2VsZWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50RE9NU291cmNlXzEuRG9jdW1lbnRET01Tb3VyY2UodGhpcy5fcnVuU3RyZWFtQWRhcHRlciwgdGhpcy5fbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9keURPTVNvdXJjZV8xLkJvZHlET01Tb3VyY2UodGhpcy5fcnVuU3RyZWFtQWRhcHRlciwgdGhpcy5fbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyaW1tZWRTZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKTtcbiAgICAgICAgdmFyIGNoaWxkTmFtZXNwYWNlID0gdHJpbW1lZFNlbGVjdG9yID09PSBcIjpyb290XCIgP1xuICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlIDpcbiAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZS5jb25jYXQodHJpbW1lZFNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYWluRE9NU291cmNlKHRoaXMuX3Jvb3RFbGVtZW50JCwgdGhpcy5fc2FuaXRhdGlvbiQsIHRoaXMuX3J1blN0cmVhbUFkYXB0ZXIsIGNoaWxkTmFtZXNwYWNlLCB0aGlzLl9pc29sYXRlTW9kdWxlLCB0aGlzLl9kZWxlZ2F0b3JzLCB0aGlzLl9uYW1lKTtcbiAgICB9O1xuICAgIE1haW5ET01Tb3VyY2UucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudFR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRPTSBkcml2ZXIncyBldmVudHMoKSBleHBlY3RzIGFyZ3VtZW50IHRvIGJlIGEgXCIgK1xuICAgICAgICAgICAgICAgIFwic3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlQ2FwdHVyZSA9IGRldGVybWluZVVzZUNhcHR1cmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMuX25hbWVzcGFjZTtcbiAgICAgICAgdmFyIHNjb3BlID0gdXRpbHNfMS5nZXRTY29wZShuYW1lc3BhY2UpO1xuICAgICAgICB2YXIga2V5UGFydHMgPSBbZXZlbnRUeXBlLCB1c2VDYXB0dXJlXTtcbiAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICBrZXlQYXJ0cy5wdXNoKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0ga2V5UGFydHMuam9pbignficpO1xuICAgICAgICB2YXIgZG9tU291cmNlID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50JDtcbiAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICByb290RWxlbWVudCQgPSB0aGlzLl9yb290RWxlbWVudCRcbiAgICAgICAgICAgICAgICAuY29tcG9zZShmaWx0ZXJCYXNlZE9uSXNvbGF0aW9uKGRvbVNvdXJjZSwgc2NvcGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50JCA9IHRoaXMuX3Jvb3RFbGVtZW50JC50YWtlKDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudCQgPSByb290RWxlbWVudCRcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gc2V0dXBFdmVudERlbGVnYXRvck9uVG9wRWxlbWVudChyb290RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gRXZlbnQgbGlzdGVuZXIganVzdCBmb3IgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRXZlbnRfMS5mcm9tRXZlbnQocm9vdEVsZW1lbnQsIGV2ZW50VHlwZSwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFdmVudCBsaXN0ZW5lciBvbiB0aGUgdG9wIGVsZW1lbnQgYXMgYW4gRXZlbnREZWxlZ2F0b3JcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0b3JzID0gZG9tU291cmNlLl9kZWxlZ2F0b3JzO1xuICAgICAgICAgICAgdmFyIHRvcCA9IGRvbVNvdXJjZS5faXNvbGF0ZU1vZHVsZS5nZXRJc29sYXRlZEVsZW1lbnQoc2NvcGUpIHx8IHJvb3RFbGVtZW50O1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRvcjtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0b3JzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdG9yID0gZGVsZWdhdG9ycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0b3IudXBkYXRlVG9wRWxlbWVudCh0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdG9yID0gbmV3IEV2ZW50RGVsZWdhdG9yXzEuRXZlbnREZWxlZ2F0b3IodG9wLCBldmVudFR5cGUsIHVzZUNhcHR1cmUsIGRvbVNvdXJjZS5faXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgICAgICAgICAgZGVsZWdhdG9ycy5zZXQoa2V5LCBkZWxlZ2F0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgZG9tU291cmNlLl9pc29sYXRlTW9kdWxlLmFkZEV2ZW50RGVsZWdhdG9yKHNjb3BlLCBkZWxlZ2F0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uSWQgPSBkZWxlZ2F0b3IuY3JlYXRlRGVzdGluYXRpb25JZCgpO1xuICAgICAgICAgICAgdmFyIHN1YmplY3QgPSB4c3RyZWFtXzEuZGVmYXVsdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ3JlcXVlc3RJZGxlQ2FsbGJhY2snIGluIHdpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdG9yLnJlbW92ZURlc3RpbmF0aW9uSWQoZGVzdGluYXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRvci5yZW1vdmVEZXN0aW5hdGlvbklkKGRlc3RpbmF0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZWdhdG9yLmFkZERlc3RpbmF0aW9uKHN1YmplY3QsIG5hbWVzcGFjZSwgZGVzdGluYXRpb25JZCk7XG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mbGF0dGVuKCk7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9ydW5TdHJlYW1BZGFwdGVyLmFkYXB0KGV2ZW50JCwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSBkb21Tb3VyY2UuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBNYWluRE9NU291cmNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zYW5pdGF0aW9uJC5zaGFtZWZ1bGx5U2VuZE5leHQoJycpO1xuICAgICAgICB0aGlzLl9pc29sYXRlTW9kdWxlLnJlc2V0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFpbkRPTVNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLk1haW5ET01Tb3VyY2UgPSBNYWluRE9NU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFpbkRPTVNvdXJjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvTWFpbkRPTVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaHlwZXJzY3JpcHRfMSA9IHJlcXVpcmUoJy4vaHlwZXJzY3JpcHQnKTtcbnZhciBjbGFzc05hbWVGcm9tVk5vZGVfMSA9IHJlcXVpcmUoJ3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9jbGFzc05hbWVGcm9tVk5vZGUnKTtcbnZhciBzZWxlY3RvclBhcnNlcl8xID0gcmVxdWlyZSgnc25hYmJkb20tc2VsZWN0b3IvbGliL3NlbGVjdG9yUGFyc2VyJyk7XG52YXIgVk5vZGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWTm9kZVdyYXBwZXIocm9vdEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuICAgIH1cbiAgICBWTm9kZVdyYXBwZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gc2VsZWN0b3JQYXJzZXJfMS5kZWZhdWx0KHZub2RlLnNlbCksIHNlbGVjdG9yVGFnTmFtZSA9IF9hLnRhZ05hbWUsIHNlbGVjdG9ySWQgPSBfYS5pZDtcbiAgICAgICAgdmFyIHZOb2RlQ2xhc3NOYW1lID0gY2xhc3NOYW1lRnJvbVZOb2RlXzEuZGVmYXVsdCh2bm9kZSk7XG4gICAgICAgIHZhciB2Tm9kZURhdGEgPSB2bm9kZS5kYXRhIHx8IHt9O1xuICAgICAgICB2YXIgdk5vZGVEYXRhUHJvcHMgPSB2Tm9kZURhdGEucHJvcHMgfHwge307XG4gICAgICAgIHZhciBfYiA9IHZOb2RlRGF0YVByb3BzLmlkLCB2Tm9kZUlkID0gX2IgPT09IHZvaWQgMCA/IHNlbGVjdG9ySWQgOiBfYjtcbiAgICAgICAgdmFyIGlzVk5vZGVBbmRSb290RWxlbWVudElkZW50aWNhbCA9IHZOb2RlSWQudG9VcHBlckNhc2UoKSA9PT0gdGhpcy5yb290RWxlbWVudC5pZC50b1VwcGVyQ2FzZSgpICYmXG4gICAgICAgICAgICBzZWxlY3RvclRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gdGhpcy5yb290RWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgJiZcbiAgICAgICAgICAgIHZOb2RlQ2xhc3NOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHRoaXMucm9vdEVsZW1lbnQuY2xhc3NOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChpc1ZOb2RlQW5kUm9vdEVsZW1lbnRJZGVudGljYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSB0aGlzLnJvb3RFbGVtZW50LCB0YWdOYW1lID0gX2MudGFnTmFtZSwgaWQgPSBfYy5pZCwgY2xhc3NOYW1lID0gX2MuY2xhc3NOYW1lO1xuICAgICAgICB2YXIgZWxlbWVudElkID0gaWQgPyBcIiNcIiArIGlkIDogXCJcIjtcbiAgICAgICAgdmFyIGVsZW1lbnRDbGFzc05hbWUgPSBjbGFzc05hbWUgP1xuICAgICAgICAgICAgXCIuXCIgKyBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLmpvaW4oXCIuXCIpIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGh5cGVyc2NyaXB0XzEuaChcIlwiICsgdGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgZWxlbWVudElkICsgZWxlbWVudENsYXNzTmFtZSwge30sIFtcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIHJldHVybiBWTm9kZVdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5WTm9kZVdyYXBwZXIgPSBWTm9kZVdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WTm9kZVdyYXBwZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL1ZOb2RlV3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaHlwZXJzY3JpcHRfMSA9IHJlcXVpcmUoJy4vaHlwZXJzY3JpcHQnKTtcbmZ1bmN0aW9uIGlzVmFsaWRTdHJpbmcocGFyYW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyAmJiBwYXJhbS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gaXNTZWxlY3RvcihwYXJhbSkge1xuICAgIHJldHVybiBpc1ZhbGlkU3RyaW5nKHBhcmFtKSAmJiAocGFyYW1bMF0gPT09ICcuJyB8fCBwYXJhbVswXSA9PT0gJyMnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhZ0Z1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaHlwZXJzY3JpcHQoZmlyc3QsIGIsIGMpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0b3IoZmlyc3QpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoeXBlcnNjcmlwdF8xLmgodGFnTmFtZSArIGZpcnN0LCBiLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoeXBlcnNjcmlwdF8xLmgodGFnTmFtZSArIGZpcnN0LCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoeXBlcnNjcmlwdF8xLmgodGFnTmFtZSArIGZpcnN0LCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoISFiKSB7XG4gICAgICAgICAgICByZXR1cm4gaHlwZXJzY3JpcHRfMS5oKHRhZ05hbWUsIGZpcnN0LCBiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghIWZpcnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaHlwZXJzY3JpcHRfMS5oKHRhZ05hbWUsIGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoeXBlcnNjcmlwdF8xLmgodGFnTmFtZSwge30pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBTVkdfVEFHX05BTUVTID0gW1xuICAgICdhJywgJ2FsdEdseXBoJywgJ2FsdEdseXBoRGVmJywgJ2FsdEdseXBoSXRlbScsICdhbmltYXRlJywgJ2FuaW1hdGVDb2xvcicsXG4gICAgJ2FuaW1hdGVNb3Rpb24nLCAnYW5pbWF0ZVRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcFBhdGgnLCAnY29sb3JQcm9maWxlJyxcbiAgICAnY3Vyc29yJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsXG4gICAgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsXG4gICAgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJyxcbiAgICAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsXG4gICAgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJyxcbiAgICAnZmVTcG90bGlnaHQnLCAnZmVUaWxlJywgJ2ZlVHVyYnVsZW5jZScsICdmaWx0ZXInLCAnZm9udCcsICdmb250RmFjZScsXG4gICAgJ2ZvbnRGYWNlRm9ybWF0JywgJ2ZvbnRGYWNlTmFtZScsICdmb250RmFjZVNyYycsICdmb250RmFjZVVyaScsXG4gICAgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJyxcbiAgICAnbGluZWFyR3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbWlzc2luZ0dseXBoJywgJ21wYXRoJyxcbiAgICAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzY3JpcHQnLFxuICAgICdzZXQnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dFBhdGgnLCAndGl0bGUnLFxuICAgICd0cmVmJywgJ3RzcGFuJywgJ3VzZScsICd2aWV3JywgJ3ZrZXJuJyxcbl07XG52YXIgc3ZnID0gY3JlYXRlVGFnRnVuY3Rpb24oJ3N2ZycpO1xuU1ZHX1RBR19OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICBzdmdbdGFnXSA9IGNyZWF0ZVRhZ0Z1bmN0aW9uKHRhZyk7XG59KTtcbnZhciBUQUdfTkFNRVMgPSBbXG4gICAgJ2EnLCAnYWJicicsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2Jhc2UnLFxuICAgICdiZGknLCAnYmRvJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLFxuICAgICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RlbCcsICdkZm4nLCAnZGlyJywgJ2RpdicsICdkbCcsXG4gICAgJ2R0JywgJ2VtJywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJyxcbiAgICAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLFxuICAgICdpJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdrZXlnZW4nLCAnbGFiZWwnLCAnbGVnZW5kJyxcbiAgICAnbGknLCAnbGluaycsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21lbnUnLCAnbWV0YScsICduYXYnLCAnbm9zY3JpcHQnLFxuICAgICdvYmplY3QnLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ3AnLCAncGFyYW0nLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLFxuICAgICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc21hbGwnLFxuICAgICdzb3VyY2UnLCAnc3BhbicsICdzdHJvbmcnLCAnc3R5bGUnLCAnc3ViJywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsXG4gICAgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3UnLCAndWwnLCAndmlkZW8nLFxuXTtcbnZhciBleHBvcnRlZCA9IHsgU1ZHX1RBR19OQU1FUzogU1ZHX1RBR19OQU1FUywgVEFHX05BTUVTOiBUQUdfTkFNRVMsIHN2Zzogc3ZnLCBpc1NlbGVjdG9yOiBpc1NlbGVjdG9yLCBjcmVhdGVUYWdGdW5jdGlvbjogY3JlYXRlVGFnRnVuY3Rpb24gfTtcblRBR19OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgZXhwb3J0ZWRbbl0gPSBjcmVhdGVUYWdGdW5jdGlvbihuKTtcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oeXBlcnNjcmlwdC1oZWxwZXJzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9oeXBlcnNjcmlwdC1oZWxwZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsc18xID0gcmVxdWlyZSgnLi91dGlscycpO1xuZnVuY3Rpb24gaXNvbGF0ZVNvdXJjZShzb3VyY2UsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zZWxlY3QodXRpbHNfMS5TQ09QRV9QUkVGSVggKyBzY29wZSk7XG59XG5leHBvcnRzLmlzb2xhdGVTb3VyY2UgPSBpc29sYXRlU291cmNlO1xuZnVuY3Rpb24gaXNvbGF0ZVNpbmsoc2luaywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2luay5tYXAoZnVuY3Rpb24gKHZUcmVlKSB7XG4gICAgICAgIGlmICh2VHJlZS5kYXRhICYmIHZUcmVlLmRhdGEuaXNvbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nU2NvcGUgPSB2VHJlZS5kYXRhLmlzb2xhdGUucmVwbGFjZSgvKGN5Y2xlfFxcLSkvZywgJycpO1xuICAgICAgICAgICAgdmFyIF9zY29wZSA9IHNjb3BlLnJlcGxhY2UoLyhjeWNsZXxcXC0pL2csICcnKTtcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUludChleGlzdGluZ1Njb3BlKSlcbiAgICAgICAgICAgICAgICB8fCBpc05hTihwYXJzZUludChfc2NvcGUpKVxuICAgICAgICAgICAgICAgIHx8IGV4aXN0aW5nU2NvcGUgPiBfc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdlRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdlRyZWUuZGF0YSA9IHZUcmVlLmRhdGEgfHwge307XG4gICAgICAgIHZUcmVlLmRhdGEuaXNvbGF0ZSA9IHNjb3BlO1xuICAgICAgICBpZiAodHlwZW9mIHZUcmVlLmtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZUcmVlLmtleSA9IHV0aWxzXzEuU0NPUEVfUFJFRklYICsgc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZUcmVlO1xuICAgIH0pO1xufVxuZXhwb3J0cy5pc29sYXRlU2luayA9IGlzb2xhdGVTaW5rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNvbGF0ZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvaXNvbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTWFwUG9seWZpbGwgPSByZXF1aXJlKCdlczYtbWFwJyk7XG52YXIgSXNvbGF0ZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXNvbGF0ZU1vZHVsZShpc29sYXRlZEVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuaXNvbGF0ZWRFbGVtZW50cyA9IGlzb2xhdGVkRWxlbWVudHM7XG4gICAgICAgIHRoaXMuZXZlbnREZWxlZ2F0b3JzID0gbmV3IE1hcFBvbHlmaWxsKCk7XG4gICAgfVxuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLnNldFNjb3BlID0gZnVuY3Rpb24gKGVsbSwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5pc29sYXRlZEVsZW1lbnRzLnNldChzY29wZSwgZWxtKTtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLnJlbW92ZVNjb3BlID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuaXNvbGF0ZWRFbGVtZW50cy5kZWxldGUoc2NvcGUpO1xuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuY2xlYW51cFZOb2RlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkYXRhID0gX2EuZGF0YSwgZWxtID0gX2EuZWxtO1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgdmFyIHNjb3BlID0gZGF0YS5pc29sYXRlIHx8ICcnO1xuICAgICAgICB2YXIgaXNDdXJyZW50RWxtID0gdGhpcy5pc29sYXRlZEVsZW1lbnRzLmdldChzY29wZSkgPT09IGVsbTtcbiAgICAgICAgaWYgKHNjb3BlICYmIGlzQ3VycmVudEVsbSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTY29wZShzY29wZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudERlbGVnYXRvcnMuZ2V0KHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREZWxlZ2F0b3JzLnNldChzY29wZSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5nZXRJc29sYXRlZEVsZW1lbnQgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvbGF0ZWRFbGVtZW50cy5nZXQoc2NvcGUpO1xuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuaXNJc29sYXRlZEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxtKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXNvbGF0ZWRFbGVtZW50cy5lbnRyaWVzKCk7XG4gICAgICAgIGZvciAodmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTsgISFyZXN1bHQudmFsdWU7IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIF9hID0gcmVzdWx0LnZhbHVlLCBzY29wZSA9IF9hWzBdLCBlbGVtZW50ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAoZWxtID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLmFkZEV2ZW50RGVsZWdhdG9yID0gZnVuY3Rpb24gKHNjb3BlLCBldmVudERlbGVnYXRvcikge1xuICAgICAgICB2YXIgZGVsZWdhdG9ycyA9IHRoaXMuZXZlbnREZWxlZ2F0b3JzLmdldChzY29wZSk7XG4gICAgICAgIGlmICghZGVsZWdhdG9ycykge1xuICAgICAgICAgICAgZGVsZWdhdG9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ldmVudERlbGVnYXRvcnMuc2V0KHNjb3BlLCBkZWxlZ2F0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxlZ2F0b3JzW2RlbGVnYXRvcnMubGVuZ3RoXSA9IGV2ZW50RGVsZWdhdG9yO1xuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNvbGF0ZWRFbGVtZW50cy5jbGVhcigpO1xuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuY3JlYXRlTW9kdWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChvbGRWTm9kZSwgdk5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBvbGRWTm9kZS5kYXRhLCBvbGREYXRhID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2E7XG4gICAgICAgICAgICAgICAgdmFyIGVsbSA9IHZOb2RlLmVsbSwgX2IgPSB2Tm9kZS5kYXRhLCBkYXRhID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFNjb3BlID0gb2xkRGF0YS5pc29sYXRlIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIHNjb3BlID0gZGF0YS5pc29sYXRlIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVTY29wZShvbGRTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRTY29wZShlbG0sIHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRvcnMgPSBzZWxmLmV2ZW50RGVsZWdhdG9ycy5nZXQoc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZWdhdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlbGVnYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0b3JzW2ldLnVwZGF0ZVRvcEVsZW1lbnQoZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWxlZ2F0b3JzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXZlbnREZWxlZ2F0b3JzLnNldChzY29wZSwgW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbGRTY29wZSAmJiAhc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVTY29wZShzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9sZFZOb2RlLCB2Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IG9sZFZOb2RlLmRhdGEsIG9sZERhdGEgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYTtcbiAgICAgICAgICAgICAgICB2YXIgZWxtID0gdk5vZGUuZWxtLCBfYiA9IHZOb2RlLmRhdGEsIGRhdGEgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2NvcGUgPSBvbGREYXRhLmlzb2xhdGUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSBkYXRhLmlzb2xhdGUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUgJiYgc2NvcGUgIT09IG9sZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVTY29wZShvbGRTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRTY29wZShlbG0sIHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9sZFNjb3BlICYmICFzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAodk5vZGUsIGNiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhbnVwVk5vZGUodk5vZGUpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKHZOb2RlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhbnVwVk5vZGUodk5vZGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJc29sYXRlTW9kdWxlO1xufSgpKTtcbmV4cG9ydHMuSXNvbGF0ZU1vZHVsZSA9IElzb2xhdGVNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc29sYXRlTW9kdWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9pc29sYXRlTW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBzbmFiYmRvbV8xID0gcmVxdWlyZSgnc25hYmJkb20nKTtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKCd4c3RyZWFtJyk7XG52YXIgTWFpbkRPTVNvdXJjZV8xID0gcmVxdWlyZSgnLi9NYWluRE9NU291cmNlJyk7XG52YXIgVk5vZGVXcmFwcGVyXzEgPSByZXF1aXJlKCcuL1ZOb2RlV3JhcHBlcicpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbW9kdWxlc18xID0gcmVxdWlyZSgnLi9tb2R1bGVzJyk7XG52YXIgaXNvbGF0ZU1vZHVsZV8xID0gcmVxdWlyZSgnLi9pc29sYXRlTW9kdWxlJyk7XG52YXIgdHJhbnNwb3NpdGlvbl8xID0gcmVxdWlyZSgnLi90cmFuc3Bvc2l0aW9uJyk7XG52YXIgeHN0cmVhbV9hZGFwdGVyXzEgPSByZXF1aXJlKCdAY3ljbGUveHN0cmVhbS1hZGFwdGVyJyk7XG52YXIgTWFwUG9seWZpbGwgPSByZXF1aXJlKCdlczYtbWFwJyk7XG5mdW5jdGlvbiBtYWtlRE9NRHJpdmVySW5wdXRHdWFyZChtb2R1bGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbmFsIG1vZHVsZXMgb3B0aW9uIG11c3QgYmUgXCIgK1xuICAgICAgICAgICAgXCJhbiBhcnJheSBmb3Igc25hYmJkb20gbW9kdWxlc1wiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb21Ecml2ZXJJbnB1dEd1YXJkKHZpZXckKSB7XG4gICAgaWYgKCF2aWV3JFxuICAgICAgICB8fCB0eXBlb2YgdmlldyQuYWRkTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIlxuICAgICAgICB8fCB0eXBlb2YgdmlldyQuZm9sZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBET00gZHJpdmVyIGZ1bmN0aW9uIGV4cGVjdHMgYXMgaW5wdXQgYSBTdHJlYW0gb2YgXCIgK1xuICAgICAgICAgICAgXCJ2aXJ0dWFsIERPTSBlbGVtZW50c1wiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlRE9NRHJpdmVyKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHZhciB0cmFuc3Bvc2l0aW9uID0gb3B0aW9ucy50cmFuc3Bvc2l0aW9uIHx8IGZhbHNlO1xuICAgIHZhciBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IG1vZHVsZXNfMS5kZWZhdWx0O1xuICAgIHZhciBpc29sYXRlTW9kdWxlID0gbmV3IGlzb2xhdGVNb2R1bGVfMS5Jc29sYXRlTW9kdWxlKChuZXcgTWFwUG9seWZpbGwoKSkpO1xuICAgIHZhciBwYXRjaCA9IHNuYWJiZG9tXzEuaW5pdChbaXNvbGF0ZU1vZHVsZS5jcmVhdGVNb2R1bGUoKV0uY29uY2F0KG1vZHVsZXMpKTtcbiAgICB2YXIgcm9vdEVsZW1lbnQgPSB1dGlsc18xLmdldEVsZW1lbnQoY29udGFpbmVyKTtcbiAgICB2YXIgdm5vZGVXcmFwcGVyID0gbmV3IFZOb2RlV3JhcHBlcl8xLlZOb2RlV3JhcHBlcihyb290RWxlbWVudCk7XG4gICAgdmFyIGRlbGVnYXRvcnMgPSBuZXcgTWFwUG9seWZpbGwoKTtcbiAgICBtYWtlRE9NRHJpdmVySW5wdXRHdWFyZChtb2R1bGVzKTtcbiAgICBmdW5jdGlvbiBET01Ecml2ZXIodm5vZGUkLCBydW5TdHJlYW1BZGFwdGVyLCBuYW1lKSB7XG4gICAgICAgIGRvbURyaXZlcklucHV0R3VhcmQodm5vZGUkKTtcbiAgICAgICAgdmFyIHRyYW5zcG9zZVZOb2RlID0gdHJhbnNwb3NpdGlvbl8xLm1ha2VUcmFuc3Bvc2VWTm9kZShydW5TdHJlYW1BZGFwdGVyKTtcbiAgICAgICAgdmFyIHByZXByb2Nlc3NlZFZOb2RlJCA9ICh0cmFuc3Bvc2l0aW9uID8gdm5vZGUkLm1hcCh0cmFuc3Bvc2VWTm9kZSkuZmxhdHRlbigpIDogdm5vZGUkKTtcbiAgICAgICAgdmFyIHNhbml0YXRpb24kID0geHN0cmVhbV8xLmRlZmF1bHQuY3JlYXRlKCk7XG4gICAgICAgIHZhciByb290RWxlbWVudCQgPSB4c3RyZWFtXzEuZGVmYXVsdC5tZXJnZShwcmVwcm9jZXNzZWRWTm9kZSQuZW5kV2hlbihzYW5pdGF0aW9uJCksIHNhbml0YXRpb24kKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodm5vZGUpIHsgcmV0dXJuIHZub2RlV3JhcHBlci5jYWxsKHZub2RlKTsgfSlcbiAgICAgICAgICAgIC5mb2xkKHBhdGNoLCByb290RWxlbWVudClcbiAgICAgICAgICAgIC5kcm9wKDEpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIHVud3JhcEVsZW1lbnRGcm9tVk5vZGUodm5vZGUpIHsgcmV0dXJuIHZub2RlLmVsbTsgfSlcbiAgICAgICAgICAgIC5jb21wb3NlKGZ1bmN0aW9uIChzdHJlYW0pIHsgcmV0dXJuIHhzdHJlYW1fMS5kZWZhdWx0Lm1lcmdlKHN0cmVhbSwgeHN0cmVhbV8xLmRlZmF1bHQubmV2ZXIoKSk7IH0pIC8vIGRvbid0IGNvbXBsZXRlIHRoaXMgc3RyZWFtXG4gICAgICAgICAgICAuc3RhcnRXaXRoKHJvb3RFbGVtZW50KTtcbiAgICAgICAgcm9vdEVsZW1lbnQkLmFkZExpc3RlbmVyKHsgbmV4dDogZnVuY3Rpb24gKCkgeyB9LCBlcnJvcjogZnVuY3Rpb24gKCkgeyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9IH0pO1xuICAgICAgICByZXR1cm4gbmV3IE1haW5ET01Tb3VyY2VfMS5NYWluRE9NU291cmNlKHJvb3RFbGVtZW50JCwgc2FuaXRhdGlvbiQsIHJ1blN0cmVhbUFkYXB0ZXIsIFtdLCBpc29sYXRlTW9kdWxlLCBkZWxlZ2F0b3JzLCBuYW1lKTtcbiAgICB9XG4gICAgO1xuICAgIERPTURyaXZlci5zdHJlYW1BZGFwdGVyID0geHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdDtcbiAgICByZXR1cm4gRE9NRHJpdmVyO1xufVxuZXhwb3J0cy5tYWtlRE9NRHJpdmVyID0gbWFrZURPTURyaXZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2VET01Ecml2ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9kb20vbGliL21ha2VET01Ecml2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIHRyYW5zcG9zaXRpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNwb3NpdGlvbicpO1xudmFyIEhUTUxTb3VyY2VfMSA9IHJlcXVpcmUoJy4vSFRNTFNvdXJjZScpO1xudmFyIHRvSFRNTCA9IHJlcXVpcmUoJ3NuYWJiZG9tLXRvLWh0bWwnKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuZnVuY3Rpb24gbWFrZUhUTUxEcml2ZXIoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdmFyIHRyYW5zcG9zaXRpb24gPSBvcHRpb25zLnRyYW5zcG9zaXRpb24gfHwgZmFsc2U7XG4gICAgZnVuY3Rpb24gaHRtbERyaXZlcih2bm9kZSQsIHJ1blN0cmVhbUFkYXB0ZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIHRyYW5zcG9zZVZOb2RlID0gdHJhbnNwb3NpdGlvbl8xLm1ha2VUcmFuc3Bvc2VWTm9kZShydW5TdHJlYW1BZGFwdGVyKTtcbiAgICAgICAgdmFyIHByZXByb2Nlc3NlZFZOb2RlJCA9ICh0cmFuc3Bvc2l0aW9uID8gdm5vZGUkLm1hcCh0cmFuc3Bvc2VWTm9kZSkuZmxhdHRlbigpIDogdm5vZGUkKTtcbiAgICAgICAgdmFyIGh0bWwkID0gcHJlcHJvY2Vzc2VkVk5vZGUkLm1hcCh0b0hUTUwpO1xuICAgICAgICBodG1sJC5hZGRMaXN0ZW5lcih7XG4gICAgICAgICAgICBuZXh0OiBlZmZlY3QgfHwgbm9vcCxcbiAgICAgICAgICAgIGVycm9yOiBub29wLFxuICAgICAgICAgICAgY29tcGxldGU6IG5vb3AsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEhUTUxTb3VyY2VfMS5IVE1MU291cmNlKGh0bWwkLCBydW5TdHJlYW1BZGFwdGVyLCBuYW1lKTtcbiAgICB9XG4gICAgO1xuICAgIGh0bWxEcml2ZXIuc3RyZWFtQWRhcHRlciA9IHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIGh0bWxEcml2ZXI7XG59XG5leHBvcnRzLm1ha2VIVE1MRHJpdmVyID0gbWFrZUhUTUxEcml2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlSFRNTERyaXZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvbWFrZUhUTUxEcml2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoJ3hzdHJlYW0nKTtcbnZhciBTQ09QRV9QUkVGSVggPSAnX19fJztcbnZhciBNb2NrZWRET01Tb3VyY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vY2tlZERPTVNvdXJjZShfc3RyZWFtQWRhcHRlciwgX21vY2tDb25maWcpIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtQWRhcHRlciA9IF9zdHJlYW1BZGFwdGVyO1xuICAgICAgICB0aGlzLl9tb2NrQ29uZmlnID0gX21vY2tDb25maWc7XG4gICAgICAgIGlmIChfbW9ja0NvbmZpZy5lbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfbW9ja0NvbmZpZy5lbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID0gX3N0cmVhbUFkYXB0ZXIuYWRhcHQoeHN0cmVhbV8xLmRlZmF1bHQuZW1wdHkoKSwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1vY2tlZERPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gJ01vY2tlZERPTSc7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1vY2tDb25maWcgPSB0aGlzLl9tb2NrQ29uZmlnO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vY2tDb25maWcpO1xuICAgICAgICB2YXIga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0XzEgPSBtb2NrQ29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgb3V0XzEuX2lzQ3ljbGVTb3VyY2UgPSAnTW9ja2VkRE9NJztcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0XzE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX3N0cmVhbUFkYXB0ZXIuYWRhcHQoeHN0cmVhbV8xLmRlZmF1bHQuZW1wdHkoKSwgeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdC5zdHJlYW1TdWJzY3JpYmUpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSAnTW9ja2VkRE9NJztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIE1vY2tlZERPTVNvdXJjZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBtb2NrQ29uZmlnID0gdGhpcy5fbW9ja0NvbmZpZztcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtb2NrQ29uZmlnKTtcbiAgICAgICAgdmFyIGtleXNMZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vY2tlZERPTVNvdXJjZSh0aGlzLl9zdHJlYW1BZGFwdGVyLCBtb2NrQ29uZmlnW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTW9ja2VkRE9NU291cmNlKHRoaXMuX3N0cmVhbUFkYXB0ZXIsIHt9KTtcbiAgICB9O1xuICAgIE1vY2tlZERPTVNvdXJjZS5wcm90b3R5cGUuaXNvbGF0ZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc2VsZWN0KCcuJyArIFNDT1BFX1BSRUZJWCArIHNjb3BlKTtcbiAgICB9O1xuICAgIE1vY2tlZERPTVNvdXJjZS5wcm90b3R5cGUuaXNvbGF0ZVNpbmsgPSBmdW5jdGlvbiAoc2luaywgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHNpbmsubWFwKGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgICAgICAgaWYgKHZub2RlLnNlbCAmJiB2bm9kZS5zZWwuaW5kZXhPZihTQ09QRV9QUkVGSVggKyBzY29wZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuc2VsICs9IFwiLlwiICsgU0NPUEVfUFJFRklYICsgc2NvcGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNb2NrZWRET01Tb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5Nb2NrZWRET01Tb3VyY2UgPSBNb2NrZWRET01Tb3VyY2U7XG5mdW5jdGlvbiBtb2NrRE9NU291cmNlKHN0cmVhbUFkYXB0ZXIsIG1vY2tDb25maWcpIHtcbiAgICByZXR1cm4gbmV3IE1vY2tlZERPTVNvdXJjZShzdHJlYW1BZGFwdGVyLCBtb2NrQ29uZmlnKTtcbn1cbmV4cG9ydHMubW9ja0RPTVNvdXJjZSA9IG1vY2tET01Tb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2NrRE9NU291cmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvZG9tL2xpYi9tb2NrRE9NU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDbGFzc01vZHVsZSA9IHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvY2xhc3MnKTtcbmV4cG9ydHMuQ2xhc3NNb2R1bGUgPSBDbGFzc01vZHVsZTtcbnZhciBQcm9wc01vZHVsZSA9IHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvcHJvcHMnKTtcbmV4cG9ydHMuUHJvcHNNb2R1bGUgPSBQcm9wc01vZHVsZTtcbnZhciBBdHRyc01vZHVsZSA9IHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvYXR0cmlidXRlcycpO1xuZXhwb3J0cy5BdHRyc01vZHVsZSA9IEF0dHJzTW9kdWxlO1xudmFyIEV2ZW50c01vZHVsZSA9IHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMnKTtcbmV4cG9ydHMuRXZlbnRzTW9kdWxlID0gRXZlbnRzTW9kdWxlO1xudmFyIFN0eWxlTW9kdWxlID0gcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9zdHlsZScpO1xuZXhwb3J0cy5TdHlsZU1vZHVsZSA9IFN0eWxlTW9kdWxlO1xudmFyIEhlcm9Nb2R1bGUgPSByZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL2hlcm8nKTtcbmV4cG9ydHMuSGVyb01vZHVsZSA9IEhlcm9Nb2R1bGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBbU3R5bGVNb2R1bGUsIENsYXNzTW9kdWxlLCBQcm9wc01vZHVsZSwgQXR0cnNNb2R1bGVdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2RvbS9saWIvbW9kdWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY2xpY2tFdmVudCA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZG9jdW1lbnQgJiYgZG9jdW1lbnQub250b3VjaHN0YXJ0ID9cbiAgICAndG91Y2hzdGFydCcgOiAnY2xpY2snO1xuZnVuY3Rpb24gd2hpY2goZXYpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZSA9IGV2IHx8IHdpbmRvdy5ldmVudDtcbiAgICByZXR1cm4gZS53aGljaCA9PT0gbnVsbCA/IGUuYnV0dG9uIDogZS53aGljaDtcbn1cbmZ1bmN0aW9uIHNhbWVPcmlnaW4oaHJlZikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBocmVmICYmIGhyZWYuaW5kZXhPZih3aW5kb3cubG9jYXRpb24ub3JpZ2luKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIG1ha2VDbGlja0xpc3RlbmVyKHB1c2gpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xpY2tMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAod2hpY2goZXZlbnQpICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZU5hbWUgIT09ICdBJykge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlTmFtZSAhPT0gJ0EnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpIHx8XG4gICAgICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdleHRlcm5hbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluayA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgIGlmIChsaW5rICYmIGxpbmsuaW5kZXhPZignbWFpbHRvOicpID4gLTEgfHwgbGluay5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2FtZU9yaWdpbihlbGVtZW50LmhyZWYpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHBhdGhuYW1lID0gZWxlbWVudC5wYXRobmFtZSwgc2VhcmNoID0gZWxlbWVudC5zZWFyY2gsIF9hID0gZWxlbWVudC5oYXNoLCBoYXNoID0gX2EgPT09IHZvaWQgMCA/ICcnIDogX2E7XG4gICAgICAgIHB1c2gocGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2FwdHVyZUNsaWNrcyhwdXNoKSB7XG4gICAgdmFyIGxpc3RlbmVyID0gbWFrZUNsaWNrTGlzdGVuZXIocHVzaCk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoY2xpY2tFdmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG59XG5leHBvcnRzLmNhcHR1cmVDbGlja3MgPSBjYXB0dXJlQ2xpY2tzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FwdHVyZUNsaWNrcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGN5Y2xlL2hpc3RvcnkvbGliL2NhcHR1cmVDbGlja3MuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNhcHR1cmVDbGlja3NfMSA9IHJlcXVpcmUoJy4vY2FwdHVyZUNsaWNrcycpO1xuZnVuY3Rpb24gbWFrZVVwZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVIaXN0b3J5KGxvY2F0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2goaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIHN1cG9ydCB0aGluZ3MgbGlrZSBoaXN0b3J5LnJlcGxhY2UoKVxuICAgICAgICAgICAgdmFyIF9hID0gbG9jYXRpb24udHlwZSwgdHlwZSA9IF9hID09PSB2b2lkIDAgPyAncHVzaCcgOiBfYTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnZ28nKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVt0eXBlXShsb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5W3R5cGVdKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGlzdG9yeSBEcml2ZXIgaW5wdXQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiAnICtcbiAgICAgICAgICAgICAgICAnb2JqZWN0IGJ1dCByZWNlaXZlZCAke3R5cGVvZiB1cmx9Jyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3JGbihlcnIpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VIaXN0b3J5RHJpdmVyKGhpc3RvcnksIG9wdGlvbnMpIHtcbiAgICBpZiAoIWhpc3RvcnkgfHwgdHlwZW9mIGhpc3RvcnkgIT09ICdvYmplY3QnXG4gICAgICAgIHx8IHR5cGVvZiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uICE9PSAnZnVuY3Rpb24nXG4gICAgICAgIHx8IHR5cGVvZiBoaXN0b3J5LmNyZWF0ZUhyZWYgIT09ICdmdW5jdGlvbidcbiAgICAgICAgfHwgdHlwZW9mIGhpc3RvcnkubGlzdGVuICE9PSAnZnVuY3Rpb24nXG4gICAgICAgIHx8IHR5cGVvZiBoaXN0b3J5LnB1c2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFrZUhpc3RvcnlEcml2ZXIgcmVxdWlyZXMgYW4gdmFsaWQgaGlzdG9yeSBvYmplY3QgJyArXG4gICAgICAgICAgICAnY29udGFpbmluZyBjcmVhdGVMb2NhdGlvbigpLCBjcmVhdGVIcmVmKCksIHB1c2goKSwgYW5kIGxpc3RlbigpIG1ldGhvZHMnKTtcbiAgICB9XG4gICAgdmFyIGNhcHR1cmUgPSBvcHRpb25zICYmIG9wdGlvbnMuY2FwdHVyZSB8fCBmYWxzZTtcbiAgICB2YXIgb25FcnJvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yRm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhpc3RvcnlEcml2ZXIoc2luayQsIHJ1blNBKSB7XG4gICAgICAgIHZhciBfYSA9IHJ1blNBLm1ha2VTdWJqZWN0KCksIG9ic2VydmVyID0gX2Eub2JzZXJ2ZXIsIHN0cmVhbSA9IF9hLnN0cmVhbTtcbiAgICAgICAgdmFyIGhpc3RvcnkkID0gcnVuU0EucmVtZW1iZXIoc3RyZWFtXG4gICAgICAgICAgICAuc3RhcnRXaXRoKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICAgICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGxvY2F0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgaGlzdG9yeS5hZGRDb21wbGV0ZUNhbGxiYWNrID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAmJiB0eXBlb2YgaGlzdG9yeS5jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaGlzdG9yeS5hZGRDb21wbGV0ZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuU0Euc3RyZWFtU3Vic2NyaWJlKHNpbmskLCB7XG4gICAgICAgICAgICBuZXh0OiBtYWtlVXBkYXRlSGlzdG9yeShoaXN0b3J5KSxcbiAgICAgICAgICAgIGVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDbGlja3NfMS5jYXB0dXJlQ2xpY2tzKGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24ocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGhpc3RvcnkucHVzaChsb2NhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBoaXN0b3J5JC5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKGhyZWYpIHsgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihocmVmKTsgfTtcbiAgICAgICAgaGlzdG9yeSQuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiAobG9jYXRpb24pIHsgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pOyB9O1xuICAgICAgICByZXR1cm4gaGlzdG9yeSQ7XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZUhpc3RvcnlEcml2ZXIgPSBtYWtlSGlzdG9yeURyaXZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2VIaXN0b3J5RHJpdmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUvaGlzdG9yeS9saWIvbWFrZUhpc3RvcnlEcml2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIFNlcnZlckhpc3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlckhpc3RvcnkoY3VycmVudExvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gdm9pZCAwOyB9O1xuICAgIH07XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgZ2l2ZW4gYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGJlZm9yZSBwdXNoaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbaV0odXRpbF8xLmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5wdXNoKGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLmNyZWF0ZUhyZWYgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzEuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgIH07XG4gICAgU2VydmVySGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50TG9jYXRpb247XG4gICAgfTtcbiAgICBTZXJ2ZXJIaXN0b3J5LnByb3RvdHlwZS5hZGRDb21wbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlQ2FsbGJhY2sgPSBjb21wbGV0ZTtcbiAgICB9O1xuICAgIFNlcnZlckhpc3RvcnkucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZUNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VydmVySGlzdG9yeTtcbn0oKSk7XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJIaXN0b3J5KGxvYykge1xuICAgIHJldHVybiBuZXcgU2VydmVySGlzdG9yeShsb2MgPyB1dGlsXzEuY3JlYXRlTG9jYXRpb24obG9jKSA6IG51bGwpO1xufVxuZXhwb3J0cy5jcmVhdGVTZXJ2ZXJIaXN0b3J5ID0gY3JlYXRlU2VydmVySGlzdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlckhpc3RvcnkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS9oaXN0b3J5L2xpYi9zZXJ2ZXJIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBiYXNlXzEgPSByZXF1aXJlKCdAY3ljbGUvYmFzZScpO1xudmFyIHhzdHJlYW1fYWRhcHRlcl8xID0gcmVxdWlyZSgnQGN5Y2xlL3hzdHJlYW0tYWRhcHRlcicpO1xuLyoqXG4gKiBUYWtlcyBhIGBtYWluYCBmdW5jdGlvbiBhbmQgY2lyY3VsYXJseSBjb25uZWN0cyBpdCB0byB0aGUgZ2l2ZW4gY29sbGVjdGlvblxuICogb2YgZHJpdmVyIGZ1bmN0aW9ucy5cbiAqXG4gKiAqKkV4YW1wbGU6KipcbiAqIGBgYGpzXG4gKiBpbXBvcnQge3J1bn0gZnJvbSAnQGN5Y2xlL3hzdHJlYW0tcnVuJztcbiAqIGNvbnN0IGRpc3Bvc2UgPSBydW4obWFpbiwgZHJpdmVycyk7XG4gKiAvLyAuLi5cbiAqIGRpc3Bvc2UoKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBgbWFpbmAgZnVuY3Rpb24gZXhwZWN0cyBhIGNvbGxlY3Rpb24gb2YgXCJzb3VyY2VcIiBzdHJlYW1zIChyZXR1cm5lZCBmcm9tXG4gKiBkcml2ZXJzKSBhcyBpbnB1dCwgYW5kIHNob3VsZCByZXR1cm4gYSBjb2xsZWN0aW9uIG9mIFwic2lua1wiIHN0cmVhbXMgKHRvIGJlXG4gKiBnaXZlbiB0byBkcml2ZXJzKS4gQSBcImNvbGxlY3Rpb24gb2Ygc3RyZWFtc1wiIGlzIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2hlcmVcbiAqIGtleXMgbWF0Y2ggdGhlIGRyaXZlciBuYW1lcyByZWdpc3RlcmVkIGJ5IHRoZSBgZHJpdmVyc2Agb2JqZWN0LCBhbmQgdmFsdWVzXG4gKiBhcmUgdGhlIHN0cmVhbXMuIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIGVhY2ggZHJpdmVyIHRvIHNlZSBtb3JlXG4gKiBkZXRhaWxzIG9uIHdoYXQgdHlwZXMgb2Ygc291cmNlcyBpdCBvdXRwdXRzIGFuZCBzaW5rcyBpdCByZWNlaXZlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYWluIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBgc291cmNlc2AgYXMgaW5wdXQgYW5kIG91dHB1dHNcbiAqIGBzaW5rc2AuXG4gKiBAcGFyYW0ge09iamVjdH0gZHJpdmVycyBhbiBvYmplY3Qgd2hlcmUga2V5cyBhcmUgZHJpdmVyIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIGFyZSBkcml2ZXIgZnVuY3Rpb25zLlxuICogQHJldHVybiB7RnVuY3Rpb259IGEgZGlzcG9zZSBmdW5jdGlvbiwgdXNlZCB0byB0ZXJtaW5hdGUgdGhlIGV4ZWN1dGlvbiBvZiB0aGVcbiAqIEN5Y2xlLmpzIHByb2dyYW0sIGNsZWFuaW5nIHVwIHJlc291cmNlcyB1c2VkLlxuICogQGZ1bmN0aW9uIHJ1blxuICovXG5mdW5jdGlvbiBydW4obWFpbiwgZHJpdmVycykge1xuICAgIHZhciBfYSA9IGJhc2VfMS5kZWZhdWx0KG1haW4sIGRyaXZlcnMsIHsgc3RyZWFtQWRhcHRlcjogeHN0cmVhbV9hZGFwdGVyXzEuZGVmYXVsdCB9KSwgcnVuID0gX2EucnVuLCBzaW5rcyA9IF9hLnNpbmtzO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbJ0N5Y2xlanNEZXZUb29sX3N0YXJ0R3JhcGhTZXJpYWxpemVyJ10pIHtcbiAgICAgICAgd2luZG93WydDeWNsZWpzRGV2VG9vbF9zdGFydEdyYXBoU2VyaWFsaXplciddKHNpbmtzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bigpO1xufVxuZXhwb3J0cy5ydW4gPSBydW47XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBwcmVwYXJlcyB0aGUgQ3ljbGUgYXBwbGljYXRpb24gdG8gYmUgZXhlY3V0ZWQuIFRha2VzIGEgYG1haW5gXG4gKiBmdW5jdGlvbiBhbmQgcHJlcGFyZXMgdG8gY2lyY3VsYXJseSBjb25uZWN0cyBpdCB0byB0aGUgZ2l2ZW4gY29sbGVjdGlvbiBvZlxuICogZHJpdmVyIGZ1bmN0aW9ucy4gQXMgYW4gb3V0cHV0LCBgQ3ljbGUoKWAgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aHJlZVxuICogcHJvcGVydGllczogYHNvdXJjZXNgLCBgc2lua3NgIGFuZCBgcnVuYC4gT25seSB3aGVuIGBydW4oKWAgaXMgY2FsbGVkIHdpbGxcbiAqIHRoZSBhcHBsaWNhdGlvbiBhY3R1YWxseSBleGVjdXRlLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbiBvZiBgcnVuKClgIGZvclxuICogbW9yZSBkZXRhaWxzLlxuICpcbiAqICoqRXhhbXBsZToqKlxuICogYGBganNcbiAqIGltcG9ydCBDeWNsZSBmcm9tICdAY3ljbGUveHN0cmVhbS1ydW4nO1xuICogY29uc3Qge3NvdXJjZXMsIHNpbmtzLCBydW59ID0gQ3ljbGUobWFpbiwgZHJpdmVycyk7XG4gKiAvLyAuLi5cbiAqIGNvbnN0IGRpc3Bvc2UgPSBydW4oKTsgLy8gRXhlY3V0ZXMgdGhlIGFwcGxpY2F0aW9uXG4gKiAvLyAuLi5cbiAqIGRpc3Bvc2UoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1haW4gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGBzb3VyY2VzYCBhcyBpbnB1dCBhbmQgb3V0cHV0c1xuICogYHNpbmtzYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkcml2ZXJzIGFuIG9iamVjdCB3aGVyZSBrZXlzIGFyZSBkcml2ZXIgbmFtZXMgYW5kIHZhbHVlc1xuICogYXJlIGRyaXZlciBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIHRocmVlIHByb3BlcnRpZXM6IGBzb3VyY2VzYCwgYHNpbmtzYCBhbmRcbiAqIGBydW5gLiBgc291cmNlc2AgaXMgdGhlIGNvbGxlY3Rpb24gb2YgZHJpdmVyIHNvdXJjZXMsIGBzaW5rc2AgaXMgdGhlXG4gKiBjb2xsZWN0aW9uIG9mIGRyaXZlciBzaW5rcywgdGhlc2UgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZyBvciB0ZXN0aW5nLiBgcnVuYFxuICogaXMgdGhlIGZ1bmN0aW9uIHRoYXQgb25jZSBjYWxsZWQgd2lsbCBleGVjdXRlIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEBmdW5jdGlvbiBDeWNsZVxuICovXG52YXIgQ3ljbGUgPSBmdW5jdGlvbiAobWFpbiwgZHJpdmVycykge1xuICAgIHZhciBvdXQgPSBiYXNlXzEuZGVmYXVsdChtYWluLCBkcml2ZXJzLCB7IHN0cmVhbUFkYXB0ZXI6IHhzdHJlYW1fYWRhcHRlcl8xLmRlZmF1bHQgfSk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1snQ3ljbGVqc0RldlRvb2xfc3RhcnRHcmFwaFNlcmlhbGl6ZXInXSkge1xuICAgICAgICB3aW5kb3dbJ0N5Y2xlanNEZXZUb29sX3N0YXJ0R3JhcGhTZXJpYWxpemVyJ10ob3V0LnNpbmtzKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5DeWNsZS5ydW4gPSBydW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDeWNsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AY3ljbGUveHN0cmVhbS1ydW4vbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGxvZ1RvQ29uc29sZUVycm9yKGVycikge1xuICAgIHZhciB0YXJnZXQgPSBlcnIuc3RhY2sgfHwgZXJyO1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcih0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZVNpbmtQcm94aWVzKGRyaXZlcnMsIHN0cmVhbUFkYXB0ZXIpIHtcbiAgICB2YXIgc2lua1Byb3hpZXMgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lXzEgaW4gZHJpdmVycykge1xuICAgICAgICBpZiAoZHJpdmVycy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgICAgICB2YXIgc3ViamVjdCA9IHN0cmVhbUFkYXB0ZXIubWFrZVN1YmplY3QoKTtcbiAgICAgICAgICAgIHZhciBkcml2ZXJTdHJlYW1BZGFwdGVyID0gZHJpdmVyc1tuYW1lXzFdLnN0cmVhbUFkYXB0ZXIgfHwgc3RyZWFtQWRhcHRlcjtcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSBkcml2ZXJTdHJlYW1BZGFwdGVyLmFkYXB0KHN1YmplY3Quc3RyZWFtLCBzdHJlYW1BZGFwdGVyLnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgICAgICBzaW5rUHJveGllc1tuYW1lXzFdID0ge1xuICAgICAgICAgICAgICAgIHN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgICAgICAgIG9ic2VydmVyOiBzdWJqZWN0Lm9ic2VydmVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2lua1Byb3hpZXM7XG59XG5mdW5jdGlvbiBjYWxsRHJpdmVycyhkcml2ZXJzLCBzaW5rUHJveGllcywgc3RyZWFtQWRhcHRlcikge1xuICAgIHZhciBzb3VyY2VzID0ge307XG4gICAgZm9yICh2YXIgbmFtZV8yIGluIGRyaXZlcnMpIHtcbiAgICAgICAgaWYgKGRyaXZlcnMuaGFzT3duUHJvcGVydHkobmFtZV8yKSkge1xuICAgICAgICAgICAgdmFyIGRyaXZlck91dHB1dCA9IGRyaXZlcnNbbmFtZV8yXShzaW5rUHJveGllc1tuYW1lXzJdLnN0cmVhbSwgc3RyZWFtQWRhcHRlciwgbmFtZV8yKTtcbiAgICAgICAgICAgIHZhciBkcml2ZXJTdHJlYW1BZGFwdGVyID0gZHJpdmVyc1tuYW1lXzJdLnN0cmVhbUFkYXB0ZXI7XG4gICAgICAgICAgICBpZiAoZHJpdmVyU3RyZWFtQWRhcHRlciAmJiBkcml2ZXJTdHJlYW1BZGFwdGVyLmlzVmFsaWRTdHJlYW0oZHJpdmVyT3V0cHV0KSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXNbbmFtZV8yXSA9IHN0cmVhbUFkYXB0ZXIuYWRhcHQoZHJpdmVyT3V0cHV0LCBkcml2ZXJTdHJlYW1BZGFwdGVyLnN0cmVhbVN1YnNjcmliZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzW25hbWVfMl0gPSBkcml2ZXJPdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlc1tuYW1lXzJdICYmIHR5cGVvZiBzb3VyY2VzW25hbWVfMl0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc291cmNlc1tuYW1lXzJdLl9pc0N5Y2xlU291cmNlID0gbmFtZV8yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xufVxuZnVuY3Rpb24gcmVwbGljYXRlTWFueShzaW5rcywgc2lua1Byb3hpZXMsIHN0cmVhbUFkYXB0ZXIpIHtcbiAgICB2YXIgc2lua05hbWVzID0gT2JqZWN0LmtleXMoc2lua3MpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gISFzaW5rUHJveGllc1tuYW1lXTsgfSk7XG4gICAgdmFyIGJ1ZmZlcnMgPSB7fTtcbiAgICB2YXIgcmVwbGljYXRvcnMgPSB7fTtcbiAgICBzaW5rTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBidWZmZXJzW25hbWVdID0geyBuZXh0OiBbXSwgZXJyb3I6IFtdLCBjb21wbGV0ZTogW10gfTtcbiAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0gPSB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gYnVmZmVyc1tuYW1lXS5uZXh0LnB1c2goeCk7IH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGJ1ZmZlcnNbbmFtZV0uZXJyb3IucHVzaCh4KTsgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gYnVmZmVyc1tuYW1lXS5jb21wbGV0ZS5wdXNoKHgpOyB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBzdWJzY3JpcHRpb25zID0gc2lua05hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtQWRhcHRlci5zdHJlYW1TdWJzY3JpYmUoc2lua3NbbmFtZV0sIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0ubmV4dCh4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ1RvQ29uc29sZUVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5jb21wbGV0ZSh4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBkaXNwb3NlRnVuY3Rpb25zID0gc3Vic2NyaXB0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nOyB9KTtcbiAgICBzaW5rTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBzaW5rUHJveGllc1tuYW1lXS5vYnNlcnZlcjtcbiAgICAgICAgdmFyIG5leHQgPSBvYnNlcnZlci5uZXh0O1xuICAgICAgICB2YXIgZXJyb3IgPSBvYnNlcnZlci5lcnJvcjtcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGU7XG4gICAgICAgIGJ1ZmZlcnNbbmFtZV0ubmV4dC5mb3JFYWNoKG5leHQpO1xuICAgICAgICBidWZmZXJzW25hbWVdLmVycm9yLmZvckVhY2goZXJyb3IpO1xuICAgICAgICBidWZmZXJzW25hbWVdLmNvbXBsZXRlLmZvckVhY2goY29tcGxldGUpO1xuICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5uZXh0ID0gbmV4dDtcbiAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0uY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkaXNwb3NlRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRpc3Bvc2UpIHsgcmV0dXJuIGRpc3Bvc2UoKTsgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpc3Bvc2VTb3VyY2VzKHNvdXJjZXMpIHtcbiAgICBmb3IgKHZhciBrIGluIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHNvdXJjZXMuaGFzT3duUHJvcGVydHkoaykgJiYgc291cmNlc1trXVxuICAgICAgICAgICAgJiYgdHlwZW9mIHNvdXJjZXNba10uZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc291cmNlc1trXS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgaXNPYmplY3RFbXB0eSA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwOyB9O1xuZnVuY3Rpb24gQ3ljbGUobWFpbiwgZHJpdmVycywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgbWFpbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIEN5Y2xlIG11c3QgYmUgdGhlICdtYWluJyBcIiArXG4gICAgICAgICAgICBcImZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkcml2ZXJzICE9PSBcIm9iamVjdFwiIHx8IGRyaXZlcnMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IGdpdmVuIHRvIEN5Y2xlIG11c3QgYmUgYW4gb2JqZWN0IFwiICtcbiAgICAgICAgICAgIFwid2l0aCBkcml2ZXIgZnVuY3Rpb25zIGFzIHByb3BlcnRpZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3RFbXB0eShkcml2ZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgZ2l2ZW4gdG8gQ3ljbGUgbXVzdCBiZSBhbiBvYmplY3QgXCIgK1xuICAgICAgICAgICAgXCJ3aXRoIGF0IGxlYXN0IG9uZSBkcml2ZXIgZnVuY3Rpb24gZGVjbGFyZWQgYXMgYSBwcm9wZXJ0eS5cIik7XG4gICAgfVxuICAgIHZhciBzdHJlYW1BZGFwdGVyID0gb3B0aW9ucy5zdHJlYW1BZGFwdGVyO1xuICAgIGlmICghc3RyZWFtQWRhcHRlciB8fCBpc09iamVjdEVtcHR5KHN0cmVhbUFkYXB0ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXJkIGFyZ3VtZW50IGdpdmVuIHRvIEN5Y2xlIG11c3QgYmUgYW4gb3B0aW9ucyBvYmplY3QgXCIgK1xuICAgICAgICAgICAgXCJ3aXRoIHRoZSBzdHJlYW1BZGFwdGVyIGtleSBzdXBwbGllZCB3aXRoIGEgdmFsaWQgc3RyZWFtIGFkYXB0ZXIuXCIpO1xuICAgIH1cbiAgICB2YXIgc2lua1Byb3hpZXMgPSBtYWtlU2lua1Byb3hpZXMoZHJpdmVycywgc3RyZWFtQWRhcHRlcik7XG4gICAgdmFyIHNvdXJjZXMgPSBjYWxsRHJpdmVycyhkcml2ZXJzLCBzaW5rUHJveGllcywgc3RyZWFtQWRhcHRlcik7XG4gICAgdmFyIHNpbmtzID0gbWFpbihzb3VyY2VzKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LkN5Y2xlanMgPSB7IHNpbmtzOiBzaW5rcyB9O1xuICAgIH1cbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlzcG9zZVJlcGxpY2F0aW9uID0gcmVwbGljYXRlTWFueShzaW5rcywgc2lua1Byb3hpZXMsIHN0cmVhbUFkYXB0ZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlzcG9zZVNvdXJjZXMoc291cmNlcyk7XG4gICAgICAgICAgICBkaXNwb3NlUmVwbGljYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IHNpbmtzOiBzaW5rcywgc291cmNlczogc291cmNlcywgcnVuOiBydW4gfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEN5Y2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BjeWNsZS94c3RyZWFtLXJ1bi9+L0BjeWNsZS9iYXNlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuZnVuY3Rpb24gaXNTdHJpY3RseUluU2NvcGUobmFtZXNwYWNlLCBwYXRoKSB7XG4gICAgdmFyIHBhdGhQYXJ0cyA9IHV0aWwuc3BsaXRQYXRoKHBhdGgpO1xuICAgIHJldHVybiBuYW1lc3BhY2UuZXZlcnkoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhQYXJ0c1tpXSA9PT0gdjtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpbHRlcmVkUGF0aChuYW1lc3BhY2UsIHBhdGgpIHtcbiAgICB2YXIgcGF0aFBhcnRzID0gdXRpbC5zcGxpdFBhdGgocGF0aCk7XG4gICAgcmV0dXJuICcvJyArIHV0aWwuZmlsdGVyUGF0aChwYXRoUGFydHMsIG5hbWVzcGFjZSk7XG59XG52YXIgUm91dGVyU291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXJTb3VyY2UoaGlzdG9yeSQsIF9uYW1lc3BhY2UsIF9jcmVhdGVIcmVmLCBfcnVuU0EsIF9yb3V0ZU1hdGNoZXIpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5JCA9IGhpc3RvcnkkO1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBfbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLl9jcmVhdGVIcmVmID0gX2NyZWF0ZUhyZWY7XG4gICAgICAgIHRoaXMuX3J1blNBID0gX3J1blNBO1xuICAgICAgICB0aGlzLl9yb3V0ZU1hdGNoZXIgPSBfcm91dGVNYXRjaGVyO1xuICAgIH1cbiAgICBSb3V0ZXJTb3VyY2UucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIHNjb3BlZE5hbWVzcGFjZSA9IHRoaXMuX25hbWVzcGFjZS5jb25jYXQodXRpbC5zcGxpdFBhdGgocGF0aG5hbWUpKTtcbiAgICAgICAgdmFyIHNjb3BlZEhpc3RvcnkkID0gdGhpcy5fcnVuU0EucmVtZW1iZXIodGhpcy5oaXN0b3J5JFxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfcGF0aCA9IF9hLnBhdGhuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0bHlJblNjb3BlKHNjb3BlZE5hbWVzcGFjZSwgX3BhdGgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBjcmVhdGVIcmVmID0gdGhpcy5fY3JlYXRlSHJlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZXJTb3VyY2Uoc2NvcGVkSGlzdG9yeSQsIHNjb3BlZE5hbWVzcGFjZSwgY3JlYXRlSHJlZiwgdGhpcy5fcnVuU0EsIHRoaXMuX3JvdXRlTWF0Y2hlcik7XG4gICAgfTtcbiAgICBSb3V0ZXJTb3VyY2UucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uIChyb3V0ZXMsIHJvdXRlTWF0Y2hlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlO1xuICAgICAgICB2YXIgX2NyZWF0ZUhyZWYgPSB0aGlzLl9jcmVhdGVIcmVmO1xuICAgICAgICB2YXIgY3JlYXRlSHJlZiA9IHV0aWwubWFrZUNyZWF0ZUhyZWYobmFtZXNwYWNlLCBfY3JlYXRlSHJlZik7XG4gICAgICAgIHZhciBtYXRjaCQgPSB0aGlzLl9ydW5TQS5yZW1lbWJlcih0aGlzLmhpc3RvcnkkXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXIgPSByb3V0ZU1hdGNoZXIgfHwgX3RoaXMuX3JvdXRlTWF0Y2hlcjtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZFBhdGggPSBnZXRGaWx0ZXJlZFBhdGgobmFtZXNwYWNlLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgICB2YXIgX2EgPSBtYXRjaGVyKGZpbHRlcmVkUGF0aCwgcm91dGVzKSwgcGF0aCA9IF9hLnBhdGgsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUsIGxvY2F0aW9uOiBsb2NhdGlvbiwgY3JlYXRlSHJlZjogY3JlYXRlSHJlZiB9O1xuICAgICAgICB9KSk7XG4gICAgICAgIG1hdGNoJC5jcmVhdGVIcmVmID0gY3JlYXRlSHJlZjtcbiAgICAgICAgcmV0dXJuIG1hdGNoJDtcbiAgICB9O1xuICAgIFJvdXRlclNvdXJjZS5wcm90b3R5cGUuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiB1dGlsLm1ha2VDcmVhdGVIcmVmKHRoaXMuX25hbWVzcGFjZSwgdGhpcy5fY3JlYXRlSHJlZikocGF0aCk7XG4gICAgfTtcbiAgICByZXR1cm4gUm91dGVyU291cmNlO1xufSgpKTtcbmV4cG9ydHMuUm91dGVyU291cmNlID0gUm91dGVyU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um91dGVyU291cmNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jeWNsaWMtcm91dGVyL2xpYi9Sb3V0ZXJTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1ha2VSb3V0ZXJEcml2ZXJfMSA9IHJlcXVpcmUoJy4vbWFrZVJvdXRlckRyaXZlcicpO1xuZXhwb3J0cy5tYWtlUm91dGVyRHJpdmVyID0gbWFrZVJvdXRlckRyaXZlcl8xLm1ha2VSb3V0ZXJEcml2ZXI7XG52YXIgaGlzdG9yeV8xID0gcmVxdWlyZSgnQGN5Y2xlL2hpc3RvcnknKTtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gaGlzdG9yeV8xLnN1cHBvcnRzSGlzdG9yeTtcbmV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBoaXN0b3J5XzEuY3JlYXRlTG9jYXRpb247XG5leHBvcnRzLmNyZWF0ZVNlcnZlckhpc3RvcnkgPSBoaXN0b3J5XzEuY3JlYXRlU2VydmVySGlzdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jeWNsaWMtcm91dGVyL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaGlzdG9yeV8xID0gcmVxdWlyZSgnQGN5Y2xlL2hpc3RvcnknKTtcbnZhciBSb3V0ZXJTb3VyY2VfMSA9IHJlcXVpcmUoJy4vUm91dGVyU291cmNlJyk7XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhbiBuZXcgcm91dGVyIGRyaXZlciBmdW5jdGlvbiB1c2luZyB0aGUgc2FtZSBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIGJ5IEBjeWNsZS9oaXN0b3J5LlxuICogQHB1YmxpY1xuICogQG1ldGhvZCBtYWtlUm91dGVyRHJpdmVyXG4gKiBAcmV0dXJuIHtyb3V0ZXJEcml2ZXJ9IFRoZSByb3V0ZXIgZHJpdmVyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG1ha2VSb3V0ZXJEcml2ZXIoaGlzdG9yeSwgcm91dGVNYXRjaGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnlEcml2ZXIgPSBoaXN0b3J5XzEubWFrZUhpc3RvcnlEcml2ZXIoaGlzdG9yeSwgb3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogVGhlIGFjdHVhbCByb3V0ZXIgZHJpdmVyLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdHlwZWRlZiB7cm91dGVyRHJpdmVyfVxuICAgICAqIEBuYW1lIHJvdXRlckRyaXZlclxuICAgICAqIEBtZXRob2Qgcm91dGVyRHJpdmVyXG4gICAgICogQHBhcmFtICB7U3RyZWFtPHN0cmluZ3xMb2NhdGlvbj59IHNpbmskIC0gVGhpcyBpcyB0aGUgc2FtZSBpbnB1dCB0aGF0IHRoZVxuICAgICAqIGhpc3RvcnkgZHJpdmVyIHdvdWxkIGV4cGVjdC5cbiAgICAgKiBAcmV0dXJuIHtyb3V0ZXJBUEl9XG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlckRyaXZlcihzaW5rJCwgcnVuU0EpIHtcbiAgICAgICAgdmFyIGhpc3RvcnkkID0gcnVuU0EucmVtZW1iZXIoaGlzdG9yeURyaXZlcihzaW5rJCwgcnVuU0EpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZXJTb3VyY2VfMS5Sb3V0ZXJTb3VyY2UoaGlzdG9yeSQsIFtdLCBoaXN0b3J5LmNyZWF0ZUhyZWYsIHJ1blNBLCByb3V0ZU1hdGNoZXIpO1xuICAgIH07XG59XG5leHBvcnRzLm1ha2VSb3V0ZXJEcml2ZXIgPSBtYWtlUm91dGVyRHJpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZVJvdXRlckRyaXZlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3ljbGljLXJvdXRlci9saWIvbWFrZVJvdXRlckRyaXZlci5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzcGxpdFBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmxlbmd0aCA+IDA7IH0pO1xufVxuZXhwb3J0cy5zcGxpdFBhdGggPSBzcGxpdFBhdGg7XG5mdW5jdGlvbiBmaWx0ZXJQYXRoKHBhdGhQYXJ0cywgbmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIHBhdGhQYXJ0cy5maWx0ZXIoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIG5hbWVzcGFjZS5pbmRleE9mKHBhcnQpIDwgMDsgfSkuam9pbignLycpO1xufVxuZXhwb3J0cy5maWx0ZXJQYXRoID0gZmlsdGVyUGF0aDtcbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkgeyByZXR1cm4gcGFyYW1bMF0gPT09IHZhbHVlOyB9O1xudmFyIHN0YXJ0c1dpdGgyID0gZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZTEsIHZhbHVlMikge1xuICAgIHJldHVybiBwYXJhbVswXSA9PT0gdmFsdWUxICYmIHBhcmFtWzFdID09PSB2YWx1ZTI7XG59O1xuZnVuY3Rpb24gbWFrZUNyZWF0ZUhyZWYobmFtZXNwYWNlLCBfY3JlYXRlSHJlZikge1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIEhSRUZzIHRoYXQgYXJlIHByb3Blcmx5IG5hbWVzcGFjZWRcbiAgICAgKiBAdHlwZWRlZiB7Y3JlYXRlSHJlZn1cbiAgICAgKiBAbmFtZSBjcmVhdGVIcmVmXG4gICAgICogQG1ldGhvZCBjcmVhdGVIcmVmXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIC0gdGhlIEhSRUYgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50XG4gICAgICogbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBhIGZ1bGx5IHF1YWxpZmllZCBIUkVGIGNvbXBvc2VkIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgKiBuYW1lc3BhY2UgYW5kIHRoZSBwYXRoIHByb3ZpZGVkXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgICAgICB2YXIgZnVsbFBhdGggPSBcIlwiICsgbmFtZXNwYWNlLmpvaW4oJy8nKSArIHBhdGg7XG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoKGZ1bGxQYXRoLCAnLycpIHx8IHN0YXJ0c1dpdGgyKGZ1bGxQYXRoLCAnIycsICcvJylcbiAgICAgICAgICAgID8gX2NyZWF0ZUhyZWYoZnVsbFBhdGgpXG4gICAgICAgICAgICA6IF9jcmVhdGVIcmVmKCcvJyArIGZ1bGxQYXRoKTtcbiAgICB9O1xufVxuZXhwb3J0cy5tYWtlQ3JlYXRlSHJlZiA9IG1ha2VDcmVhdGVIcmVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3ljbGljLXJvdXRlci9saWIvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29weSAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2NvcHknKVxuICAsIG1hcCAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9tYXAnKVxuICAsIGNhbGxhYmxlICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsaWRWYWx1ZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcblxuICAsIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZWZpbmU7XG5cbmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXNjLCBiaW5kVG8pIHtcblx0dmFyIHZhbHVlID0gdmFsaWRWYWx1ZShkZXNjKSAmJiBjYWxsYWJsZShkZXNjLnZhbHVlKSwgZGdzO1xuXHRkZ3MgPSBjb3B5KGRlc2MpO1xuXHRkZWxldGUgZGdzLndyaXRhYmxlO1xuXHRkZWxldGUgZGdzLnZhbHVlO1xuXHRkZ3MuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSByZXR1cm4gdmFsdWU7XG5cdFx0ZGVzYy52YWx1ZSA9IGJpbmQuY2FsbCh2YWx1ZSwgKGJpbmRUbyA9PSBudWxsKSA/IHRoaXMgOiB0aGlzW2JpbmRUb10pO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIGRlc2MpO1xuXHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHR9O1xuXHRyZXR1cm4gZGdzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcHMvKiwgYmluZFRvKi8pIHtcblx0dmFyIGJpbmRUbyA9IGFyZ3VtZW50c1sxXTtcblx0cmV0dXJuIG1hcChwcm9wcywgZnVuY3Rpb24gKGRlc2MsIG5hbWUpIHtcblx0XHRyZXR1cm4gZGVmaW5lKG5hbWUsIGRlc2MsIGJpbmRUbyk7XG5cdH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kL2F1dG8tYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9Qb3NJbnQgPSByZXF1aXJlKCcuLi8uLi9udW1iZXIvdG8tcG9zLWludGVnZXInKVxuICAsIHZhbHVlICAgID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlJylcblxuICAsIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4Ki8pIHtcblx0dmFyIGksIGwsIGZyb21JbmRleCwgdmFsO1xuXHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gc2VhcmNoRWxlbWVudCkgeyAvL2pzbGludDogaWdub3JlXG5cdFx0cmV0dXJuIGluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXG5cdGwgPSB0b1Bvc0ludCh2YWx1ZSh0aGlzKS5sZW5ndGgpO1xuXHRmcm9tSW5kZXggPSBhcmd1bWVudHNbMV07XG5cdGlmIChpc05hTihmcm9tSW5kZXgpKSBmcm9tSW5kZXggPSAwO1xuXHRlbHNlIGlmIChmcm9tSW5kZXggPj0gMCkgZnJvbUluZGV4ID0gZmxvb3IoZnJvbUluZGV4KTtcblx0ZWxzZSBmcm9tSW5kZXggPSB0b1Bvc0ludCh0aGlzLmxlbmd0aCkgLSBmbG9vcihhYnMoZnJvbUluZGV4KSk7XG5cblx0Zm9yIChpID0gZnJvbUluZGV4OyBpIDwgbDsgKytpKSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkpIHtcblx0XHRcdHZhbCA9IHRoaXNbaV07XG5cdFx0XHRpZiAodmFsICE9PSB2YWwpIHJldHVybiBpOyAvL2pzbGludDogaWdub3JlXG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE1hdGguc2lnblxuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvbWF0aC9zaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2lnbiA9IE1hdGguc2lnbjtcblx0aWYgKHR5cGVvZiBzaWduICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoKHNpZ24oMTApID09PSAxKSAmJiAoc2lnbigtMjApID09PSAtMSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L21hdGgvc2lnbi9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmIChpc05hTih2YWx1ZSkgfHwgKHZhbHVlID09PSAwKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gKHZhbHVlID4gMCkgPyAxIDogLTE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvbWF0aC9zaWduL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNpZ24gPSByZXF1aXJlKCcuLi9tYXRoL3NpZ24nKVxuXG4gICwgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIDA7XG5cdHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblx0aWYgKCh2YWx1ZSA9PT0gMCkgfHwgIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gc2lnbih2YWx1ZSkgKiBmbG9vcihhYnModmFsdWUpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9udW1iZXIvdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90by1pbnRlZ2VyJylcblxuICAsIG1heCA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbWF4KDAsIHRvSW50ZWdlcih2YWx1ZSkpOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvbnVtYmVyL3RvLXBvcy1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJbnRlcm5hbCBtZXRob2QsIHVzZWQgYnkgaXRlcmF0aW9uIGZ1bmN0aW9ucy5cbi8vIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2gga2V5LXZhbHVlIHBhaXIgZm91bmQgaW4gb2JqZWN0XG4vLyBPcHRpb25hbGx5IHRha2VzIGNvbXBhcmVGbiB0byBpdGVyYXRlIG9iamVjdCBpbiBzcGVjaWZpYyBvcmRlclxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsYWJsZSA9IHJlcXVpcmUoJy4vdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbHVlICAgID0gcmVxdWlyZSgnLi92YWxpZC12YWx1ZScpXG5cbiAgLCBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCwga2V5cyA9IE9iamVjdC5rZXlzXG4gICwgcHJvcGVydHlJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGRlZlZhbCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKG9iaiwgY2IvKiwgdGhpc0FyZywgY29tcGFyZUZuKi8pIHtcblx0XHR2YXIgbGlzdCwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXSwgY29tcGFyZUZuID0gYXJndW1lbnRzWzNdO1xuXHRcdG9iaiA9IE9iamVjdCh2YWx1ZShvYmopKTtcblx0XHRjYWxsYWJsZShjYik7XG5cblx0XHRsaXN0ID0ga2V5cyhvYmopO1xuXHRcdGlmIChjb21wYXJlRm4pIHtcblx0XHRcdGxpc3Quc29ydCgodHlwZW9mIGNvbXBhcmVGbiA9PT0gJ2Z1bmN0aW9uJykgPyBiaW5kLmNhbGwoY29tcGFyZUZuLCBvYmopIDogdW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIG1ldGhvZCA9IGxpc3RbbWV0aG9kXTtcblx0XHRyZXR1cm4gY2FsbC5jYWxsKG1ldGhvZCwgbGlzdCwgZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcblx0XHRcdGlmICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSkpIHJldHVybiBkZWZWYWw7XG5cdFx0XHRyZXR1cm4gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBvYmpba2V5XSwga2V5LCBvYmosIGluZGV4KTtcblx0XHR9KTtcblx0fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvX2l0ZXJhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiAncmF6JyB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogJ2R3YScgfSwgeyB0cnp5OiAndHJ6eScgfSk7XG5cdHJldHVybiAob2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSkgPT09ICdyYXpkd2F0cnp5Jztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzICA9IHJlcXVpcmUoJy4uL2tleXMnKVxuICAsIHZhbHVlID0gcmVxdWlyZSgnLi4vdmFsaWQtdmFsdWUnKVxuXG4gICwgbWF4ID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc3QsIHNyYy8qLCDigKZzcmNuKi8pIHtcblx0dmFyIGVycm9yLCBpLCBsID0gbWF4KGFyZ3VtZW50cy5sZW5ndGgsIDIpLCBhc3NpZ247XG5cdGRlc3QgPSBPYmplY3QodmFsdWUoZGVzdCkpO1xuXHRhc3NpZ24gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dHJ5IHsgZGVzdFtrZXldID0gc3JjW2tleV07IH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZTtcblx0XHR9XG5cdH07XG5cdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0a2V5cyhzcmMpLmZvckVhY2goYXNzaWduKTtcblx0fVxuXHRpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyb3I7XG5cdHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9hc3NpZ24nKVxuICAsIHZhbHVlICA9IHJlcXVpcmUoJy4vdmFsaWQtdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHZhciBjb3B5ID0gT2JqZWN0KHZhbHVlKG9iaikpO1xuXHRpZiAoY29weSAhPT0gb2JqKSByZXR1cm4gY29weTtcblx0cmV0dXJuIGFzc2lnbih7fSwgb2JqKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvY29weS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gV29ya2Fyb3VuZCBmb3IgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjgwNFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBzaGltO1xuXG5pZiAoIXJlcXVpcmUoJy4vc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZCcpKCkpIHtcblx0c2hpbSA9IHJlcXVpcmUoJy4vc2V0LXByb3RvdHlwZS1vZi9zaGltJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG51bGxPYmplY3QsIHByb3BzLCBkZXNjO1xuXHRpZiAoIXNoaW0pIHJldHVybiBjcmVhdGU7XG5cdGlmIChzaGltLmxldmVsICE9PSAxKSByZXR1cm4gY3JlYXRlO1xuXG5cdG51bGxPYmplY3QgPSB7fTtcblx0cHJvcHMgPSB7fTtcblx0ZGVzYyA9IHsgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLFxuXHRcdHZhbHVlOiB1bmRlZmluZWQgfTtcblx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuXHRcdFx0cHJvcHNbbmFtZV0gPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkIH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHByb3BzW25hbWVdID0gZGVzYztcblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG51bGxPYmplY3QsIHByb3BzKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc2hpbSwgJ251bGxQb2x5ZmlsbCcsIHsgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogbnVsbE9iamVjdCB9KTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcHMpIHtcblx0XHRyZXR1cm4gY3JlYXRlKChwcm90b3R5cGUgPT09IG51bGwpID8gbnVsbE9iamVjdCA6IHByb3RvdHlwZSwgcHJvcHMpO1xuXHR9O1xufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlcmF0ZScpKCdmb3JFYWNoJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvZm9yLWVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBEZXByZWNhdGVkXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwID0geyBmdW5jdGlvbjogdHJ1ZSwgb2JqZWN0OiB0cnVlIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0cmV0dXJuICgoeCAhPSBudWxsKSAmJiBtYXBbdHlwZW9mIHhdKSB8fCBmYWxzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvaXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gT2JqZWN0LmtleXNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRPYmplY3Qua2V5cygncHJpbWl0aXZlJyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXHRyZXR1cm4ga2V5cyhvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IE9iamVjdChvYmplY3QpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbGFibGUgPSByZXF1aXJlKCcuL3ZhbGlkLWNhbGxhYmxlJylcbiAgLCBmb3JFYWNoICA9IHJlcXVpcmUoJy4vZm9yLWVhY2gnKVxuXG4gICwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGNiLyosIHRoaXNBcmcqLykge1xuXHR2YXIgbyA9IHt9LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuXHRjYWxsYWJsZShjYik7XG5cdGZvckVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgb2JqLCBpbmRleCkge1xuXHRcdG9ba2V5XSA9IGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdmFsdWUsIGtleSwgb2JqLCBpbmRleCk7XG5cdH0pO1xuXHRyZXR1cm4gbztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM1LWV4dC9vYmplY3QvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG52YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIG9iaikge1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBzcmMpIG9ialtrZXldID0gc3JjW2tleV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLyosIOKApm9wdGlvbnMqLykge1xuXHR2YXIgcmVzdWx0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zID09IG51bGwpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmcvKiwg4oCmYXJncyovKSB7XG5cdHZhciBzZXQgPSBjcmVhdGUobnVsbCk7XG5cdGZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChuYW1lKSB7IHNldFtuYW1lXSA9IHRydWU7IH0pO1xuXHRyZXR1cm4gc2V0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L29iamVjdC9wcmltaXRpdmUtc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyID0gJ3JhemR3YXRyenknO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBzdHIuY29udGFpbnMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICgoc3RyLmNvbnRhaW5zKCdkd2EnKSA9PT0gdHJ1ZSkgJiYgKHN0ci5jb250YWlucygnZm9vJykgPT09IGZhbHNlKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmRleE9mID0gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcvKiwgcG9zaXRpb24qLykge1xuXHRyZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsIHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKSA+IC0xO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGNvbnRhaW5zICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucycpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJy4vJylcblxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgQXJyYXlJdGVyYXRvcjtcblxuQXJyYXlJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyciwga2luZCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQXJyYXlJdGVyYXRvcikpIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihhcnIsIGtpbmQpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIGFycik7XG5cdGlmICgha2luZCkga2luZCA9ICd2YWx1ZSc7XG5cdGVsc2UgaWYgKGNvbnRhaW5zLmNhbGwoa2luZCwgJ2tleSt2YWx1ZScpKSBraW5kID0gJ2tleSt2YWx1ZSc7XG5cdGVsc2UgaWYgKGNvbnRhaW5zLmNhbGwoa2luZCwgJ2tleScpKSBraW5kID0gJ2tleSc7XG5cdGVsc2Uga2luZCA9ICd2YWx1ZSc7XG5cdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2tpbmRfXycsIGQoJycsIGtpbmQpKTtcbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKEFycmF5SXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuQXJyYXlJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChBcnJheUl0ZXJhdG9yKSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gJ3ZhbHVlJykgcmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICdrZXkrdmFsdWUnKSByZXR1cm4gW2ksIHRoaXMuX19saXN0X19baV1dO1xuXHRcdHJldHVybiBpO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgQXJyYXkgSXRlcmF0b3JdJzsgfSlcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1pdGVyYXRvci9hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMnKVxuICAsIGNhbGxhYmxlICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIGlzU3RyaW5nICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nJylcbiAgLCBnZXQgICAgICAgICA9IHJlcXVpcmUoJy4vZ2V0JylcblxuICAsIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjYi8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIG1vZGUsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIHJlc3VsdCwgZG9CcmVhaywgYnJva2VuLCBpLCBsLCBjaGFyLCBjb2RlO1xuXHRpZiAoaXNBcnJheShpdGVyYWJsZSkgfHwgaXNBcmd1bWVudHMoaXRlcmFibGUpKSBtb2RlID0gJ2FycmF5Jztcblx0ZWxzZSBpZiAoaXNTdHJpbmcoaXRlcmFibGUpKSBtb2RlID0gJ3N0cmluZyc7XG5cdGVsc2UgaXRlcmFibGUgPSBnZXQoaXRlcmFibGUpO1xuXG5cdGNhbGxhYmxlKGNiKTtcblx0ZG9CcmVhayA9IGZ1bmN0aW9uICgpIHsgYnJva2VuID0gdHJ1ZTsgfTtcblx0aWYgKG1vZGUgPT09ICdhcnJheScpIHtcblx0XHRzb21lLmNhbGwoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB2YWx1ZSwgZG9CcmVhayk7XG5cdFx0XHRpZiAoYnJva2VuKSByZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1vZGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0bCA9IGl0ZXJhYmxlLmxlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRjaGFyID0gaXRlcmFibGVbaV07XG5cdFx0XHRpZiAoKGkgKyAxKSA8IGwpIHtcblx0XHRcdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0aWYgKChjb2RlID49IDB4RDgwMCkgJiYgKGNvZGUgPD0gMHhEQkZGKSkgY2hhciArPSBpdGVyYWJsZVsrK2ldO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBjaGFyLCBkb0JyZWFrKTtcblx0XHRcdGlmIChicm9rZW4pIGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXG5cdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgZG9CcmVhayk7XG5cdFx0aWYgKGJyb2tlbikgcmV0dXJuO1xuXHRcdHJlc3VsdCA9IGl0ZXJhYmxlLm5leHQoKTtcblx0fVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtaXRlcmF0b3IvZm9yLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHMgICAgPSByZXF1aXJlKCdlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50cycpXG4gICwgaXNTdHJpbmcgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy9pcy1zdHJpbmcnKVxuICAsIEFycmF5SXRlcmF0b3IgID0gcmVxdWlyZSgnLi9hcnJheScpXG4gICwgU3RyaW5nSXRlcmF0b3IgPSByZXF1aXJlKCcuL3N0cmluZycpXG4gICwgaXRlcmFibGUgICAgICAgPSByZXF1aXJlKCcuL3ZhbGlkLWl0ZXJhYmxlJylcbiAgLCBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS5pdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGlmICh0eXBlb2YgaXRlcmFibGUob2JqKVtpdGVyYXRvclN5bWJvbF0gPT09ICdmdW5jdGlvbicpIHJldHVybiBvYmpbaXRlcmF0b3JTeW1ib2xdKCk7XG5cdGlmIChpc0FyZ3VtZW50cyhvYmopKSByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcblx0aWYgKGlzU3RyaW5nKG9iaikpIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Iob2JqKTtcblx0cmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1pdGVyYXRvci9nZXQuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoJ2VzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzJylcbiAgLCBpc1N0cmluZyAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nL2lzLXN0cmluZycpXG4gICwgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykuaXRlcmF0b3JcblxuICAsIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaXNBcnJheSh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNTdHJpbmcodmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGlzQXJndW1lbnRzKHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiAodHlwZW9mIHZhbHVlW2l0ZXJhdG9yU3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1pdGVyYXRvci9pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoYW5rcyBAbWF0aGlhc2J5bmVuc1xuLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlI2l0ZXJhdGluZy1vdmVyLXN5bWJvbHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnLi8nKVxuXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBTdHJpbmdJdGVyYXRvcjtcblxuU3RyaW5nSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmluZ0l0ZXJhdG9yKSkgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcihzdHIpO1xuXHRzdHIgPSBTdHJpbmcoc3RyKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBzdHIpO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19sZW5ndGhfXycsIGQoJycsIHN0ci5sZW5ndGgpKTtcblxufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoU3RyaW5nSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoU3RyaW5nSXRlcmF0b3IpLFxuXHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm47XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA8IHRoaXMuX19sZW5ndGhfXykgcmV0dXJuIHRoaXMuX19uZXh0SW5kZXhfXysrO1xuXHRcdHRoaXMuX3VuQmluZCgpO1xuXHR9KSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHR2YXIgY2hhciA9IHRoaXMuX19saXN0X19baV0sIGNvZGU7XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA9PT0gdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gY2hhcjtcblx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdGlmICgoY29kZSA+PSAweEQ4MDApICYmIChjb2RlIDw9IDB4REJGRikpIHJldHVybiBjaGFyICsgdGhpcy5fX2xpc3RfX1t0aGlzLl9fbmV4dEluZGV4X18rK107XG5cdFx0cmV0dXJuIGNoYXI7XG5cdH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJzsgfSlcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1pdGVyYXRvci9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbWFwLCBpdGVyYXRvciwgcmVzdWx0O1xuXHRpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHR0cnkge1xuXHRcdC8vIFdlYktpdCBkb2Vzbid0IHN1cHBvcnQgYXJndW1lbnRzIGFuZCBjcmFzaGVzXG5cdFx0bWFwID0gbmV3IE1hcChbWydyYXonLCAnb25lJ10sIFsnZHdhJywgJ3R3byddLCBbJ3RyenknLCAndGhyZWUnXV0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChTdHJpbmcobWFwKSAhPT0gJ1tvYmplY3QgTWFwXScpIHJldHVybiBmYWxzZTtcblx0aWYgKG1hcC5zaXplICE9PSAzKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmNsZWFyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmRlbGV0ZSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5lbnRyaWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZ2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmhhcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5rZXlzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLnNldCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC52YWx1ZXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuXHRpdGVyYXRvciA9IG1hcC5lbnRyaWVzKCk7XG5cdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0aWYgKHJlc3VsdC5kb25lICE9PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXJlc3VsdC52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAocmVzdWx0LnZhbHVlWzBdICE9PSAncmF6JykgcmV0dXJuIGZhbHNlO1xuXHRpZiAocmVzdWx0LnZhbHVlWzFdICE9PSAnb25lJykgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtbWFwL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gRXhwb3J0cyB0cnVlIGlmIGVudmlyb25tZW50IHByb3ZpZGVzIG5hdGl2ZSBgTWFwYCBpbXBsZW1lbnRhdGlvbixcbi8vIHdoYXRldmVyIHRoYXQgaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpKSA9PT0gJ1tvYmplY3QgTWFwXScpO1xufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtbWFwL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9wcmltaXRpdmUtc2V0JykoJ2tleScsXG5cdCd2YWx1ZScsICdrZXkrdmFsdWUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtbWFwL2xpYi9pdGVyYXRvci1raW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgZCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBJdGVyYXRvciAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvcicpXG4gICwgdG9TdHJpbmdUYWdTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykudG9TdHJpbmdUYWdcbiAgLCBraW5kcyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vaXRlcmF0b3Ita2luZHMnKVxuXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgdW5CaW5kID0gSXRlcmF0b3IucHJvdG90eXBlLl91bkJpbmRcbiAgLCBNYXBJdGVyYXRvcjtcblxuTWFwSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXAsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcEl0ZXJhdG9yKSkgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcihtYXAsIGtpbmQpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIG1hcC5fX21hcEtleXNEYXRhX18sIG1hcCk7XG5cdGlmICgha2luZCB8fCAha2luZHNba2luZF0pIGtpbmQgPSAna2V5K3ZhbHVlJztcblx0ZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0X19raW5kX186IGQoJycsIGtpbmQpLFxuXHRcdF9fdmFsdWVzX186IGQoJ3cnLCBtYXAuX19tYXBWYWx1ZXNEYXRhX18pXG5cdH0pO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoTWFwSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuTWFwSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoTWFwSXRlcmF0b3IpLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAndmFsdWUnKSByZXR1cm4gdGhpcy5fX3ZhbHVlc19fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAna2V5JykgcmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0cmV0dXJuIFt0aGlzLl9fbGlzdF9fW2ldLCB0aGlzLl9fdmFsdWVzX19baV1dO1xuXHR9KSxcblx0X3VuQmluZDogZChmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fX3ZhbHVlc19fID0gbnVsbDtcblx0XHR1bkJpbmQuY2FsbCh0aGlzKTtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nOyB9KVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwSXRlcmF0b3IucHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCxcblx0ZCgnYycsICdNYXAgSXRlcmF0b3InKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LW1hcC9saWIvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbGVhciAgICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9jbGVhcicpXG4gICwgZUluZGV4T2YgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L2FycmF5LyMvZS1pbmRleC1vZicpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBjYWxsYWJsZSAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCB2YWxpZFZhbHVlICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIGVlICAgICAgICAgICAgID0gcmVxdWlyZSgnZXZlbnQtZW1pdHRlcicpXG4gICwgU3ltYm9sICAgICAgICAgPSByZXF1aXJlKCdlczYtc3ltYm9sJylcbiAgLCBpdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZScpXG4gICwgZm9yT2YgICAgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3IvZm9yLW9mJylcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJy4vbGliL2l0ZXJhdG9yJylcbiAgLCBpc05hdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vaXMtbmF0aXZlLWltcGxlbWVudGVkJylcblxuICAsIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgLCBNYXBQb2x5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcFBvbHkgPSBmdW5jdGlvbiAoLyppdGVyYWJsZSovKSB7XG5cdHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXSwga2V5cywgdmFsdWVzLCBzZWxmO1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwUG9seSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnN0cnVjdG9yIHJlcXVpcmVzIFxcJ25ld1xcJycpO1xuXHRpZiAoaXNOYXRpdmUgJiYgc2V0UHJvdG90eXBlT2YgJiYgKE1hcCAhPT0gTWFwUG9seSkpIHtcblx0XHRzZWxmID0gc2V0UHJvdG90eXBlT2YobmV3IE1hcCgpLCBnZXRQcm90b3R5cGVPZih0aGlzKSk7XG5cdH0gZWxzZSB7XG5cdFx0c2VsZiA9IHRoaXM7XG5cdH1cblx0aWYgKGl0ZXJhYmxlICE9IG51bGwpIGl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0ZGVmaW5lUHJvcGVydGllcyhzZWxmLCB7XG5cdFx0X19tYXBLZXlzRGF0YV9fOiBkKCdjJywga2V5cyA9IFtdKSxcblx0XHRfX21hcFZhbHVlc0RhdGFfXzogZCgnYycsIHZhbHVlcyA9IFtdKVxuXHR9KTtcblx0aWYgKCFpdGVyYWJsZSkgcmV0dXJuIHNlbGY7XG5cdGZvck9mKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR2YXIga2V5ID0gdmFsaWRWYWx1ZSh2YWx1ZSlbMF07XG5cdFx0dmFsdWUgPSB2YWx1ZVsxXTtcblx0XHRpZiAoZUluZGV4T2YuY2FsbChrZXlzLCBrZXkpICE9PSAtMSkgcmV0dXJuO1xuXHRcdGtleXMucHVzaChrZXkpO1xuXHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0fSwgc2VsZik7XG5cdHJldHVybiBzZWxmO1xufTtcblxuaWYgKGlzTmF0aXZlKSB7XG5cdGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoTWFwUG9seSwgTWFwKTtcblx0TWFwUG9seS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1hcC5wcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogZChNYXBQb2x5KVxuXHR9KTtcbn1cblxuZWUoZGVmaW5lUHJvcGVydGllcyhNYXBQb2x5LnByb3RvdHlwZSwge1xuXHRjbGVhcjogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbWFwS2V5c0RhdGFfXy5sZW5ndGgpIHJldHVybjtcblx0XHRjbGVhci5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fKTtcblx0XHRjbGVhci5jYWxsKHRoaXMuX19tYXBWYWx1ZXNEYXRhX18pO1xuXHRcdHRoaXMuZW1pdCgnX2NsZWFyJyk7XG5cdH0pLFxuXHRkZWxldGU6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXHRcdHRoaXMuX19tYXBLZXlzRGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5fX21hcFZhbHVlc0RhdGFfXy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMuZW1pdCgnX2RlbGV0ZScsIGluZGV4LCBrZXkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9KSxcblx0ZW50cmllczogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpOyB9KSxcblx0Zm9yRWFjaDogZChmdW5jdGlvbiAoY2IvKiwgdGhpc0FyZyovKSB7XG5cdFx0dmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV0sIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdFx0Y2FsbGFibGUoY2IpO1xuXHRcdGl0ZXJhdG9yID0gdGhpcy5lbnRyaWVzKCk7XG5cdFx0cmVzdWx0ID0gaXRlcmF0b3IuX25leHQoKTtcblx0XHR3aGlsZSAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdGhpcy5fX21hcFZhbHVlc0RhdGFfX1tyZXN1bHRdLFxuXHRcdFx0XHR0aGlzLl9fbWFwS2V5c0RhdGFfX1tyZXN1bHRdLCB0aGlzKTtcblx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLl9uZXh0KCk7XG5cdFx0fVxuXHR9KSxcblx0Z2V0OiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpO1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcblx0XHRyZXR1cm4gdGhpcy5fX21hcFZhbHVlc0RhdGFfX1tpbmRleF07XG5cdH0pLFxuXHRoYXM6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiAoZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KSAhPT0gLTEpO1xuXHR9KSxcblx0a2V5czogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ2tleScpOyB9KSxcblx0c2V0OiBkKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KSwgZW1pdDtcblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX19tYXBLZXlzRGF0YV9fLnB1c2goa2V5KSAtIDE7XG5cdFx0XHRlbWl0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0dGhpcy5fX21hcFZhbHVlc0RhdGFfX1tpbmRleF0gPSB2YWx1ZTtcblx0XHRpZiAoZW1pdCkgdGhpcy5lbWl0KCdfYWRkJywgaW5kZXgsIGtleSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pLFxuXHRzaXplOiBkLmdzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19tYXBLZXlzRGF0YV9fLmxlbmd0aDsgfSksXG5cdHZhbHVlczogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7IH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBNYXBdJzsgfSlcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBQb2x5LnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCBkKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZW50cmllcygpO1xufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFBvbHkucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoJ2MnLCAnTWFwJykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1tYXAvcG9seWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZFR5cGVzID0geyBvYmplY3Q6IHRydWUsIHN5bWJvbDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHN5bWJvbDtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0c3ltYm9sID0gU3ltYm9sKCd0ZXN0IHN5bWJvbCcpO1xuXHR0cnkgeyBTdHJpbmcoc3ltYm9sKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBSZXR1cm4gJ3RydWUnIGFsc28gZm9yIHBvbHlmaWxsc1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC5pdGVyYXRvcl0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9QcmltaXRpdmVdKSByZXR1cm4gZmFsc2U7XG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnXSkgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtc3ltYm9sL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdGlmICgheCkgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHggPT09ICdzeW1ib2wnKSByZXR1cm4gdHJ1ZTtcblx0aWYgKCF4LmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cdGlmICh4LmNvbnN0cnVjdG9yLm5hbWUgIT09ICdTeW1ib2wnKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoeFt4LmNvbnN0cnVjdG9yLnRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCcpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtc3ltYm9sL2lzLXN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEVTMjAxNSBTeW1ib2wgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0IChvciBwYXJ0aWFsbHkgc3VwcG9ydCBpdClcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCB2YWxpZGF0ZVN5bWJvbCA9IHJlcXVpcmUoJy4vdmFsaWRhdGUtc3ltYm9sJylcblxuICAsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBvYmpQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlXG4gICwgTmF0aXZlU3ltYm9sLCBTeW1ib2xQb2x5ZmlsbCwgSGlkZGVuU3ltYm9sLCBnbG9iYWxTeW1ib2xzID0gY3JlYXRlKG51bGwpXG4gICwgaXNOYXRpdmVTYWZlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHROYXRpdmVTeW1ib2wgPSBTeW1ib2w7XG5cdHRyeSB7XG5cdFx0U3RyaW5nKE5hdGl2ZVN5bWJvbCgpKTtcblx0XHRpc05hdGl2ZVNhZmUgPSB0cnVlO1xuXHR9IGNhdGNoIChpZ25vcmUpIHt9XG59XG5cbnZhciBnZW5lcmF0ZU5hbWUgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgY3JlYXRlZCA9IGNyZWF0ZShudWxsKTtcblx0cmV0dXJuIGZ1bmN0aW9uIChkZXNjKSB7XG5cdFx0dmFyIHBvc3RmaXggPSAwLCBuYW1lLCBpZTExQnVnV29ya2Fyb3VuZDtcblx0XHR3aGlsZSAoY3JlYXRlZFtkZXNjICsgKHBvc3RmaXggfHwgJycpXSkgKytwb3N0Zml4O1xuXHRcdGRlc2MgKz0gKHBvc3RmaXggfHwgJycpO1xuXHRcdGNyZWF0ZWRbZGVzY10gPSB0cnVlO1xuXHRcdG5hbWUgPSAnQEAnICsgZGVzYztcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmpQcm90b3R5cGUsIG5hbWUsIGQuZ3MobnVsbCwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQvLyBGb3IgSUUxMSBpc3N1ZSBzZWU6XG5cdFx0XHQvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFja2RldGFpbC92aWV3LzE5Mjg1MDgvXG5cdFx0XHQvLyAgICBpZTExLWJyb2tlbi1nZXR0ZXJzLW9uLWRvbS1vYmplY3RzXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWtvby9lczYtc3ltYm9sL2lzc3Vlcy8xMlxuXHRcdFx0aWYgKGllMTFCdWdXb3JrYXJvdW5kKSByZXR1cm47XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IHRydWU7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkKHZhbHVlKSk7XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IGZhbHNlO1xuXHRcdH0pKTtcblx0XHRyZXR1cm4gbmFtZTtcblx0fTtcbn0oKSk7XG5cbi8vIEludGVybmFsIGNvbnN0cnVjdG9yIChub3Qgb25lIGV4cG9zZWQpIGZvciBjcmVhdGluZyBTeW1ib2wgaW5zdGFuY2VzLlxuLy8gVGhpcyBvbmUgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBgc29tZVN5bWJvbCBpbnN0YW5jZW9mIFN5bWJvbGAgYWx3YXlzIHJldHVybiBmYWxzZVxuSGlkZGVuU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgSGlkZGVuU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlRXJyb3I6IFN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuXHRyZXR1cm4gU3ltYm9sUG9seWZpbGwoZGVzY3JpcHRpb24pO1xufTtcblxuLy8gRXhwb3NlZCBgU3ltYm9sYCBjb25zdHJ1Y3RvclxuLy8gKHJldHVybnMgaW5zdGFuY2VzIG9mIEhpZGRlblN5bWJvbClcbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sUG9seWZpbGwgPSBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcblx0dmFyIHN5bWJvbDtcblx0aWYgKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGVFcnJvcjogU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG5cdGlmIChpc05hdGl2ZVNhZmUpIHJldHVybiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuXHRzeW1ib2wgPSBjcmVhdGUoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSk7XG5cdGRlc2NyaXB0aW9uID0gKGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhkZXNjcmlwdGlvbikpO1xuXHRyZXR1cm4gZGVmaW5lUHJvcGVydGllcyhzeW1ib2wsIHtcblx0XHRfX2Rlc2NyaXB0aW9uX186IGQoJycsIGRlc2NyaXB0aW9uKSxcblx0XHRfX25hbWVfXzogZCgnJywgZ2VuZXJhdGVOYW1lKGRlc2NyaXB0aW9uKSlcblx0fSk7XG59O1xuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbCwge1xuXHRmb3I6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdGlmIChnbG9iYWxTeW1ib2xzW2tleV0pIHJldHVybiBnbG9iYWxTeW1ib2xzW2tleV07XG5cdFx0cmV0dXJuIChnbG9iYWxTeW1ib2xzW2tleV0gPSBTeW1ib2xQb2x5ZmlsbChTdHJpbmcoa2V5KSkpO1xuXHR9KSxcblx0a2V5Rm9yOiBkKGZ1bmN0aW9uIChzKSB7XG5cdFx0dmFyIGtleTtcblx0XHR2YWxpZGF0ZVN5bWJvbChzKTtcblx0XHRmb3IgKGtleSBpbiBnbG9iYWxTeW1ib2xzKSBpZiAoZ2xvYmFsU3ltYm9sc1trZXldID09PSBzKSByZXR1cm4ga2V5O1xuXHR9KSxcblxuXHQvLyBJZiB0aGVyZSdzIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBnaXZlbiBzeW1ib2wsIGxldCdzIGZhbGxiYWNrIHRvIGl0XG5cdC8vIHRvIGVuc3VyZSBwcm9wZXIgaW50ZXJvcGVyYWJpbGl0eSB3aXRoIG90aGVyIG5hdGl2ZSBmdW5jdGlvbnMgZS5nLiBBcnJheS5mcm9tXG5cdGhhc0luc3RhbmNlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5oYXNJbnN0YW5jZSkgfHwgU3ltYm9sUG9seWZpbGwoJ2hhc0luc3RhbmNlJykpLFxuXHRpc0NvbmNhdFNwcmVhZGFibGU6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSkgfHxcblx0XHRTeW1ib2xQb2x5ZmlsbCgnaXNDb25jYXRTcHJlYWRhYmxlJykpLFxuXHRpdGVyYXRvcjogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaXRlcmF0b3IpIHx8IFN5bWJvbFBvbHlmaWxsKCdpdGVyYXRvcicpKSxcblx0bWF0Y2g6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLm1hdGNoKSB8fCBTeW1ib2xQb2x5ZmlsbCgnbWF0Y2gnKSksXG5cdHJlcGxhY2U6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnJlcGxhY2UpIHx8IFN5bWJvbFBvbHlmaWxsKCdyZXBsYWNlJykpLFxuXHRzZWFyY2g6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNlYXJjaCkgfHwgU3ltYm9sUG9seWZpbGwoJ3NlYXJjaCcpKSxcblx0c3BlY2llczogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc3BlY2llcykgfHwgU3ltYm9sUG9seWZpbGwoJ3NwZWNpZXMnKSksXG5cdHNwbGl0OiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zcGxpdCkgfHwgU3ltYm9sUG9seWZpbGwoJ3NwbGl0JykpLFxuXHR0b1ByaW1pdGl2ZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudG9QcmltaXRpdmUpIHx8IFN5bWJvbFBvbHlmaWxsKCd0b1ByaW1pdGl2ZScpKSxcblx0dG9TdHJpbmdUYWc6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvU3RyaW5nVGFnKSB8fCBTeW1ib2xQb2x5ZmlsbCgndG9TdHJpbmdUYWcnKSksXG5cdHVuc2NvcGFibGVzOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC51bnNjb3BhYmxlcykgfHwgU3ltYm9sUG9seWZpbGwoJ3Vuc2NvcGFibGVzJykpXG59KTtcblxuLy8gSW50ZXJuYWwgdHdlYWtzIGZvciByZWFsIHN5bWJvbCBwcm9kdWNlclxuZGVmaW5lUHJvcGVydGllcyhIaWRkZW5TeW1ib2wucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKFN5bWJvbFBvbHlmaWxsKSxcblx0dG9TdHJpbmc6IGQoJycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19uYW1lX187IH0pXG59KTtcblxuLy8gUHJvcGVyIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgZXhwb3NlZCBvbiBTeW1ib2wucHJvdG90eXBlXG4vLyBUaGV5IHdvbid0IGJlIGFjY2Vzc2libGUgb24gcHJvZHVjZWQgc3ltYm9sIGluc3RhbmNlcyBhcyB0aGV5IGRlcml2ZSBmcm9tIEhpZGRlblN5bWJvbC5wcm90b3R5cGVcbmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCB7XG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTeW1ib2wgKCcgKyB2YWxpZGF0ZVN5bWJvbCh0aGlzKS5fX2Rlc2NyaXB0aW9uX18gKyAnKSc7IH0pLFxuXHR2YWx1ZU9mOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlU3ltYm9sKHRoaXMpOyB9KVxufSk7XG5kZWZpbmVQcm9wZXJ0eShTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlLCBkKCcnLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBzeW1ib2wgPSB2YWxpZGF0ZVN5bWJvbCh0aGlzKTtcblx0aWYgKHR5cGVvZiBzeW1ib2wgPT09ICdzeW1ib2wnKSByZXR1cm4gc3ltYm9sO1xuXHRyZXR1cm4gc3ltYm9sLnRvU3RyaW5nKCk7XG59KSk7XG5kZWZpbmVQcm9wZXJ0eShTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCBkKCdjJywgJ1N5bWJvbCcpKTtcblxuLy8gUHJvcGVyIGltcGxlbWVudGF0b24gb2YgdG9QcmltaXRpdmUgYW5kIHRvU3RyaW5nVGFnIGZvciByZXR1cm5lZCBzeW1ib2wgaW5zdGFuY2VzXG5kZWZpbmVQcm9wZXJ0eShIaWRkZW5TeW1ib2wucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyxcblx0ZCgnYycsIFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZVtTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZ10pKTtcblxuLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdG8gZGVmaW5lIGB0b1ByaW1pdGl2ZWAgYXMgbGFzdCBvbmUsIGFzIHNvbWUgaW1wbGVtZW50YXRpb25zXG4vLyBpbXBsZW1lbnQgYHRvUHJpbWl0aXZlYCBuYXRpdmVseSB3aXRob3V0IGltcGxlbWVudGluZyBgdG9TdHJpbmdUYWdgIChvciBvdGhlciBzcGVjaWZpZWQgc3ltYm9scylcbi8vIEFuZCB0aGF0IG1heSBpbnZva2UgZXJyb3IgaW4gZGVmaW5pdGlvbiBmbG93OlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWtvby9lczYtc3ltYm9sL2lzc3Vlcy8xMyNpc3N1ZWNvbW1lbnQtMTY0MTQ2MTQ5XG5kZWZpbmVQcm9wZXJ0eShIaWRkZW5TeW1ib2wucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSxcblx0ZCgnYycsIFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZVtTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZV0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtc3ltYm9sL3BvbHlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzLXN5bWJvbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzU3ltYm9sKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCBhIHN5bWJvbFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtc3ltYm9sL3ZhbGlkYXRlLXN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG5cbiAgLCBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG5cbiAgLCBvbiwgb25jZSwgb2ZmLCBlbWl0LCBtZXRob2RzLCBkZXNjcmlwdG9ycywgYmFzZTtcblxub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGE7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHtcblx0XHRkYXRhID0gZGVzY3JpcHRvci52YWx1ZSA9IGNyZWF0ZShudWxsKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19lZV9fJywgZGVzY3JpcHRvcik7XG5cdFx0ZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHR9XG5cdGlmICghZGF0YVt0eXBlXSkgZGF0YVt0eXBlXSA9IGxpc3RlbmVyO1xuXHRlbHNlIGlmICh0eXBlb2YgZGF0YVt0eXBlXSA9PT0gJ29iamVjdCcpIGRhdGFbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdGVsc2UgZGF0YVt0eXBlXSA9IFtkYXRhW3R5cGVdLCBsaXN0ZW5lcl07XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBvbmNlLCBzZWxmO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblx0c2VsZiA9IHRoaXM7XG5cdG9uLmNhbGwodGhpcywgdHlwZSwgb25jZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYuY2FsbChzZWxmLCB0eXBlLCBvbmNlKTtcblx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmd1bWVudHMpO1xuXHR9KTtcblxuXHRvbmNlLl9fZWVPbmNlTGlzdGVuZXJfXyA9IGxpc3RlbmVyO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YSwgbGlzdGVuZXJzLCBjYW5kaWRhdGUsIGk7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybiB0aGlzO1xuXHRkYXRhID0gdGhpcy5fX2VlX187XG5cdGlmICghZGF0YVt0eXBlXSkgcmV0dXJuIHRoaXM7XG5cdGxpc3RlbmVycyA9IGRhdGFbdHlwZV07XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yIChpID0gMDsgKGNhbmRpZGF0ZSA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0aWYgKChjYW5kaWRhdGUgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHRcdChjYW5kaWRhdGUuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDIpIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcnNbaSA/IDAgOiAxXTtcblx0XHRcdFx0ZWxzZSBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoKGxpc3RlbmVycyA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdChsaXN0ZW5lcnMuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdGRlbGV0ZSBkYXRhW3R5cGVdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHZhciBpLCBsLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBhcmdzO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybjtcblx0bGlzdGVuZXJzID0gdGhpcy5fX2VlX19bdHlwZV07XG5cdGlmICghbGlzdGVuZXJzKSByZXR1cm47XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cblx0XHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblx0XHRmb3IgKGkgPSAwOyAobGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0YXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG59O1xuXG5tZXRob2RzID0ge1xuXHRvbjogb24sXG5cdG9uY2U6IG9uY2UsXG5cdG9mZjogb2ZmLFxuXHRlbWl0OiBlbWl0XG59O1xuXG5kZXNjcmlwdG9ycyA9IHtcblx0b246IGQob24pLFxuXHRvbmNlOiBkKG9uY2UpLFxuXHRvZmY6IGQob2ZmKSxcblx0ZW1pdDogZChlbWl0KVxufTtcblxuYmFzZSA9IGRlZmluZVByb3BlcnRpZXMoe30sIGRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKG8pIHtcblx0cmV0dXJuIChvID09IG51bGwpID8gY3JlYXRlKGJhc2UpIDogZGVmaW5lUHJvcGVydGllcyhPYmplY3QobyksIGRlc2NyaXB0b3JzKTtcbn07XG5leHBvcnRzLm1ldGhvZHMgPSBtZXRob2RzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2ZW50LWVtaXR0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBsb29wQXN5bmMgPSBleHBvcnRzLmxvb3BBc3luYyA9IGZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgaXNTeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHZvaWQgMDtcblxuICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaXNEb25lID0gdHJ1ZTtcblxuICAgIGlmIChpc1N5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IGFyZ3M7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkgcmV0dXJuO1xuXG4gICAgaGFzTmV4dCA9IHRydWU7XG5cbiAgICBpZiAoaXNTeW5jKSByZXR1cm47IC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG5cbiAgICBpc1N5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrKGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIGlzU3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBfdG9Db25zdW1hYmxlQXJyYXkoZG9uZUFyZ3MpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIG5leHQoKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdvID0gZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX0Jyb3dzZXJQcm90b2NvbCA9IHJlcXVpcmUoJy4vQnJvd3NlclByb3RvY29sJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2V0VXNlckNvbmZpcm1hdGlvbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dvJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Jyb3dzZXJQcm90b2NvbC5nbztcbiAgfVxufSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhpbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGkgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaSA+PSAwID8gaSA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgZW5zdXJlU2xhc2ggPSBmdW5jdGlvbiBlbnN1cmVTbGFzaCgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuXG4gIGlmICgoMCwgX1BhdGhVdGlscy5pc0Fic29sdXRlUGF0aCkocGF0aCkpIHJldHVybiB0cnVlO1xuXG4gIHJlcGxhY2VIYXNoUGF0aCgnLycgKyBwYXRoKTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24ocXVlcnlLZXkpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIga2V5ID0gKDAsIF9QYXRoVXRpbHMuZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKShwYXRoLCBxdWVyeUtleSk7XG5cbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICBpZiAoa2V5KSB7XG4gICAgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKShwYXRoLCBxdWVyeUtleSk7XG4gICAgc3RhdGUgPSAoMCwgX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUpKGtleSk7XG4gIH1cblxuICB2YXIgaW5pdCA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XG4gIGluaXQuc3RhdGUgPSBzdGF0ZTtcblxuICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShpbml0LCB1bmRlZmluZWQsIGtleSk7XG59O1xuXG52YXIgcHJldkxvY2F0aW9uID0gdm9pZCAwO1xuXG52YXIgc3RhcnRMaXN0ZW5lciA9IGV4cG9ydHMuc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIHF1ZXJ5S2V5KSB7XG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHJldHVybjsgLy8gSGFzaCBwYXRoIG11c3QgYWx3YXlzIGJlZ2luIHdpdGggYSAvXG5cbiAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKHF1ZXJ5S2V5KTtcblxuICAgIGlmIChwcmV2TG9jYXRpb24gJiYgY3VycmVudExvY2F0aW9uLmtleSAmJiBwcmV2TG9jYXRpb24ua2V5ID09PSBjdXJyZW50TG9jYXRpb24ua2V5KSByZXR1cm47IC8vIElnbm9yZSBleHRyYW5lb3VzIGhhc2hjaGFuZ2UgZXZlbnRzXG5cbiAgICBwcmV2TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG5cbiAgICBsaXN0ZW5lcihjdXJyZW50TG9jYXRpb24pO1xuICB9O1xuXG4gIGVuc3VyZVNsYXNoKCk7XG4gICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICB9O1xufTtcblxudmFyIHVwZGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHF1ZXJ5S2V5LCB1cGRhdGVIYXNoKSB7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG4gIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuXG4gIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgpKHBhdGgsIHF1ZXJ5S2V5LCBrZXkpO1xuICAgICgwLCBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZSkoa2V5LCBzdGF0ZSk7XG4gIH1cblxuICBwcmV2TG9jYXRpb24gPSBsb2NhdGlvbjtcblxuICB1cGRhdGVIYXNoKHBhdGgpO1xufTtcblxudmFyIHB1c2hMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uLCBxdWVyeUtleSkge1xuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHF1ZXJ5S2V5LCBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChnZXRIYXNoUGF0aCgpICE9PSBwYXRoKSB7XG4gICAgICBwdXNoSGFzaFBhdGgocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGggdXNpbmcgaGFzaCBoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciByZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbiwgcXVlcnlLZXkpIHtcbiAgcmV0dXJuIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBxdWVyeUtleSwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoZ2V0SGFzaFBhdGgoKSAhPT0gcGF0aCkgcmVwbGFjZUhhc2hQYXRoKHBhdGgpO1xuICB9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL0hhc2hQcm90b2NvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ28gPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfQnJvd3NlclByb3RvY29sID0gcmVxdWlyZSgnLi9Ccm93c2VyUHJvdG9jb2wnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnZXRVc2VyQ29uZmlybWF0aW9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Jyb3dzZXJQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ28nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdvO1xuICB9XG59KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKSh3aW5kb3cubG9jYXRpb24pO1xufTtcblxudmFyIHB1c2hMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICByZXR1cm4gZmFsc2U7IC8vIERvbid0IHVwZGF0ZSBsb2NhdGlvblxufTtcblxudmFyIHJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSk7XG4gIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgdXBkYXRlIGxvY2F0aW9uXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi9SZWZyZXNoUHJvdG9jb2wuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfQnJvd3NlclByb3RvY29sID0gcmVxdWlyZSgnLi9Ccm93c2VyUHJvdG9jb2wnKTtcblxudmFyIEJyb3dzZXJQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9Ccm93c2VyUHJvdG9jb2wpO1xuXG52YXIgX1JlZnJlc2hQcm90b2NvbCA9IHJlcXVpcmUoJy4vUmVmcmVzaFByb3RvY29sJyk7XG5cbnZhciBSZWZyZXNoUHJvdG9jb2wgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfUmVmcmVzaFByb3RvY29sKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIEhUTUw1J3MgaGlzdG9yeSBBUElcbiAqIChwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudCkgdG8gbWFuYWdlIGhpc3RvcnkuXG4gKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2Qgb2YgbWFuYWdpbmcgaGlzdG9yeSBpbiBicm93c2VycyBiZWNhdXNlXG4gKiBpdCBwcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqXG4gKiBOb3RlOiBJbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBmdWxsXG4gKiBwYWdlIHJlbG9hZHMgd2lsbCBiZSB1c2VkIHRvIHByZXNlcnZlIGNsZWFuIFVSTHMuIFlvdSBjYW4gZm9yY2UgdGhpc1xuICogYmVoYXZpb3IgdXNpbmcgeyBmb3JjZVJlZnJlc2g6IHRydWUgfSBpbiBvcHRpb25zLlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgdmFyIHVzZVJlZnJlc2ggPSBvcHRpb25zLmZvcmNlUmVmcmVzaCB8fCAhKDAsIF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkpKCk7XG4gIHZhciBQcm90b2NvbCA9IHVzZVJlZnJlc2ggPyBSZWZyZXNoUHJvdG9jb2wgOiBCcm93c2VyUHJvdG9jb2w7XG5cbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gUHJvdG9jb2wuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgcHVzaExvY2F0aW9uID0gUHJvdG9jb2wucHVzaExvY2F0aW9uO1xuICB2YXIgcmVwbGFjZUxvY2F0aW9uID0gUHJvdG9jb2wucmVwbGFjZUxvY2F0aW9uO1xuICB2YXIgZ28gPSBQcm90b2NvbC5nbztcblxuXG4gIHZhciBoaXN0b3J5ID0gKDAsIF9jcmVhdGVIaXN0b3J5Mi5kZWZhdWx0KShfZXh0ZW5kcyh7XG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogZ2V0VXNlckNvbmZpcm1hdGlvbiB9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgcHVzaExvY2F0aW9uOiBwdXNoTG9jYXRpb24sXG4gICAgcmVwbGFjZUxvY2F0aW9uOiByZXBsYWNlTG9jYXRpb24sXG4gICAgZ286IGdvXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wTGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgdmFyIHN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBiZWZvcmUpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wTGlzdGVuZXIgPSBCcm93c2VyUHJvdG9jb2wuc3RhcnRMaXN0ZW5lcihoaXN0b3J5LnRyYW5zaXRpb25Ubyk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBiZWZvcmUgPyBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcikgOiBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcExpc3RlbmVyKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIHRydWUpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH0pO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9IYXNoUHJvdG9jb2wgPSByZXF1aXJlKCcuL0hhc2hQcm90b2NvbCcpO1xuXG52YXIgSGFzaFByb3RvY29sID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0hhc2hQcm90b2NvbCk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBEZWZhdWx0UXVlcnlLZXkgPSAnX2snO1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgdmFyIHF1ZXJ5S2V5ID0gb3B0aW9ucy5xdWVyeUtleTtcblxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHF1ZXJ5S2V5ICE9PSBmYWxzZSwgJ1VzaW5nIHsgcXVlcnlLZXk6IGZhbHNlIH0gbm8gbG9uZ2VyIHdvcmtzLiBJbnN0ZWFkLCBqdXN0IGRvblxcJ3QgJyArICd1c2UgbG9jYXRpb24gc3RhdGUgaWYgeW91IGRvblxcJ3Qgd2FudCBhIGtleSBpbiB5b3VyIFVSTCBxdWVyeSBzdHJpbmcnKSA6IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIHF1ZXJ5S2V5ICE9PSAnc3RyaW5nJykgcXVlcnlLZXkgPSBEZWZhdWx0UXVlcnlLZXk7XG5cbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBIYXNoUHJvdG9jb2wuZ2V0VXNlckNvbmZpcm1hdGlvbjtcblxuXG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIEhhc2hQcm90b2NvbC5nZXRDdXJyZW50TG9jYXRpb24ocXVlcnlLZXkpO1xuICB9O1xuXG4gIHZhciBwdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLnB1c2hMb2NhdGlvbihsb2NhdGlvbiwgcXVlcnlLZXkpO1xuICB9O1xuXG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLnJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbiwgcXVlcnlLZXkpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0gKDAsIF9jcmVhdGVIaXN0b3J5Mi5kZWZhdWx0KShfZXh0ZW5kcyh7XG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogZ2V0VXNlckNvbmZpcm1hdGlvbiB9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgcHVzaExvY2F0aW9uOiBwdXNoTG9jYXRpb24sXG4gICAgcmVwbGFjZUxvY2F0aW9uOiByZXBsYWNlTG9jYXRpb24sXG4gICAgZ286IEhhc2hQcm90b2NvbC5nb1xuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcExpc3RlbmVyID0gdm9pZCAwO1xuXG4gIHZhciBzdGFydExpc3RlbmVyID0gZnVuY3Rpb24gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgYmVmb3JlKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcExpc3RlbmVyID0gSGFzaFByb3RvY29sLnN0YXJ0TGlzdGVuZXIoaGlzdG9yeS50cmFuc2l0aW9uVG8sIHF1ZXJ5S2V5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGJlZm9yZSA/IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKSA6IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgdHJ1ZSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBmYWxzZSk7XG4gIH07XG5cbiAgdmFyIGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCkoKTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKSA6IHZvaWQgMDtcblxuICAgIGhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICByZXR1cm4gJyMnICsgaGlzdG9yeS5jcmVhdGVIcmVmKHBhdGgpO1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIGdvOiBnbyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmXG4gIH0pO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVTdGF0ZVN0b3JhZ2UgPSBmdW5jdGlvbiBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnN0YXRlO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGVudHJ5KSB7XG4gICAgbWVtb1tlbnRyeS5rZXldID0gZW50cnkuc3RhdGU7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn07XG5cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IG9wdGlvbnMgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBbb3B0aW9uc10gfTtcbiAgfVxuXG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tjdXJyZW50XTtcbiAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGVudHJ5KTtcblxuICAgIHZhciBrZXkgPSB2b2lkIDAsXG4gICAgICAgIHN0YXRlID0gdm9pZCAwO1xuICAgIGlmIChlbnRyeS5rZXkpIHtcbiAgICAgIGtleSA9IGVudHJ5LmtleTtcbiAgICAgIHN0YXRlID0gcmVhZFN0YXRlKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXQgPSAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKHBhdGgpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoX2V4dGVuZHMoe30sIGluaXQsIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNhbkdvID0gZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBpbmRleCA9IGN1cnJlbnQgKyBuO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGlmICghbikgcmV0dXJuO1xuXG4gICAgaWYgKCFjYW5HbyhuKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdDYW5ub3QgZ28oJXMpIHRoZXJlIGlzIG5vdCBlbm91Z2ggaGlzdG9yeScsIG4pIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudCArPSBuO1xuICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcblxuICAgIC8vIENoYW5nZSBhY3Rpb24gdG8gUE9QXG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oX2V4dGVuZHMoe30sIGN1cnJlbnRMb2NhdGlvbiwgeyBhY3Rpb246IF9BY3Rpb25zLlBPUCB9KSk7XG4gIH07XG5cbiAgdmFyIHB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIGN1cnJlbnQgKz0gMTtcblxuICAgIGlmIChjdXJyZW50IDwgZW50cmllcy5sZW5ndGgpIGVudHJpZXMuc3BsaWNlKGN1cnJlbnQpO1xuXG4gICAgZW50cmllcy5wdXNoKGxvY2F0aW9uKTtcblxuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgZW50cmllc1tjdXJyZW50XSA9IGxvY2F0aW9uO1xuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9ICgwLCBfY3JlYXRlSGlzdG9yeTIuZGVmYXVsdCkoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBwdXNoTG9jYXRpb246IHB1c2hMb2NhdGlvbixcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcbiAgICBnbzogZ29cbiAgfSkpO1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHZhciBlbnRyaWVzID0gX29wdGlvbnMuZW50cmllcztcbiAgdmFyIGN1cnJlbnQgPSBfb3B0aW9ucy5jdXJyZW50O1xuXG5cbiAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnc3RyaW5nJykge1xuICAgIGVudHJpZXMgPSBbZW50cmllc107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICBlbnRyaWVzID0gWycvJ107XG4gIH1cblxuICBlbnRyaWVzID0gZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoZW50cnkpO1xuICB9KTtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgY3VycmVudCA9IGVudHJpZXMubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIHtcbiAgICAhKGN1cnJlbnQgPj0gMCAmJiBjdXJyZW50IDwgZW50cmllcy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ0N1cnJlbnQgaW5kZXggbXVzdCBiZSA+PSAwIGFuZCA8ICVzLCB3YXMgJXMnLCBlbnRyaWVzLmxlbmd0aCwgY3VycmVudCkgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgdmFyIHN0b3JhZ2UgPSBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcyk7XG5cbiAgdmFyIHNhdmVTdGF0ZSA9IGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XSA9IHN0YXRlO1xuICB9O1xuXG4gIHZhciByZWFkU3RhdGUgPSBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XTtcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5BY3Rpb25zID0gZXhwb3J0cy51c2VRdWVyaWVzID0gZXhwb3J0cy51c2VCZWZvcmVVbmxvYWQgPSBleHBvcnRzLnVzZUJhc2VuYW1lID0gZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gZXhwb3J0cy5jcmVhdGVIYXNoSGlzdG9yeSA9IGV4cG9ydHMuY3JlYXRlSGlzdG9yeSA9IHVuZGVmaW5lZDtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbG9jYXRpb25zQXJlRXF1YWwnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbDtcbiAgfVxufSk7XG5cbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQnJvd3Nlckhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeTIpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5Mik7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gcmVxdWlyZSgnLi91c2VCYXNlbmFtZScpO1xuXG52YXIgX3VzZUJhc2VuYW1lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZUJhc2VuYW1lMik7XG5cbnZhciBfdXNlQmVmb3JlVW5sb2FkMiA9IHJlcXVpcmUoJy4vdXNlQmVmb3JlVW5sb2FkJyk7XG5cbnZhciBfdXNlQmVmb3JlVW5sb2FkMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZUJlZm9yZVVubG9hZDIpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gcmVxdWlyZSgnLi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzMik7XG5cbnZhciBfQWN0aW9uczIgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9BY3Rpb25zMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FjdGlvbnMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5jcmVhdGVIaXN0b3J5ID0gX2NyZWF0ZUJyb3dzZXJIaXN0b3J5Mi5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVIYXNoSGlzdG9yeSA9IF9jcmVhdGVIYXNoSGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IF9jcmVhdGVNZW1vcnlIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy51c2VCYXNlbmFtZSA9IF91c2VCYXNlbmFtZTMuZGVmYXVsdDtcbmV4cG9ydHMudXNlQmVmb3JlVW5sb2FkID0gX3VzZUJlZm9yZVVubG9hZDMuZGVmYXVsdDtcbmV4cG9ydHMudXNlUXVlcmllcyA9IF91c2VRdWVyaWVzMy5kZWZhdWx0O1xuZXhwb3J0cy5BY3Rpb25zID0gX0FjdGlvbnMzLmRlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpc3RvcnkvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdXNlQmFzZW5hbWUgPSBmdW5jdGlvbiB1c2VCYXNlbmFtZShjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcbiAgICB2YXIgYmFzZW5hbWUgPSBvcHRpb25zLmJhc2VuYW1lO1xuXG5cbiAgICB2YXIgYWRkQmFzZW5hbWUgPSBmdW5jdGlvbiBhZGRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgJiYgbG9jYXRpb24uYmFzZW5hbWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlbmFtZSkgPT09IDApIHtcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZyhiYXNlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gYmFzZW5hbWU7XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09ICcnKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9O1xuXG4gICAgdmFyIHByZXBlbmRCYXNlbmFtZSA9IGZ1bmN0aW9uIHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICB2YXIgb2JqZWN0ID0gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkobG9jYXRpb24pIDogbG9jYXRpb247XG4gICAgICB2YXIgcG5hbWUgPSBvYmplY3QucGF0aG5hbWU7XG4gICAgICB2YXIgbm9ybWFsaXplZEJhc2VuYW1lID0gYmFzZW5hbWUuc2xpY2UoLTEpID09PSAnLycgPyBiYXNlbmFtZSA6IGJhc2VuYW1lICsgJy8nO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRQYXRobmFtZSA9IHBuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gcG5hbWUuc2xpY2UoMSkgOiBwbmFtZTtcbiAgICAgIHZhciBwYXRobmFtZSA9IG5vcm1hbGl6ZWRCYXNlbmFtZSArIG5vcm1hbGl6ZWRQYXRobmFtZTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBhZGRCYXNlbmFtZShoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKDAsIF9ydW5UcmFuc2l0aW9uSG9vazIuZGVmYXVsdCkoaG9vaywgYWRkQmFzZW5hbWUobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoYWRkQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucHVzaChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5yZXBsYWNlKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZEJhc2VuYW1lKGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW3ByZXBlbmRCYXNlbmFtZShsb2NhdGlvbildLmNvbmNhdChhcmdzKSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb25cbiAgICB9KTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZUJhc2VuYW1lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGdldFByb21wdE1lc3NhZ2UpIHtcbiAgdmFyIGhhbmRsZUJlZm9yZVVubG9hZCA9IGZ1bmN0aW9uIGhhbmRsZUJlZm9yZVVubG9hZChldmVudCkge1xuICAgIHZhciBtZXNzYWdlID0gZ2V0UHJvbXB0TWVzc2FnZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgKGV2ZW50IHx8IHdpbmRvdy5ldmVudCkucmV0dXJuVmFsdWUgPSBtZXNzYWdlO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgJ2JlZm9yZXVubG9hZCcsIGhhbmRsZUJlZm9yZVVubG9hZCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csICdiZWZvcmV1bmxvYWQnLCBoYW5kbGVCZWZvcmVVbmxvYWQpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNyZWF0ZUhpc3RvcnkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGVcbiAqIGhpc3Rvcnkgb2JqZWN0cyB0aGF0IGtub3cgaG93IHRvIHVzZSB0aGUgYmVmb3JldW5sb2FkIGV2ZW50IGluIHdlYlxuICogYnJvd3NlcnMgdG8gY2FuY2VsIG5hdmlnYXRpb24uXG4gKi9cbnZhciB1c2VCZWZvcmVVbmxvYWQgPSBmdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoY3JlYXRlSGlzdG9yeSkge1xuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICd1c2VCZWZvcmVVbmxvYWQgb25seSB3b3JrcyBpbiBET00gZW52aXJvbm1lbnRzJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICB2YXIgc3RvcExpc3RlbmVyID0gdm9pZCAwO1xuXG4gICAgdmFyIGdldFByb21wdE1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRQcm9tcHRNZXNzYWdlKCkge1xuICAgICAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgbWVzc2FnZSA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICBtZXNzYWdlID0gbGlzdGVuZXJzW2ldLmNhbGwoKTtcbiAgICAgIH1yZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RlbkJlZm9yZVVubG9hZCA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZVVubG9hZChsaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKSA9PT0gMSkgc3RvcExpc3RlbmVyID0gc3RhcnRMaXN0ZW5lcihnZXRQcm9tcHRNZXNzYWdlKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDAgJiYgc3RvcExpc3RlbmVyKSB7XG4gICAgICAgICAgc3RvcExpc3RlbmVyKCk7XG4gICAgICAgICAgc3RvcExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBsaXN0ZW5CZWZvcmVVbmxvYWQ6IGxpc3RlbkJlZm9yZVVubG9hZFxuICAgIH0pO1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlQmVmb3JlVW5sb2FkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi91c2VCZWZvcmVVbmxvYWQuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeS1zdHJpbmcnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0U3RyaW5naWZ5UXVlcnkgPSBmdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuICgwLCBfcXVlcnlTdHJpbmcuc3RyaW5naWZ5KShxdWVyeSkucmVwbGFjZSgvJTIwL2csICcrJyk7XG59O1xuXG52YXIgZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcucGFyc2U7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byBoYW5kbGUgVVJMIHF1ZXJpZXMuXG4gKi9cbnZhciB1c2VRdWVyaWVzID0gZnVuY3Rpb24gdXNlUXVlcmllcyhjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBvcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gb3B0aW9ucy5wYXJzZVF1ZXJ5U3RyaW5nO1xuXG5cbiAgICBpZiAodHlwZW9mIHN0cmluZ2lmeVF1ZXJ5ICE9PSAnZnVuY3Rpb24nKSBzdHJpbmdpZnlRdWVyeSA9IGRlZmF1bHRTdHJpbmdpZnlRdWVyeTtcblxuICAgIGlmICh0eXBlb2YgcGFyc2VRdWVyeVN0cmluZyAhPT0gJ2Z1bmN0aW9uJykgcGFyc2VRdWVyeVN0cmluZyA9IGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgdmFyIGRlY29kZVF1ZXJ5ID0gZnVuY3Rpb24gZGVjb2RlUXVlcnkobG9jYXRpb24pIHtcbiAgICAgIGlmICghbG9jYXRpb24pIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5ID09IG51bGwpIGxvY2F0aW9uLnF1ZXJ5ID0gcGFyc2VRdWVyeVN0cmluZyhsb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH07XG5cbiAgICB2YXIgZW5jb2RlUXVlcnkgPSBmdW5jdGlvbiBlbmNvZGVRdWVyeShsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIGlmIChxdWVyeSA9PSBudWxsKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIHZhciBvYmplY3QgPSB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShsb2NhdGlvbikgOiBsb2NhdGlvbjtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIHZhciBzZWFyY2ggPSBxdWVyeVN0cmluZyA/ICc/JyArIHF1ZXJ5U3RyaW5nIDogJyc7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgb2JqZWN0LCB7XG4gICAgICAgIHNlYXJjaDogc2VhcmNoXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZGVjb2RlUXVlcnkoaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGhvb2ssIGRlY29kZVF1ZXJ5KGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGRlY29kZVF1ZXJ5KGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LnB1c2goZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucmVwbGFjZShlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdMb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW2VuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSldLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgIGlmIChsb2NhdGlvbi5xdWVyeSkgbmV3TG9jYXRpb24ucXVlcnkgPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlUXVlcnkpKGxvY2F0aW9uLnF1ZXJ5KTtcblxuICAgICAgcmV0dXJuIGRlY29kZVF1ZXJ5KG5ld0xvY2F0aW9uKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uXG4gICAgfSk7XG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VRdWVyaWVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjQgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggYWRkZWQgc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmdcbiAqIGZsYXR0ZW5pbmcgYW5kIHNwZWNpZnlpbmcgdGhlIHN0YXJ0IGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgZmxhdHRlbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cy1saWtlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXAsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgIChpc1N0cmljdCB8fCBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBpc0RlZXAsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fYmFzZWZsYXR0ZW4vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjAuMyAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JJbmAgYW5kIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlc1xuICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3JcbiAqIGVhY2ggcHJvcGVydHkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseVxuICogcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fYmFzZWZvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMS4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgTmFOYCBpcyBmb3VuZCBpbiBgYXJyYXlgLlxuICogSWYgYGZyb21SaWdodGAgaXMgcHJvdmlkZWQgZWxlbWVudHMgb2YgYGFycmF5YCBhcmUgaXRlcmF0ZWQgZnJvbSByaWdodCB0byBsZWZ0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIGBOYU5gLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAwIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChvdGhlciAhPT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fYmFzZWluZGV4b2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjAuMyAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlaW5kZXhvZicpLFxuICAgIGNhY2hlSW5kZXhPZiA9IHJlcXVpcmUoJ2xvZGFzaC5fY2FjaGVpbmRleG9mJyksXG4gICAgY3JlYXRlQ2FjaGUgPSByZXF1aXJlKCdsb2Rhc2guX2NyZWF0ZWNhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluZGV4T2YgPSBiYXNlSW5kZXhPZixcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGlzTGFyZ2UgPSBpc0NvbW1vbiAmJiBsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSxcbiAgICAgIHNlZW4gPSBpc0xhcmdlID8gY3JlYXRlQ2FjaGUoKSA6IG51bGwsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBpZiAoc2Vlbikge1xuICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgMCkgPCAwKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUgfHwgaXNMYXJnZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fYmFzZXVuaXEvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUNhbGxiYWNrYCB3aGljaCBvbmx5IHN1cHBvcnRzIGB0aGlzYCBiaW5kaW5nXG4gKiBhbmQgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHRoaXNBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG4gIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZENhbGxiYWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fYmluZGNhbGxiYWNrL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY2FjaGVgIG1pbWlja2luZyB0aGUgcmV0dXJuIHNpZ25hdHVyZSBvZlxuICogYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gY2FjaGUuZGF0YSxcbiAgICAgIHJlc3VsdCA9ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSA/IGRhdGEuc2V0Lmhhcyh2YWx1ZSkgOiBkYXRhLmhhc2hbdmFsdWVdO1xuXG4gIHJldHVybiByZXN1bHQgPyAwIDogLTE7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC5fY2FjaGVpbmRleG9mL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBnZXROYXRpdmUgPSByZXF1aXJlKCdsb2Rhc2guX2dldG5hdGl2ZScpO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShnbG9iYWwsICdTZXQnKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmRhdGEgPSB7ICdoYXNoJzogbmF0aXZlQ3JlYXRlKG51bGwpLCAnc2V0JzogbmV3IFNldCB9O1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB0aGlzLnB1c2godmFsdWVzW2xlbmd0aF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgcHVzaFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gY2FjaGVQdXNoKHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGRhdGEuc2V0LmFkZCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5oYXNoW3ZhbHVlXSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYFNldGAgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIG5ldyBjYWNoZSBvYmplY3QgaWYgYFNldGAgaXMgc3VwcG9ydGVkLCBlbHNlIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUodmFsdWVzKSB7XG4gIHJldHVybiAobmF0aXZlQ3JlYXRlICYmIFNldCkgPyBuZXcgU2V0Q2FjaGUodmFsdWVzKSA6IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBTZXRgIGNhY2hlLlxuU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBjYWNoZVB1c2g7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLl9jcmVhdGVjYWNoZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMi4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciByb290ID0gcmVxdWlyZSgnbG9kYXNoLl9yb290Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluMSA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZVxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyMycsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGYwJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyAnXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKiBVc2VkIHRvIG1hcCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzLiAqL1xudmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNDJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVDJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xuZnVuY3Rpb24gZGVidXJyTGV0dGVyKGxldHRlcikge1xuICByZXR1cm4gZGVidXJyZWRMZXR0ZXJzW2xldHRlcl07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBTeW1ib2wgPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IG9uZS4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBmb3IgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gU3ltYm9sID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nIFtsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVyc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gKiB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZyBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbjEsIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVycjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2guZGVidXJyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGRlYnVyciA9IHJlcXVpcmUoJ2xvZGFzaC5kZWJ1cnInKSxcbiAgICB3b3JkcyA9IHJlcXVpcmUoJ2xvZGFzaC53b3JkcycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpKSwgY2FsbGJhY2ssICcnKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnX19mb29fYmFyX18nKTtcbiAqIC8vID0+ICdmb28tYmFyJ1xuICovXG52YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZWJhYkNhc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLmtlYmFiY2FzZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9nZXRuYXRpdmUnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICB9XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLmtleXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjYuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gKiB9KTtcbiAqXG4gKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdFtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgcmVzdCk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgfVxuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIGluZGV4ID0gLTE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc3RQYXJhbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gucmVzdHBhcmFtL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWZsYXR0ZW4nKSxcbiAgICBiYXNlVW5pcSA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZXVuaXEnKSxcbiAgICByZXN0UGFyYW0gPSByZXF1aXJlKCdsb2Rhc2gucmVzdHBhcmFtJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICogYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlvbihbMSwgMl0sIFs0LCAyXSwgWzIsIDFdKTtcbiAqIC8vID0+IFsxLCAyLCA0XVxuICovXG52YXIgdW5pb24gPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIGZhbHNlLCB0cnVlKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gudW5pb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAzLjIuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgcm9vdCA9IHJlcXVpcmUoJ2xvZGFzaC5fcm9vdCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdWZlMjAtXFxcXHVmZTIzJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZjAnLFxuICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICByc1F1b3RlUmFuZ2UgPSAnXFxcXHUyMDE4XFxcXHUyMDE5XFxcXHUyMDFjXFxcXHUyMDFkJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1F1b3RlUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc0xvd2VyTWlzYyA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc1VwcGVyTWlzYyA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbm9uLWNvbXBvdW5kIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlQmFzaWNXb3JkID0gL1thLXpBLVowLTldKy9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xudmFyIHJlQ29tcGxleFdvcmQgPSBSZWdFeHAoW1xuICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlck1pc2MgKyAnKyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTG93ZXJNaXNjLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXJNaXNjICsgJysnLFxuICByc1VwcGVyICsgJysnLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbnZhciByZUhhc0NvbXBsZXhXb3JkID0gL1thLXpdW0EtWl18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gU3ltYm9sID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCdzIG5vdCBvbmUuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICogZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIFN5bWJvbCA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHBhdHRlcm4gPSByZUhhc0NvbXBsZXhXb3JkLnRlc3Qoc3RyaW5nKSA/IHJlQ29tcGxleFdvcmQgOiByZUJhc2ljV29yZDtcbiAgfVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdvcmRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC53b3Jkcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gZW5jb2RlckZvckFycmF5Rm9ybWF0KG9wdHMpIHtcblx0c3dpdGNoIChvcHRzLmFycmF5Rm9ybWF0KSB7XG5cdFx0Y2FzZSAnaW5kZXgnOlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgPyBbXG5cdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG5cdFx0XHRcdFx0J1snLFxuXHRcdFx0XHRcdGluZGV4LFxuXHRcdFx0XHRcdCddJ1xuXHRcdFx0XHRdLmpvaW4oJycpIDogW1xuXHRcdFx0XHRcdGVuY29kZShrZXksIG9wdHMpLFxuXHRcdFx0XHRcdCdbJyxcblx0XHRcdFx0XHRlbmNvZGUoaW5kZXgsIG9wdHMpLFxuXHRcdFx0XHRcdCddPScsXG5cdFx0XHRcdFx0ZW5jb2RlKHZhbHVlLCBvcHRzKVxuXHRcdFx0XHRdLmpvaW4oJycpO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2JyYWNrZXQnOlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IGVuY29kZShrZXksIG9wdHMpIDogW1xuXHRcdFx0XHRcdGVuY29kZShrZXksIG9wdHMpLFxuXHRcdFx0XHRcdCdbXT0nLFxuXHRcdFx0XHRcdGVuY29kZSh2YWx1ZSwgb3B0cylcblx0XHRcdFx0XS5qb2luKCcnKTtcblx0XHRcdH07XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IGVuY29kZShrZXksIG9wdHMpIDogW1xuXHRcdFx0XHRcdGVuY29kZShrZXksIG9wdHMpLFxuXHRcdFx0XHRcdCc9Jyxcblx0XHRcdFx0XHRlbmNvZGUodmFsdWUsIG9wdHMpXG5cdFx0XHRcdF0uam9pbignJyk7XG5cdFx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHBhcnNlckZvckFycmF5Rm9ybWF0KG9wdHMpIHtcblx0dmFyIHJlc3VsdDtcblxuXHRzd2l0Y2ggKG9wdHMuYXJyYXlGb3JtYXQpIHtcblx0XHRjYXNlICdpbmRleCc6XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSB7XG5cdFx0XHRcdHJlc3VsdCA9IC9cXFsoXFxkKildJC8uZXhlYyhrZXkpO1xuXG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtcXGQqXSQvLCAnJyk7XG5cblx0XHRcdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV1bcmVzdWx0WzFdXSA9IHZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2JyYWNrZXQnOlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikge1xuXHRcdFx0XHRyZXN1bHQgPSAvKFxcW10pJC8uZXhlYyhrZXkpO1xuXG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtdJC8sICcnKTtcblxuXHRcdFx0XHRpZiAoIXJlc3VsdCB8fCBhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpIHtcblx0XHRcdFx0aWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW10uY29uY2F0KGFjY3VtdWxhdG9yW2tleV0sIHZhbHVlKTtcblx0XHRcdH07XG5cdH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBvcHRzKSB7XG5cdGlmIChvcHRzLmVuY29kZSkge1xuXHRcdHJldHVybiBvcHRzLnN0cmljdCA/IHN0cmljdFVyaUVuY29kZSh2YWx1ZSkgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBrZXlzU29ydGVyKGlucHV0KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdHJldHVybiBpbnB1dC5zb3J0KCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBrZXlzU29ydGVyKE9iamVjdC5rZXlzKGlucHV0KSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcblx0XHR9KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuIGlucHV0W2tleV07XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gaW5wdXQ7XG59XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5zcGxpdCgnPycpWzFdIHx8ICcnO1xufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcblx0b3B0cyA9IG9iamVjdEFzc2lnbih7YXJyYXlGb3JtYXQ6ICdub25lJ30sIG9wdHMpO1xuXG5cdHZhciBmb3JtYXR0ZXIgPSBwYXJzZXJGb3JBcnJheUZvcm1hdChvcHRzKTtcblxuXHQvLyBDcmVhdGUgYW4gb2JqZWN0IHdpdGggbm8gcHJvdG90eXBlXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nL2lzc3Vlcy80N1xuXHR2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0c3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG5cdGlmICghc3RyKSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdHN0ci5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG5cdFx0dmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcblx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuXHRcdHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkO1xuXG5cdFx0Ly8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cblx0XHRmb3JtYXR0ZXIoZGVjb2RlVVJJQ29tcG9uZW50KGtleSksIHZhbCwgcmV0KTtcblx0fSk7XG5cblx0cmV0dXJuIE9iamVjdC5rZXlzKHJldCkuc29ydCgpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcblx0XHR2YXIgdmFsID0gcmV0W2tleV07XG5cdFx0aWYgKEJvb2xlYW4odmFsKSAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHQvLyBTb3J0IG9iamVjdCBrZXlzLCBub3QgdmFsdWVzXG5cdFx0XHRyZXN1bHRba2V5XSA9IGtleXNTb3J0ZXIodmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0W2tleV0gPSB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcblx0dmFyIGRlZmF1bHRzID0ge1xuXHRcdGVuY29kZTogdHJ1ZSxcblx0XHRzdHJpY3Q6IHRydWUsXG5cdFx0YXJyYXlGb3JtYXQ6ICdub25lJ1xuXHR9O1xuXG5cdG9wdHMgPSBvYmplY3RBc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuXG5cdHZhciBmb3JtYXR0ZXIgPSBlbmNvZGVyRm9yQXJyYXlGb3JtYXQob3B0cyk7XG5cblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdHMpO1xuXHRcdH1cblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdFx0dmFsLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuXHRcdFx0XHRpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0LnB1c2goZm9ybWF0dGVyKGtleSwgdmFsMiwgcmVzdWx0Lmxlbmd0aCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRzKSArICc9JyArIGVuY29kZSh2YWwsIG9wdHMpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuXHR9KS5qb2luKCcmJykgOiAnJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnktc3RyaW5nL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xhc3NOYW1lRnJvbVZOb2RlO1xuXG52YXIgX3NlbGVjdG9yUGFyc2VyMiA9IHJlcXVpcmUoJy4vc2VsZWN0b3JQYXJzZXInKTtcblxudmFyIF9zZWxlY3RvclBhcnNlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZWxlY3RvclBhcnNlcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjbGFzc05hbWVGcm9tVk5vZGUodk5vZGUpIHtcbiAgdmFyIF9zZWxlY3RvclBhcnNlciA9ICgwLCBfc2VsZWN0b3JQYXJzZXIzLmRlZmF1bHQpKHZOb2RlLnNlbCk7XG5cbiAgdmFyIGNuID0gX3NlbGVjdG9yUGFyc2VyLmNsYXNzTmFtZTtcblxuXG4gIGlmICghdk5vZGUuZGF0YSkge1xuICAgIHJldHVybiBjbjtcbiAgfVxuXG4gIHZhciBfdk5vZGUkZGF0YSA9IHZOb2RlLmRhdGE7XG4gIHZhciBkYXRhQ2xhc3MgPSBfdk5vZGUkZGF0YS5jbGFzcztcbiAgdmFyIHByb3BzID0gX3ZOb2RlJGRhdGEucHJvcHM7XG5cblxuICBpZiAoZGF0YUNsYXNzKSB7XG4gICAgdmFyIGMgPSBPYmplY3Qua2V5cyh2Tm9kZS5kYXRhLmNsYXNzKS5maWx0ZXIoZnVuY3Rpb24gKGNsKSB7XG4gICAgICByZXR1cm4gdk5vZGUuZGF0YS5jbGFzc1tjbF07XG4gICAgfSk7XG4gICAgY24gKz0gJyAnICsgYy5qb2luKCcgJyk7XG4gIH1cblxuICBpZiAocHJvcHMgJiYgcHJvcHMuY2xhc3NOYW1lKSB7XG4gICAgY24gKz0gJyAnICsgcHJvcHMuY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIGNuLnRyaW0oKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tc2VsZWN0b3IvbGliL2NsYXNzTmFtZUZyb21WTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gQWxsIFNWRyBjaGlsZHJlbiBlbGVtZW50cywgbm90IGluIHRoaXMgbGlzdCwgc2hvdWxkIHNlbGYtY2xvc2VcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9pbnRyby5odG1sI1Rlcm1Db250YWluZXJFbGVtZW50XG4gICdhJzogdHJ1ZSxcbiAgJ2RlZnMnOiB0cnVlLFxuICAnZ2x5cGgnOiB0cnVlLFxuICAnZyc6IHRydWUsXG4gICdtYXJrZXInOiB0cnVlLFxuICAnbWFzayc6IHRydWUsXG4gICdtaXNzaW5nLWdseXBoJzogdHJ1ZSxcbiAgJ3BhdHRlcm4nOiB0cnVlLFxuICAnc3ZnJzogdHJ1ZSxcbiAgJ3N3aXRjaCc6IHRydWUsXG4gICdzeW1ib2wnOiB0cnVlLFxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9pbnRyby5odG1sI1Rlcm1EZXNjcmlwdGl2ZUVsZW1lbnRcbiAgJ2Rlc2MnOiB0cnVlLFxuICAnbWV0YWRhdGEnOiB0cnVlLFxuICAndGl0bGUnOiB0cnVlXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9jb250YWluZXItZWxlbWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBpbml0ID0gcmVxdWlyZSgnLi9pbml0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdChbcmVxdWlyZSgnLi9tb2R1bGVzL2F0dHJpYnV0ZXMnKSwgcmVxdWlyZSgnLi9tb2R1bGVzL3N0eWxlJyldKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tdG8taHRtbC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBwYXJzZVNlbGVjdG9yID0gcmVxdWlyZSgnLi9wYXJzZS1zZWxlY3RvcicpO1xudmFyIFZPSURfRUxFTUVOVFMgPSByZXF1aXJlKCcuL3ZvaWQtZWxlbWVudHMnKTtcbnZhciBDT05UQUlORVJfRUxFTUVOVFMgPSByZXF1aXJlKCcuL2NvbnRhaW5lci1lbGVtZW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaXQobW9kdWxlcykge1xuICBmdW5jdGlvbiBwYXJzZShkYXRhKSB7XG4gICAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICBhcnIucHVzaChmbihkYXRhKSk7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sIFtdKS5maWx0ZXIoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gJyc7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLnNlbCAmJiB2bm9kZS50ZXh0KSB7XG4gICAgICByZXR1cm4gdm5vZGUudGV4dDtcbiAgICB9XG5cbiAgICB2bm9kZS5kYXRhID0gdm5vZGUuZGF0YSB8fCB7fTtcblxuICAgIC8vIFN1cHBvcnQgdGh1bmtzXG4gICAgaWYgKHR5cGVvZiB2bm9kZS5zZWwgPT09ICdzdHJpbmcnICYmIHZub2RlLnNlbC5zbGljZSgwLCA1KSA9PT0gJ3RodW5rJykge1xuICAgICAgdm5vZGUgPSB2bm9kZS5kYXRhLmZuLmFwcGx5KG51bGwsIHZub2RlLmRhdGEuYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIHRhZ05hbWUgPSBwYXJzZVNlbGVjdG9yKHZub2RlLnNlbCkudGFnTmFtZTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHBhcnNlKHZub2RlKTtcbiAgICB2YXIgc3ZnID0gdm5vZGUuZGF0YS5ucyA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICB2YXIgdGFnID0gW107XG5cbiAgICAvLyBPcGVuIHRhZ1xuICAgIHRhZy5wdXNoKCc8JyArIHRhZ05hbWUpO1xuICAgIGlmIChhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgdGFnLnB1c2goJyAnICsgYXR0cmlidXRlcy5qb2luKCcgJykpO1xuICAgIH1cbiAgICBpZiAoc3ZnICYmIENPTlRBSU5FUl9FTEVNRU5UU1t0YWdOYW1lXSAhPT0gdHJ1ZSkge1xuICAgICAgdGFnLnB1c2goJyAvJyk7XG4gICAgfVxuICAgIHRhZy5wdXNoKCc+Jyk7XG5cbiAgICAvLyBDbG9zZSB0YWcsIGlmIG5lZWRlZFxuICAgIGlmIChWT0lEX0VMRU1FTlRTW3RhZ05hbWVdICE9PSB0cnVlICYmICFzdmcgfHwgc3ZnICYmIENPTlRBSU5FUl9FTEVNRU5UU1t0YWdOYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHZub2RlLmRhdGEucHJvcHMgJiYgdm5vZGUuZGF0YS5wcm9wcy5pbm5lckhUTUwpIHtcbiAgICAgICAgdGFnLnB1c2godm5vZGUuZGF0YS5wcm9wcy5pbm5lckhUTUwpO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS50ZXh0KSB7XG4gICAgICAgIHRhZy5wdXNoKHZub2RlLnRleHQpO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIHRhZy5wdXNoKHJlbmRlclRvU3RyaW5nKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGFnLnB1c2goJzwvJyArIHRhZ05hbWUgKyAnPicpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWcuam9pbignJyk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9pbml0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgZm9yT3duID0gcmVxdWlyZSgnbG9kYXNoLmZvcm93bicpO1xudmFyIGVzY2FwZSA9IHJlcXVpcmUoJ2xvZGFzaC5lc2NhcGUnKTtcbnZhciB1bmlvbiA9IHJlcXVpcmUoJ2xvZGFzaC51bmlvbicpO1xuXG52YXIgcGFyc2VTZWxlY3RvciA9IHJlcXVpcmUoJy4uL3BhcnNlLXNlbGVjdG9yJyk7XG5cbi8vIGRhdGEuYXR0cnMsIGRhdGEucHJvcHMsIGRhdGEuY2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdHRyaWJ1dGVzKHZub2RlKSB7XG4gIHZhciBzZWxlY3RvciA9IHBhcnNlU2VsZWN0b3Iodm5vZGUuc2VsKTtcbiAgdmFyIHBhcnNlZENsYXNzZXMgPSBzZWxlY3Rvci5jbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICB2YXIgY2xhc3NlcyA9IFtdO1xuICB2YXIgdmFsdWVzID0ge307XG5cbiAgaWYgKHNlbGVjdG9yLmlkKSB7XG4gICAgdmFsdWVzLmlkID0gc2VsZWN0b3IuaWQ7XG4gIH1cblxuICBzZXRBdHRyaWJ1dGVzKHZub2RlLmRhdGEucHJvcHMsIHZhbHVlcyk7XG4gIHNldEF0dHJpYnV0ZXModm5vZGUuZGF0YS5hdHRycywgdmFsdWVzKTsgLy8gYGF0dHJzYCBvdmVycmlkZSBgcHJvcHNgLCBub3Qgc3VyZSBpZiB0aGlzIGlzIGdvb2Qgc29cblxuICBpZiAodm5vZGUuZGF0YS5jbGFzcykge1xuICAgIC8vIE9taXQgYGNsYXNzTmFtZWAgYXR0cmlidXRlIGlmIGBjbGFzc2AgaXMgc2V0IG9uIHZub2RlXG4gICAgdmFsdWVzLmNsYXNzID0gdW5kZWZpbmVkO1xuICB9XG4gIGZvck93bih2bm9kZS5kYXRhLmNsYXNzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgY2xhc3Nlcy5wdXNoKGtleSk7XG4gICAgfVxuICB9KTtcbiAgY2xhc3NlcyA9IHVuaW9uKGNsYXNzZXMsIHZhbHVlcy5jbGFzcywgcGFyc2VkQ2xhc3NlcykuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggIT09ICcnO1xuICB9KTtcblxuICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICB2YWx1ZXMuY2xhc3MgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGZvck93bih2YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgYXR0cmlidXRlcy5wdXNoKHZhbHVlID09PSB0cnVlID8ga2V5IDoga2V5ICsgJz1cIicgKyBlc2NhcGUodmFsdWUpICsgJ1wiJyk7XG4gIH0pO1xuXG4gIHJldHVybiBhdHRyaWJ1dGVzLmxlbmd0aCA/IGF0dHJpYnV0ZXMuam9pbignICcpIDogJyc7XG59O1xuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKHZhbHVlcywgdGFyZ2V0KSB7XG4gIGZvck93bih2YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ2h0bWxGb3InKSB7XG4gICAgICB0YXJnZXRbJ2ZvciddID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICdjbGFzc05hbWUnKSB7XG4gICAgICB0YXJnZXRbJ2NsYXNzJ10gPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tdG8taHRtbC9saWIvbW9kdWxlcy9hdHRyaWJ1dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIGZvck93biA9IHJlcXVpcmUoJ2xvZGFzaC5mb3Jvd24nKTtcbnZhciBlc2NhcGUgPSByZXF1aXJlKCdsb2Rhc2guZXNjYXBlJyk7XG52YXIga2ViYWJDYXNlID0gcmVxdWlyZSgnbG9kYXNoLmtlYmFiY2FzZScpO1xuXG4vLyBkYXRhLnN0eWxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3R5bGUodm5vZGUpIHtcbiAgdmFyIHN0eWxlcyA9IFtdO1xuICB2YXIgc3R5bGUgPSB2bm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIG1lcmdlIGluIGBkZWxheWVkYCBwcm9wZXJ0aWVzXG4gIGlmIChzdHlsZS5kZWxheWVkKSB7XG4gICAgX2V4dGVuZHMoc3R5bGUsIHN0eWxlLmRlbGF5ZWQpO1xuICB9XG5cbiAgZm9yT3duKHN0eWxlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIC8vIG9taXQgaG9vayBvYmplY3RzXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN0eWxlcy5wdXNoKGtlYmFiQ2FzZShrZXkpICsgJzogJyArIGVzY2FwZSh2YWx1ZSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHN0eWxlcy5sZW5ndGggPyAnc3R5bGU9XCInICsgc3R5bGVzLmpvaW4oJzsgJykgKyAnXCInIDogJyc7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS10by1odG1sL2xpYi9tb2R1bGVzL3N0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBodHRwOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9zeW50YXguaHRtbCN2b2lkLWVsZW1lbnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20tdG8taHRtbC9saWIvdm9pZC1lbGVtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBWTm9kZSA9IHJlcXVpcmUoJy4vdm5vZGUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuZnVuY3Rpb24gYWRkTlMoZGF0YSwgY2hpbGRyZW4pIHtcbiAgZGF0YS5ucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgYWRkTlMoY2hpbGRyZW5baV0uZGF0YSwgY2hpbGRyZW5baV0uY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGgoc2VsLCBiLCBjKSB7XG4gIHZhciBkYXRhID0ge30sIGNoaWxkcmVuLCB0ZXh0LCBpO1xuICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0YSA9IGI7XG4gICAgaWYgKGlzLmFycmF5KGMpKSB7IGNoaWxkcmVuID0gYzsgfVxuICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShjKSkgeyB0ZXh0ID0gYzsgfVxuICB9IGVsc2UgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpcy5hcnJheShiKSkgeyBjaGlsZHJlbiA9IGI7IH1cbiAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYikpIHsgdGV4dCA9IGI7IH1cbiAgICBlbHNlIHsgZGF0YSA9IGI7IH1cbiAgfVxuICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaXMucHJpbWl0aXZlKGNoaWxkcmVuW2ldKSkgY2hpbGRyZW5baV0gPSBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIGlmIChzZWxbMF0gPT09ICdzJyAmJiBzZWxbMV0gPT09ICd2JyAmJiBzZWxbMl0gPT09ICdnJykge1xuICAgIGFkZE5TKGRhdGEsIGNoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gVk5vZGUoc2VsLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgdW5kZWZpbmVkKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vaC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSl7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKXtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KXtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuXG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKXtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpe1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpe1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZShub2RlKXtcbiAgcmV0dXJuIG5vZGUucGFyZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSl7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lKG5vZGUpe1xuICByZXR1cm4gbm9kZS50YWdOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KXtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL2h0bWxkb21hcGkuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYm9vbGVhbkF0dHJzID0gW1wiYWxsb3dmdWxsc2NyZWVuXCIsIFwiYXN5bmNcIiwgXCJhdXRvZm9jdXNcIiwgXCJhdXRvcGxheVwiLCBcImNoZWNrZWRcIiwgXCJjb21wYWN0XCIsIFwiY29udHJvbHNcIiwgXCJkZWNsYXJlXCIsIFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiLCBcImRlZmF1bHRjaGVja2VkXCIsIFwiZGVmYXVsdG11dGVkXCIsIFwiZGVmYXVsdHNlbGVjdGVkXCIsIFwiZGVmZXJcIiwgXCJkaXNhYmxlZFwiLCBcImRyYWdnYWJsZVwiLCBcbiAgICAgICAgICAgICAgICBcImVuYWJsZWRcIiwgXCJmb3Jtbm92YWxpZGF0ZVwiLCBcImhpZGRlblwiLCBcImluZGV0ZXJtaW5hdGVcIiwgXCJpbmVydFwiLCBcImlzbWFwXCIsIFwiaXRlbXNjb3BlXCIsIFwibG9vcFwiLCBcIm11bHRpcGxlXCIsIFxuICAgICAgICAgICAgICAgIFwibXV0ZWRcIiwgXCJub2hyZWZcIiwgXCJub3Jlc2l6ZVwiLCBcIm5vc2hhZGVcIiwgXCJub3ZhbGlkYXRlXCIsIFwibm93cmFwXCIsIFwib3BlblwiLCBcInBhdXNlb25leGl0XCIsIFwicmVhZG9ubHlcIiwgXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiLCBcInJldmVyc2VkXCIsIFwic2NvcGVkXCIsIFwic2VhbWxlc3NcIiwgXCJzZWxlY3RlZFwiLCBcInNvcnRhYmxlXCIsIFwic3BlbGxjaGVja1wiLCBcInRyYW5zbGF0ZVwiLCBcbiAgICAgICAgICAgICAgICBcInRydWVzcGVlZFwiLCBcInR5cGVtdXN0bWF0Y2hcIiwgXCJ2aXNpYmxlXCJdO1xuICAgIFxudmFyIGJvb2xlYW5BdHRyc0RpY3QgPSB7fTtcbmZvcih2YXIgaT0wLCBsZW4gPSBib29sZWFuQXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgYm9vbGVhbkF0dHJzRGljdFtib29sZWFuQXR0cnNbaV1dID0gdHJ1ZTtcbn1cbiAgICBcbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIga2V5LCBjdXIsIG9sZCwgZWxtID0gdm5vZGUuZWxtLFxuICAgICAgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9LCBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIFxuICAvLyB1cGRhdGUgbW9kaWZpZWQgYXR0cmlidXRlcywgYWRkIG5ldyBhdHRyaWJ1dGVzXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgdG8gbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIChzZXRBdHRyaWJ1dGVOUylcbiAgICAgIGlmKCFjdXIgJiYgYm9vbGVhbkF0dHJzRGljdFtrZXldKVxuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICBlbHNlXG4gICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoa2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvL3JlbW92ZSByZW1vdmVkIGF0dHJpYnV0ZXNcbiAgLy8gdXNlIGBpbmAgb3BlcmF0b3Igc2luY2UgdGhlIHByZXZpb3VzIGBmb3JgIGl0ZXJhdGlvbiB1c2VzIGl0ICguaS5lLiBhZGQgZXZlbiBhdHRyaWJ1dGVzIHdpdGggdW5kZWZpbmVkIHZhbHVlKVxuICAvLyB0aGUgb3RoZXIgb3B0aW9uIGlzIHRvIHJlbW92ZSBhbGwgYXR0cmlidXRlcyB3aXRoIHZhbHVlID09IHVuZGVmaW5lZFxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmICghKGtleSBpbiBhdHRycykpIHtcbiAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVBdHRycywgdXBkYXRlOiB1cGRhdGVBdHRyc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vbW9kdWxlcy9hdHRyaWJ1dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gdXBkYXRlQ2xhc3Mob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZENsYXNzID0gb2xkVm5vZGUuZGF0YS5jbGFzcyB8fCB7fSxcbiAgICAgIGtsYXNzID0gdm5vZGUuZGF0YS5jbGFzcyB8fCB7fTtcbiAgZm9yIChuYW1lIGluIG9sZENsYXNzKSB7XG4gICAgaWYgKCFrbGFzc1tuYW1lXSkge1xuICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBrbGFzcykge1xuICAgIGN1ciA9IGtsYXNzW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZENsYXNzW25hbWVdKSB7XG4gICAgICBlbG0uY2xhc3NMaXN0W2N1ciA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtjcmVhdGU6IHVwZGF0ZUNsYXNzLCB1cGRhdGU6IHVwZGF0ZUNsYXNzfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9tb2R1bGVzL2NsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcblxuZnVuY3Rpb24gYXJySW52b2tlcihhcnIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuO1xuICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGxlbmd0aCBpcyB0d28sIGZvciBwZXJmb3JtYW5jZVxuICAgIGFyci5sZW5ndGggPT09IDIgPyBhcnJbMF0oYXJyWzFdKSA6IGFyclswXS5hcHBseSh1bmRlZmluZWQsIGFyci5zbGljZSgxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZuSW52b2tlcihvKSB7XG4gIHJldHVybiBmdW5jdGlvbihldikgeyBcbiAgICBpZiAoby5mbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIG8uZm4oZXYpOyBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRXZlbnRMaXN0ZW5lcnMob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZWxtID0gdm5vZGUuZWxtLFxuICAgICAgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9LCBvbiA9IHZub2RlLmRhdGEub247XG4gIGlmICghb24pIHJldHVybjtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgaWYgKG9sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaXMuYXJyYXkoY3VyKSkge1xuICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBhcnJJbnZva2VyKGN1cikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyID0ge2ZuOiBjdXJ9O1xuICAgICAgICBvbltuYW1lXSA9IGN1cjtcbiAgICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZm5JbnZva2VyKGN1cikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXMuYXJyYXkob2xkKSkge1xuICAgICAgLy8gRGVsaWJlcmF0ZWx5IG1vZGlmeSBvbGQgYXJyYXkgc2luY2UgaXQncyBjYXB0dXJlZCBpbiBjbG9zdXJlIGNyZWF0ZWQgd2l0aCBgYXJySW52b2tlcmBcbiAgICAgIG9sZC5sZW5ndGggPSBjdXIubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIG9sZFtpXSA9IGN1cltpXTtcbiAgICAgIG9uW25hbWVdICA9IG9sZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkLmZuID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGlmIChvbGRPbikge1xuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgaWYgKG9uW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgICAgICBpZiAoaXMuYXJyYXkob2xkKSkge1xuICAgICAgICAgIG9sZC5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9sZC5mbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVFdmVudExpc3RlbmVycywgdXBkYXRlOiB1cGRhdGVFdmVudExpc3RlbmVyc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vbW9kdWxlcy9ldmVudGxpc3RlbmVycy5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByYWYgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgc2V0VGltZW91dDtcbnZhciBuZXh0RnJhbWUgPSBmdW5jdGlvbihmbikgeyByYWYoZnVuY3Rpb24oKSB7IHJhZihmbik7IH0pOyB9O1xuXG5mdW5jdGlvbiBzZXROZXh0RnJhbWUob2JqLCBwcm9wLCB2YWwpIHtcbiAgbmV4dEZyYW1lKGZ1bmN0aW9uKCkgeyBvYmpbcHJvcF0gPSB2YWw7IH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0Tm9kZVJlY3QodGV4dE5vZGUpIHtcbiAgdmFyIHJlY3Q7XG4gIGlmIChkb2N1bWVudC5jcmVhdGVSYW5nZSkge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRleHROb2RlKTtcbiAgICBpZiAocmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgIHJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGNhbGNUcmFuc2Zvcm1PcmlnaW4oaXNUZXh0Tm9kZSwgdGV4dFJlY3QsIGJvdW5kaW5nUmVjdCkge1xuICBpZiAoaXNUZXh0Tm9kZSkge1xuICAgIGlmICh0ZXh0UmVjdCkge1xuICAgICAgLy9jYWxjdWxhdGUgcGl4ZWxzIHRvIGNlbnRlciBvZiB0ZXh0IGZyb20gbGVmdCBlZGdlIG9mIGJvdW5kaW5nIGJveFxuICAgICAgdmFyIHJlbGF0aXZlQ2VudGVyWCA9IHRleHRSZWN0LmxlZnQgKyB0ZXh0UmVjdC53aWR0aC8yIC0gYm91bmRpbmdSZWN0LmxlZnQ7XG4gICAgICB2YXIgcmVsYXRpdmVDZW50ZXJZID0gdGV4dFJlY3QudG9wICsgdGV4dFJlY3QuaGVpZ2h0LzIgLSBib3VuZGluZ1JlY3QudG9wO1xuICAgICAgcmV0dXJuIHJlbGF0aXZlQ2VudGVyWCArICdweCAnICsgcmVsYXRpdmVDZW50ZXJZICsgJ3B4JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcwIDAnOyAvL3RvcCBsZWZ0XG59XG5cbmZ1bmN0aW9uIGdldFRleHREeChvbGRUZXh0UmVjdCwgbmV3VGV4dFJlY3QpIHtcbiAgaWYgKG9sZFRleHRSZWN0ICYmIG5ld1RleHRSZWN0KSB7XG4gICAgcmV0dXJuICgob2xkVGV4dFJlY3QubGVmdCArIG9sZFRleHRSZWN0LndpZHRoLzIpIC0gKG5ld1RleHRSZWN0LmxlZnQgKyBuZXdUZXh0UmVjdC53aWR0aC8yKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBnZXRUZXh0RHkob2xkVGV4dFJlY3QsIG5ld1RleHRSZWN0KSB7XG4gIGlmIChvbGRUZXh0UmVjdCAmJiBuZXdUZXh0UmVjdCkge1xuICAgIHJldHVybiAoKG9sZFRleHRSZWN0LnRvcCArIG9sZFRleHRSZWN0LmhlaWdodC8yKSAtIChuZXdUZXh0UmVjdC50b3AgKyBuZXdUZXh0UmVjdC5oZWlnaHQvMikpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpc1RleHRFbGVtZW50KGVsbSkge1xuICByZXR1cm4gZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIGVsbS5jaGlsZE5vZGVzWzBdLm5vZGVUeXBlID09PSAzO1xufVxuXG52YXIgcmVtb3ZlZCwgY3JlYXRlZDtcblxuZnVuY3Rpb24gcHJlKG9sZFZub2RlLCB2bm9kZSkge1xuICByZW1vdmVkID0ge307XG4gIGNyZWF0ZWQgPSBbXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaGVybyA9IHZub2RlLmRhdGEuaGVybztcbiAgaWYgKGhlcm8gJiYgaGVyby5pZCkge1xuICAgIGNyZWF0ZWQucHVzaChoZXJvLmlkKTtcbiAgICBjcmVhdGVkLnB1c2godm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kodm5vZGUpIHtcbiAgdmFyIGhlcm8gPSB2bm9kZS5kYXRhLmhlcm87XG4gIGlmIChoZXJvICYmIGhlcm8uaWQpIHtcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICAgIHZub2RlLmlzVGV4dE5vZGUgPSBpc1RleHRFbGVtZW50KGVsbSk7IC8vaXMgdGhpcyBhIHRleHQgbm9kZT9cbiAgICB2bm9kZS5ib3VuZGluZ1JlY3QgPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vc2F2ZSB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIHRvIGEgbmV3IHByb3BlcnR5IG9uIHRoZSB2bm9kZVxuICAgIHZub2RlLnRleHRSZWN0ID0gdm5vZGUuaXNUZXh0Tm9kZSA/IGdldFRleHROb2RlUmVjdChlbG0uY2hpbGROb2Rlc1swXSkgOiBudWxsOyAvL3NhdmUgYm91bmRpbmcgcmVjdCBvZiBpbm5lciB0ZXh0IG5vZGVcbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsbSwgbnVsbCk7IC8vZ2V0IGN1cnJlbnQgc3R5bGVzIChpbmNsdWRlcyBpbmhlcml0ZWQgcHJvcGVydGllcylcbiAgICB2bm9kZS5zYXZlZFN0eWxlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb21wdXRlZFN0eWxlKSk7IC8vc2F2ZSBhIGNvcHkgb2YgY29tcHV0ZWQgc3R5bGUgdmFsdWVzXG4gICAgcmVtb3ZlZFtoZXJvLmlkXSA9IHZub2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3QoKSB7XG4gIHZhciBpLCBpZCwgbmV3RWxtLCBvbGRWbm9kZSwgb2xkRWxtLCBoUmF0aW8sIHdSYXRpbyxcbiAgICAgIG9sZFJlY3QsIG5ld1JlY3QsIGR4LCBkeSwgb3JpZ1RyYW5zZm9ybSwgb3JpZ1RyYW5zaXRpb24sXG4gICAgICBuZXdTdHlsZSwgb2xkU3R5bGUsIG5ld0NvbXB1dGVkU3R5bGUsIGlzVGV4dE5vZGUsXG4gICAgICBuZXdUZXh0UmVjdCwgb2xkVGV4dFJlY3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVkLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWQgPSBjcmVhdGVkW2ldO1xuICAgIG5ld0VsbSA9IGNyZWF0ZWRbaSsxXS5lbG07XG4gICAgb2xkVm5vZGUgPSByZW1vdmVkW2lkXTtcbiAgICBpZiAob2xkVm5vZGUpIHtcbiAgICAgIGlzVGV4dE5vZGUgPSBvbGRWbm9kZS5pc1RleHROb2RlICYmIGlzVGV4dEVsZW1lbnQobmV3RWxtKTsgLy9BcmUgb2xkICYgbmV3IGJvdGggdGV4dD9cbiAgICAgIG5ld1N0eWxlID0gbmV3RWxtLnN0eWxlO1xuICAgICAgbmV3Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5ld0VsbSwgbnVsbCk7IC8vZ2V0IGZ1bGwgY29tcHV0ZWQgc3R5bGUgZm9yIG5ldyBlbGVtZW50XG4gICAgICBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICBvbGRTdHlsZSA9IG9sZEVsbS5zdHlsZTtcbiAgICAgIC8vT3ZlcmFsbCBlbGVtZW50IGJvdW5kaW5nIGJveGVzXG4gICAgICBuZXdSZWN0ID0gbmV3RWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgb2xkUmVjdCA9IG9sZFZub2RlLmJvdW5kaW5nUmVjdDsgLy9wcmV2aW91c2x5IHNhdmVkIGJvdW5kaW5nIHJlY3RcbiAgICAgIC8vVGV4dCBub2RlIGJvdW5kaW5nIGJveGVzICYgZGlzdGFuY2VzXG4gICAgICBpZiAoaXNUZXh0Tm9kZSkge1xuICAgICAgICBuZXdUZXh0UmVjdCA9IGdldFRleHROb2RlUmVjdChuZXdFbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIG9sZFRleHRSZWN0ID0gb2xkVm5vZGUudGV4dFJlY3Q7XG4gICAgICAgIGR4ID0gZ2V0VGV4dER4KG9sZFRleHRSZWN0LCBuZXdUZXh0UmVjdCk7XG4gICAgICAgIGR5ID0gZ2V0VGV4dER5KG9sZFRleHRSZWN0LCBuZXdUZXh0UmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL0NhbGN1bGF0ZSBkaXN0YW5jZXMgYmV0d2VlbiBvbGQgJiBuZXcgcG9zaXRpb25zXG4gICAgICAgIGR4ID0gb2xkUmVjdC5sZWZ0IC0gbmV3UmVjdC5sZWZ0O1xuICAgICAgICBkeSA9IG9sZFJlY3QudG9wIC0gbmV3UmVjdC50b3A7XG4gICAgICB9XG4gICAgICBoUmF0aW8gPSBuZXdSZWN0LmhlaWdodCAvIChNYXRoLm1heChvbGRSZWN0LmhlaWdodCwgMSkpO1xuICAgICAgd1JhdGlvID0gaXNUZXh0Tm9kZSA/IGhSYXRpbyA6IG5ld1JlY3Qud2lkdGggLyAoTWF0aC5tYXgob2xkUmVjdC53aWR0aCwgMSkpOyAvL3RleHQgc2NhbGVzIGJhc2VkIG9uIGhSYXRpb1xuICAgICAgLy8gQW5pbWF0ZSBuZXcgZWxlbWVudFxuICAgICAgb3JpZ1RyYW5zZm9ybSA9IG5ld1N0eWxlLnRyYW5zZm9ybTtcbiAgICAgIG9yaWdUcmFuc2l0aW9uID0gbmV3U3R5bGUudHJhbnNpdGlvbjtcbiAgICAgIGlmIChuZXdDb21wdXRlZFN0eWxlLmRpc3BsYXkgPT09ICdpbmxpbmUnKSAvL2lubGluZSBlbGVtZW50cyBjYW5ub3QgYmUgdHJhbnNmb3JtZWRcbiAgICAgICAgbmV3U3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snOyAgICAgICAgLy90aGlzIGRvZXMgbm90IGFwcGVhciB0byBoYXZlIGFueSBuZWdhdGl2ZSBzaWRlIGVmZmVjdHNcbiAgICAgIG5ld1N0eWxlLnRyYW5zaXRpb24gPSBvcmlnVHJhbnNpdGlvbiArICd0cmFuc2Zvcm0gMHMnO1xuICAgICAgbmV3U3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2FsY1RyYW5zZm9ybU9yaWdpbihpc1RleHROb2RlLCBuZXdUZXh0UmVjdCwgbmV3UmVjdCk7XG4gICAgICBuZXdTdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgbmV3U3R5bGUudHJhbnNmb3JtID0gb3JpZ1RyYW5zZm9ybSArICd0cmFuc2xhdGUoJytkeCsncHgsICcrZHkrJ3B4KSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2NhbGUoJysxL3dSYXRpbysnLCAnKzEvaFJhdGlvKycpJztcbiAgICAgIHNldE5leHRGcmFtZShuZXdTdHlsZSwgJ3RyYW5zaXRpb24nLCBvcmlnVHJhbnNpdGlvbik7XG4gICAgICBzZXROZXh0RnJhbWUobmV3U3R5bGUsICd0cmFuc2Zvcm0nLCBvcmlnVHJhbnNmb3JtKTtcbiAgICAgIHNldE5leHRGcmFtZShuZXdTdHlsZSwgJ29wYWNpdHknLCAnMScpO1xuICAgICAgLy8gQW5pbWF0ZSBvbGQgZWxlbWVudFxuICAgICAgZm9yICh2YXIga2V5IGluIG9sZFZub2RlLnNhdmVkU3R5bGUpIHsgLy9yZS1hcHBseSBzYXZlZCBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAgICBpZiAocGFyc2VJbnQoa2V5KSAhPSBrZXkpIHtcbiAgICAgICAgICB2YXIgbXMgPSBrZXkuc3Vic3RyaW5nKDAsMikgPT09ICdtcyc7XG4gICAgICAgICAgdmFyIG1veiA9IGtleS5zdWJzdHJpbmcoMCwzKSA9PT0gJ21veic7XG4gICAgICAgICAgdmFyIHdlYmtpdCA9IGtleS5zdWJzdHJpbmcoMCw2KSA9PT0gJ3dlYmtpdCc7XG4gICAgICBcdCAgaWYgKCFtcyAmJiAhbW96ICYmICF3ZWJraXQpIC8vaWdub3JlIHByZWZpeGVkIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgXHQgIG9sZFN0eWxlW2tleV0gPSBvbGRWbm9kZS5zYXZlZFN0eWxlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9sZFN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIG9sZFN0eWxlLnRvcCA9IG9sZFJlY3QudG9wICsgJ3B4JzsgLy9zdGFydCBhdCBleGlzdGluZyBwb3NpdGlvblxuICAgICAgb2xkU3R5bGUubGVmdCA9IG9sZFJlY3QubGVmdCArICdweCc7XG4gICAgICBvbGRTdHlsZS53aWR0aCA9IG9sZFJlY3Qud2lkdGggKyAncHgnOyAvL05lZWRlZCBmb3IgZWxlbWVudHMgd2hvIHdlcmUgc2l6ZWQgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50c1xuICAgICAgb2xkU3R5bGUuaGVpZ2h0ID0gb2xkUmVjdC5oZWlnaHQgKyAncHgnOyAvL05lZWRlZCBmb3IgZWxlbWVudHMgd2hvIHdlcmUgc2l6ZWQgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50c1xuICAgICAgb2xkU3R5bGUubWFyZ2luID0gMDsgLy9NYXJnaW4gb24gaGVybyBlbGVtZW50IGxlYWRzIHRvIGluY29ycmVjdCBwb3NpdGlvbmluZ1xuICAgICAgb2xkU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2FsY1RyYW5zZm9ybU9yaWdpbihpc1RleHROb2RlLCBvbGRUZXh0UmVjdCwgb2xkUmVjdCk7XG4gICAgICBvbGRTdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgIG9sZFN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG9sZEVsbSk7XG4gICAgICBzZXROZXh0RnJhbWUob2xkU3R5bGUsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcrIC1keCArJ3B4LCAnKyAtZHkgKydweCkgc2NhbGUoJyt3UmF0aW8rJywgJytoUmF0aW8rJyknKTsgLy9zY2FsZSBtdXN0IGJlIG9uIGZhciByaWdodCBmb3IgdHJhbnNsYXRlIHRvIGJlIGNvcnJlY3RcbiAgICAgIHNldE5leHRGcmFtZShvbGRTdHlsZSwgJ29wYWNpdHknLCAnMCcpO1xuICAgICAgb2xkRWxtLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoZXYucHJvcGVydHlOYW1lID09PSAndHJhbnNmb3JtJylcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGV2LnRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlZCA9IGNyZWF0ZWQgPSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge3ByZTogcHJlLCBjcmVhdGU6IGNyZWF0ZSwgZGVzdHJveTogZGVzdHJveSwgcG9zdDogcG9zdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vbW9kdWxlcy9oZXJvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gdXBkYXRlUHJvcHMob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBrZXksIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEucHJvcHMgfHwge30sIHByb3BzID0gdm5vZGUuZGF0YS5wcm9wcyB8fCB7fTtcbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIXByb3BzW2tleV0pIHtcbiAgICAgIGRlbGV0ZSBlbG1ba2V5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIG9sZCA9IG9sZFByb3BzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyICYmIChrZXkgIT09ICd2YWx1ZScgfHwgZWxtW2tleV0gIT09IGN1cikpIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtjcmVhdGU6IHVwZGF0ZVByb3BzLCB1cGRhdGU6IHVwZGF0ZVByb3BzfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zbmFiYmRvbS9tb2R1bGVzL3Byb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJhZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB8fCBzZXRUaW1lb3V0O1xudmFyIG5leHRGcmFtZSA9IGZ1bmN0aW9uKGZuKSB7IHJhZihmdW5jdGlvbigpIHsgcmFmKGZuKTsgfSk7IH07XG5cbmZ1bmN0aW9uIHNldE5leHRGcmFtZShvYmosIHByb3AsIHZhbCkge1xuICBuZXh0RnJhbWUoZnVuY3Rpb24oKSB7IG9ialtwcm9wXSA9IHZhbDsgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgY3VyLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRTdHlsZSA9IG9sZFZub2RlLmRhdGEuc3R5bGUgfHwge30sXG4gICAgICBzdHlsZSA9IHZub2RlLmRhdGEuc3R5bGUgfHwge30sXG4gICAgICBvbGRIYXNEZWwgPSAnZGVsYXllZCcgaW4gb2xkU3R5bGU7XG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmICghc3R5bGVbbmFtZV0pIHtcbiAgICAgIGVsbS5zdHlsZVtuYW1lXSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICBjdXIgPSBzdHlsZVtuYW1lXTtcbiAgICBpZiAobmFtZSA9PT0gJ2RlbGF5ZWQnKSB7XG4gICAgICBmb3IgKG5hbWUgaW4gc3R5bGUuZGVsYXllZCkge1xuICAgICAgICBjdXIgPSBzdHlsZS5kZWxheWVkW25hbWVdO1xuICAgICAgICBpZiAoIW9sZEhhc0RlbCB8fCBjdXIgIT09IG9sZFN0eWxlLmRlbGF5ZWRbbmFtZV0pIHtcbiAgICAgICAgICBzZXROZXh0RnJhbWUoZWxtLnN0eWxlLCBuYW1lLCBjdXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICE9PSAncmVtb3ZlJyAmJiBjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICBlbG0uc3R5bGVbbmFtZV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVzdHJveVN0eWxlKHZub2RlKSB7XG4gIHZhciBzdHlsZSwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBzID0gdm5vZGUuZGF0YS5zdHlsZTtcbiAgaWYgKCFzIHx8ICEoc3R5bGUgPSBzLmRlc3Ryb3kpKSByZXR1cm47XG4gIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgIGVsbS5zdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5UmVtb3ZlU3R5bGUodm5vZGUsIHJtKSB7XG4gIHZhciBzID0gdm5vZGUuZGF0YS5zdHlsZTtcbiAgaWYgKCFzIHx8ICFzLnJlbW92ZSkge1xuICAgIHJtKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIGlkeCwgaSA9IDAsIG1heER1ciA9IDAsXG4gICAgICBjb21wU3R5bGUsIHN0eWxlID0gcy5yZW1vdmUsIGFtb3VudCA9IDAsIGFwcGxpZWQgPSBbXTtcbiAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgYXBwbGllZC5wdXNoKG5hbWUpO1xuICAgIGVsbS5zdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICB9XG4gIGNvbXBTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxtKTtcbiAgdmFyIHByb3BzID0gY29tcFN0eWxlWyd0cmFuc2l0aW9uLXByb3BlcnR5J10uc3BsaXQoJywgJyk7XG4gIGZvciAoOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZihhcHBsaWVkLmluZGV4T2YocHJvcHNbaV0pICE9PSAtMSkgYW1vdW50Kys7XG4gIH1cbiAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbihldikge1xuICAgIGlmIChldi50YXJnZXQgPT09IGVsbSkgLS1hbW91bnQ7XG4gICAgaWYgKGFtb3VudCA9PT0gMCkgcm0oKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlU3R5bGUsIHVwZGF0ZTogdXBkYXRlU3R5bGUsIGRlc3Ryb3k6IGFwcGx5RGVzdHJveVN0eWxlLCByZW1vdmU6IGFwcGx5UmVtb3ZlU3R5bGV9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBqc2hpbnQgbmV3Y2FwOiBmYWxzZVxuLyogZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSwgZG9jdW1lbnQsIE5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFZOb2RlID0gcmVxdWlyZSgnLi92bm9kZScpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIGRvbUFwaSA9IHJlcXVpcmUoJy4vaHRtbGRvbWFwaScpO1xuXG5mdW5jdGlvbiBpc1VuZGVmKHMpIHsgcmV0dXJuIHMgPT09IHVuZGVmaW5lZDsgfVxuZnVuY3Rpb24gaXNEZWYocykgeyByZXR1cm4gcyAhPT0gdW5kZWZpbmVkOyB9XG5cbnZhciBlbXB0eU5vZGUgPSBWTm9kZSgnJywge30sIFtdLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSh2bm9kZTEsIHZub2RlMikge1xuICByZXR1cm4gdm5vZGUxLmtleSA9PT0gdm5vZGUyLmtleSAmJiB2bm9kZTEuc2VsID09PSB2bm9kZTIuc2VsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwgbWFwID0ge30sIGtleTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIG1hcFtrZXldID0gaTtcbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knLCAncHJlJywgJ3Bvc3QnXTtcblxuZnVuY3Rpb24gaW5pdChtb2R1bGVzLCBhcGkpIHtcbiAgdmFyIGksIGosIGNicyA9IHt9O1xuXG4gIGlmIChpc1VuZGVmKGFwaSkpIGFwaSA9IGRvbUFwaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChtb2R1bGVzW2pdW2hvb2tzW2ldXSAhPT0gdW5kZWZpbmVkKSBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgIHJldHVybiBWTm9kZShhcGkudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYihjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tbGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBhcGkucGFyZW50Tm9kZShjaGlsZEVsbSk7XG4gICAgICAgIGFwaS5yZW1vdmVDaGlsZChwYXJlbnQsIGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICB2YXIgaSwgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSk7XG4gICAgICAgIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZWxtLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLCBzZWwgPSB2bm9kZS5zZWw7XG4gICAgaWYgKGlzRGVmKHNlbCkpIHtcbiAgICAgIC8vIFBhcnNlIHNlbGVjdG9yXG4gICAgICB2YXIgaGFzaElkeCA9IHNlbC5pbmRleE9mKCcjJyk7XG4gICAgICB2YXIgZG90SWR4ID0gc2VsLmluZGV4T2YoJy4nLCBoYXNoSWR4KTtcbiAgICAgIHZhciBoYXNoID0gaGFzaElkeCA+IDAgPyBoYXNoSWR4IDogc2VsLmxlbmd0aDtcbiAgICAgIHZhciBkb3QgPSBkb3RJZHggPiAwID8gZG90SWR4IDogc2VsLmxlbmd0aDtcbiAgICAgIHZhciB0YWcgPSBoYXNoSWR4ICE9PSAtMSB8fCBkb3RJZHggIT09IC0xID8gc2VsLnNsaWNlKDAsIE1hdGgubWluKGhhc2gsIGRvdCkpIDogc2VsO1xuICAgICAgZWxtID0gdm5vZGUuZWxtID0gaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEubnMpID8gYXBpLmNyZWF0ZUVsZW1lbnROUyhpLCB0YWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhcGkuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgaWYgKGhhc2ggPCBkb3QpIGVsbS5pZCA9IHNlbC5zbGljZShoYXNoICsgMSwgZG90KTtcbiAgICAgIGlmIChkb3RJZHggPiAwKSBlbG0uY2xhc3NOYW1lID0gc2VsLnNsaWNlKGRvdCsxKS5yZXBsYWNlKC9cXC4vZywgJyAnKTtcbiAgICAgIGlmIChpcy5hcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgYXBpLmFwcGVuZENoaWxkKGVsbSwgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpcy5wcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgICAgYXBpLmFwcGVuZENoaWxkKGVsbSwgYXBpLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICBpZiAoaS5jcmVhdGUpIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgICBpZiAoaS5pbnNlcnQpIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtID0gdm5vZGUuZWxtID0gYXBpLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUuZWxtO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgYmVmb3JlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgYmVmb3JlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayh2bm9kZSkge1xuICAgIHZhciBpLCBqLCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgaSh2bm9kZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIGNicy5kZXN0cm95W2ldKHZub2RlKTtcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBpLCBsaXN0ZW5lcnMsIHJtLCBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC5zZWwpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICAgIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgICBybSA9IGNyZWF0ZVJtQ2IoY2guZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSBjYnMucmVtb3ZlW2ldKGNoLCBybSk7XG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBjaC5kYXRhKSAmJiBpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgICAgICBpKGNoLCBybSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50RWxtLCBjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4ocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDAsIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgYmVmb3JlO1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBhcGkubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZHhJbk9sZCA9IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICBiZWZvcmUgPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCsxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4KzFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICB2YXIgaSwgaG9vaztcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEpICYmIGlzRGVmKGhvb2sgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBob29rLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtLCBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuLCBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHJldHVybjtcbiAgICBpZiAoIXNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICB2YXIgcGFyZW50RWxtID0gYXBpLnBhcmVudE5vZGUob2xkVm5vZGUuZWxtKTtcbiAgICAgIGVsbSA9IGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBlbG0sIG9sZFZub2RlLmVsbSk7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgaSA9IHZub2RlLmRhdGEuaG9vaztcbiAgICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgYXBpLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgYXBpLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgYXBpLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihob29rKSAmJiBpc0RlZihpID0gaG9vay5wb3N0cGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBpLCBlbG0sIHBhcmVudDtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGNicy5wcmUubGVuZ3RoOyArK2kpIGNicy5wcmVbaV0oKTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLnNlbCkpIHtcbiAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgIH1cblxuICAgIGlmIChzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHBhcmVudCA9IGFwaS5wYXJlbnROb2RlKGVsbSk7XG5cbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblxuICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudCwgdm5vZGUuZWxtLCBhcGkubmV4dFNpYmxpbmcoZWxtKSk7XG4gICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnQsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnNlcnRlZFZub2RlUXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KGluc2VydGVkVm5vZGVRdWV1ZVtpXSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucG9zdC5sZW5ndGg7ICsraSkgY2JzLnBvc3RbaV0oKTtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2luaXQ6IGluaXR9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NuYWJiZG9tL3NuYWJiZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGggPSByZXF1aXJlKCcuL2gnKTtcblxuZnVuY3Rpb24gY29weVRvVGh1bmsodm5vZGUsIHRodW5rKSB7XG4gIHRodW5rLmVsbSA9IHZub2RlLmVsbTtcbiAgdm5vZGUuZGF0YS5mbiA9IHRodW5rLmRhdGEuZm47XG4gIHZub2RlLmRhdGEuYXJncyA9IHRodW5rLmRhdGEuYXJncztcbiAgdGh1bmsuZGF0YSA9IHZub2RlLmRhdGE7XG4gIHRodW5rLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gIHRodW5rLnRleHQgPSB2bm9kZS50ZXh0O1xuICB0aHVuay5lbG0gPSB2bm9kZS5lbG07XG59XG5cbmZ1bmN0aW9uIGluaXQodGh1bmspIHtcbiAgdmFyIGksIGN1ciA9IHRodW5rLmRhdGE7XG4gIHZhciB2bm9kZSA9IGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGN1ci5hcmdzKTtcbiAgY29weVRvVGh1bmsodm5vZGUsIHRodW5rKTtcbn1cblxuZnVuY3Rpb24gcHJlcGF0Y2gob2xkVm5vZGUsIHRodW5rKSB7XG4gIHZhciBpLCBvbGQgPSBvbGRWbm9kZS5kYXRhLCBjdXIgPSB0aHVuay5kYXRhLCB2bm9kZTtcbiAgdmFyIG9sZEFyZ3MgPSBvbGQuYXJncywgYXJncyA9IGN1ci5hcmdzO1xuICBpZiAob2xkLmZuICE9PSBjdXIuZm4gfHwgb2xkQXJncy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgY29weVRvVGh1bmsoY3VyLmZuLmFwcGx5KHVuZGVmaW5lZCwgYXJncyksIHRodW5rKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChvbGRBcmdzW2ldICE9PSBhcmdzW2ldKSB7XG4gICAgICBjb3B5VG9UaHVuayhjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKSwgdGh1bmspO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb3B5VG9UaHVuayhvbGRWbm9kZSwgdGh1bmspO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbCwga2V5LCBmbiwgYXJncykge1xuICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJncyA9IGZuO1xuICAgIGZuID0ga2V5O1xuICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gaChzZWwsIHtcbiAgICBrZXk6IGtleSxcbiAgICBob29rOiB7aW5pdDogaW5pdCwgcHJlcGF0Y2g6IHByZXBhdGNofSxcbiAgICBmbjogZm4sXG4gICAgYXJnczogYXJnc1xuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25hYmJkb20vdGh1bmsuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBpc1BhdHRlcm4sIGlzUm91dGVEZWZpbml0aW9uLCB0cmF2ZXJzZVJvdXRlcywgaXNOb3ROdWxsLCBzcGxpdFBhdGgsIGlzUGFyYW0sIGV4dHJhY3RQYXJ0aWFsLCB1bnByZWZpeGVkLCB9IGZyb20gJy4vdXRpbCc7XG5mdW5jdGlvbiBzd2l0Y2hQYXRoSW5wdXRHdWFyZChwYXRoLCByb3V0ZXMpIHtcbiAgICBpZiAoIWlzUGF0dGVybihwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBwYXJhbWV0ZXIgdG8gc3dpdGNoUGF0aCBtdXN0IGJlIGEgcm91dGUgcGF0aC5cIik7XG4gICAgfVxuICAgIGlmICghaXNSb3V0ZURlZmluaXRpb24ocm91dGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgcGFyYW1ldGVyIHRvIHN3aXRjaFBhdGggbXVzdCBiZSBhbiBvYmplY3QgXCIgK1xuICAgICAgICAgICAgXCJjb250YWluaW5nIHJvdXRlIHBhdHRlcm5zLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGgoc291cmNlUGF0aCwgbWF0Y2hlZFBhdGgpIHtcbiAgICB2YXIgc291cmNlUGFydHMgPSBzcGxpdFBhdGgoc291cmNlUGF0aCk7XG4gICAgdmFyIG1hdGNoZWRQYXJ0cyA9IHNwbGl0UGF0aChtYXRjaGVkUGF0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVkUGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1hdGNoZWRQYXJ0c1tpXSAhPT0gc291cmNlUGFydHNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIi9cIiArIGV4dHJhY3RQYXJ0aWFsKHNvdXJjZVBhdGgsIG1hdGNoZWRQYXRoKTtcbn1cbmZ1bmN0aW9uIGJldHRlck1hdGNoKGNhbmRpZGF0ZSwgcmVmZXJlbmNlKSB7XG4gICAgaWYgKCFpc05vdE51bGwoY2FuZGlkYXRlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNOb3ROdWxsKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVQYXRoKGNhbmRpZGF0ZSwgcmVmZXJlbmNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGUubGVuZ3RoID49IHJlZmVyZW5jZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBtYXRjaGVzV2l0aFBhcmFtcyhzb3VyY2VQYXRoLCBwYXR0ZXJuKSB7XG4gICAgdmFyIHNvdXJjZVBhcnRzID0gc3BsaXRQYXRoKHNvdXJjZVBhdGgpO1xuICAgIHZhciBwYXR0ZXJuUGFydHMgPSBzcGxpdFBhdGgocGF0dGVybik7XG4gICAgdmFyIHBhcmFtcyA9IHBhdHRlcm5QYXJ0c1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0LCBpKSB7IHJldHVybiBpc1BhcmFtKHBhcnQpID8gc291cmNlUGFydHNbaV0gOiBudWxsOyB9KVxuICAgICAgICAuZmlsdGVyKGlzTm90TnVsbCk7XG4gICAgdmFyIG1hdGNoZWQgPSBwYXR0ZXJuUGFydHNcbiAgICAgICAgLmV2ZXJ5KGZ1bmN0aW9uIChwYXJ0LCBpKSB7IHJldHVybiBpc1BhcmFtKHBhcnQpIHx8IHBhcnQgPT09IHNvdXJjZVBhcnRzW2ldOyB9KTtcbiAgICByZXR1cm4gbWF0Y2hlZCA/IHBhcmFtcyA6IFtdO1xufVxuZnVuY3Rpb24gZ2V0UGFyYW1GblZhbHVlKHBhcmFtRm4sIHBhcmFtcykge1xuICAgIHZhciBfcGFyYW1GbiA9IGlzUm91dGVEZWZpbml0aW9uKHBhcmFtRm4pID8gcGFyYW1GbltcIi9cIl0gOiBwYXJhbUZuO1xuICAgIHJldHVybiB0eXBlb2YgX3BhcmFtRm4gPT09IFwiZnVuY3Rpb25cIiA/IF9wYXJhbUZuLmFwcGx5KHZvaWQgMCwgcGFyYW1zKSA6IF9wYXJhbUZuO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUoX2EpIHtcbiAgICB2YXIgc291cmNlUGF0aCA9IF9hLnNvdXJjZVBhdGgsIG1hdGNoZWRQYXRoID0gX2EubWF0Y2hlZFBhdGgsIG1hdGNoZWRWYWx1ZSA9IF9hLm1hdGNoZWRWYWx1ZSwgcm91dGVzID0gX2Eucm91dGVzO1xuICAgIHZhciBwYXRoID0gbWF0Y2hlZFBhdGggPyB2YWxpZGF0ZVBhdGgoc291cmNlUGF0aCwgbWF0Y2hlZFBhdGgpIDogbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBtYXRjaGVkVmFsdWU7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHBhdGggPSByb3V0ZXNbXCIqXCJdID8gc291cmNlUGF0aCA6IG51bGw7XG4gICAgICAgIHZhbHVlID0gcGF0aCA/IHJvdXRlc1tcIipcIl0gOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN3aXRjaFBhdGgoc291cmNlUGF0aCwgcm91dGVzKSB7XG4gICAgc3dpdGNoUGF0aElucHV0R3VhcmQoc291cmNlUGF0aCwgcm91dGVzKTtcbiAgICB2YXIgbWF0Y2hlZFBhdGggPSBudWxsO1xuICAgIHZhciBtYXRjaGVkVmFsdWUgPSBudWxsO1xuICAgIHRyYXZlcnNlUm91dGVzKHJvdXRlcywgZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKHNvdXJjZVBhdGguc2VhcmNoKHBhdHRlcm4pID09PSAwICYmIGJldHRlck1hdGNoKHBhdHRlcm4sIG1hdGNoZWRQYXRoKSkge1xuICAgICAgICAgICAgbWF0Y2hlZFBhdGggPSBwYXR0ZXJuO1xuICAgICAgICAgICAgbWF0Y2hlZFZhbHVlID0gcm91dGVzW3BhdHRlcm5dO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSBtYXRjaGVzV2l0aFBhcmFtcyhzb3VyY2VQYXRoLCBwYXR0ZXJuKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCAmJiBiZXR0ZXJNYXRjaChzb3VyY2VQYXRoLCBtYXRjaGVkUGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoZWRQYXRoID0gZXh0cmFjdFBhcnRpYWwoc291cmNlUGF0aCwgcGF0dGVybik7XG4gICAgICAgICAgICBtYXRjaGVkVmFsdWUgPSBnZXRQYXJhbUZuVmFsdWUocm91dGVzW3BhdHRlcm5dLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JvdXRlRGVmaW5pdGlvbihyb3V0ZXNbcGF0dGVybl0pICYmIHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VQYXRoICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHN3aXRjaFBhdGgodW5wcmVmaXhlZChzb3VyY2VQYXRoLCBwYXR0ZXJuKSB8fCBcIi9cIiwgcm91dGVzW3BhdHRlcm5dKTtcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUGF0aCA9IHBhdHRlcm4gKyBjaGlsZC5wYXRoO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wYXRoICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGJldHRlck1hdGNoKG5lc3RlZFBhdGgsIG1hdGNoZWRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUGF0aCA9IG5lc3RlZFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRWYWx1ZSA9IGNoaWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWxpZGF0ZSh7IHNvdXJjZVBhdGg6IHNvdXJjZVBhdGgsIG1hdGNoZWRQYXRoOiBtYXRjaGVkUGF0aCwgbWF0Y2hlZFZhbHVlOiBtYXRjaGVkVmFsdWUsIHJvdXRlczogcm91dGVzIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N3aXRjaC1wYXRoL2xpYi9lczIwMTUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuKGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiBjYW5kaWRhdGUuY2hhckF0KDApID09PSBcIi9cIiB8fCBjYW5kaWRhdGUgPT09IFwiKlwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUm91dGVEZWZpbml0aW9uKGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiAhY2FuZGlkYXRlIHx8IHR5cGVvZiBjYW5kaWRhdGUgIT09IFwib2JqZWN0XCIgP1xuICAgICAgICBmYWxzZSA6IGlzUGF0dGVybihPYmplY3Qua2V5cyhjYW5kaWRhdGUpWzBdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZVJvdXRlcyhyb3V0ZXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyb3V0ZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGtleXNbaV07XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSBcIipcIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYWxsYmFjayhwYXR0ZXJuKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb3ROdWxsKGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiBjYW5kaWRhdGUgIT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAhIXM7IH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyYW0oY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZS5tYXRjaCgvOlxcdysvKSAhPT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFydGlhbChzb3VyY2VQYXRoLCBwYXR0ZXJuKSB7XG4gICAgdmFyIHBhdHRlcm5QYXJ0cyA9IHNwbGl0UGF0aChwYXR0ZXJuKTtcbiAgICB2YXIgc291cmNlUGFydHMgPSBzcGxpdFBhdGgoc291cmNlUGF0aCk7XG4gICAgdmFyIG1hdGNoZWRQYXJ0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVyblBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1hdGNoZWRQYXJ0cy5wdXNoKHNvdXJjZVBhcnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZWRQYXJ0cy5maWx0ZXIoaXNOb3ROdWxsKS5qb2luKFwiL1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnByZWZpeGVkKGZ1bGxTdHJpbmcsIHByZWZpeCkge1xuICAgIHJldHVybiBmdWxsU3RyaW5nLnNwbGl0KHByZWZpeClbMV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zd2l0Y2gtcGF0aC9saWIvZXMyMDE1L3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcG9ueWZpbGwgPSByZXF1aXJlKCcuL3BvbnlmaWxsJyk7XG5cbnZhciBfcG9ueWZpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9ueWZpbGwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciByb290OyAvKiBnbG9iYWwgd2luZG93ICovXG5cblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IG1vZHVsZTtcbn0gZWxzZSB7XG4gIHJvb3QgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufVxuXG52YXIgcmVzdWx0ID0gKDAsIF9wb255ZmlsbDJbJ2RlZmF1bHQnXSkocm9vdCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSByZXN1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bWJvbE9ic2VydmFibGVQb255ZmlsbDtcbmZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBfU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBfU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKF9TeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRfU3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9wb255ZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIFVJIGZyb20gXCIuLi91aVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG5pbXBvcnQgeyBkaXYsIGEsIHByZSwgY29kZSwgVk5vZGUgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHsgRXhhbXBsZSB9IGZyb20gXCIuLi9jb21wb25lbnRzXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQnJlYWRjcnVtYiB7XG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlcykge1xuICAgIGxldCBiYXNpY3MgPSBjcmVhdGVCYXNpY0V4YW1wbGVzKHNvdXJjZXMpO1xuICAgIGxldCBjb250ZW50ID0gY3JlYXRlQ29udGVudEV4YW1wbGVzKHNvdXJjZXMpO1xuICAgIGxldCB2YXJpYXRpb25zID0gY3JlYXRlVmFyaWF0aW9uRXhhbXBsZXMoc291cmNlcyk7XG5cbiAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKGJhc2ljcywgY29udGVudCwgdmFyaWF0aW9ucykubWFwKFxuICAgICAgKFtiYXNpY3MsIGNvbnRlbnQsIHZhcmlhdGlvbnNdKSA9PlxuICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiYXJ0aWNsZVwiIH0gfSwgW1xuICAgICAgICAgIFVJLlNlZ21lbnQucmVuZGVyKHsgdmVydGljYWw6IHRydWUgfSwgW1xuICAgICAgICAgICAgVUkuQ29udGFpbmVyLnJlbmRlcihbXG4gICAgICAgICAgICAgIFVJLkhlYWRlci5yZW5kZXIoeyBzaXplOiBVSS5TaXplLkh1Z2UgfSwgXCJCcmVhZGNydW1iXCIsIHtcbiAgICAgICAgICAgICAgICBzdWJ0ZXh0OiBcIkEgYnJlYWRjcnVtYiBpcyB1c2VkIHRvIHNob3cgaGllcmFyY2h5IGJldHdlZW4gY29udGVudFwiXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgVUkuQ29udGFpbmVyLnJlbmRlcihbXG4gICAgICAgICAgICBVSS5TZWdtZW50LnJlbmRlcih7IGJhc2ljOiB0cnVlIH0sIFtVSS5IZWFkZXIucmVuZGVyKHsgZGl2aWRpbmc6IHRydWUsIHNpemU6IFVJLlNpemUuSHVnZSB9LCBcIlR5cGVzXCIpXS5jb25jYXQoYmFzaWNzKSksXG4gICAgICAgICAgICBVSS5TZWdtZW50LnJlbmRlcih7IGJhc2ljOiB0cnVlIH0sIFtVSS5IZWFkZXIucmVuZGVyKHsgZGl2aWRpbmc6IHRydWUsIHNpemU6IFVJLlNpemUuSHVnZSB9LCBcIkNvbnRlbnRcIildLmNvbmNhdChjb250ZW50KSksXG4gICAgICAgICAgICBVSS5TZWdtZW50LnJlbmRlcih7IGJhc2ljOiB0cnVlIH0sIFtVSS5IZWFkZXIucmVuZGVyKHsgZGl2aWRpbmc6IHRydWUsIHNpemU6IFVJLlNpemUuSHVnZSB9LCBcIlZhcmlhdGlvbnNcIildLmNvbmNhdCh2YXJpYXRpb25zKSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgXSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBET006IHZUcmVlJCxcbiAgICAgIHJvdXRlcjogeHMubmV2ZXIoKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCYXNpY0V4YW1wbGVzKHNvdXJjZXMpIHtcbiAgICBsZXQgZXgxID0gRXhhbXBsZS5ydW4oc291cmNlcywge1xuICAgICAgVk5vZGUkOiB4cy5vZihVSS5CcmVhZGNydW1iLnJlbmRlcihbXG4gICAgICAgIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgIHsgdGV4dDogXCJTdG9yZVwiLCBocmVmOiBcIiNcIiB9LFxuICAgICAgICB7IHRleHQ6IFwiVC1TaGlydFwiLCBhY3RpdmU6IHRydWUgfVxuICAgICAgXSkpLFxuICAgICAgY29kZTogYEJyZWFkY3J1bWIucmVuZGVyKFtcbiAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgeyB0ZXh0OiBcIlN0b3JlXCIsIGhyZWY6IFwiI1wiIH0sXG4gIHsgdGV4dDogXCJULVNoaXJ0XCIsIGFjdGl2ZTogdHJ1ZSB9XG5dKWAsXG4gICAgICBoZWFkZXI6IFwiQnJlYWRjcnVtYlwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQSBzdGFuZGFyZCBicmVhZGNydW1iLlwiXG4gICAgfSk7XG4gICAgbGV0IGV4MiA9IEV4YW1wbGUucnVuKHNvdXJjZXMsIHtcbiAgICAgIFZOb2RlJDogeHMub2YoVUkuQnJlYWRjcnVtYi5yZW5kZXIoe1xuICAgICAgICBzdHlsZTogeyBkaXZpZGVyOiBVSS5JY29uLnJlbmRlcihVSS5JY29uVHlwZS5BbmdsZVJpZ2h0KSB9LFxuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiU3RvcmVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiVC1TaGlydFwiLCBhY3RpdmU6IHRydWUgfVxuICAgICAgICBdXG4gICAgICB9KSksXG4gICAgICBjb2RlOiBgQnJlYWRjcnVtYi5yZW5kZXIoe1xuICBzdHlsZTogeyBkaXZpZGVyOiBJY29uLnJlbmRlcihJY29uVHlwZS5BbmdsZVJpZ2h0KSB9LFxuICBjb250ZW50OiBbXG4gICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiU3RvcmVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiVC1TaGlydFwiLCBhY3RpdmU6IHRydWUgfVxuICBdXG59KWBcbiAgICB9KTtcbiAgICByZXR1cm4geHMuY29tYmluZShleDEuRE9NLCBleDIuRE9NKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDb250ZW50RXhhbXBsZXMoc291cmNlcykge1xuICAgIGxldCBleDEgPSBFeGFtcGxlLnJ1bihzb3VyY2VzLCB7XG4gICAgICBoZWFkZXI6IFwiRGl2aWRlclwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQSBicmVhZGNydW1iIGNhbiBjb250YWluIGEgZGl2aWRlciB0byBzaG93IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBzZWN0aW9ucywgdGhpcyBjYW4gYmUgZm9ybWF0dGVkIGFzIGFuIGljb24gb3IgdGV4dC5cIixcbiAgICAgIFZOb2RlJDogeHMub2YoVUkuQnJlYWRjcnVtYi5yZW5kZXIoe1xuICAgICAgICBzdHlsZTogeyBkaXZpZGVyOiBVSS5JY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICAgIH0pKSxcbiAgICAgIGNvZGU6IGBCcmVhZGNydW1iLnJlbmRlcih7XG5zdHlsZTogeyBkaXZpZGVyOiBJY29uLnJlbmRlcihJY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuY29udGVudDpbXG4gIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gIHsgdGV4dDogXCJSZWdpc3RyYXRpb25cIiwgaHJlZjogXCIjXCIgfSxcbiAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG5dfSlgXG4gICAgfSk7XG4gICAgbGV0IGV4MiA9IEV4YW1wbGUucnVuKHNvdXJjZXMsIHtcbiAgICAgIFZOb2RlJDogeHMub2YoVUkuQnJlYWRjcnVtYi5yZW5kZXIoe1xuICAgICAgICBzdHlsZTogeyBkaXZpZGVyOiBcInxcIiB9LFxuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICAgIH0pKSxcbiAgICAgIGNvZGU6IGBCcmVhZGNydW1iLnJlbmRlcih7XG4gIHN0eWxlOiB7IGRpdmlkZXI6IFwifFwiIH0sXG4gIGNvbnRlbnQ6IFtcbiAgICB7IHRleHQ6IFwiSG9tZVwiLCBocmVmOiBcIiNcIiB9LFxuICAgIHsgdGV4dDogXCJSZWdpc3RyYXRpb25cIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiUGVyc29uYWwgSW5mb3JtYXRpb25cIiwgYWN0aXZlOiB0cnVlIH1cbiAgXVxufSlgXG4gICAgfSk7XG4gICAgbGV0IGV4MyA9IEV4YW1wbGUucnVuKHNvdXJjZXMsIHtcbiAgICAgIGhlYWRlcjogXCJTZWN0aW9uXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJBIGJyZWFkY3J1bWIgY2FuIGNvbnRhaW4gc2VjdGlvbnMgdGhhdCBjYW4gZWl0aGVyIGJlIGZvcm1hdHRlZCBhcyBhIGxpbmsgb3IgdGV4dC5cIixcbiAgICAgIFZOb2RlJDogeHMub2YoVUkuQnJlYWRjcnVtYi5yZW5kZXIoe1xuICAgICAgICBzdHlsZTogeyBkaXZpZGVyOiBVSS5JY29uLnJlbmRlcihVSS5JY29uVHlwZS5BbmdsZVJpZ2h0KSB9LFxuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgeyB0ZXh0OiBcIkhvbWVcIiB9LFxuICAgICAgICAgIHsgdGV4dDogXCJTZWFyY2hcIiwgYWN0aXZlOiB0cnVlIH0sXG4gICAgICAgIF1cbiAgICAgIH0pKSxcbiAgICAgIGNvZGU6IGBCcmVhZGNydW1iLnJlbmRlcih7XG4gIHN0eWxlOiB7IGRpdmlkZXI6IEljb24ucmVuZGVyKEljb25UeXBlLkFuZ2xlUmlnaHQpIH0sXG4gIGNvbnRlbnQ6IFtcbiAgICB7IHRleHQ6IFwiSG9tZVwiIH0sXG4gICAgeyB0ZXh0OiBcIlNlYXJjaFwiLCBhY3RpdmU6IHRydWUgfSxcbiAgXVxufSlgXG4gICAgfSk7XG4gICAgbGV0IGV4NCA9IEV4YW1wbGUucnVuKHNvdXJjZXMsIHtcbiAgICAgIGhlYWRlcjogXCJMaW5rXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJBIHNlY3Rpb24gbWF5IGJlIGxpbmthYmxlIG9yIGNvbnRhaW4gYSBsaW5rLlwiLFxuICAgICAgVk5vZGUkOiB4cy5vZihVSS5CcmVhZGNydW1iLnJlbmRlcih7XG4gICAgICAgIHN0eWxlOiB7IGRpdmlkZXI6IFVJLkljb24ucmVuZGVyKFVJLkljb25UeXBlLkFuZ2xlUmlnaHQpIH0sXG4gICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICB7IHRleHQ6IFwiSG9tZVwiLCBocmVmOiBcIiNcIiB9LFxuICAgICAgICAgIHsgdGV4dDogW1wiU2VhcmNoIGZvcjogXCIsIGEoXCJwYXBlciB0b3dlbHNcIildLCBhY3RpdmU6IHRydWUgfSxcbiAgICAgICAgXVxuICAgICAgfSkpLFxuICAgICAgY29kZTogYEJyZWFkY3J1bWIucmVuZGVyKHtcbiAgc3R5bGU6IHsgZGl2aWRlcjogSWNvbi5yZW5kZXIoSWNvblR5cGUuQW5nbGVSaWdodCkgfSxcbiAgY29udGVudDogW1xuICAgIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgeyB0ZXh0OiBbXCJTZWFyY2ggZm9yOiBcIiwgYShcInBhcGVyIHRvd2Vsc1wiKV0sIGFjdGl2ZTogdHJ1ZSB9LFxuICBdXG59KWBcbiAgICB9KTtcbiAgICByZXR1cm4geHMuY29tYmluZShleDEuRE9NLCBleDIuRE9NLCBleDMuRE9NLCBleDQuRE9NKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZhcmlhdGlvbkV4YW1wbGVzKHNvdXJjZXMpIHtcbiAgICBsZXQgZXgxID0gRXhhbXBsZS5ydW4oc291cmNlcywge1xuICAgICAgaGVhZGVyOiBcIlNpemVcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkEgYnJlYWRjcnVtYiBjYW4gdmFyeSBpbiBzaXplLlwiLFxuICAgICAgVk5vZGUkOiB4cy5vZihVSS5CcmVhZGNydW1iLnJlbmRlcih7XG4gICAgICAgIHN0eWxlOiB7IHNpemU6IFVJLlNpemUuTWluaSwgZGl2aWRlcjogVUkuSWNvbi5yZW5kZXIoVUkuSWNvblR5cGUuQXJyb3dSaWdodCkgfSxcbiAgICAgICAgY29udGVudDogW1xuICAgICAgICAgIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlJlZ2lzdHJhdGlvblwiLCBocmVmOiBcIiNcIiB9LFxuICAgICAgICAgIHsgdGV4dDogXCJQZXJzb25hbCBJbmZvcm1hdGlvblwiLCBhY3RpdmU6IHRydWUgfVxuICAgICAgICBdXG4gICAgICB9KSksXG4gICAgICBjb2RlOiBgQnJlYWRjcnVtYi5yZW5kZXIoe1xuICBzdHlsZTogeyBzaXplOiBTaXplLk1pbmksIGRpdmlkZXI6IEljb24ucmVuZGVyKFVJLkljb25UeXBlLkFycm93UmlnaHQpIH0sXG4gIGNvbnRlbnQ6IFtcbiAgICB7IHRleHQ6IFwiSG9tZVwiLCBocmVmOiBcIiNcIiB9LFxuICAgIHsgdGV4dDogXCJSZWdpc3RyYXRpb25cIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiUGVyc29uYWwgSW5mb3JtYXRpb25cIiwgYWN0aXZlOiB0cnVlIH1cbiAgXVxufSlgXG4gICAgfSk7XG4gICAgbGV0IGV4MiA9IEV4YW1wbGUucnVuKHNvdXJjZXMsIHtcbiAgICAgIFZOb2RlJDogeHMub2YoVUkuQnJlYWRjcnVtYi5yZW5kZXIoe1xuICAgICAgICBzdHlsZTogeyBzaXplOiBVSS5TaXplLlRpbnksIGRpdmlkZXI6IFVJLkljb24ucmVuZGVyKFVJLkljb25UeXBlLkFycm93UmlnaHQpIH0sXG4gICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICB7IHRleHQ6IFwiSG9tZVwiLCBocmVmOiBcIiNcIiB9LFxuICAgICAgICAgIHsgdGV4dDogXCJSZWdpc3RyYXRpb25cIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiUGVyc29uYWwgSW5mb3JtYXRpb25cIiwgYWN0aXZlOiB0cnVlIH1cbiAgICAgICAgXVxuICAgICAgfSkpLFxuICAgICAgY29kZTogYEJyZWFkY3J1bWIucmVuZGVyKHtcbiAgc3R5bGU6IHsgc2l6ZTogU2l6ZS5UaW55LCBkaXZpZGVyOiBJY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICBjb250ZW50OiBbXG4gICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gIF1cbn0pYFxuICAgIH0pO1xuICAgIGxldCBleDMgPSBFeGFtcGxlLnJ1bihzb3VyY2VzLCB7XG4gICAgICBWTm9kZSQ6IHhzLm9mKFVJLkJyZWFkY3J1bWIucmVuZGVyKHtcbiAgICAgICAgc3R5bGU6IHsgc2l6ZTogVUkuU2l6ZS5TbWFsbCwgZGl2aWRlcjogVUkuSWNvbi5yZW5kZXIoVUkuSWNvblR5cGUuQXJyb3dSaWdodCkgfSxcbiAgICAgICAgY29udGVudDogW1xuICAgICAgICAgIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlJlZ2lzdHJhdGlvblwiLCBocmVmOiBcIiNcIiB9LFxuICAgICAgICAgIHsgdGV4dDogXCJQZXJzb25hbCBJbmZvcm1hdGlvblwiLCBhY3RpdmU6IHRydWUgfVxuICAgICAgICBdXG4gICAgICB9KSksXG4gICAgICBjb2RlOiBgQnJlYWRjcnVtYi5yZW5kZXIoe1xuICBzdHlsZTogeyBzaXplOiBTaXplLlNtYWxsLCBkaXZpZGVyOiBJY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICBjb250ZW50OiBbXG4gICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gIF1cbn0pYFxuICAgIH0pOyBsZXQgZXg0ID0gRXhhbXBsZS5ydW4oc291cmNlcywge1xuICAgICAgVk5vZGUkOiB4cy5vZihVSS5CcmVhZGNydW1iLnJlbmRlcih7XG4gICAgICAgIHN0eWxlOiB7IHNpemU6IFVJLlNpemUuTWVkaXVtLCBkaXZpZGVyOiBVSS5JY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICAgIH0pKSxcbiAgICAgIGNvZGU6IGBCcmVhZGNydW1iLnJlbmRlcih7XG4gIHN0eWxlOiB7IHNpemU6IFNpemUuTWVkaXVtLCBkaXZpZGVyOiBJY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICBjb250ZW50OiBbXG4gICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gIF1cbn0pYFxuICAgIH0pOyBsZXQgZXg1ID0gRXhhbXBsZS5ydW4oc291cmNlcywge1xuICAgICAgVk5vZGUkOiB4cy5vZihVSS5CcmVhZGNydW1iLnJlbmRlcih7XG4gICAgICAgIHN0eWxlOiB7IHNpemU6IFVJLlNpemUuTGFyZ2UsIGRpdmlkZXI6IFVJLkljb24ucmVuZGVyKFVJLkljb25UeXBlLkFycm93UmlnaHQpIH0sXG4gICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICB7IHRleHQ6IFwiSG9tZVwiLCBocmVmOiBcIiNcIiB9LFxuICAgICAgICAgIHsgdGV4dDogXCJSZWdpc3RyYXRpb25cIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiUGVyc29uYWwgSW5mb3JtYXRpb25cIiwgYWN0aXZlOiB0cnVlIH1cbiAgICAgICAgXVxuICAgICAgfSkpLFxuICAgICAgY29kZTogYEJyZWFkY3J1bWIucmVuZGVyKHtcbiAgc3R5bGU6IHsgc2l6ZTogU2l6ZS5MYXJnZSwgZGl2aWRlcjogSWNvbi5yZW5kZXIoVUkuSWNvblR5cGUuQXJyb3dSaWdodCkgfSxcbiAgY29udGVudDogW1xuICAgIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgeyB0ZXh0OiBcIlJlZ2lzdHJhdGlvblwiLCBocmVmOiBcIiNcIiB9LFxuICAgIHsgdGV4dDogXCJQZXJzb25hbCBJbmZvcm1hdGlvblwiLCBhY3RpdmU6IHRydWUgfVxuICBdXG59KWBcbiAgICB9KTtcbiAgICBsZXQgZXg2ID0gRXhhbXBsZS5ydW4oc291cmNlcywge1xuICAgICAgVk5vZGUkOiB4cy5vZihVSS5CcmVhZGNydW1iLnJlbmRlcih7XG4gICAgICAgIHN0eWxlOiB7IHNpemU6IFVJLlNpemUuQmlnLCBkaXZpZGVyOiBVSS5JY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICAgIH0pKSxcbiAgICAgIGNvZGU6IGBCcmVhZGNydW1iLnJlbmRlcih7XG4gIHN0eWxlOiB7IHNpemU6IFNpemUuQmlnLCBkaXZpZGVyOiBJY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICBjb250ZW50OiBbXG4gICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gIF1cbn0pYFxuICAgIH0pOyBsZXQgZXg3ID0gRXhhbXBsZS5ydW4oc291cmNlcywge1xuICAgICAgVk5vZGUkOiB4cy5vZihVSS5CcmVhZGNydW1iLnJlbmRlcih7XG4gICAgICAgIHN0eWxlOiB7IHNpemU6IFVJLlNpemUuSHVnZSwgZGl2aWRlcjogVUkuSWNvbi5yZW5kZXIoVUkuSWNvblR5cGUuQXJyb3dSaWdodCkgfSxcbiAgICAgICAgY29udGVudDogW1xuICAgICAgICAgIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlJlZ2lzdHJhdGlvblwiLCBocmVmOiBcIiNcIiB9LFxuICAgICAgICAgIHsgdGV4dDogXCJQZXJzb25hbCBJbmZvcm1hdGlvblwiLCBhY3RpdmU6IHRydWUgfVxuICAgICAgICBdXG4gICAgICB9KSksXG4gICAgICBjb2RlOiBgQnJlYWRjcnVtYi5yZW5kZXIoe1xuICBzdHlsZTogeyBzaXplOiBTaXplLkh1Z2UsIGRpdmlkZXI6IEljb24ucmVuZGVyKFVJLkljb25UeXBlLkFycm93UmlnaHQpIH0sXG4gIGNvbnRlbnQ6IFtcbiAgICB7IHRleHQ6IFwiSG9tZVwiLCBocmVmOiBcIiNcIiB9LFxuICAgIHsgdGV4dDogXCJSZWdpc3RyYXRpb25cIiwgaHJlZjogXCIjXCIgfSxcbiAgICB7IHRleHQ6IFwiUGVyc29uYWwgSW5mb3JtYXRpb25cIiwgYWN0aXZlOiB0cnVlIH1cbiAgXVxufSlgXG4gICAgfSk7IGxldCBleDggPSBFeGFtcGxlLnJ1bihzb3VyY2VzLCB7XG4gICAgICBWTm9kZSQ6IHhzLm9mKFVJLkJyZWFkY3J1bWIucmVuZGVyKHtcbiAgICAgICAgc3R5bGU6IHsgc2l6ZTogVUkuU2l6ZS5NYXNzaXZlLCBkaXZpZGVyOiBVSS5JY29uLnJlbmRlcihVSS5JY29uVHlwZS5BcnJvd1JpZ2h0KSB9LFxuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgeyB0ZXh0OiBcIkhvbWVcIiwgaHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7IHRleHQ6IFwiUmVnaXN0cmF0aW9uXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgeyB0ZXh0OiBcIlBlcnNvbmFsIEluZm9ybWF0aW9uXCIsIGFjdGl2ZTogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICAgIH0pKSxcbiAgICAgIGNvZGU6IGBCcmVhZGNydW1iLnJlbmRlcih7XG4gIHN0eWxlOiB7IHNpemU6IFNpemUuTWFzc2l2ZSwgZGl2aWRlcjogSWNvbi5yZW5kZXIoVUkuSWNvblR5cGUuQXJyb3dSaWdodCkgfSxcbiAgY29udGVudDogW1xuICAgIHsgdGV4dDogXCJIb21lXCIsIGhyZWY6IFwiI1wiIH0sXG4gICAgeyB0ZXh0OiBcIlJlZ2lzdHJhdGlvblwiLCBocmVmOiBcIiNcIiB9LFxuICAgIHsgdGV4dDogXCJQZXJzb25hbCBJbmZvcm1hdGlvblwiLCBhY3RpdmU6IHRydWUgfVxuICBdXG59KWBcbiAgICB9KTtcbiAgICByZXR1cm4geHMuY29tYmluZShleDEuRE9NLCBleDIuRE9NLCBleDMuRE9NLCBleDQuRE9NLCBleDUuRE9NLCBleDYuRE9NLCBleDcuRE9NLCBleDguRE9NKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvY29sbGVjdGlvbnMvYnJlYWRjcnVtYi50cyIsImV4cG9ydCAqIGZyb20gXCIuL2JyZWFkY3J1bWJcIjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL2NvbGxlY3Rpb25zL2luZGV4LnRzIiwiaW1wb3J0ICogYXMgVUkgZnJvbSBcIi4uL3VpXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCB7IGRpdiwgcCwgcHJlLCBjb2RlLCBWTm9kZSwgYnIsIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmRlY2xhcmUgdmFyIGhsanM6IGFueTtcblxuZXhwb3J0IG5hbWVzcGFjZSBFeGFtcGxlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBcmd1bWVudHMge1xuICAgIFZOb2RlJDogU3RyZWFtPFZOb2RlPjtcbiAgICBjb2RlOiBzdHJpbmc7XG4gICAgaGVhZGVyPzogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlcywgYXJnczogQXJndW1lbnRzKSB7XG4gICAgLy9TaG93IGNvZGUgaWNvblxuICAgIGxldCBidG5TaG93ID0gVUkuSWNvbi5ydW4oe1xuICAgICAgRE9NOiBzb3VyY2VzLkRPTSxcbiAgICAgIGNvbnRlbnQkOiB4cy5vZihVSS5JY29uVHlwZS5Db2RlKVxuICAgIH0pO1xuICAgIGxldCBhbmltYXRpb24kID0gYnRuU2hvdy5FdmVudHMoXCJjbGlja1wiKS5mb2xkKChwcmV2LCBuKSA9PiAhcHJldiwgZmFsc2UpLmRyb3AoMSkubWFwKFxuICAgICAgbiA9PiAoe1xuICAgICAgICBhbmltYXRpb246IFVJLkFuaW1hdGlvbi5TbGlkZSxcbiAgICAgICAgZGlyZWN0aW9uOiBuID8gVUkuRGlyZWN0aW9uLkluIDogVUkuRGlyZWN0aW9uLk91dFxuICAgICAgfSlcbiAgICApLnN0YXJ0V2l0aCh7XG4gICAgICBhbmltYXRpb246IFVJLkFuaW1hdGlvbi5Ob25lLFxuICAgICAgZGlyZWN0aW9uOiBVSS5EaXJlY3Rpb24uT3V0XG4gICAgfSk7XG5cbiAgICAvL1NsaWRpbmcgY29kZSB2aWV3XG4gICAgbGV0IGNvZGUkID0geHMub2YoXG4gICAgICBVSS5TZWdtZW50LnJlbmRlcih7IGF0dGFjaG1lbnQ6IFVJLkF0dGFjaG1lbnQuQm90dG9tIH0sIFtwcmUoW1xuICAgICAgICBjb2RlKHtcbiAgICAgICAgICBwcm9wczogeyBjbGFzc05hbWU6IFwiamF2YXNjcmlwdFwiIH0sIGhvb2s6IHtcbiAgICAgICAgICAgIGluc2VydDogKHZub2RlKSA9PiB7IGhsanMuaGlnaGxpZ2h0QmxvY2sodm5vZGUuZWxtKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgYXJncy5jb2RlLnNwbGl0KC9cXHI/XFxuLykubWFwKGxpbmUgPT4gW2xpbmUsIGJyKCldKS5yZWR1Y2UoKGFjYywgbikgPT4gYWNjLmNvbmNhdChuKSwgW10pKVxuICAgICAgXSlcbiAgICAgIF0pXG4gICAgKTtcbiAgICBsZXQgYW5pbWF0ZWRDb2RlJCA9IFVJLlRyYW5zaXRpb24ucnVuKHtcbiAgICAgIERPTTogc291cmNlcy5ET00sXG4gICAgICB0YXJnZXQkOiBjb2RlJCxcbiAgICAgIGFyZ3MkOiBhbmltYXRpb24kXG4gICAgfSk7XG5cbiAgICAvL0V4YW1wbGUgYmFyXG4gICAgbGV0IHRvcCQgPSB4cy5jb21iaW5lKGFuaW1hdGlvbiQsIGFyZ3MuVk5vZGUkKS5tYXAoKFthbmltYXRpb24sIG9ial0pID0+IHtcbiAgICAgIGxldCBpc0FjdGl2ZSA9IGFuaW1hdGlvbi5kaXJlY3Rpb24gPT09IFVJLkRpcmVjdGlvbi5JbjtcbiAgICAgIGxldCBlbGVtID0gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBpc0FjdGl2ZSA/IFwidWkgdG9wIGF0dGFjaGVkIHNlZ21lbnQgY29kZVwiIDogXCJjb2RlXCIgfSB9LCBbXG4gICAgICAgIGlzQWN0aXZlID8gVUkuTGFiZWwucmVuZGVyKHsgYXR0YWNobWVudDogVUkuQXR0YWNobWVudC5Ub3AgfSwgW1xuICAgICAgICAgIFwiRXhhbXBsZVwiXG4gICAgICAgIF0pIDogZGl2KHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSwgcHJvcHM6IHsgY2xhc3NOYW1lOiBcIlwiIH0gfSksXG4gICAgICAgIG9ialxuICAgICAgXSk7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9KTtcbiAgICBsZXQgdlRyZWUkID0geHMuY29tYmluZShidG5TaG93LkRPTSwgYW5pbWF0ZWRDb2RlJC5ET00sIHRvcCQpLm1hcChcbiAgICAgIChbYnRuU2hvdywgY29kZSwgdG9wXSkgPT4ge1xuICAgICAgICBsZXQgY29udGVudCA9IFtidG5TaG93LCB0b3AsIGNvZGVdO1xuICAgICAgICBpZiAodHlwZW9mIChhcmdzLmRlc2NyaXB0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGNvbnRlbnQgPSBbcChhcmdzLmRlc2NyaXB0aW9uKV0uY29uY2F0KGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGFyZ3MuaGVhZGVyKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGNvbnRlbnQgPSBbVUkuSGVhZGVyLnJlbmRlcihhcmdzLmhlYWRlcildLmNvbmNhdChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImV4YW1wbGVcIiB9IH0sIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIERPTTogdlRyZWUkXG4gICAgfTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvY29tcG9uZW50cy9leGFtcGxlLnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vZXhhbXBsZVwiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy1zcmMvY29tcG9uZW50cy9pbmRleC50cyIsImltcG9ydCAqIGFzIFVJIGZyb20gXCIuLi91aVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG5pbXBvcnQge2RpdiwgVk5vZGV9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgSW5kZXgge1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXMpIHtcbiAgICBjb25zdCB2VHJlZSQgPSB4cy5vZihcbiAgICAgIGRpdihcIi5jZW50ZXJlZFwiLCBbXG4gICAgICAgIFVJLkNvbnRhaW5lci5yZW5kZXIoW1xuICAgICAgICAgIFVJLkdyaWQucmVuZGVyKHtjZW50ZXJlZDogdHJ1ZX0sIFtcbiAgICAgICAgICAgIFVJLlJvdy5yZW5kZXIoW1xuICAgICAgICAgICAgICBVSS5IZWFkZXIucmVuZGVyKHtzaXplOiBVSS5TaXplLkh1Z2V9LCBcIldlbGNvbWUuXCIsIHtcbiAgICAgICAgICAgICAgICBzdWJ0ZXh0OiBcIkF0IHRoZSBtb21lbnQgdGhlIGRvY3MgYXJlIGEgV0lQLiBQbGFubmVkIHBhZ2VzIGFyZSBzY2FmZm9sZGVkIGluIHRoZSBzaWRlbWVudS5cIlxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICByb3V0ZXI6IHhzLm5ldmVyKClcbiAgICB9O1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy9pbmRleC9pbmRleC50cyIsIi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuaW1wb3J0IHsgZGl2LCBWTm9kZSB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeyBTaWRlYmFyIH0gZnJvbSBcIi4vc2lkZWJhclwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIExheW91dCB7XG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogYW55LCBwYWdlOiBhbnkpIHtcblxuICAgIC8qKiogQ3JlYXRlIGNvbXBvbmVudHMgKioqL1xuICAgIGxldCBzaWRlYmFyID0gU2lkZWJhci5ydW4oc291cmNlcyk7XG4gICAgLyoqKiBDb21wb3NlIHZpZXcgKioqL1xuICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc2lkZWJhci5ET00sIHBhZ2UuRE9NLClcbiAgICAgIC5tYXAoKFtzaWRlYmFyLCBwYWdlXSkgPT5cbiAgICAgICAgZGl2KFwiLmZ1bGwuaGVpZ2h0XCIsIFtcbiAgICAgICAgICBkaXYoXCIuY29udGVudC5wdXNoZXJcIiwgW1xuICAgICAgICAgICAgc2lkZWJhcixcbiAgICAgICAgICAgIHBhZ2VcbiAgICAgICAgICBdKSxcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIERPTTogdlRyZWUkLFxuICAgICAgcm91dGVyOiBwYWdlLnJvdXRlclxuICAgIH07XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL2xheW91dC9pbmRleC50cyIsImltcG9ydCAqIGFzIFVJIGZyb20gXCIuLi8uLi91aVwiO1xuaW1wb3J0IHhzLCB7IFN0cmVhbSB9IGZyb20gXCJ4c3RyZWFtXCI7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG5pbXBvcnQgeyBkaXYsIFZOb2RlIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBTaWRlYmFyIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzKSB7XG4gICAgbGV0IGN1cnJlbnRQYWdlJCA9IHNvdXJjZXMucm91dGVyLmhpc3RvcnkkLm1hcCh4ID0+IHgucGF0aG5hbWUpIGFzIFN0cmVhbTxzdHJpbmc+O1xuICAgIGxldCBwcmVmaXggPSBcIi9jeWNsZS1zZW1hbnRpYy11aVwiO1xuICAgIGNvbnN0IHZUcmVlJCA9IGN1cnJlbnRQYWdlJC5tYXAocGFnZSA9PlxuICAgICAgZGl2KFwiLmxlZnQubWVudVwiLCBbXG4gICAgICAgIGRpdihcIi5maXhlZFwiLCBbXG4gICAgICAgICAgVUkuTWVudS5yZW5kZXIoe1xuICAgICAgICAgICAgdmVydGljYWw6IHRydWUsIGludmVydGVkOiB0cnVlLFxuICAgICAgICAgICAgYXR0YWNobWVudDogVUkuQXR0YWNobWVudC5Ob25lLCBzaXplOiBVSS5TaXplLkZsdWlkXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IFtcIkludHJvZHVjdGlvblwiLCBVSS5NZW51LnJlbmRlcihcbiAgICAgICAgICAgICAgeyBzdWJtZW51OiB0cnVlLCB9LCBbe1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL1wiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL1wiIHx8IHBhZ2UgPT09IHByZWZpeCArIFwiL2hvbWVcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkFib3V0XCJcbiAgICAgICAgICAgICAgfV0pXVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogW1wiRWxlbWVudHNcIiwgVUkuTWVudS5yZW5kZXIoXG4gICAgICAgICAgICAgIHsgc3VibWVudTogdHJ1ZSwgfSwgW3tcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9idXR0b25cIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9lbGVtZW50cy9idXR0b25cIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkJ1dHRvblwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9jb250YWluZXJcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9lbGVtZW50cy9jb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkNvbnRhaW5lclwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9kaXZpZGVyXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvZGl2aWRlclwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiRGl2aWRlclwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9oZWFkZXJcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9lbGVtZW50cy9oZWFkZXJcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkhlYWRlclwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9pY29uXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvaWNvblwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiSWNvblwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9pbWFnZVwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL2ltYWdlXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJJbWFnZVwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9sYWJlbFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2VsZW1lbnRzL2xhYmVsXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJMYWJlbFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9saXN0XCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvbGlzdFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiTGlzdFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9sb2FkZXJcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9lbGVtZW50cy9sb2FkZXJcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkxvYWRlclwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9zZWdtZW50XCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvc2VnbWVudFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiU2VnbWVudFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy9zdGVwXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvc3RlcFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiU3RlcFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9lbGVtZW50cy90ZXh0Ym94XCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvZWxlbWVudHMvdGV4dGJveFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiVGV4dGJveFwiXG4gICAgICAgICAgICAgIH1dKV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IFtcIkNvbGxlY3Rpb25zXCIsIFVJLk1lbnUucmVuZGVyKFxuICAgICAgICAgICAgICB7IHN1Ym1lbnU6IHRydWUsIH0sIFt7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvY29sbGVjdGlvbnMvYnJlYWRjcnVtYlwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL2JyZWFkY3J1bWJcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkJyZWFkY3J1bWJcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvY29sbGVjdGlvbnMvZm9ybVwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL2Zvcm1cIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkZvcm1cIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvY29sbGVjdGlvbnMvZ3JpZFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL2dyaWRcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkdyaWRcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvY29sbGVjdGlvbnMvbWVudVwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL21lbnVcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIk1lbnVcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvY29sbGVjdGlvbnMvbWVzc2FnZVwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL2NvbGxlY3Rpb25zL21lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIk1lc3NhZ2VcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvY29sbGVjdGlvbnMvdGFibGVcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9jb2xsZWN0aW9ucy90YWJsZVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiVGFibGVcIlxuICAgICAgICAgICAgICB9XSldXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBbXCJNb2R1bGVzXCIsIFVJLk1lbnUucmVuZGVyKFxuICAgICAgICAgICAgICB7IHN1Ym1lbnU6IHRydWUsIH0sIFt7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvbW9kdWxlcy9jaGVja2JveFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL21vZHVsZXMvY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkNoZWNrYm94XCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL21vZHVsZXMvZGltbWVyXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvbW9kdWxlcy9kaW1tZXJcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIkRpbW1lclwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9tb2R1bGVzL2Ryb3Bkb3duXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvbW9kdWxlcy9kcm9wZG93blwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiRHJvcGRvd25cIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvbW9kdWxlcy9tb2RhbFwiLCBhY3RpdmU6IHBhZ2UgPT09IHByZWZpeCArIFwiL21vZHVsZXMvbW9kYWxcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIk1vZGFsXCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbms6IHRydWUsIGhyZWY6IHByZWZpeCArIFwiL21vZHVsZXMvcG9wdXBcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi9tb2R1bGVzL3BvcHVwXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJQb3B1cFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi9tb2R1bGVzL3Byb2dyZXNzXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvbW9kdWxlcy9wcm9ncmVzc1wiLFxuICAgICAgICAgICAgICAgIGJvZHk6IFwiUHJvZ3Jlc3NcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluazogdHJ1ZSwgaHJlZjogcHJlZml4ICsgXCIvbW9kdWxlcy90cmFuc2l0aW9uXCIsIGFjdGl2ZTogcGFnZSA9PT0gcHJlZml4ICsgXCIvbW9kdWxlcy90cmFuc2l0aW9uXCIsXG4gICAgICAgICAgICAgICAgYm9keTogXCJUcmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgfV0pXVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogW1wiVmlld3NcIiwgVUkuTWVudS5yZW5kZXIoXG4gICAgICAgICAgICAgIHsgc3VibWVudTogdHJ1ZSwgfSwgW3tcbiAgICAgICAgICAgICAgICBsaW5rOiB0cnVlLCBocmVmOiBwcmVmaXggKyBcIi92aWV3cy9zdGF0aXN0aWNcIiwgYWN0aXZlOiBwYWdlID09PSBwcmVmaXggKyBcIi92aWV3cy9zdGF0aXN0aWNcIixcbiAgICAgICAgICAgICAgICBib2R5OiBcIlN0YXRpc3RpY1wiXG4gICAgICAgICAgICAgIH1dKV1cbiAgICAgICAgICB9XSlcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICByb3V0ZXI6IHhzLm5ldmVyKClcbiAgICB9O1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy9sYXlvdXQvc2lkZWJhci9pbmRleC50cyIsImltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHhzLCB7U3RyZWFtfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IHtET01Tb3VyY2V9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmludGVyZmFjZSBDb21wb25lbnRSb3V0ZXJTb3VyY2VzIHtcbiAgcm91dGVzOiBhbnk7XG4gIHJvdXRlcjogYW55O1xuICBET006IERPTVNvdXJjZTtcbn1cblxuY29uc3QgY2FsbFBhZ2UgPSBmdW5jdGlvbiAoc291cmNlczogQ29tcG9uZW50Um91dGVyU291cmNlcykge1xuICByZXR1cm4gKHtwYXRoLCB2YWx1ZX0pID0+IHtcbiAgICBjb25zdCBwU291cmNlcyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZXMsIHtyb3V0ZXI6IHNvdXJjZXMucm91dGVyLnBhdGgocGF0aCl9KTtcbiAgICBjb25zdCBpc29sYXRlZFBhZ2UgPSBpc29sYXRlKHZhbHVlKShwU291cmNlcykgYXMgYW55O1xuICAgIHJldHVybiBpc29sYXRlZFBhZ2U7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBwcm9wT3JOZXZlcihrZXk6IHN0cmluZywgeDogT2JqZWN0KSB7XG4gIGlmICh4Lmhhc093blByb3BlcnR5KGtleSkpe1xuICAgIHJldHVybiB4W2tleV07XG4gIH1cbiAgcmV0dXJuIHhzLm5ldmVyKCk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5CeUtleShrZXk6IHN0cmluZywgc3RyZWFtOiBTdHJlYW08YW55Pikge1xuICAgIHJldHVybiBzdHJlYW0ubWFwKHggPT4gcHJvcE9yTmV2ZXIoa2V5LCB4KSkuZmxhdHRlbigpO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnRSb3V0ZXIgKHNvdXJjZXM6IENvbXBvbmVudFJvdXRlclNvdXJjZXMpIHtcbiAgY29uc3QgY29tcG9uZW50JCA9IHNvdXJjZXMucm91dGVyLmRlZmluZShzb3VyY2VzLnJvdXRlcylcbiAgICAubWFwKHJvdXRlID0+IGNhbGxQYWdlKHNvdXJjZXMpKHJvdXRlKSlcbiAgICAucmVtZW1iZXIoKVxuICAgIC5kZWJ1ZygoKSA9PiB7fSk7IC8vU3RhdGUkIGRvZXMgbm90IHdvcmsgd2l0aG91dCB0aGlzIGxpbmUuIFVuYWJsZSB0byByZXByb2R1Y2UgaW4gd2VicGFja2Jpbi5cbiAgY29uc3QgcGx1Y2sgPSBrZXkgPT4gZmxhdHRlbkJ5S2V5KGtleSwgY29tcG9uZW50JCk7XG4gIGNvbnN0IHNpbmtzID0ge1xuICAgIHBsdWNrOiBwbHVjayxcbiAgICBET006IHBsdWNrKFwiRE9NXCIpLFxuICAgIHJvdXRlcjogcGx1Y2soXCJyb3V0ZXJcIiksXG4gIH07XG4gIHJldHVybiBzaW5rcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc291cmNlcyA9PiBpc29sYXRlKENvbXBvbmVudFJvdXRlcikoc291cmNlcyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzLXNyYy9yb3V0ZXIudHMiLCIvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG5pbXBvcnQgeyBWTm9kZSB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHsgQnJlYWRjcnVtYn0gZnJvbSBcIi4vY29sbGVjdGlvbnNcIjtcblxuXG5sZXQgcHJlZml4ID0gXCIvY3ljbGUtc2VtYW50aWMtdWlcIjtcbmxldCByb3V0ZXMgPSB7XG4gIFwiL1wiOiBJbmRleC5ydW4sXG59O1xucm91dGVzW3ByZWZpeCArIFwiL2NvbGxlY3Rpb25zL2JyZWFkY3J1bWJcIl0gPSBCcmVhZGNydW1iLnJ1bjtcbmV4cG9ydCBkZWZhdWx0IHJvdXRlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3Mtc3JjL3JvdXRlcy50cyIsImltcG9ydCB7IGRpdiwgYSwgc3BhbiwgVk5vZGUgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IENvbXBvbmVudFNvdXJjZXMsIENvbnRlbnRPYmosIERPTUNvbnRlbnQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IFNpemUsIFNpemVTdHJpbmcgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBCcmVhZGNydW1iIHtcbiAgZXhwb3J0IGludGVyZmFjZSBTdHlsZSB7XG4gICAgZGl2aWRlcj86IFZOb2RlIHwgc3RyaW5nO1xuICAgIHNpemU/OiBTaXplIHwgU2l6ZVN0cmluZztcbiAgfVxuICBleHBvcnQgdHlwZSBDb250ZW50ID0gQXJyYXk8QnJlYWRDcnVtYkl0ZW0+O1xuICBleHBvcnQgaW50ZXJmYWNlIEJyZWFkQ3J1bWJJdGVtIHtcbiAgICBhY3RpdmU/OiBib29sZWFuO1xuICAgIHRleHQ/OiBET01Db250ZW50O1xuICAgIGhyZWY/OiBzdHJpbmc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBCcmVhZENydW1iQXJncyB7XG4gICAgc3R5bGU/OiBTdHlsZTtcbiAgICBjb250ZW50PzogQ29udGVudE9iajxDb250ZW50PiB8IENvbnRlbnQ7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKGFyZzE/OiBTdHlsZSB8IENvbnRlbnQgfCBCcmVhZENydW1iQXJncywgYXJnMj86IENvbnRlbnQpOiBWTm9kZSB7XG4gICAgaWYgKGlzQXJncyhhcmcxKSkge1xuICAgICAgcmV0dXJuIGJyZWFkY3J1bWIoYXJnMSk7XG4gICAgfVxuICAgIGxldCBhcmdzOiBCcmVhZENydW1iQXJncyA9IHt9O1xuICAgIGlmIChpc0NvbnRlbnQoYXJnMSkpIHtcbiAgICAgIGFyZ3Muc3R5bGUgPSB7IGRpdmlkZXI6IFwiL1wiIH07XG4gICAgICBhcmdzLmNvbnRlbnQgPSB7IG1haW46IGFyZzEgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy5zdHlsZSA9IGFyZzEgfHwgeyBkaXZpZGVyOiBcIi9cIiB9O1xuICAgICAgYXJncy5jb250ZW50ID0geyBtYWluOiBhcmcyIHx8IFtdIH07XG4gICAgfVxuICAgIHJldHVybiBicmVhZGNydW1iKGFyZ3MpO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBDb21wb25lbnRTb3VyY2VzPFN0eWxlLCBDb250ZW50T2JqPENvbnRlbnQ+IHwgQ29udGVudD4pIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IENvbXBvbmVudFNvdXJjZXM8U3R5bGUsIENvbnRlbnRPYmo8Q29udGVudD4gfCBDb250ZW50Pikge1xuICAgICAgc291cmNlcy5zdHlsZSQgPSBzb3VyY2VzLnN0eWxlJCA/IHNvdXJjZXMuc3R5bGUkIDogeHMub2YoeyBkaXZpZGVyOiBcIi9cIiB9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcbiAgICAgIGNvbnN0IGJyZWFkY3J1bWIkID0geHMuY29tYmluZShzb3VyY2VzLnN0eWxlJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3N0eWxlLCBjb250ZW50XSkgPT4gcmVuZGVyKHtcbiAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgY29udGVudDogaXNDb250ZW50KGNvbnRlbnQpID8geyBtYWluOiBjb250ZW50IH0gOiBjb250ZW50XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiBicmVhZGNydW1iJCxcbiAgICAgICAgRXZlbnRzOiB0eXBlID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5icmVhZGNydW1iXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuICBmdW5jdGlvbiBicmVhZGNydW1iKGFyZ3M6IEJyZWFkQ3J1bWJBcmdzKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0NvbnRlbnQoYXJncy5jb250ZW50KSA/IGFyZ3MuY29udGVudCA6IGFyZ3MuY29udGVudC5tYWluO1xuICAgIGxldCBjaGlsZHJlbiA9IGNvbnRlbnQubWFwKGMgPT4gW1xuICAgICAgc2VjdGlvbihjKSwgZGl2aWRlcihhcmdzLnN0eWxlKVxuICAgIF0pLnJlZHVjZSgoYSwgbikgPT4gYS5jb25jYXQobiksIFtdKTtcbiAgICBjaGlsZHJlbi5zcGxpY2UoLTEsIDEpO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzTmFtZShhcmdzLnN0eWxlKSB9IH0sIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShzdHlsZTogU3R5bGUpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHR5cGVvZiAoc3R5bGUuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHN0eWxlLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lICsgXCIgYnJlYWRjcnVtYlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VjdGlvbihzZWN0aW9uOiBCcmVhZENydW1iSXRlbSk6IFZOb2RlIHtcbiAgICByZXR1cm4gc2VjdGlvbi5hY3RpdmVcbiAgICAgID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImFjdGl2ZSBzZWN0aW9uXCIgfSB9LCBzZWN0aW9uLnRleHQpXG4gICAgICA6IHNlY3Rpb24uaHJlZiBcbiAgICAgICAgPyBhKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInNlY3Rpb25cIiwgaHJlZjogc2VjdGlvbi5ocmVmIH0gfSwgc2VjdGlvbi50ZXh0KVxuICAgICAgICA6IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJzZWN0aW9uXCIgfSB9LCBzZWN0aW9uLnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIGRpdmlkZXIoc3R5bGU6IFN0eWxlKTogVk5vZGUge1xuICAgIGlmICh0eXBlb2YgKHN0eWxlLmRpdmlkZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gc3Bhbih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkaXZpZGVyXCIgfSB9LCBzdHlsZS5kaXZpZGVyKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLmRpdmlkZXIuZGF0YS5wcm9wcy5jbGFzc05hbWUuaW5kZXhPZihcInVpXCIpICE9PSAtMSkge1xuICAgICAgc3R5bGUuZGl2aWRlci5kYXRhLnByb3BzLmNsYXNzTmFtZSA9IHN0eWxlLmRpdmlkZXIuZGF0YS5wcm9wcy5jbGFzc05hbWUuc3Vic3RyaW5nKDMpO1xuICAgIH1cbiAgICBpZiAoc3R5bGUuZGl2aWRlci5kYXRhLnByb3BzLmNsYXNzTmFtZS5pbmRleE9mKFwiZGl2aWRlclwiKSA9PT0gLTEpIHtcbiAgICAgIHN0eWxlLmRpdmlkZXIuZGF0YS5wcm9wcy5jbGFzc05hbWUgKz0gXCIgZGl2aWRlclwiO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGUuZGl2aWRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29udGVudChvYmopOiBvYmogaXMgQ29udGVudCB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xuICB9XG4gIGZ1bmN0aW9uIGlzQXJncyhvYmopOiBvYmogaXMgQnJlYWRDcnVtYkFyZ3Mge1xuICAgIHJldHVybiBvYmogJiYgKFxuICAgICAgdHlwZW9mIChvYmouc3R5bGUpICE9PSBcInVuZGVmaW5lZFwiIHx8XG4gICAgICAodHlwZW9mIChvYmouY29udGVudCkgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNDb250ZW50KG9iai5jb250ZW50Lm1haW4pKVxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9icmVhZGNydW1iL2luZGV4LnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzLFxuICBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50XG59IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBudW1Ub1RleHQgfSBmcm9tIFwiLi4vLi4vdXRpbHNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYsIGxhYmVsLCBWTm9kZSB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmllbGQge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBpbmxpbmU/OiBib29sZWFuO1xuICAgIGNlbnRlcmVkPzogYm9vbGVhbjtcbiAgICByZXF1aXJlZD86IGJvb2xlYW47XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGNvbnRlbnQgaW4gYSBGaWVsZCBzdWl0YWJsZSBmb3IgdGhlIEZvcm0gY29tcG9uZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgd2lkdGg/OiBudW1iZXIgLSBUaGUgd2lkdGggb2YgdGhlIGZpZWxkIGluIGdyaWQgY29sdW1ucy5cbiAgICogICBpbmxpbmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBuZXh0IHRvIHRoZSBmaWVsZCBpbnN0ZWFkIG9mIGFib3ZlIGl0LlxuICAgKiAgIGNlbnRlcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY29udGVudCBvZiB0aGUgZmllbGQgdG8gYmUgY2VudGVyZWQuXG4gICAqICAgcmVxdWlyZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmaWVsZCB0byBzaG93IGl0IGlzIG1hbmRhdG9yeS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge30gb2ZcbiAgICogICBsYWJlbD86IERPTUNvbnRlbnQgLSBUaGUgbGFiZWwgZm9yIHRoZSBmaWVsZC5cbiAgICogICBib2R5OiBET01Db250ZW50IC0gVGhlIGZpZWxkIGlucHV0LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLmV4dHJhcyQgPSBzb3VyY2VzLmV4dHJhcyQgPyBzb3VyY2VzLmV4dHJhcyQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCwgc291cmNlcy5leHRyYXMkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnQsIGV4dHJhXSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50LCBleHRyYSlcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmZpZWxkXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBjb250ZW50IGluIGEgRmllbGQgc3VpdGFibGUgZm9yIHRoZSBGb3JtIGNvbXBvbmVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgd2lkdGg/OiBudW1iZXIgLSBUaGUgd2lkdGggb2YgdGhlIGZpZWxkIGluIGdyaWQgY29sdW1ucy5cbiAgICogICBpbmxpbmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBuZXh0IHRvIHRoZSBmaWVsZCBpbnN0ZWFkIG9mIGFib3ZlIGl0LlxuICAgKiAgIGNlbnRlcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY29udGVudCBvZiB0aGUgZmllbGQgdG8gYmUgY2VudGVyZWQuXG4gICAqICAgcmVxdWlyZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmaWVsZCB0byBzaG93IGl0IGlzIG1hbmRhdG9yeS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDoge30gb2ZcbiAgICogICBsYWJlbD86IERPTUNvbnRlbnQgLSBUaGUgbGFiZWwgZm9yIHRoZSBmaWVsZC5cbiAgICogICBib2R5OiBET01Db250ZW50IC0gVGhlIGZpZWxkIGlucHV0LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIsIGU6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIGxldCBleHRyYSA9IGlzRE9NQ29udGVudChwT3JDKSA/IChjID09PSBcIlwiKSA/IGUgOiBjIDogZTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW10uY29uY2F0KGV4dHJhID8gbGFiZWwoZXh0cmEpIDogXCJcIiwgY29udGVudCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcykge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLndpZHRoKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KHByb3BzLndpZHRoKSArIFwiIHdpZGVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlubGluZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGlubGluZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2VudGVyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjZW50ZXJlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmVxdWlyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByZXF1aXJlZFwiO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgZmllbGRcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9maWVsZC50cyIsImltcG9ydCB7XG4gIERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLFxuICBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50XG59IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBudW1Ub1RleHQgfSBmcm9tIFwiLi4vLi4vdXRpbHNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYsIGxhYmVsIH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBGaWVsZHMge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBsYWJlbD86IERPTUNvbnRlbnQ7XG4gICAgZXF1YWxXaWR0aD86IGJvb2xlYW47XG4gICAgZ3JvdXBlZD86IGJvb2xlYW47XG4gICAgaW5saW5lPzogYm9vbGVhbjtcbiAgICByZXF1aXJlZD86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgbXVsdGlwbGUgcmVsYXRlZCBGaWVsZCBjb21wb25lbnRzIHRvZ2V0aGVyLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgbGFiZWw/OiBET01Db250ZW50IC0gQSBsYWJlbCBmb3IgdGhlIGZpZWxkcy5cbiAgICogICBlcXVhbFdpZHRoPzogYm9vbGVhbiAtIERpdmlkZXMgZmllbGRzIGluIGVxdWFsIHdpZHRoLlxuICAgKiAgIGdyb3VwZWQ/OiBib29sZWFuIC0gR3JvdXBzIGZpZWxkcyB0b2dldGhlciBmb3IgcmVsYXRlZCBjaG9pY2VzLlxuICAgKiAgIGlubGluZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVscyB0byBiZSBuZXh0IHRvIHRoZSBmaWVsZHMgaW5zdGVhZCBvZiBhYm92ZSB0aGVtLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5maWVsZHNcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgICB2YWx1ZSQ6IHhzLm5ldmVyKClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBtdWx0aXBsZSByZWxhdGVkIEZpZWxkIGNvbXBvbmVudHMgdG9nZXRoZXIuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGxhYmVsPzogRE9NQ29udGVudCAtIEEgbGFiZWwgZm9yIHRoZSBmaWVsZHMuXG4gICAqICAgZXF1YWxXaWR0aD86IGJvb2xlYW4gLSBEaXZpZGVzIGZpZWxkcyBpbiBlcXVhbCB3aWR0aC5cbiAgICogICBncm91cGVkPzogYm9vbGVhbiAtIEdyb3VwcyBmaWVsZHMgdG9nZXRoZXIgZm9yIHJlbGF0ZWQgY2hvaWNlcy5cbiAgICogICBpbmxpbmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbHMgdG8gYmUgbmV4dCB0byB0aGUgZmllbGRzIGluc3RlYWQgb2YgYWJvdmUgdGhlbS5cbiAgICogICByZXF1aXJlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRoZSBmaWVsZHMgdG8gbWFrZSB0aGVtIGFwcGVhciBtYW5kZXRvcnkuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIGxldCBsYmwgPSBwcm9wcy5sYWJlbCA/IGxhYmVsKHByb3BzLmxhYmVsKSA6IFwiXCI7XG4gICAgbGV0IGNoaWxkcmVuID0gKDxBcnJheTxhbnk+PmNvbnRlbnQpLmxlbmd0aCA/IFtsYmxdLmNvbmNhdChjb250ZW50KSA6IFtsYmwsIGNvbnRlbnRdO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcywgY29udGVudCkgfSB9LCBjaGlsZHJlbik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzLCBjb250ZW50KSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuZXF1YWxXaWR0aCAmJiBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChjb250ZW50Lmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbmxpbmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbmxpbmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmdyb3VwZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBncm91cGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yZXF1aXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBmaWVsZHNcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9maWVsZHMudHMiLCJpbXBvcnQge1xuICBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcyxcbiAgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudFxufSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSB9IGZyb20gXCIuLi8uLi9lbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgRm9ybSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGxvYWRpbmc/OiBib29sZWFuO1xuICAgIGVxdWFsV2lkdGg/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBzaXplPzogU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZvcm0gY29tcG9uZW50IGZvciBjYXB0dXJpbmcgZ3JvdXBzIG9mIHVzZXIgaW5wdXQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBsb2FkaW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZm9ybSB3aXRoIGEgbG9hZGVyLlxuICAgKiAgIGVxdWFsV2lkdGg/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmb3JtIGNvbnRlbnQgdG8gaGF2ZSBlcXVhbCB3aWR0aHMgcGVyIHJvdy5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZvcm0gZm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgZm9ybSdzIGNvbnRlbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpXG4gICAgICAgIC5tYXAoKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuZm9ybVwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZvcm0gY29tcG9uZW50IGZvciBjYXB0dXJpbmcgZ3JvdXBzIG9mIHVzZXIgaW5wdXQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGxvYWRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBmb3JtIHdpdGggYSBsb2FkZXIuXG4gICAqICAgZXF1YWxXaWR0aD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGZvcm0gY29udGVudCB0byBoYXZlIGVxdWFsIHdpZHRocyBwZXIgcm93LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgZm9ybSBmb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBmb3JtJ3MgY29udGVudC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNvbnRlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5sb2FkaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbG9hZGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZXF1YWxXaWR0aCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGVxdWFsIHdpZHRoXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIGZvcm1cIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZm9ybS9mb3JtLnRzIiwiZXhwb3J0ICogZnJvbSBcIi4vZm9ybVwiXG5leHBvcnQgKiBmcm9tIFwiLi9maWVsZFwiXG5leHBvcnQgKiBmcm9tIFwiLi9maWVsZHNcIlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2Zvcm0vaW5kZXgudHMiLCJpbXBvcnQge1xuICBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcyxcbiAgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudFxufSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgVmVydGljYWxBbGlnbm1lbnQsIFRleHRBbGlnbm1lbnQsIFNpemUsIEZsb2F0IH0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgeyBudW1Ub1RleHQgfSBmcm9tIFwiLi4vLi4vdXRpbHNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbHVtbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIG1vYmlsZT86IG51bWJlcjtcbiAgICB0YWJsZXQ/OiBudW1iZXI7XG4gICAgY29tcHV0ZXI/OiBudW1iZXI7XG4gICAgbGFyZ2VzY3JlZW4/OiBudW1iZXI7XG4gICAgc2l6ZT86IFNpemU7XG4gICAgYWxpZ25tZW50PzogVmVydGljYWxBbGlnbm1lbnQ7XG4gICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQ7XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgfVxuICAvKipcbiAgICogV3JhcHMgY29udGVudCBpbiBhIGNvbHVtbiBzdWl0YWJsZSBmb3IgdGhlIEdyaWQgY29tcG9uZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFdldGhlciB0aGUgY29sdW1uIHNob3VsZCBiZSBsZWZ0IG9yIHJpZ2h0IGZsb2F0ZWQuXG4gICAqICAgd2lkdGg/OiBpbnQgLSBUaGUgZGVmYXVsdCB3aWR0aCBvZiB0aGUgY29sdW1uLlxuICAgKiAgIG1vYmlsZT86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiAgIHRhYmxldD86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIHRhYmxldCBkZXZpY2VzLlxuICAgKiAgIGNvbXB1dGVyPzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gY29tcHV0ZXIgZGV2aWNlcy5cbiAgICogICBsYXJnZXNjcmVlbj86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIGxhcmdlIHNjcmVlbiBkZXZpY2VzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGNvbHVtbi5cbiAgICogICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudCAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGhlIGNvbHVtbi5cbiAgICogICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudCAtIFRoZSB0ZXh0IGFsaWdubWVudCBvZiB0aGUgY29sdW1uLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIENvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5jb2x1bW5cIikuZXZlbnRzKHR5cGUpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGNvbnRlbnQgaW4gYSBjb2x1bW4gc3VpdGFibGUgZm9yIHRoZSBHcmlkIGNvbXBvbmVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFdldGhlciB0aGUgY29sdW1uIHNob3VsZCBiZSBsZWZ0IG9yIHJpZ2h0IGZsb2F0ZWQuXG4gICAqICAgd2lkdGg/OiBpbnQgLSBUaGUgZGVmYXVsdCB3aWR0aCBvZiB0aGUgY29sdW1uLlxuICAgKiAgIG1vYmlsZT86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiAgIHRhYmxldD86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIHRhYmxldCBkZXZpY2VzLlxuICAgKiAgIGNvbXB1dGVyPzogaW50IC0gVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gb24gY29tcHV0ZXIgZGV2aWNlcy5cbiAgICogICBsYXJnZXNjcmVlbj86IGludCAtIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIG9uIGxhcmdlIHNjcmVlbiBkZXZpY2VzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGNvbHVtbi5cbiAgICogICBhbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudCAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGhlIGNvbHVtbi5cbiAgICogICB0ZXh0QWxpZ25tZW50PzogVGV4dEFsaWdubWVudCAtIFRoZSB0ZXh0IGFsaWdubWVudCBvZiB0aGUgY29sdW1uLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgY29udGVudCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuZmxvYXQgJiYgcHJvcHMuZmxvYXQgPT09IEZsb2F0LlJpZ2h0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmlnaHQgZmxvYXRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmxvYXQgJiYgcHJvcHMuZmxvYXQgPT09IEZsb2F0LkxlZnQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsZWZ0IGZsb2F0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm1vYmlsZSkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChwcm9wcy5tb2JpbGUpICsgXCIgd2lkZSBtb2JpbGVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRhYmxldCkge1xuICAgICAgY2xhc3NOYW1lICs9IG51bVRvVGV4dChwcm9wcy50YWJsZXQpICsgXCIgd2lkZSB0YWJsZXRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXB1dGVyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KHByb3BzLmNvbXB1dGVyKSArIFwiIHdpZGUgY29tcHV0ZXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxhcmdlc2NyZWVuKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KHByb3BzLmxhcmdlc2NyZWVuKSArIFwiIHdpZGUgbGFyZ2VzY3JlZW5cIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVmVydGljYWxBbGlnbm1lbnQuVG9DbGFzc25hbWUocHJvcHMuYWxpZ25tZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMudGV4dEFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBUZXh0QWxpZ25tZW50LlRvQ2xhc3NuYW1lKHByb3BzLnRleHRBbGlnbm1lbnQpO1xuICAgIH1cbiAgICBpZiAocHJvcHMud2lkdGgpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQocHJvcHMud2lkdGgpICsgXCIgd2lkZVwiO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgY29sdW1uXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2dyaWQvY29sdW1uLnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IFZlcnRpY2FsQWxpZ25tZW50LCBUZXh0QWxpZ25tZW50IH0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgeyBudW1Ub1RleHQgfSBmcm9tIFwiLi4vLi4vdXRpbHNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEdyaWQge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBlcXVhbGx5RGl2aWRlZD86IGJvb2xlYW47XG4gICAgZGl2aWRlZD86IGJvb2xlYW47XG4gICAgY29udGFpbmVyPzogYm9vbGVhbjtcbiAgICBjZWxsZWQ/OiBib29sZWFuO1xuICAgIGludENlbGxlZD86IGJvb2xlYW47XG4gICAgcGFkZGVkPzogYm9vbGVhbjtcbiAgICByZWxheGVkPzogYm9vbGVhbjtcbiAgICBjZW50ZXJlZD86IGJvb2xlYW47XG4gICAgYWxpZ25tZW50PzogVmVydGljYWxBbGlnbm1lbnQ7XG4gICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29udGVudCBpbiBhIGNvbHVtbiBzdWl0YWJsZSBmb3IgdGhlIEdyaWQgY29tcG9uZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgZXF1YWxseURpdmlkZWQ/OiBib29sZWFuIC0gU3R5bGVzIGdyaWQgY29udGVudCB0byB0YWtlIHVwIGVxdWFsIGFtb3VudHMgb2Ygc3BhY2UuXG4gICAqICAgZGl2aWRlZD86IGJvb2xlYW4gLSBVc2UgZGl2aWRlcnMgdG8gc2VwZXJhdGUgY29udGVudCBpbiB0aGUgR3JpZC5cbiAgICogICBjb250YWluZXI/IDogYm9vbGVhbiAtIFdyYXBzIHRoZSBncmlkIGluIGEgY29udGFpbmVyLlxuICAgKiAgIGNlbGxlZD86IGJvb2xlYW4gLSBEaXZpZGVzIHRoZSBncmlkIGludG8gY2VsbHMuXG4gICAqICAgaW50Q2VsbGVkPzogYm9vbGVhbiAtIERpdmlkZXMgdGhlIGdyaWQgaW50byBjZWxscyB3aXRoIG9ubHkgaW50ZXJuYWwgZGl2aWRlcnMuXG4gICAqICAgcGFkZGVkPzogYm9vbGVhbiAtIEFkZHMgdmVydGljYWwgYW5kIGhvcml6b250YWwgZ3V0dGVycyB0byB0aGUgZ3JpZC5cbiAgICogICByZWxheGVkPzogYm9vbGVhbiAtIEluY3JlYXNlcyB0aGUgYW1vdW50IG9mIG5lZ2F0aXZlIHNwYWNlLlxuICAgKiAgIGNlbnRlcmVkPzogYm9vbGVhbiAtIENlbnRlcnMgdGhlIGNvbnRlbnQgb2YgdGhlIEdyaWQuXG4gICAqICAgYWxpZ25tZW50PzogVmVydGljYWxBbGlnbm1lbnQ6IERldGVybWluZXMgdGhlIGFsaWdubWVudCBvZiBjb250ZW50IGluIHRoZSBHcmlkLlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50OiBEZXRlcm1pbmVzIHRoZSB0ZXh0IGFsaWdubWVudCBvZiBjb250ZW50IGluIHRoZSBHcmlkLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKVxuICAgICAgICAubWFwKChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmdyaWRcIikuZXZlbnRzKHR5cGUpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGNvbnRlbnQgaW4gYSBjb2x1bW4gc3VpdGFibGUgZm9yIHRoZSBHcmlkIGNvbXBvbmVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgZXF1YWxseURpdmlkZWQ/OiBib29sZWFuIC0gU3R5bGVzIGdyaWQgY29udGVudCB0byB0YWtlIHVwIGVxdWFsIGFtb3VudHMgb2Ygc3BhY2UuXG4gICAqICAgZGl2aWRlZD86IGJvb2xlYW4gLSBVc2UgZGl2aWRlcnMgdG8gc2VwZXJhdGUgY29udGVudCBpbiB0aGUgR3JpZC5cbiAgICogICBjb250YWluZXI/IDogYm9vbGVhbiAtIFdyYXBzIHRoZSBncmlkIGluIGEgY29udGFpbmVyLlxuICAgKiAgIGNlbGxlZD86IGJvb2xlYW4gLSBEaXZpZGVzIHRoZSBncmlkIGludG8gY2VsbHMuXG4gICAqICAgaW50Q2VsbGVkPzogYm9vbGVhbiAtIERpdmlkZXMgdGhlIGdyaWQgaW50byBjZWxscyB3aXRoIG9ubHkgaW50ZXJuYWwgZGl2aWRlcnMuXG4gICAqICAgcGFkZGVkPzogYm9vbGVhbiAtIEFkZHMgdmVydGljYWwgYW5kIGhvcml6b250YWwgZ3V0dGVycyB0byB0aGUgZ3JpZC5cbiAgICogICByZWxheGVkPzogYm9vbGVhbiAtIEluY3JlYXNlcyB0aGUgYW1vdW50IG9mIG5lZ2F0aXZlIHNwYWNlLlxuICAgKiAgIGNlbnRlcmVkPzogYm9vbGVhbiAtIENlbnRlcnMgdGhlIGNvbnRlbnQgb2YgdGhlIEdyaWQuXG4gICAqICAgYWxpZ25tZW50PzogVmVydGljYWxBbGlnbm1lbnQ6IERldGVybWluZXMgdGhlIGFsaWdubWVudCBvZiBjb250ZW50IGluIHRoZSBHcmlkLlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50OiBEZXRlcm1pbmVzIHRoZSB0ZXh0IGFsaWdubWVudCBvZiBjb250ZW50IGluIHRoZSBHcmlkLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMsIGNvbnRlbnQpIH0gfSwgY29udGVudCk7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMsIGNvbnRlbnQpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmVxdWFsbHlEaXZpZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KGNvbnRlbnQubGVuZ3RoID8gY29udGVudC5sZW5ndGggOiAxKSArIFwiIGNvbHVtblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpdmlkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbnRhaW5lcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbnRhaW5lclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2VsbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2VsbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnRDZWxsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnRlcm5hbGx5IGNlbGxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucGFkZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcGFkZGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yZWxheGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmVsYXhlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2VudGVyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjZW50ZXJlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVmVydGljYWxBbGlnbm1lbnQuVG9DbGFzc25hbWUocHJvcHMuYWxpZ25tZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMudGV4dEFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBUZXh0QWxpZ25tZW50LlRvQ2xhc3NuYW1lKHByb3BzLnRleHRBbGlnbm1lbnQpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgZ3JpZFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9ncmlkL2dyaWQudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9ncmlkXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yb3dcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbHVtblwiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL2dyaWQvaW5kZXgudHMiLCJpbXBvcnQge1xuICBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcyxcbiAgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudFxufSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgbnVtVG9UZXh0IH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBSb3cge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBzdHJldGNoZWQ/OiBib29sZWFuO1xuICAgIG1vYmlsZT86IGJvb2xlYW47XG4gICAgdGFibGV0PzogYm9vbGVhbjtcbiAgICBjb21wdXRlcj86IGJvb2xlYW47XG4gICAgbGFyZ2VzY3JlZW4/OiBib29sZWFuO1xuICAgIGVxdWFsbHlEaXZpZGVkPzogYm9vbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUm93IGNvbXBvbmVudCB0aGF0IHdyYXBzIENvbHVtbiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgc3RyZXRjaGVkPzogYm9vbGVhbiAtIEVuc3VyZXMgdGhlIGNvbHVtbnMgYXJlIHN0cmV0Y2hlZCB0byBlcXVhbCBoZWlnaHQuXG4gICAqICAgbW9iaWxlPzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiAgIHRhYmxldD86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiB0YWJsZXQgZGV2aWNlcy5cbiAgICogICBjb21wdXRlcj86IGJvb2xlYW4gLSBNYWtlcyB0aGUgcm93IHZpc2libGUgb25seSBvbiBjb21wdXRlciBkZXZpY2VzLlxuICAgKiAgIGxhcmdlc2NyZWVuPzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIGxhcmdlc2NyZWVuIGRldmljZXMuXG4gICAqICAgZXF1YWxseURpdmlkZWQ/OiBib29sZWFuIC0gTWFrZXMgZWFjaCBjb2x1bW4gb2YgdGhlIHJvdyBlcXVhbCBpbiB3aWR0aC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIucm93XCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUm93IGNvbXBvbmVudCB0aGF0IHdyYXBzIENvbHVtbiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogICBzdHJldGNoZWQ/OiBib29sZWFuIC0gRW5zdXJlcyB0aGUgY29sdW1ucyBhcmUgc3RyZXRjaGVkIHRvIGVxdWFsIGhlaWdodC5cbiAgICogICBtb2JpbGU/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gbW9iaWxlIGRldmljZXMuXG4gICAqICAgdGFibGV0PzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIHRhYmxldCBkZXZpY2VzLlxuICAgKiAgIGNvbXB1dGVyPzogYm9vbGVhbiAtIE1ha2VzIHRoZSByb3cgdmlzaWJsZSBvbmx5IG9uIGNvbXB1dGVyIGRldmljZXMuXG4gICAqICAgbGFyZ2VzY3JlZW4/OiBib29sZWFuIC0gTWFrZXMgdGhlIHJvdyB2aXNpYmxlIG9ubHkgb24gbGFyZ2VzY3JlZW4gZGV2aWNlcy5cbiAgICogICBlcXVhbGx5RGl2aWRlZD86IGJvb2xlYW4gLSBNYWtlcyBlYWNoIGNvbHVtbiBvZiB0aGUgcm93IGVxdWFsIGluIHdpZHRoLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzfERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzLCBjb250ZW50KSB9IH0sIGNvbnRlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMsIGNvbnRlbnQpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnN0cmV0Y2hlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHN0cmV0Y2hlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubW9iaWxlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbW9iaWxlIG9ubHlcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRhYmxldCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRhYmxldCBvbmx5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wdXRlcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXB1dGVyIG9ubHlcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxhcmdlc2NyZWVuKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgbGFyZ2VzY3JlZW4gb25seVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZXF1YWxseURpdmlkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBudW1Ub1RleHQoY29udGVudC5sZW5ndGggPyBjb250ZW50Lmxlbmd0aCA6IDEpICsgXCIgY29sdW1uXCI7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiByb3dcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29sbGVjdGlvbnMvZ3JpZC9yb3cudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9icmVhZGNydW1iXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9mb3JtXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ncmlkXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tZW51XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tZXNzYWdlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90YWJsZVwiO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50IH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IEljb25UeXBlLCBTaXplLCBDb2xvciwgQW5pbWF0aW9uLCBEaXJlY3Rpb24gfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gXCIuLi8uLi9lbGVtZW50cy9pY29uXCI7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4uLy4uL21vZHVsZXMvdHJhbnNpdGlvblwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBvbiQ/OiBTdHJlYW08Ym9vbGVhbj47XG4gICAgY2xvc2VhYmxlPzogYm9vbGVhbjtcbiAgICBpY29uPzogYm9vbGVhbjtcbiAgICBmbG9hdGluZz86IGJvb2xlYW47XG4gICAgY29tcGFjdD86IGJvb2xlYW47XG4gICAgYXR0YWNoZWQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDb250ZW50IHtcbiAgICBpY29uPzogSWNvblR5cGU7XG4gICAgaGVhZGVyPzogRE9NQ29udGVudDtcbiAgICBib2R5PzogRE9NQ29udGVudDtcbiAgfVxuICAvKipcbiAgICogQSBtZXNzYWdlIGNvbXBvbmVudCB0byBwcmVzZW50IG1lc3NhZ2VzIHRvIHVzZXJzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgb24kPzogU3RyZWFtPGJvb2xlYW4+IC0gV2hlbiB0byBzaG93L2hpZGUgdGhlIG1lc3NhZ2UuXG4gICAqICAgY2xvc2VhYmxlPzogYm9vbGVhbiAtIFByb3ZpZGVzIGEgY2xvc2UgaWNvbiBmb3IgdGhlIG1lc3NhZ2UgZm9yIGRpc21pc3NhbC5cbiAgICogICBpY29uPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIG1lc3NhZ2UgdG8gc3VwcG9ydCBhbiBpY29uLlxuICAgKiAgIGZsb2F0aW5nPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIG1lc3NhZ2UgdG8gZmxvYXQgYWJvdmUgcmVsYXRlZCBjb250ZW50LlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gRm9ybWF0cyBhIG1lc3NhZ2UgdG8gb25seSBvY2N1cHkgd2lkdGggbmVlZGVkIGJ5IGl0cyBjb250ZW50LlxuICAgKiAgIGF0dGFjaGVkPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIG1lc3NhZ2UgdG8gYXBwZWFyIGF0dGFjaGVkIHRvIG90aGVyIGNvbnRlbnQuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgbWVzc2FnZS5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiB7fVxuICAgKiAgIGljb24/OiBTdHJpbmd8Vk5vZGUgLSBBIG1lc3NhZ2UgY2FuIGhhdmUgYW4gaWNvbiBzaWduaWZ5aW5nIHRoZSB0eXBlIG9mIG1lc3NhZ2UuXG4gICAqICAgaGVhZGVyPzogU3RyaW5nfFZOb2RlIC0gQSBtZXNzYWdlIGNhbiBoYXZlIGEgaGVhZGVyIHRleHQuXG4gICAqICAgYm9keT86IFN0cmluZ3xWTm9kZSAtIEEgbWVzc2FnZSBjYW4gaGF2ZSBhZGRpdGlvbmFseSBib2R5IGNvbnRlbnQuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCBpY29uID0gSWNvbi5ydW4oeyBET006IHNvdXJjZXMuRE9NLCBwcm9wcyQ6IHhzLm9mKHsgdHlwZTogXCJjbG9zZVwiIH0pIH0pO1xuICAgICAgY29uc3QgY2xvc2UkID0gaWNvbi5FdmVudHMoXCJjbGlja1wiKS5tYXBUbyhmYWxzZSk7XG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkLCBpY29uLkRPTSlcbiAgICAgICAgLm1hcCgoW3Byb3BzLCBjb250ZW50LCBjbG9zZUljb25dKSA9PlxuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIFtcbiAgICAgICAgICAgIGNvbnRlbnQuaWNvbixcbiAgICAgICAgICAgIHByb3BzLmNsb3NlYWJsZSA/IGNsb3NlSWNvbiA6IFwiXCIsXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiY29udGVudFwiIH0gfSwgW10uY29uY2F0KFxuICAgICAgICAgICAgICBjb250ZW50LmhlYWRlciA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJoZWFkZXJcIiB9IH0sIGNvbnRlbnQuaGVhZGVyKSA6IFwiXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQuYm9keVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgY29uc3Qgb24kID0gc291cmNlcy5wcm9wcyQubWFwKHByb3BzID0+IHByb3BzLm9uJCA/IHByb3BzLm9uJCA6IHhzLm9mKHRydWUpKS5mbGF0dGVuKCk7XG4gICAgICBjb25zdCBhY3RpdmUkID0geHMubWVyZ2Uob24kLCBjbG9zZSQpO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiQgPSBhY3RpdmUkLmZvbGQoKHByZXZBbmltLCBhY3RpdmUpID0+IHByZXZBbmltLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5vbmVcbiAgICAgICAgPyB7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogYWN0aXZlID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dCB9XG4gICAgICAgIDogeyBhbmltYXRpb246IEFuaW1hdGlvbi5GYWRlLCBkaXJlY3Rpb246IGFjdGl2ZSA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXQgfVxuICAgICAgICAsIHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uTm9uZSB9KTtcbiAgICAgIGNvbnN0IGFuaW1hdGVkVlRyZWUkID0gVHJhbnNpdGlvbi5ydW4oeyBET006IHNvdXJjZXMuRE9NLCB0YXJnZXQkOiB2VHJlZSQsIGFyZ3MkOiB0cmFuc2l0aW9uJCB9KS5ET007XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IGFuaW1hdGVkVlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIubWVzc2FnZVwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1lc3NhZ2UgY29tcG9uZW50IHRvIHByZXNlbnQgbWVzc2FnZXMgdG8gdXNlcnMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIG9uJD86IFN0cmVhbTxib29sZWFuPiAtIFdoZW4gdG8gc2hvdy9oaWRlIHRoZSBtZXNzYWdlLlxuICAgKiAgIGNsb3NlYWJsZT86IGJvb2xlYW4gLSBQcm92aWRlcyBhIGNsb3NlIGljb24gZm9yIHRoZSBtZXNzYWdlIGZvciBkaXNtaXNzYWwuXG4gICAqICAgaWNvbj86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZXNzYWdlIHRvIHN1cHBvcnQgYW4gaWNvbi5cbiAgICogICBmbG9hdGluZz86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZXNzYWdlIHRvIGZsb2F0IGFib3ZlIHJlbGF0ZWQgY29udGVudC5cbiAgICogICBjb21wYWN0PzogYm9vbGVhbiAtIEZvcm1hdHMgYSBtZXNzYWdlIHRvIG9ubHkgb2NjdXB5IHdpZHRoIG5lZWRlZCBieSBpdHMgY29udGVudC5cbiAgICogICBhdHRhY2hlZD86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBtZXNzYWdlIHRvIGFwcGVhciBhdHRhY2hlZCB0byBvdGhlciBjb250ZW50LlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIG1lc3NhZ2UuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbWVzc2FnZS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDoge31cbiAgICogICBpY29uPzogU3RyaW5nfFZOb2RlIC0gQSBtZXNzYWdlIGNhbiBoYXZlIGFuIGljb24gc2lnbmlmeWluZyB0aGUgdHlwZSBvZiBtZXNzYWdlLlxuICAgKiAgIGhlYWRlcj86IFN0cmluZ3xWTm9kZSAtIEEgbWVzc2FnZSBjYW4gaGF2ZSBhIGhlYWRlciB0ZXh0LlxuICAgKiAgIGJvZHk/OiBTdHJpbmd8Vk5vZGUgLSBBIG1lc3NhZ2UgY2FuIGhhdmUgYWRkaXRpb25hbHkgYm9keSBjb250ZW50LlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IENvbnRlbnQgPSB7fSwgYzogQ29udGVudCA9IHt9KTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIGNvbnN0IGNsb3NlSWNvbiA9IEljb24ucmVuZGVyKHt9LCBJY29uVHlwZS5DbG9zZSk7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIFtcbiAgICAgIGNvbnRlbnQuaWNvbiA/IEljb24ucmVuZGVyKGNvbnRlbnQuaWNvbikgOiBcIlwiLFxuICAgICAgcHJvcHMuY2xvc2VhYmxlID8gY2xvc2VJY29uIDogXCJcIixcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBbXS5jb25jYXQoXG4gICAgICAgIGNvbnRlbnQuaGVhZGVyID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImhlYWRlclwiIH0gfSwgY29udGVudC5oZWFkZXIpIDogXCJcIixcbiAgICAgICAgY29udGVudC5ib2R5XG4gICAgICApKVxuICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZsb2F0aW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZmxvYXRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbXBhY3QpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb21wYWN0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5hdHRhY2hlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGF0dGFjaGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgbWVzc2FnZVwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbnRlbnQoY29udGVudCk6IGNvbnRlbnQgaXMgQ29udGVudCB7XG4gICAgcmV0dXJuIGNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiAoaXNET01Db250ZW50KGNvbnRlbnQuaWNvbikgfHwgaXNET01Db250ZW50KGNvbnRlbnQuaGVhZGVyKSB8fCBpc0RPTUNvbnRlbnQoY29udGVudC5ib2R5KSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb2xsZWN0aW9ucy9tZXNzYWdlL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnQgfSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgQ29sb3IgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyB0YWJsZSwgdHIsIHRoLCB0ZCwgdGhlYWQsIHRib2R5LCB0Zm9vdCB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGFibGUge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBzaW5nbGVsaW5lPzogYm9vbGVhbjtcbiAgICBmaXhlZD86IGJvb2xlYW47XG4gICAgc2VsZWN0YWJsZT86IGJvb2xlYW47XG4gICAgc3RyaXBlZD86IGJvb2xlYW47XG4gICAgY2VsbGVkPzogYm9vbGVhbjtcbiAgICBiYXNpYz86IGJvb2xlYW47XG4gICAgdmVyeWJhc2ljPzogYm9vbGVhbjtcbiAgICBjb2xsYXBzaW5nPzogYm9vbGVhbjtcbiAgICBwYWRkZWQ/OiBib29sZWFuO1xuICAgIHZlcnlwYWRkZWQ/OiBib29sZWFuO1xuICAgIGNvbXBhY3Q/OiBib29sZWFuO1xuICAgIHZlcnljb21wYWN0PzogYm9vbGVhbjtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBjb2xvcj86IENvbG9yO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29udGVudCB7XG4gICAgaGVhZGVyPzogQXJyYXk8RE9NQ29udGVudD47XG4gICAgYm9keTogQXJyYXk8QXJyYXk8RE9NQ29udGVudD4+O1xuICAgIGZvb3Rlcj86IEFycmF5PERPTUNvbnRlbnQ+IHwgRE9NQ29udGVudDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEEgdGFibGUgY29tcG9uZW50IHRvIHNob3cgY29udGVudCBpbiBhIHRhYmxlLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgc2luZ2xlbGluZT86IGJvb2xlYW4gLSBGb3JtYXRzIHRoZSBjb250ZW50IG9mIHRoZSB0YWJsZSB0byBmaXQgb24gYSBzaW5nbGUgbGluZS5cbiAgICogICBmaXhlZD86IGJvb2xlYW4gLSBTdG9wcyByZXNpemluZyBvZiB0YWJsZSBjZWxscyBiYXNlZCBvbiBjb250ZW50LlxuICAgKiAgIHNlbGVjdGFibGU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSByb3dzIG9mIHRoZSB0YWJsZSB0byBiZSBzZWxlY3RhYmxlLlxuICAgKiAgIHN0cmlwZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSByb3dzIG9mIHRoZSB0YWJsZSB0byBhbHRlcm5hdGUgY29sb3JzLlxuICAgKiAgIGNlbGxlZD86IGJvb2xlYW4gLSBEaXZpZGVzIGVhY2ggcm93IGludG8gc2VwZXJhdGUgY2VsbHMuXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gUmVkdWNlcyB0aGUgY29tcGxleGl0eSBvZiB0aGUgdGFibGUuXG4gICAqICAgdmVyeWJhc2ljPzogYm9vbGVhbiAtIFJlZHVjZXMgdGhlIGNvbXBsZXhpdHkgb2YgdGhlIHRhYmxlIGJ5IGEgbG90LlxuICAgKiAgIGNvbGxhcHNpbmc/OiBib29sZWFuIC0gTWFrZXMgdGhlIHRhYmxlIG9ubHkgdGFrZSB1cCBhcyBtdWNoIHNwYWNlIGFzIG5lZWRlZC5cbiAgICogICBwYWRkZWQ/OiBib29sZWFuIC0gQWRkcyBleHRyYSBwYWRkaW5nIHRvIHRoZSB0YWJsZSBjb250ZW50LlxuICAgKiAgIHZlcnlwYWRkZWQ/OiBib29sZWFuIC0gQWRkcyBhIGxvdCBvZiBleHRyYSBwYWRkaW5nIHRvIHRoZSB0YWJsZSBjb250ZW50LlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0YWJsZSBjb250ZW50IHRvIGJlIG1vcmUgY29tcGFjdCwgdG8gYWxsb3cgZm9yIG1vcmUgcm93cy5cbiAgICogICB2ZXJ5Y29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRhYmxlIGNvbnRlbnQgdG8gYmUgZ3JlYXRseSBjb21wYWN0ZWQuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGFibGUgY29udGVudC5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG91ciBvZiB0aGUgdGFibGUuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IHt9IG9mXG4gICAqIFx0aGVhZGVyczogW0RPTUNvbnRlbnRdXG4gICAqIFx0Ym9keTogW1tEb21Db250ZW50XV1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoeyBib2R5OiBbXSB9KTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIudGFibGVcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSB0YWJsZSBjb21wb25lbnQgdG8gc2hvdyBjb250ZW50IGluIGEgdGFibGUuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBzaW5nbGVsaW5lPzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRhYmxlIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lLlxuICAgKiAgIGZpeGVkPzogYm9vbGVhbiAtIFN0b3BzIHJlc2l6aW5nIG9mIHRhYmxlIGNlbGxzIGJhc2VkIG9uIGNvbnRlbnQuXG4gICAqICAgc2VsZWN0YWJsZT86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHJvd3Mgb2YgdGhlIHRhYmxlIHRvIGJlIHNlbGVjdGFibGUuXG4gICAqICAgc3RyaXBlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHJvd3Mgb2YgdGhlIHRhYmxlIHRvIGFsdGVybmF0ZSBjb2xvcnMuXG4gICAqICAgY2VsbGVkPzogYm9vbGVhbiAtIERpdmlkZXMgZWFjaCByb3cgaW50byBzZXBlcmF0ZSBjZWxscy5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBSZWR1Y2VzIHRoZSBjb21wbGV4aXR5IG9mIHRoZSB0YWJsZS5cbiAgICogICB2ZXJ5YmFzaWM/OiBib29sZWFuIC0gUmVkdWNlcyB0aGUgY29tcGxleGl0eSBvZiB0aGUgdGFibGUgYnkgYSBsb3QuXG4gICAqICAgY29sbGFwc2luZz86IGJvb2xlYW4gLSBNYWtlcyB0aGUgdGFibGUgb25seSB0YWtlIHVwIGFzIG11Y2ggc3BhY2UgYXMgbmVlZGVkLlxuICAgKiAgIHBhZGRlZD86IGJvb2xlYW4gLSBBZGRzIGV4dHJhIHBhZGRpbmcgdG8gdGhlIHRhYmxlIGNvbnRlbnQuXG4gICAqICAgdmVyeXBhZGRlZD86IGJvb2xlYW4gLSBBZGRzIGEgbG90IG9mIGV4dHJhIHBhZGRpbmcgdG8gdGhlIHRhYmxlIGNvbnRlbnQuXG4gICAqICAgY29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRhYmxlIGNvbnRlbnQgdG8gYmUgbW9yZSBjb21wYWN0LCB0byBhbGxvdyBmb3IgbW9yZSByb3dzLlxuICAgKiAgIHZlcnljb21wYWN0PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGFibGUgY29udGVudCB0byBiZSBncmVhdGx5IGNvbXBhY3RlZC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0YWJsZSBjb250ZW50LlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3VyIG9mIHRoZSB0YWJsZS5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge30gb2ZcbiAgICogXHRoZWFkZXJzOiBbRE9NQ29udGVudF1cbiAgICogXHRib2R5OiBbW0RvbUNvbnRlbnRdXVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IENvbnRlbnQgPSB7fSwgYzogQ29udGVudCA9IHsgYm9keTogW10gfSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0NvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0NvbnRlbnQocE9yQykgPyBwT3JDIDogYztcblxuICAgIGxldCBoZWFkZXIgPSBjb250ZW50LmhlYWRlciA/IHRoZWFkKFt0cihjb250ZW50LmhlYWRlci5tYXAoaCA9PiB0aChoKSkpXSkgOiBcIlwiO1xuICAgIGxldCBmb290ZXI7XG4gICAgaWYgKGlzRE9NQ29udGVudChjb250ZW50LmZvb3RlcikpIHtcbiAgICAgIGZvb3RlciA9IHRmb290KGNvbnRlbnQuZm9vdGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb290ZXIgPSBjb250ZW50LmZvb3RlciA/IHRmb290KFt0cihjb250ZW50LmZvb3Rlci5tYXAoZiA9PiB0aChmKSkpXSkgOiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZSh7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIFtcbiAgICAgIGhlYWRlcixcbiAgICAgIHRib2R5KGNvbnRlbnQuYm9keS5tYXAociA9PiB0cihyLm1hcChjID0+IHRkKGMpKSkpKSxcbiAgICAgIGZvb3RlclxuICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcykge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnNpbmdsZWxpbmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzaW5nbGUgbGluZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZml4ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmaXhlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2VsZWN0YWJsZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNlbGVjdGFibGVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnN0cmlwZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzdHJpcGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jZWxsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjZWxsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmJhc2ljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYmFzaWNcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnliYXNpYykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnkgYmFzaWNcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbGxhcHNpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjb2xsYXBzaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wYWRkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwYWRkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnlwYWRkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ5IHBhZGRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcGFjdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXBhY3RcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnljb21wYWN0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVyeSBjb21wYWN0XCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgdGFibGVcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb250ZW50KGNvbnRlbnQpOiBjb250ZW50IGlzIENvbnRlbnQge1xuICAgIHJldHVybiBjb250ZW50ICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgKDxDb250ZW50PmNvbnRlbnQpLmJvZHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKCg8Q29udGVudD5jb250ZW50KS5oZWFkZXIgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoPENvbnRlbnQ+Y29udGVudCkuZm9vdGVyICE9PSB1bmRlZmluZWQpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbGxlY3Rpb25zL3RhYmxlL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgU2l6ZSwgQXR0YWNobWVudCwgRmxvYXQgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYsIGEgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEJ1dHRvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGFuaW1hdGVkPzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbEFuaW1hdGVkPzogYm9vbGVhbjtcbiAgICBsYWJlbGVkPzogYm9vbGVhbjtcbiAgICByaWdodGxhYmVsZWQ/OiBib29sZWFuO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGJhc2ljPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgY29tcGFjdD86IGJvb2xlYW47XG4gICAgY2lyY3VsYXI/OiBib29sZWFuO1xuICAgIGZsdWlkPzogYm9vbGVhbjtcbiAgICBocmVmPzogc3RyaW5nO1xuICAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50O1xuICAgIHNpemU/OiBTaXplO1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgfVxuICAvKipcbiAgICogQW4gaW50ZXJhY3RpdmUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdXNlciBpbnRlcmFjdGlvbiB0aHJvdWdoIGNsaWNraW5nLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBhbmltYXRlZD8gOiBib29sZWFuIC0gQWxsb3dzIGZvciBhbiBhbmltYXRpb24gaW4gdGhlIGJ1dHRvbiB0byBzaG93IGhpZGRlbiBjb250ZW50LlxuICAgKiAgIHZlcnRpY2FsQW5pbWF0ZWQ/OiBib29sZWFuIC0gU2VlIGFuaW1hdGVkLiBUaGlzIGFuaW1hdGlvbiBpcyB2ZXJ0aWNhbC5cbiAgICogICBsYWJlbGVkPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgbGFiZWxlZCBidXR0b25zLlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBidXR0b25zIHdpdGggYW4gaWNvbi5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgc2ltcGxlci5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgb24gZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBhY3RpdmU/OiBib29sZWFuIC0gU2V0cyB0aGUgYnV0dG9uIHRvIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGxvYWRpbmc/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gc2hvdyB0aGF0IGl0IGlzIGxvYWRpbmcgLyB3b3JraW5nLlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gZm9yIGEgdGlnaHQgZml0LlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGFwcGVhciBjaXJjdWxhci5cbiAgICogICBmbHVpZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBiZSBhcyB3aWRlIGFzIHBvc3NpYmxlLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBPdXRwdXRzIHRoZSBidXR0b24gYXMgYSBsaW5rIHRvIHRvIHRoZSBocmVmLlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gV2hlcmUgdGhlIGJ1dHRvbiBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYnV0dG9uLlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBUaGUgbGVmdCBvciByaWdodCBmbG9hdCBvZiB0aGUgYnV0dG9uLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGJ1dHRvbi5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge30gb2ZcbiAgICogICBib2R5PzogRE9NQ29udGVudCAtIFRoZSBib2R5IGNvbnRlbnQgdG8gZGlzcGxheSBvbiB0aGUgYnV0dG9uLlxuICAgKiAgIGhpZGRlbj86IERPTUNvbnRlbnQgLSBUaGUgaGlkZGVuIGNvbnRlbnQgdG8gZGlzcGxheSBmb3IgYW5pbWF0ZWQgYnV0dG9ucy5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50PikgOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcbiAgICAgIHNvdXJjZXMuZXh0cmFzJCA9IHNvdXJjZXMuZXh0cmFzJCA/IHNvdXJjZXMuZXh0cmFzJCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2dHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkLCBzb3VyY2VzLmV4dHJhcyQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudCwgZXh0cmFzXSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50LCBleHRyYXMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2dHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi51aS5idXR0b25cIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzdGF0aWMgYnV0dG9uIGNvbXBvbmVudCBmb3IgdXNlciBpbnRlcmFjdGlvbiB0aHJvdWdoIGNsaWNraW5nLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBwcm9wZXJ0aWVzOlxuICAgKiAgIGFuaW1hdGVkPyA6IGJvb2xlYW4gLSBBbGxvd3MgZm9yIGFuIGFuaW1hdGlvbiBpbiB0aGUgYnV0dG9uIHRvIHNob3cgaGlkZGVuIGNvbnRlbnQuXG4gICAqICAgdmVydGljYWxBbmltYXRlZD86IGJvb2xlYW4gLSBTZWUgYW5pbWF0ZWQuIFRoaXMgYW5pbWF0aW9uIGlzIHZlcnRpY2FsLlxuICAgKiAgIGxhYmVsZWQ/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBsYWJlbGVkIGJ1dHRvbnMuXG4gICAqICAgaWNvbj86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGJ1dHRvbnMgd2l0aCBhbiBpY29uLlxuICAgKiAgIGJhc2ljPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGFwcGVhciBzaW1wbGVyLlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGFwcGVhciBvbiBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIGFjdGl2ZT86IGJvb2xlYW4gLSBTZXRzIHRoZSBidXR0b24gdG8gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiBzaG93IHRoYXQgaXQgaXMgbG9hZGluZyAvIHdvcmtpbmcuXG4gICAqICAgY29tcGFjdD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGJ1dHRvbiBmb3IgYSB0aWdodCBmaXQuXG4gICAqICAgY2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBidXR0b24gdG8gYXBwZWFyIGNpcmN1bGFyLlxuICAgKiAgIGZsdWlkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgYnV0dG9uIHRvIGJlIGFzIHdpZGUgYXMgcG9zc2libGUuXG4gICAqICAgaHJlZj86IHN0cmluZyAtIE91dHB1dHMgdGhlIGJ1dHRvbiBhcyBhIGxpbmsgdG8gdG8gdGhlIGhyZWYuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBXaGVyZSB0aGUgYnV0dG9uIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBidXR0b24uXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFRoZSBsZWZ0IG9yIHJpZ2h0IGZsb2F0IG9mIHRoZSBidXR0b24uXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgYnV0dG9uLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiB7fSBvZlxuICAgKiAgIGJvZHk/OiBET01Db250ZW50IC0gVGhlIGJvZHkgY29udGVudCB0byBkaXNwbGF5IG9uIHRoZSBidXR0b24uXG4gICAqICAgaGlkZGVuPzogRE9NQ29udGVudCAtIFRoZSBoaWRkZW4gY29udGVudCB0byBkaXNwbGF5IGZvciBhbmltYXRlZCBidXR0b25zLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIsIGU6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckMgOiBjO1xuICAgIGxldCBleHRyYSA9IGlzRE9NQ29udGVudChwT3JDKSA/IChjICE9PSBcIlwiKSA/IGMgOiBlIDogZTtcbiAgICBsZXQgY2hpbGRyZW4gPSBleHRyYVxuICAgICAgPyBbZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInZpc2libGUgY29udGVudFwiIH0gfSwgY29udGVudCksXG4gICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiaGlkZGVuIGNvbnRlbnRcIiB9IH0sIGV4dHJhKV1cbiAgICAgIDogY29udGVudDtcbiAgICByZXR1cm4gcHJvcHMuaHJlZlxuICAgICAgPyBhKHsgcHJvcHM6IHsgaHJlZjogcHJvcHMuaHJlZiwgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgY2hpbGRyZW4pXG4gICAgICA6IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmFuaW1hdGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYW5pbWF0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsQW5pbWF0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ0aWNhbC5hbmltYXRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubGFiZWxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxhYmVsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJpZ2h0bGFiZWxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJpZ2h0IGxhYmVsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmljb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpY29uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5iYXNpYykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJhc2ljXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5hY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wYWN0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGFjdFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2lyY3VsYXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBjaXJjdWxhclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmx1aWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbHVpZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hdHRhY2htZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuZmxvYXQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gRmxvYXQuVG9DbGFzc25hbWUocHJvcHMuZmxvYXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5jb2xvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBDb2xvci5Ub0NsYXNzbmFtZShwcm9wcy5jb2xvcik7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBidXR0b25cIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvYnV0dG9uL2luZGV4LnRzIiwiaW1wb3J0IHtET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQge2Rpdn0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBDb250YWluZXIge1xuICAvKipcbiAgKiBBIHJlc3BvbnNpdmUgY29udGFpbmVyIGNvbXBvbmVudCB0byBob3N0IG90aGVyIGNvbnRlbnQuXG4gICogRG9lcyBub3QgYWNjZXB0IGFueSBwcm9wZXJ0aWVzIGluIHByb3BzJC5cbiAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxhbnksIERPTUNvbnRlbnQ+KSA6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8YW55LCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHNvdXJjZXMuY29udGVudCQubWFwKGNvbnRlbnQgPT4gcmVuZGVyKGNvbnRlbnQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuY29udGFpbmVyXCIpLmV2ZW50cyh0eXBlKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICogQSByZXNwb25zaXZlIGNvbnRhaW5lciBjb21wb25lbnQgdG8gaG9zdCBvdGhlciBjb250ZW50LlxuICAqIERvZXMgbm90IGFjY2VwdCBhbnkgcHJvcGVydGllcy5cbiAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogT2JqZWN0fERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpIDogVk5vZGUge1xuICAgIC8vIGxldCBwcm9wcyA9IGlzRE9NQ29udGVudChwT3JDKSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IGlzRE9NQ29udGVudChwT3JDKSA/IHBPckM6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ1aSBjb250YWluZXJcIn19LCBjb250ZW50KTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2NvbnRhaW5lci9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnR9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHtkaXZ9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgRGl2aWRlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGhvcml6b250YWw/OiBib29sZWFuO1xuICAgIHZlcnRpY2FsPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgZml0dGVkPzogYm9vbGVhbjtcbiAgICBoaWRkZW4/OiBib29sZWFuO1xuICAgIHNlY3Rpb24/OiBib29sZWFuO1xuICAgIGNsZWFyaW5nPzogYm9vbGVhbjtcbiAgICBoZWFkZXI/OiBib29sZWFuO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGl2aWRlciBlbGVtZW50IHRvIHNlcGVyYXRlIGNvbnRlbnQgb24gcGFnZS5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiBcdGNvbnRlbnQ/OiBWTm9kZSAtIFRoZSBjb250ZW50IHRvIGFkZCB0byB0aGUgZGl2aWRlci5cbiAgICogXHRob3Jpem9udGFsPzogYm9vbGVhbiAtIE5lZWRlZCB0byByZW5kZXIgdGV4dCBob3Jpem9udGFsbHkgaW4gdGhlIGRpdmlkZXIuXG4gICAqIFx0dmVydGljYWw/OiBib29sZWFuIC0gRGV0ZXJtaW5lcyB2ZXJ0aWNhbC9ob3Jpem9udGFsIG9yaWVudGF0aW9uIG9mIHRoZSBkaXZpZGVyLlxuICAgKiBcdGludmVydGVkPzogYm9vbGVhbiAtIEZvciBkYXJrIGJhY2tncm91bmRzLlxuICAgKiBcdGZpdHRlZD86IGJvb2xlYW4gLSBNaW5pbWl6ZXMgdGhlIHNwYWNlIGJldHdlZW4gZGl2aWRlZCBjb250ZW50LlxuICAgKiBcdGhpZGRlbj86IGJvb2xlYW4gLSBDcmVhdGVzIGFuIGludmlzaWJsZSBkaXZpZGVyIHRoYXQgZGl2aWRlcyB0aGUgY29udGVudC5cbiAgICogXHRzZWN0aW9uPzogYm9vbGVhbiAtIFByb3ZpZGVzIGdyZWF0ZXIgbWFyZ2lucyBmb3IgYmV0d2VlbiBkaXZpZGVkIGNvbnRlbnQuXG4gICAqIFx0Y2xlYXJpbmc/OiBib29sZWFuIC0gQ2xlYXJzIGZsb2F0ZWQgY29udGVudC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50PikgOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuZGl2aWRlclwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGl2aWRlciBlbGVtZW50IHRvIHNlcGVyYXRlIGNvbnRlbnQgb24gcGFnZS5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIFx0Y29udGVudD86IFZOb2RlIC0gVGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSBkaXZpZGVyLlxuICAgKiBcdGhvcml6b250YWw/OiBib29sZWFuIC0gTmVlZGVkIHRvIHJlbmRlciB0ZXh0IGhvcml6b250YWxseSBpbiB0aGUgZGl2aWRlci5cbiAgICogXHR2ZXJ0aWNhbD86IGJvb2xlYW4gLSBEZXRlcm1pbmVzIHZlcnRpY2FsL2hvcml6b250YWwgb3JpZW50YXRpb24gb2YgdGhlIGRpdmlkZXIuXG4gICAqIFx0aW52ZXJ0ZWQ/OiBib29sZWFuIC0gRm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqIFx0Zml0dGVkPzogYm9vbGVhbiAtIE1pbmltaXplcyB0aGUgc3BhY2UgYmV0d2VlbiBkaXZpZGVkIGNvbnRlbnQuXG4gICAqIFx0aGlkZGVuPzogYm9vbGVhbiAtIENyZWF0ZXMgYW4gaW52aXNpYmxlIGRpdmlkZXIgdGhhdCBkaXZpZGVzIHRoZSBjb250ZW50LlxuICAgKiBcdHNlY3Rpb24/OiBib29sZWFuIC0gUHJvdmlkZXMgZ3JlYXRlciBtYXJnaW5zIGZvciBiZXR3ZWVuIGRpdmlkZWQgY29udGVudC5cbiAgICogXHRjbGVhcmluZz86IGJvb2xlYW4gLSBDbGVhcnMgZmxvYXRlZCBjb250ZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzfERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7Y2xhc3NOYW1lOiBnZXRDbGFzc05hbWUocHJvcHMsIGNvbnRlbnQpIH19LCBjb250ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcHM6IFByb3BzLCBjb250ZW50PykgOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxcIjtcbiAgICB9IGVsc2UgaWYgKHByb3BzLmhvcml6b250YWwpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBob3Jpem9udGFsXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5maXR0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmaXR0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhpZGRlbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGhpZGRlblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2VjdGlvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNlY3Rpb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNsZWFyaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2xlYXJpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhlYWRlcikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGhlYWRlclwiO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgZGl2aWRlclwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9kaXZpZGVyL2luZGV4LnRzIiwiaW1wb3J0IHtET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzLElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnR9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplLCBBdHRhY2htZW50LCBGbG9hdCwgVGV4dEFsaWdubWVudCwgQ29sb3IgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIEhlYWRlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGRpdmlkZXI/OiBib29sZWFuO1xuICAgIGRpdmlkaW5nPzogYm9vbGVhbjtcbiAgICBibG9jaz86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgICBmbG9hdD86IEZsb2F0O1xuICAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50O1xuICAgIHNpemU/OiBTaXplO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBFeHRyYXMge1xuICAgIHN1YnRleHQ/OiBET01Db250ZW50O1xuICAgIGljb24/OiBET01Db250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoZWFkZXIgZm9yIGltcG9ydGFudCB0ZXh0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgaWNvbj86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGljb24gaGVhZGVycy5cbiAgICogICBkaXZpZGVyPzogYm9vbGVhbiAtIEFkZHMgc3R5bGluZyBmb3IgaGVhZGVycyB0byBzZXBlcmF0ZSBjb250ZW50LlxuICAgKiAgIGJsb2NrPzogYm9vbGVhbiAtIFdyYXBzIGhlYWRlciBpbiBhIGJsb2NrLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGRpc2FibGVkIGNvbnRlbnQuXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuIC0gU3R5bGluZyBmb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFN0eWxpbmcgZm9yIGhlYWRlcnMgYXR0YWNoZWQgdG8gb3RoZXIgY29udGVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gRmxvYXRzIHRoZSBoZWFkZXIgdG8gdGhlIGxlZnQgb3IgcmlnaHQuXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQgLSBUZXh0IGFsaWdubWVudCBvZiB0aGUgaGVhZGVyIHRleHQuXG4gICAqICAgc2l6ZT86IFNpemUgLSBEZXRlcm1pbmVzIHRoZSBzaXplIG9mIHRoZSBoZWFkZXIuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaGVhZGVyLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiB7fSBvZlxuICAgKiAgIHRleHQ6IERPTUNvbnRlbnQgLSBUaGUgaGVhZGVyIHRleHQuXG4gICAqICAgc3VidGV4dD86IERPTUNvbnRlbnQtIEFuIG9wdGlvbmFsIHN1Yi1oZWFkZXIgdG8gYWNjb21wYW55IHRoZSBoZWFkZXIuXG4gICAqICAgaWNvbj86IERPTUNvbnRlbnQgLSBPcHRpb25hbCBpbWFnZS9pY29uIGNvbnRlbnQgZm9yIHRoZSBoZWFkZXIuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRXh0cmFzPik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRXh0cmFzPikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLmV4dHJhcyQgPSBzb3VyY2VzLmV4dHJhcyQgPyBzb3VyY2VzLmV4dHJhcyQgOiB4cy5vZih7fSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQsIHNvdXJjZXMuZXh0cmFzJCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50LCBleHRyYXNdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQsIGV4dHJhcylcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmhlYWRlclwiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGhlYWRlciBmb3IgaW1wb3J0YW50IHRleHQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gQWRkcyBzdHlsaW5nIGZvciBpY29uIGhlYWRlcnMuXG4gICAqICAgZGl2aWRlcj86IGJvb2xlYW4gLSBBZGRzIHN0eWxpbmcgZm9yIGhlYWRlcnMgdG8gc2VwZXJhdGUgY29udGVudC5cbiAgICogICBibG9jaz86IGJvb2xlYW4gLSBXcmFwcyBoZWFkZXIgaW4gYSBibG9jay5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBkaXNhYmxlZCBjb250ZW50LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGRhcmsgYmFja2dyb3VuZHMuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBTdHlsaW5nIGZvciBoZWFkZXJzIGF0dGFjaGVkIHRvIG90aGVyIGNvbnRlbnQuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIEZsb2F0cyB0aGUgaGVhZGVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGV4dCBhbGlnbm1lbnQgb2YgdGhlIGhlYWRlciB0ZXh0LlxuICAgKiAgIHNpemU/OiBTaXplIC0gRGV0ZXJtaW5lcyB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGhlYWRlci5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDoge30gb2ZcbiAgICogICB0ZXh0OiBET01Db250ZW50IC0gVGhlIGhlYWRlciB0ZXh0LlxuICAgKiAgIHN1YnRleHQ/OiBET01Db250ZW50LSBBbiBvcHRpb25hbCBzdWItaGVhZGVyIHRvIGFjY29tcGFueSB0aGUgaGVhZGVyLlxuICAgKiAgIGljb24/OiBET01Db250ZW50IC0gT3B0aW9uYWwgaW1hZ2UvaWNvbiBjb250ZW50IGZvciB0aGUgaGVhZGVyLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDb3JFOiBQcm9wcyB8IERPTUNvbnRlbnQgfCBFeHRyYXMgPSB7fSwgY09yRTogRE9NQ29udGVudCB8IEV4dHJhcyA9IHt9LCBlOiBFeHRyYXMgPSB7fSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQ29yRSkgPyB7fSA6IGlzRXh0cmFzKHBPckNvckUpID8ge30gOiBwT3JDb3JFO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckNvckUpID8gcE9yQ29yRSA6IGlzRE9NQ29udGVudChjT3JFKSA/IGNPckUgOiBcIlwiO1xuICAgIGxldCBleHRyYXMgPSBpc0V4dHJhcyhwT3JDb3JFKSA/IHBPckNvckUgOiBpc0V4dHJhcyhjT3JFKSA/IGNPckUgOiBlO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICBleHRyYXMuaWNvbiA/IGV4dHJhcy5pY29uIDogXCJcIixcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBbXS5jb25jYXQoXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGV4dHJhcy5zdWJ0ZXh0ID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInN1YiBoZWFkZXJcIiB9IH0sIGV4dHJhcy5zdWJ0ZXh0KSA6IFwiXCJcbiAgICAgICkpXG4gICAgXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpdmlkaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGl2aWRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpdmlkZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXZpZGVyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ibG9jaykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJsb2NrXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnRleHRBbGlnbm1lbnQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gVGV4dEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy50ZXh0QWxpZ25tZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgaGVhZGVyXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXh0cmFzKGV4dHJhKTogZXh0cmEgaXMgRXh0cmFzIHtcbiAgICByZXR1cm4gZXh0cmEgIT09IHVuZGVmaW5lZCAmJiAoKDxFeHRyYXM+ZXh0cmEpLnN1YnRleHQgIT09IHVuZGVmaW5lZFxuICAgICAgfHwgKCg8RXh0cmFzPmV4dHJhKS5pY29uICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICgoPEV4dHJhcz5leHRyYSkuaWNvbikgIT09IFwiYm9vbGVhblwiKSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9oZWFkZXIvaW5kZXgudHMiLCJpbXBvcnQgeyBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MgfSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgVmVydGljYWxBbGlnbm1lbnQsIEZsb2F0IH0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGEsIGltZyB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBJbWFnZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGhyZWY/OiBzdHJpbmc7XG4gICAgaGlkZGVuPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgYXZhdGFyPzogYm9vbGVhbjtcbiAgICBib3JkZXJlZD86IGJvb2xlYW47XG4gICAgc3BhY2VkPzogYm9vbGVhbjtcbiAgICBjaXJjdWxhcj86IGJvb2xlYW47XG4gICAgcm91bmRlZD86IGJvb2xlYW47XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgICBzaXplPzogU2l6ZTtcbiAgICB2ZXJ0aWNhbEFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltYWdlIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyBpbWFnZXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBocmVmPzogc3RyaW5nIC0gU3R5bGVzIHRoZSBpbWFnZSBhcyBhIGxpbmsgdG93YXJkcyB0aGUgbG9jYXRpb24uXG4gICAqICAgaGlkZGVuPzogYm9vbGVhbiAtIEhpZGVzIHRoZSBpbWFnZS5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBhdmF0YXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSBmb3IgdXNhZ2UgYXMgYW4gYXZhdGFyLlxuICAgKiAgIGJvcmRlcmVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2Ugd2l0aCBhIGJvcmRlci5cbiAgICogICBzcGFjZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB3aXRoIGV4dHJhIHNwYWNpbmcgdG8gc2VwZXJhdGUgaXQgZnJvbSBuZWFyYnkgY29udGVudC5cbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIHJvdW5kZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB0byBoYXZlIHJvdW5kZWQgZWRnZXMuXG4gICAqICAgZmxvYXQ/OiBGbG9hdCAtIFRoZSBmbG9hdCBvcmllbnRhdGlvbiBvZiB0aGUgaW1hZ2UuXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgaW1hZ2UuXG4gICAqICAgdmVydGljYWxBbGlnbm1lbnQ/OiBWZXJ0aWNhbEFsaWdubWVudCAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGV4dCBuZWFyYnkgdGhlIGltYWdlLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBzdHJpbmcgLSBUaGUgc3JjIHVybC5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgc3RyaW5nPik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIHN0cmluZz4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5pbWFnZVwiKS5ldmVudHModHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1hZ2UgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGltYWdlcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgbGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIGFzIGEgbGluay5cbiAgICogICBoaWRkZW4/OiBib29sZWFuIC0gSGlkZXMgdGhlIGltYWdlLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2UgdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGF2YXRhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIGZvciB1c2FnZSBhcyBhbiBhdmF0YXIuXG4gICAqICAgYm9yZGVyZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBpbWFnZSB3aXRoIGEgYm9yZGVyLlxuICAgKiAgIHNwYWNlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHdpdGggZXh0cmEgc3BhY2luZyB0byBzZXBlcmF0ZSBpdCBmcm9tIG5lYXJieSBjb250ZW50LlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgaW1hZ2UgdG8gYmUgY2lyY3VsYXIuXG4gICAqICAgcm91bmRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGltYWdlIHRvIGhhdmUgcm91bmRlZCBlZGdlcy5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gVGhlIGZsb2F0IG9yaWVudGF0aW9uIG9mIHRoZSBpbWFnZS5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBpbWFnZS5cbiAgICogICB2ZXJ0aWNhbEFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0ZXh0IG5lYXJieSB0aGUgaW1hZ2UuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IHN0cmluZyAtIFRoZSBzcmMgdXJsLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IHN0cmluZyA9IHt9LCBjOiBzdHJpbmcgPSBcIlwiKTogVk5vZGUge1xuICAgIGxldCBwcm9wcyA9IHR5cGVvZiAocE9yQykgPT09IFwic3RyaW5nXCIgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSB0eXBlb2YgKHBPckMpID09PSBcInN0cmluZ1wiID8gcE9yQyA6IGM7XG4gICAgbGV0IGltYWdlID0gaW1nKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpLCBzcmM6IGNvbnRlbnQgfSB9KTtcbiAgICByZXR1cm4gcHJvcHMuaHJlZiA/IGEoeyBwcm9wczogeyBocmVmOiBwcm9wcy5ocmVmIH0gfSwgaW1hZ2UpIDogaW1hZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMuaHJlZikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxpbmtcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhpZGRlbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGhpZGRlblwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuYXZhdGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYXZhdGFyXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ib3JkZXJlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGJvcmRlcmVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zcGFjZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzcGFjZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJvdW5kZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByb3VuZGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKHByb3BzLmZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy52ZXJ0aWNhbEFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBWZXJ0aWNhbEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy52ZXJ0aWNhbEFsaWdubWVudCk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWUgKyBcIiBpbWFnZVwiO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvaW1hZ2UvaW5kZXgudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9idXR0b25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbnRhaW5lclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZGl2aWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVhZGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pY29uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbWFnZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGFiZWxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpc3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xvYWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2VnbWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RlcFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdGV4dGJveFwiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplLCBBdHRhY2htZW50LCBDb2xvciB9IGZyb20gXCIuLi8uLi9lbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTGFiZWwge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBjaXJjdWxhcj86IGJvb2xlYW47XG4gICAgZW1wdHk/OiBib29sZWFuO1xuICAgIHBvaW50aW5nPzogYm9vbGVhbjtcbiAgICBiYXNpYz86IGJvb2xlYW47XG4gICAgbGVmdENvcm5lcj86IGJvb2xlYW47XG4gICAgcmlnaHRDb3JuZXI/OiBib29sZWFuO1xuICAgIHRhZz86IGJvb2xlYW47XG4gICAgcmliYm9uPzogYm9vbGVhbjtcbiAgICBpbnZSaWJib24/OiBib29sZWFuO1xuICAgIGhvcml6b250YWw/OiBib29sZWFuO1xuICAgIGZsb2F0aW5nPzogYm9vbGVhbjtcbiAgICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBjb2xvcj86IENvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMYWJlbCBjb21wb25lbnQgdG8gYWRkIGluZm9ybWF0aW9uIHRvIGNlcnRhaW4gY29udGVudC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgY2lyY3VsYXIuXG4gICAqICAgZW1wdHk/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCBmb3IgZW1wdHkgY29udGVudC5cbiAgICogICBwb2ludGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIHBvaW50aW5nIHRvd2FyZHMgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBtaW5pbWFsaXN0aWMuXG4gICAqICAgbGVmdENvcm5lcj86IGJvb2xlYW4gLSBBdHRhY2hlcyB0aGUgbGFiZWwgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiBuZWFyYnkgY29udGVudC5cbiAgICogICByaWdodENvcm5lcj86IGJvb2xlYW4gLSBBdHRhY2hlcyB0aGUgbGFiZWwgdG8gdGhlIHRvcC1yaWdodCBjb3JuZXIgb2YgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgdGFnPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gbG9vayBsaWtlIGEgdGFnLlxuICAgKiAgIHJpYmJvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGxvb2sgbGlrZSBhIHJpYmJvbiBvdmVyIHRoZSBsZWZ0IHNpZGUgb2YgY29udGVudC5cbiAgICogICBpbnZSaWJib24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBsb29rIGxpa2UgYSByaWJib24gb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiBjb250ZW50LlxuICAgKiAgIGhvcml6b250YWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCBmb3IgaG9yaXpvbnRhbCBjb250ZW50LlxuICAgKiAgIGZsb2F0aW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgZmxvYXRpbmcgb3ZlciBuZWFyYnkgY29udGVudC5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFdoZXJlIHRoZSBsYWJlbCBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgbGFiZWwuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbGFiZWwuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgYW5kIGV4dHJhczogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQsIERPTUNvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoW10pO1xuICAgICAgc291cmNlcy5leHRyYXMkID0gc291cmNlcy5leHRyYXMkID8gc291cmNlcy5leHRyYXMkIDogeHMub2YoW10pO1xuXG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkLCBzb3VyY2VzLmV4dHJhcyQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudCwgZXh0cmFzXSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50LCBleHRyYXMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5sYWJlbFwiKS5ldmVudHModHlwZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTGFiZWwgY29tcG9uZW50IHRvIGFkZCBpbmZvcm1hdGlvbiB0byBjZXJ0YWluIGNvbnRlbnQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGNpcmN1bGFyPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgY2lyY3VsYXIuXG4gICAqICAgZW1wdHk/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCBmb3IgZW1wdHkgY29udGVudC5cbiAgICogICBwb2ludGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGJlIHBvaW50aW5nIHRvd2FyZHMgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBiZSBtaW5pbWFsaXN0aWMuXG4gICAqICAgbGVmdENvcm5lcj86IGJvb2xlYW4gLSBBdHRhY2hlcyB0aGUgbGFiZWwgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiBuZWFyYnkgY29udGVudC5cbiAgICogICByaWdodENvcm5lcj86IGJvb2xlYW4gLSBBdHRhY2hlcyB0aGUgbGFiZWwgdG8gdGhlIHRvcC1yaWdodCBjb3JuZXIgb2YgbmVhcmJ5IGNvbnRlbnQuXG4gICAqICAgdGFnPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gbG9vayBsaWtlIGEgdGFnLlxuICAgKiAgIHJpYmJvbj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGxhYmVsIHRvIGxvb2sgbGlrZSBhIHJpYmJvbiBvdmVyIHRoZSBsZWZ0IHNpZGUgb2YgY29udGVudC5cbiAgICogICBpbnZSaWJib24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCB0byBsb29rIGxpa2UgYSByaWJib24gb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiBjb250ZW50LlxuICAgKiAgIGhvcml6b250YWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBsYWJlbCBmb3IgaG9yaXpvbnRhbCBjb250ZW50LlxuICAgKiAgIGZsb2F0aW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgbGFiZWwgdG8gYmUgZmxvYXRpbmcgb3ZlciBuZWFyYnkgY29udGVudC5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFdoZXJlIHRoZSBsYWJlbCBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgbGFiZWwuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbGFiZWwuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgYW5kIGV4dHJhczogRE9NQ29udGVudFxuICAgKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiLCBlOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgZGV0YWlsID0gaXNET01Db250ZW50KHBPckMpID8gYyA6IGU7XG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgY29udGVudCA9IGNvbnRlbnQuY29uY2F0KGRldGFpbCA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkZXRhaWxcIiB9IH0sIGRldGFpbCkgOiBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IFtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZGV0YWlsID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImRldGFpbFwiIH0gfSwgZGV0YWlsKSA6IFwiXCJcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBjb250ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmVtcHR5KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZW1wdHlcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBvaW50aW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcG9pbnRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmJhc2ljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYmFzaWNcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxlZnRDb3JuZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsZWZ0IGNvcm5lclwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmlnaHRDb3JuZXIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodCBjb3JuZXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRhZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHRhZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmliYm9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmliYm9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZSaWJib24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodCByaWJib25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhvcml6b250YWwpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBob3Jpem9udGFsXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbG9hdGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsb2F0aW5nIFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hdHRhY2htZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgbGFiZWxcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvbGFiZWwvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MgfSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgVmVydGljYWxBbGlnbm1lbnQsIEZsb2F0IH0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgYSwgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBMaXN0IHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgYnVsbGV0ZWQ/OiBib29sZWFuO1xuICAgIG9yZGVyZWQ/OiBib29sZWFuO1xuICAgIGhvcml6b250YWw/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBzZWxlY3Rpb24/OiBib29sZWFuO1xuICAgIGFuaW1hdGVkPzogYm9vbGVhbjtcbiAgICByZWxheGVkPzogYm9vbGVhbjtcbiAgICBkaXZpZGVkPzogYm9vbGVhbjtcbiAgICBjZWxsZWQ/OiBib29sZWFuO1xuICAgIHNpemU/OiBTaXplO1xuICAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50O1xuICAgIGZsb2F0PzogRmxvYXQ7XG4gIH1cbiAgZXhwb3J0IHR5cGUgQ29udGVudCA9IEFycmF5PExpc3RJdGVtPjtcbiAgZXhwb3J0IGludGVyZmFjZSBMaXN0SXRlbSB7XG4gICAgbGVmdD86IERPTUNvbnRlbnQ7XG4gICAgY29udGVudD86IERPTUNvbnRlbnQ7XG4gICAgaWNvbj86IERPTUNvbnRlbnQ7XG4gICAgcmlnaHQ/OiBET01Db250ZW50O1xuICAgIGhlYWRlcj86IERPTUNvbnRlbnQ7XG4gICAgZGVzY3JpcHRpb24/OiBET01Db250ZW50O1xuICAgIGhyZWY/OiBzdHJpbmc7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMaXN0IGNvbXBvbmVudCBmb3Igc2hvd2luZyBsaXN0cyBvZiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgYnVsbGV0ZWQ/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBhcyBhIGJ1bGxldGVkIGxpc3QuXG4gICAqICAgb3JkZXJlZD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGFzIGFuIG9yZGVyZWQgbGlzdC5cbiAgICogICBsaW5rPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGxpc3RzIHdpdGggbGlua3MuXG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGhvcml6b250YWxseS5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBvbiBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIHNlbGVjdGlvbj86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBtZWFudCB0byBkaXNwbGF5IGEgc2VsZWN0aW9uLlxuICAgKiAgIGFuaW1hdGVkPzogYm9vbGVhbiAtIEFkZHMgYW4gYW5pbWF0aW9uIHRvIGRpc3BsYXkgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0uXG4gICAqICAgcmVsYXhlZD86IGJvb2xlYW4gLSBBZGRzIG1vcmUgbmVnYXRpdmUgc3BhY2UgYXJyb3VuZCB0aGUgbGlzdC5cbiAgICogICBkaXZpZGVkPzogYm9vbGVhbiAtIEFkZHMgaG9yaXpvbnRhbCBkaXZpZGVycyBiZXR3ZWVuIGNvbnRlbnQgb2YgbGlzdC5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gV3JhcHMgY29udGVudCBvZiBsaXN0IGluIGNlbGxzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxpc3QgYW5kIGl0cyBjb250ZW50LlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiBsaXN0J3MgY29udGVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2V0aGVyIHRoZSBsaXN0IHNob3VsZCBiZSBsZWZ0IG9yIHJpZ2h0IGZsb2F0aW5nLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiAgIGxlZnQ/OiBET01Db250ZW50IC0gTGVmdCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGJvZHk/OiBET01Db250ZW50IC0gQm9keSBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICByaWdodD86IERPTUNvbnRlbnQgLSBSaWdodCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGhlYWRlcj86IERPTUNvbnRlbnQgLSBOYW1lIG9mIHRoZSBsaXN0IGl0ZW1cbiAgICogICBkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQgLSBEZXNjcmlwdGlvbiBvZiB0aGUgbGlzdCBpdGVtLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBMaW5rIGZvciBsaW5rIGxpc3RzXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KTogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIubGlzdFwiKS5ldmVudHModHlwZSksXG4gICAgICAgIHZhbHVlJDogeHMubmV2ZXIoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMaXN0IGNvbXBvbmVudCBmb3Igc2hvd2luZyBsaXN0cyBvZiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgYnVsbGV0ZWQ/OiBib29sZWFuIC0gRGlzcGxheXMgbGlzdCBhcyBhIGJ1bGxldGVkIGxpc3QuXG4gICAqICAgb3JkZXJlZD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGFzIGFuIG9yZGVyZWQgbGlzdC5cbiAgICogICBsaW5rPzogYm9vbGVhbiAtIFN0eWxpbmcgZm9yIGxpc3RzIHdpdGggbGlua3MuXG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBEaXNwbGF5cyBsaXN0IGhvcml6b250YWxseS5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBvbiBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIHNlbGVjdGlvbj86IGJvb2xlYW4gLSBTdHlsaW5nIGZvciBsaXN0cyBtZWFudCB0byBkaXNwbGF5IGEgc2VsZWN0aW9uLlxuICAgKiAgIGFuaW1hdGVkPzogYm9vbGVhbiAtIEFkZHMgYW4gYW5pbWF0aW9uIHRvIGRpc3BsYXkgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0uXG4gICAqICAgcmVsYXhlZD86IGJvb2xlYW4gLSBBZGRzIG1vcmUgbmVnYXRpdmUgc3BhY2UgYXJyb3VuZCB0aGUgbGlzdC5cbiAgICogICBkaXZpZGVkPzogYm9vbGVhbiAtIEFkZHMgaG9yaXpvbnRhbCBkaXZpZGVycyBiZXR3ZWVuIGNvbnRlbnQgb2YgbGlzdC5cbiAgICogICBjZWxsZWQ/OiBib29sZWFuIC0gV3JhcHMgY29udGVudCBvZiBsaXN0IGluIGNlbGxzLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxpc3QgYW5kIGl0cyBjb250ZW50LlxuICAgKiAgIGFsaWdubWVudD86IFZlcnRpY2FsQWxpZ25tZW50IC0gVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiBsaXN0J3MgY29udGVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2V0aGVyIHRoZSBsaXN0IHNob3VsZCBiZSBsZWZ0IG9yIHJpZ2h0IGZsb2F0aW5nLlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBBcnJheSBvZiB7fVxuICAgKiAgIGxlZnQ/OiBET01Db250ZW50IC0gTGVmdCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGJvZHk/OiBET01Db250ZW50IC0gQm9keSBjb250ZW50IGZvciB0aGUgaXRlbS5cbiAgICogICByaWdodD86IERPTUNvbnRlbnQgLSBSaWdodCBmbG9hdGVkIGNvbnRlbnQgZm9yIHRoZSBpdGVtLlxuICAgKiAgIGhlYWRlcj86IERPTUNvbnRlbnQgLSBOYW1lIG9mIHRoZSBsaXN0IGl0ZW1cbiAgICogICBkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQgLSBEZXNjcmlwdGlvbiBvZiB0aGUgbGlzdCBpdGVtLlxuICAgKiAgIGhyZWY/OiBzdHJpbmcgLSBMaW5rIGZvciBsaW5rIGxpc3RzXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgQ29udGVudCA9IHt9LCBjOiBDb250ZW50ID0gW10pOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gKHBPckMgaW5zdGFuY2VvZiBBcnJheSkgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSAocE9yQyBpbnN0YW5jZW9mIEFycmF5KSA/IHBPckMgOiBjO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LFxuICAgICAgY29udGVudC5tYXAoKHtoZWFkZXIsIGljb24sIGNvbnRlbnQsIGRlc2NyaXB0aW9uLCBocmVmLCBsZWZ0LCByaWdodH0pID0+IHtcbiAgICAgICAgbGV0IGwgPSBsZWZ0ID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImxlZnQgZmxvYXRlZCBjb250ZW50XCIgfSB9LCBsZWZ0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHIgPSByaWdodCA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJyaWdodCBmbG9hdGVkIGNvbnRlbnRcIiB9IH0sIHJpZ2h0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGggPSBoZWFkZXIgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiaGVhZGVyXCIgfSB9LCBoZWFkZXIpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZCA9IGRlc2NyaXB0aW9uID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImRlc2NyaXB0aW9uXCIgfSB9LCBkZXNjcmlwdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBpID0gaWNvbiA/IGljb24gOiBcIlwiO1xuICAgICAgICBsZXQgYyA9IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LFxuICAgICAgICAgIFtdLmNvbmNhdChoLCBkLCBjb250ZW50KVxuICAgICAgICApO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXS5jb25jYXQobCwgaSwgYywgcik7XG4gICAgICAgIHJldHVybiBocmVmXG4gICAgICAgICAgPyBhKHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcIml0ZW1cIiB9IH0sIHsgcHJvcHM6IHsgaHJlZjogaHJlZiB9IH0sIGNoaWxkcmVuKVxuICAgICAgICAgIDogZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcIml0ZW1cIiB9IH0sIGNoaWxkcmVuKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLmJ1bGxldGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYnVsbGV0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9yZGVyZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBvcmRlcmVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaW52ZXJ0ZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbnZlcnRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2VsZWN0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5hbmltYXRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFuaW1hdGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yZWxheGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmVsYXhlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGl2aWRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpdmlkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbGxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNlbGxlZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBWZXJ0aWNhbEFsaWdubWVudC5Ub0NsYXNzbmFtZShwcm9wcy5hbGlnbm1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBGbG9hdC5Ub0NsYXNzbmFtZShwcm9wcy5mbG9hdCk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBsaXN0XCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VsZW1lbnRzL2xpc3QvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3MsIGlzRE9NQ29udGVudCB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTaXplIH0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgeHMsIHsgU3RyZWFtIH0gZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB7IERpbW1lciB9IGZyb20gXCIuLi8uLi9tb2R1bGVzL2RpbW1lclwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIExvYWRlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHR5cGU6IExvYWRlclR5cGU7XG4gICAgZWxlbWVudD86IFN0cmVhbTxWTm9kZT47XG4gICAgb24kPzogU3RyZWFtPGJvb2xlYW4+O1xuICAgIGNlbnRlcmVkPzogYm9vbGVhbjtcbiAgICBhY3RpdmU/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBpbmRldGVybWluYXRlPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgdGV4dD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIEEgbG9hZGVyIGNvbXBvbmVudCB0byBzaG93IHRoYXQgY2VydGFpbiBjb250ZW50IG9yIGEgcGFnZSBpcyBsb2FkaW5nLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgdHlwZTogTG9hZGVyVHlwZSAtIFRoZSB0eXBlIG9mIGxvYWRlciB0byB1c2UuIFNlZSBleHBvcnRlZCBlbnVtLlxuICAgKiAgIGVsZW1lbnQ/OiBTdHJlYW08Vk5vZGU+IC0gVGhlIGVsZW1lbnQgdG8gbWFyayBhcyBsb2FkZWQuIChPbmx5IHVzZWQgZm9yIHR5cGUuQ29udGVudClcbiAgICogICBvbiQ6IFN0cmVhbTxib29sZWFuPiAtIFdoZW4gdG8gc2hvdy9oaWRlIHRoZSBsb2FkZXIuIChOb3QgdXNlZCBmb3IgaW5saW5lLCBhZGQgZGlzYWJsZWQgcHJvcGVydHkgaW5zdGVhZC4pXG4gICAqICAgY2VudGVyZWQ/OiBib29sZWFuIC0gQ2VudGVycyB0aGUgbG9hZGVyIHNwaW5uZXIgaW4gaXRzIHBhcmVudCBjb21wb25lbnQuXG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIEFsd2F5cyBzaG93cyB0aGUgbG9hZGVyLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIEFsd2F5cyBoaWRlcyB0aGUgbG9hZGVyLlxuICAgKiAgIGluZGV0ZXJtaW5hdGU/OiBib29sZWFuIC0gTWFrZXMgdGhlIGxvYWRlciBzcGluIGluZGljYXRlIGl0cyB1bnN1cmUgb2YgaG93IGxvbmcgYSB0YXNrIHdpbGwgdGFrZS5cbiAgICogICB0ZXh0PzogYm9vbGVhbiAtIFBvc2l0aW9ucyB0aGUgbG9hZGVyIHRvIGxlYXZlIHNwYWNlIGZvciB0ZXh0LlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIGxvYWRlci5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JCBvZjogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7IHR5cGU6IExvYWRlclR5cGUuSW5saW5lIH0pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHByb3BzJCA9IHNvdXJjZXMucHJvcHMkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKHByb3BzJCwgc291cmNlcy5jb250ZW50JClcbiAgICAgICAgLm1hcCgoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgICApO1xuICAgICAgY29uc3Qgb24kID0gcHJvcHMkLm1hcChwcm9wcyA9PiBwcm9wcy5vbiQpLmZsYXR0ZW4oKTtcbiAgICAgIGNvbnN0IHRhcmdldCQgPSBwcm9wcyQubWFwKHByb3BzID0+IHByb3BzLnR5cGUgPT09IExvYWRlclR5cGUuUGFnZSA/IHhzLm9mKFwicGFnZVwiKSA6IHByb3BzLmVsZW1lbnQpLmZsYXR0ZW4oKTtcbiAgICAgIGNvbnN0IGRpbW1lciA9IERpbW1lci5ydW4oeyBET006IHNvdXJjZXMuRE9NLCBhcmdzJDogb24kLCB0YXJnZXQkLCBjb250ZW50JDogdlRyZWUkIH0sIHByb3BzJC5tYXAocHJvcHMgPT4gcHJvcHMuaW52ZXJ0ZWQpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCQgPSBwcm9wcyQubWFwKFxuICAgICAgICBwcm9wcyA9PiBwcm9wcy50eXBlID09PSBMb2FkZXJUeXBlLklubGluZSA/IHZUcmVlJCA6IGRpbW1lci5ET01cbiAgICAgICkuZmxhdHRlbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiByZXN1bHQkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIubG9hZGVyXCIpLmV2ZW50cyh0eXBlKSxcbiAgICAgICAgdmFsdWUkOiB4cy5uZXZlcigpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBsb2FkZXIgY29tcG9uZW50IHRvIHNob3cgdGhhdCBjZXJ0YWluIGNvbnRlbnQgb3IgYSBwYWdlIGlzIGxvYWRpbmcuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIHR5cGU6IExvYWRlclR5cGUgLSBUaGUgdHlwZSBvZiBsb2FkZXIgdG8gdXNlLiBTZWUgZXhwb3J0ZWQgZW51bS5cbiAgICogICBlbGVtZW50PzogU3RyZWFtPFZOb2RlPiAtIFRoZSBlbGVtZW50IHRvIG1hcmsgYXMgbG9hZGVkLiAoT25seSB1c2VkIGZvciB0eXBlLkNvbnRlbnQpXG4gICAqICAgb24kOiBTdHJlYW08Ym9vbGVhbj4gLSBXaGVuIHRvIHNob3cvaGlkZSB0aGUgbG9hZGVyLiAoTm90IHVzZWQgZm9yIGlubGluZSwgYWRkIGRpc2FibGVkIHByb3BlcnR5IGluc3RlYWQuKVxuICAgKiAgIGNlbnRlcmVkPzogYm9vbGVhbiAtIENlbnRlcnMgdGhlIGxvYWRlciBzcGlubmVyIGluIGl0cyBwYXJlbnQgY29tcG9uZW50LlxuICAgKiAgIGFjdGl2ZT86IGJvb2xlYW4gLSBBbHdheXMgc2hvd3MgdGhlIGxvYWRlci5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBBbHdheXMgaGlkZXMgdGhlIGxvYWRlci5cbiAgICogICBpbmRldGVybWluYXRlPzogYm9vbGVhbiAtIE1ha2VzIHRoZSBsb2FkZXIgc3BpbiBpbmRpY2F0ZSBpdHMgdW5zdXJlIG9mIGhvdyBsb25nIGEgdGFzayB3aWxsIHRha2UuXG4gICAqICAgdGV4dD86IGJvb2xlYW4gLSBQb3NpdGlvbnMgdGhlIGxvYWRlciB0byBsZWF2ZSBzcGFjZSBmb3IgdGV4dC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsb2FkZXIuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBET01Db250ZW50ID0ge3R5cGU6IExvYWRlclR5cGUuUGFnZX0sIGM6IERPTUNvbnRlbnQgPSBcIlwiKTogVk5vZGVbXSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8geyB0eXBlOiBMb2FkZXJUeXBlLlBhZ2UgfSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICByZXR1cm4gW2Rpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNvbnRlbnQpXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5hY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNlbnRlcmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2VudGVyZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBpbmRldGVybWluYXRlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50ZXh0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdGV4dFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBMb2FkZXJUeXBlLlRvQ2xhc3NuYW1lKHByb3BzLnR5cGUpO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbiAgZXhwb3J0IGVudW0gTG9hZGVyVHlwZSB7XG4gICAgSW5saW5lLCBQYWdlLCBDb250ZW50XG4gIH1cbiAgZXhwb3J0IG5hbWVzcGFjZSBMb2FkZXJUeXBlIHtcbiAgICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUodHlwZTogTG9hZGVyVHlwZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgTG9hZGVyVHlwZS5JbmxpbmU6IHJldHVybiBcIiBpbmxpbmUgbG9hZGVyXCI7XG4gICAgICAgIGNhc2UgTG9hZGVyVHlwZS5QYWdlOiByZXR1cm4gXCIgbG9hZGVyXCI7XG4gICAgICAgIGNhc2UgTG9hZGVyVHlwZS5Db250ZW50OiByZXR1cm4gXCIgbG9hZGVyXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvbG9hZGVyL2luZGV4LnRzIiwiaW1wb3J0IHtcbiAgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsXG4gIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnRcbn0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IENvbG9yLCBBdHRhY2htZW50LCBGbG9hdCwgVGV4dEFsaWdubWVudCB9IGZyb20gXCIuLi8uLi9lbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2VnbWVudCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHJhaXNlZD86IGJvb2xlYW47XG4gICAgc3RhY2tlZD86IGJvb2xlYW47XG4gICAgdGFsbFN0YWNrZWQ/OiBib29sZWFuO1xuICAgIHBpbGVkPzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbD86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIHBhZGRlZD86IGJvb2xlYW47XG4gICAgdmVyeVBhZGRlZD86IGJvb2xlYW47XG4gICAgY29tcGFjdD86IGJvb2xlYW47XG4gICAgY2lyY3VsYXI/OiBib29sZWFuO1xuICAgIGNsZWFyaW5nPzogYm9vbGVhbjtcbiAgICBiYXNpYz86IGJvb2xlYW47XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgICBhdHRhY2htZW50PzogQXR0YWNobWVudDtcbiAgICBmbG9hdD86IEZsb2F0O1xuICAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2VnbWVudCBjb21wb25lbnQgdG8gZGl2aWRlIHVwIHBhZ2UgY29udGVudCBpbnRvIHNlZ21lbnRzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgcmFpc2VkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGZsb2F0aW5nIGFib3ZlIG5lYXJieSBjb250ZW50LlxuICAgKiAgIHN0YWNrZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgbGlrZSBhIHN0YWNrIG9mIHBhcGVycy5cbiAgICogICB0YWxsU3RhY2tlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGFwcGVhciBsaWtlIGEgdGFsbCBzdGFjayBvZiBwYXBlcnMuXG4gICAqICAgcGlsZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgbGlrZSBhIHBpbGUgb2YgcGFwZXJzLlxuICAgKiAgIHZlcnRpY2FsPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgY29udGVudCB0byBiZSBhbGlnbmVkIGFzIHBhcnQgb2YgYSB2ZXJ0aWNhbCBncm91cC5cbiAgICogICBsb2FkaW5nPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgd2l0aCBhIGxvYWRpbmcgaWNvbi5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IGZvciBkYXJrIGNvbnRlbnQuXG4gICAqICAgcGFkZGVkPzogYm9vbGVhbj8gLSBJbmNyZWFzZXMgdGhlIHBhZGRpbmcgb24gdGhlIHNlZ21lbnQuXG4gICAqICAgdmVyeVBhZGRlZD86IGJvb2xlYW4gLSBJbmNyZWFzZXMgdGhlIHBhZGRpbmcgb24gdGhlIHNlZ21lbnQgYnkgYSBsb3QuXG4gICAqICAgY29tcGFjdD86IGJvb2xlYW4gLSBNYWtlcyB0aGUgc2VnbWVudCB0YWtlIHVwIG9ubHkgdGhlIHNwYWNlIG5lZWRlZCBieSBpdHMgY29udGVudC5cbiAgICogICBjaXJjdWxhcj86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYmUgY2lyY3VsYXIuXG4gICAqICAgY2xlYXJpbmc/OiBib29sZWFuIC0gQ2xlYXJzIGZsb2F0ZWQgY29udGVudC5cbiAgICogICBiYXNpYz86IGJvb2xlYW4gLSBSZW1vdmVzIGFueSBzcGVjaWFsIHN0eWxpbmcuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgc2VnbWVudC5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFRoZSBhdHRhY2htZW50IG9mIHRoZSBzZWdtZW50LlxuICAgKiAgIGZsb2F0PzogRmxvYXQgLSBXaGVyZSB0aGUgc2VnbWVudCBzaG91bGQgZmxvYXQuXG4gICAqICAgdGV4dEFsaWdubWVudD86IFRleHRBbGlnbm1lbnQgLSBUaGUgdGV4dCBhbGlnbm1lbnQgb2YgdGhlIHNlZ21lbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLnNlZ21lbnRcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzZWdtZW50IGNvbXBvbmVudCB0byBkaXZpZGUgdXAgcGFnZSBjb250ZW50IGludG8gc2VnbWVudHMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIHJhaXNlZD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGFwcGVhciBmbG9hdGluZyBhYm92ZSBuZWFyYnkgY29udGVudC5cbiAgICogICBzdGFja2VkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGxpa2UgYSBzdGFjayBvZiBwYXBlcnMuXG4gICAqICAgdGFsbFN0YWNrZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCB0byBhcHBlYXIgbGlrZSBhIHRhbGwgc3RhY2sgb2YgcGFwZXJzLlxuICAgKiAgIHBpbGVkPzogYm9vbGVhbj8gLSBTdHlsZXMgdGhlIHNlZ21lbnQgdG8gYXBwZWFyIGxpa2UgYSBwaWxlIG9mIHBhcGVycy5cbiAgICogICB2ZXJ0aWNhbD86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IGNvbnRlbnQgdG8gYmUgYWxpZ25lZCBhcyBwYXJ0IG9mIGEgdmVydGljYWwgZ3JvdXAuXG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4/IC0gU3R5bGVzIHRoZSBzZWdtZW50IHdpdGggYSBsb2FkaW5nIGljb24uXG4gICAqICAgaW52ZXJ0ZWQ/OiBib29sZWFuPyAtIFN0eWxlcyB0aGUgc2VnbWVudCBmb3IgZGFyayBjb250ZW50LlxuICAgKiAgIHBhZGRlZD86IGJvb2xlYW4/IC0gSW5jcmVhc2VzIHRoZSBwYWRkaW5nIG9uIHRoZSBzZWdtZW50LlxuICAgKiAgIHZlcnlQYWRkZWQ/OiBib29sZWFuIC0gSW5jcmVhc2VzIHRoZSBwYWRkaW5nIG9uIHRoZSBzZWdtZW50IGJ5IGEgbG90LlxuICAgKiAgIGNvbXBhY3Q/OiBib29sZWFuIC0gTWFrZXMgdGhlIHNlZ21lbnQgdGFrZSB1cCBvbmx5IHRoZSBzcGFjZSBuZWVkZWQgYnkgaXRzIGNvbnRlbnQuXG4gICAqICAgY2lyY3VsYXI/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzZWdtZW50IHRvIGJlIGNpcmN1bGFyLlxuICAgKiAgIGNsZWFyaW5nPzogYm9vbGVhbiAtIENsZWFycyBmbG9hdGVkIGNvbnRlbnQuXG4gICAqICAgYmFzaWM/OiBib29sZWFuIC0gUmVtb3ZlcyBhbnkgc3BlY2lhbCBzdHlsaW5nLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHNlZ21lbnQuXG4gICAqICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBUaGUgYXR0YWNobWVudCBvZiB0aGUgc2VnbWVudC5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2hlcmUgdGhlIHNlZ21lbnQgc2hvdWxkIGZsb2F0LlxuICAgKiAgIHRleHRBbGlnbm1lbnQ/OiBUZXh0QWxpZ25tZW50IC0gVGhlIHRleHQgYWxpZ25tZW50IG9mIHRoZSBzZWdtZW50LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7fSwgYzogRE9NQ29udGVudCA9IFwiXCIpOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIGNvbnRlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMucmFpc2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmFpc2VkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5zdGFja2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3RhY2tlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGFsbFN0YWNrZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB0YWxsIHN0YWNrZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBpbGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcGlsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdmVydGljYWxcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGludmVydGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wYWRkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwYWRkZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZlcnlQYWRkZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ5IHBhZGRlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29tcGFjdCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGNvbXBhY3RcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNpcmN1bGFyKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2lyY3VsYXJcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNsZWFyaW5nKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2xlYXJpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmJhc2ljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgYmFzaWNcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuY29sb3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5hdHRhY2htZW50KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEF0dGFjaG1lbnQuVG9DbGFzc25hbWUocHJvcHMuYXR0YWNobWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmZsb2F0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKHByb3BzLmZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMudGV4dEFsaWdubWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBUZXh0QWxpZ25tZW50LlRvQ2xhc3NuYW1lKHByb3BzLnRleHRBbGlnbm1lbnQpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgc2VnbWVudFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lbGVtZW50cy9zZWdtZW50L2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIEF0dGFjaG1lbnQgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB7IG51bVRvVGV4dCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7IGRpdiwgYSB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgU3RlcHMge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBsaW5rPzogYm9vbGVhbjtcbiAgICB2ZXJ0aWNhbD86IGJvb2xlYW47XG4gICAgc3RhY2thYmxlPzogYm9vbGVhbjtcbiAgICBldmVubHlEaXZpZGVkPzogYm9vbGVhbjtcbiAgICBmbHVpZD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gIH1cbiAgZXhwb3J0IHR5cGUgQ29udGVudCA9IEFycmF5PFN0ZXBJdGVtPjtcbiAgZXhwb3J0IGludGVyZmFjZSBTdGVwSXRlbSB7XG4gICAgaWNvbj86IERPTUNvbnRlbnQ7XG4gICAgaGVhZGVyPzogRE9NQ29udGVudDtcbiAgICBkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQ7XG4gICAgaXNDb21wbGV0ZWQ/OiBib29sZWFuO1xuICAgIGlzQWN0aXZlPzogYm9vbGVhbjtcbiAgICBpc0Rpc2FibGVkPzogYm9vbGVhbjtcbiAgICBsaW5rPzogYm9vbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0ZXBzIGNvbXBvbmVudCB0byBzaG93IHRoZSBjb21wbGV0aW9uIHN0YXR1cyBvZiBhIHNlcmllcyBvZiBhY3Rpdml0aWVzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICBsaW5rPzogYm9vbGVhbiAtIFN0eWxlcyB0byBzdGVwcyB0byBkaXNwbGF5IGFzIGEgbGluay5cbiAgICogXHR2ZXJ0aWNhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0ZXBzIHRvIGFsaWduIHZlcnRpY2FsbHkuXG4gICAqIFx0c3RhY2thYmxlPzogYm9vbGVhbiAtIExldHMgdGhlIHN0ZXBzIHJlYWxpZ24gdmVydGljYWxseSBvbiBzbWFsbGVyIHNjcmVlbnMuXG4gICAqIFx0ZXZlbmx5RGl2aWRlZD86IGJvb2xlYW4gLSBBcnJhbmdlcyB0aGUgc3RlcHMgdG8gdGFrZSB1cCBlcXVhbCBhbW91bnQgb2Ygd2lkdGggb2YgdGhlaXIgcGFyZW50LlxuICAgKiBcdGZsdWlkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgc3RlcHMgdG8gdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiB0aGVpciBwYXJlbnQuXG4gICAqIFx0c2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgc3RlcHMuXG4gICAqIFx0YXR0YWNobWVudD86IEF0dGFjaG1lbnQgLSBTdHlsZXMgdGhlIHN0ZXBzIHRvIGFwcGVhciBhdHRhY2hlZCB0byBuZWFyYnkgY29udGVudC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogQXJyYXkgb2Yge31cbiAgICogXHRpY29uPzogRE9NQ29udGVudCBUaGUgaWNvbiB0byB1c2UgZm9yIHRoZSBzdGVwLlxuICAgKiBcdGhlYWRlcj86IERPTUNvbnRlbnQgLSBUaGUgdGl0bGUgZm9yIHRoZSBzdGVwLlxuICAgKiBcdGRlc2NyaXB0aW9uPzogRE9NQ29udGVudCAtIFRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIHN0ZXAuXG4gICAqIFx0aXNDb21wbGV0ZWQ/OiBib29sZWFuIC0gTWFya3MgdGhlIHN0ZXAgYXMgY29tcGxldGVkLlxuICAgKiBcdGlzQWN0aXZlPzogYm9vbGVhbiAtIE1hcmtzIHRoZSBzdGVwIGFzIHRoZSBjdXJyZW50IHN0ZXAuXG4gICAqIFx0aXNEaXNhYmxlZD86IGJvb2xlYW4gLSBNYXJrcyB0aGUgc3RlcCBhcyBkaXNhYmxlZC5cbiAgICogIGxpbms/OiBib29sZWFuIC0gU3R5bGUgdGhlIHN0ZXAgdG8gYmUgY2xpY2thYmxlLlxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50Pik6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ+KSB7XG4gICAgICBzb3VyY2VzLnByb3BzJCA9IHNvdXJjZXMucHJvcHMkID8gc291cmNlcy5wcm9wcyQgOiB4cy5vZih7fSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihbXSk7XG5cbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUoc291cmNlcy5wcm9wcyQsIHNvdXJjZXMuY29udGVudCQpLm1hcChcbiAgICAgICAgKFtwcm9wcywgY29udGVudF0pID0+IHJlbmRlcihwcm9wcywgY29udGVudClcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGV2dCA9ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuc3RlcFwiKS5ldmVudHModHlwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiBldnQsXG4gICAgICAgIHZhbHVlJDogeHMubmV2ZXIoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3RlcHMgY29tcG9uZW50IHRvIHNob3cgdGhlIGNvbXBsZXRpb24gc3RhdHVzIG9mIGEgc2VyaWVzIG9mIGFjdGl2aXRpZXMuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgbGluaz86IGJvb2xlYW4gLSBTdHlsZXMgdG8gc3RlcHMgdG8gZGlzcGxheSBhcyBhIGxpbmsuXG4gICAqIFx0dmVydGljYWw/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBzdGVwcyB0byBhbGlnbiB2ZXJ0aWNhbGx5LlxuICAgKiBcdHN0YWNrYWJsZT86IGJvb2xlYW4gLSBMZXRzIHRoZSBzdGVwcyByZWFsaWduIHZlcnRpY2FsbHkgb24gc21hbGxlciBzY3JlZW5zLlxuICAgKiBcdGV2ZW5seURpdmlkZWQ/OiBib29sZWFuIC0gQXJyYW5nZXMgdGhlIHN0ZXBzIHRvIHRha2UgdXAgZXF1YWwgYW1vdW50IG9mIHdpZHRoIG9mIHRoZWlyIHBhcmVudC5cbiAgICogXHRmbHVpZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0ZXBzIHRvIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgdGhlaXIgcGFyZW50LlxuICAgKiBcdHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHN0ZXBzLlxuICAgKiBcdGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gU3R5bGVzIHRoZSBzdGVwcyB0byBhcHBlYXIgYXR0YWNoZWQgdG8gbmVhcmJ5IGNvbnRlbnQuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQ6IEFycmF5IG9mIHt9XG4gICAqIFx0aWNvbj86IERPTUNvbnRlbnQgVGhlIGljb24gdG8gdXNlIGZvciB0aGUgc3RlcC5cbiAgICogXHRoZWFkZXI/OiBET01Db250ZW50IC0gVGhlIHRpdGxlIGZvciB0aGUgc3RlcC5cbiAgICogXHRkZXNjcmlwdGlvbj86IERPTUNvbnRlbnQgLSBUaGUgZGVzY3JpcHRpb24gZm9yIHRoZSBzdGVwLlxuICAgKiBcdGlzQ29tcGxldGVkPzogYm9vbGVhbiAtIE1hcmtzIHRoZSBzdGVwIGFzIGNvbXBsZXRlZC5cbiAgICogXHRpc0FjdGl2ZT86IGJvb2xlYW4gLSBNYXJrcyB0aGUgc3RlcCBhcyB0aGUgY3VycmVudCBzdGVwLlxuICAgKiBcdGlzRGlzYWJsZWQ/OiBib29sZWFuIC0gTWFya3MgdGhlIHN0ZXAgYXMgZGlzYWJsZWQuXG4gICAqICBsaW5rPzogYm9vbGVhbiAtIFN0eWxlIHRoZSBzdGVwIHRvIGJlIGNsaWNrYWJsZS5cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIocE9yQzogUHJvcHMgfCBDb250ZW50ID0ge30sIGM6IENvbnRlbnQgPSBbXSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBwT3JDIGluc3RhbmNlb2YgQXJyYXkgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBwT3JDIGluc3RhbmNlb2YgQXJyYXkgPyBwT3JDIDogYztcbiAgICBsZXQgY2hpbGRyZW4gPSBjb250ZW50Lm1hcCgoe2ljb24sIGhlYWRlciwgZGVzY3JpcHRpb24sIGlzQ29tcGxldGVkLCBpc0FjdGl2ZSwgaXNEaXNhYmxlZCwgbGlua30sIGkpID0+XG4gICAgICBwcm9wcy5saW5rXG4gICAgICAgID8gYSh7IHByb3BzOiB7IGlkOiBpLCBjbGFzc05hbWU6IGdldFN0ZXBDbGFzc25hbWUoaXNDb21wbGV0ZWQsIGlzQWN0aXZlLCBpc0Rpc2FibGVkLCBsaW5rKSB9IH0sIFtcbiAgICAgICAgICBpY29uLFxuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBbXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidGl0bGVcIiB9IH0sIGhlYWRlciksXG4gICAgICAgICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiZGVzY3JpcHRpb25cIiB9IH0sIGRlc2NyaXB0aW9uKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICAgIDogZGl2KHsgcHJvcHM6IHsgaWQ6IGksIGNsYXNzTmFtZTogZ2V0U3RlcENsYXNzbmFtZShpc0NvbXBsZXRlZCwgaXNBY3RpdmUsIGlzRGlzYWJsZWQsIGxpbmspIH0gfSwgW1xuICAgICAgICAgIGljb24sXG4gICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImNvbnRlbnRcIiB9IH0sIFtcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ0aXRsZVwiIH0gfSwgaGVhZGVyKSxcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJkZXNjcmlwdGlvblwiIH0gfSwgZGVzY3JpcHRpb24pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICApO1xuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcywgY29udGVudC5sZW5ndGgpIH0gfSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RlcENsYXNzbmFtZShpc0NvbXBsZXRlZD86IGJvb2xlYW4sIGlzQWN0aXZlPzogYm9vbGVhbiwgaXNEaXNhYmxlZD86IGJvb2xlYW4sIGxpbms/OiBib29sZWFuKSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCJhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGxldGVkXCI7XG4gICAgfVxuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKGxpbmspIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsaW5rXCI7XG4gICAgfVxuICAgIGNsYXNzTmFtZSArPSBcIiBzdGVwXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzLCBsZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMudmVydGljYWwpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB2ZXJ0aWNhbFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc3RhY2thYmxlKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc3RhY2thYmxlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mbHVpZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsdWlkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5ldmVubHlEaXZpZGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gbnVtVG9UZXh0KGxlbmd0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLnNpemUpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjbGFzc05hbWUgKz0gU2l6ZS5Ub0NsYXNzbmFtZShwcm9wcy5zaXplKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgc3RlcHNcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvc3RlcC9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzLCBJVmFsdWVDb21wb25lbnRTaW5rcywgaXNET01Db250ZW50IH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IENvbG9yLCBTaXplIH0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgeHMgZnJvbSBcInhzdHJlYW1cIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2LCBpbnB1dCwgdGV4dGFyZWEgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFRleHRib3gge1xuICBleHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBpbml0aWFsPzogc3RyaW5nO1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIGljb24/OiBib29sZWFuO1xuICAgIGxhYmVsZWQ/OiBib29sZWFuO1xuICAgIGFjdGlvbj86IGJvb2xlYW47XG4gICAgbGVmdENvbnRlbnQ/OiBib29sZWFuO1xuICAgIHJpZ2h0Q29udGVudD86IGJvb2xlYW47XG4gICAgdHJhbnNwYXJlbnQ/OiBib29sZWFuO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgICBmb2N1cz86IGJvb2xlYW47XG4gICAgbG9hZGluZz86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGxhcmdlPzogYm9vbGVhbjtcbiAgICB0eXBlPzogc3RyaW5nO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cblxuICAvKipcbiAgICogQSB0ZXh0Ym94IGNvbXBvbmVudCBmb3IgY2FwdHVyaW5nIHVzZXIgaW5wdXQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBpbml0aWFsPzogc3RyaW5nIC0gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHRleHRib3guXG4gICAqICAgcGxhY2Vob2xkZXI/OiBzdHJpbmcgLSBUaGUgcGxhY2Vob2xkZXIgdGV4dCBvZiB0aGUgdGV4dGJveC5cbiAgICogICBpY29uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGlzcGxheWluZyBhbiBpY29uIGluIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGxhYmVsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkaXNwbGF5aW5nIGEgbGFiZWwgaW4gdGhlIHRleHRib3guXG4gICAqICAgYWN0aW9uPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGlzcGxheWluZyBhbiBhY3Rpb24gY29tcG9uZW50IGluIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGxlZnRDb250ZW50PzogYm9vbGVhbiAtIEFkZHMgY29udGVudCB0byB0aGUgbGVmdCBzaWRlIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIHJpZ2h0Q29udGVudD86IGJvb2xlYW4gLSBBZGRzIGNvbnRlbnQgdG8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRleHRib3guXG4gICAqICAgdHJhbnNwYXJlbnQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IHRvIGFwcGVhciB0cmFuc3BhcmVudC5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggZm9yIGRhcmtlciBiYWNrZ3JvdW5kcy5cbiAgICogICBmb2N1cz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gc2hvdyBpdCBoYXMgZm9jdXMuXG4gICAqICAgbG9hZGluZz86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggd2l0aCBhIGxvYWRpbmcgaWNvbi5cbiAgICogICBkaXNhYmxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHRleHRib3guXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGV4dGJveC5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pik6IElWYWx1ZUNvbXBvbmVudFNpbmtzPHN0cmluZz4ge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFwiXCIpO1xuXG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmlucHV0XCIpLmV2ZW50cyh0eXBlKTtcbiAgICAgIGNvbnN0IHByb3BzJCA9IHNvdXJjZXMucHJvcHMkLnJlbWVtYmVyKCk7XG4gICAgICAvLyBjb25zdCBpbml0aWFsVmFsdWUkID0gcHJvcHMkLm1hcChwcm9wcyA9PiBwcm9wcy5pbml0aWFsKTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlJCA9IGV2dChcImlucHV0XCIpLm1hcChldiA9PiAoZXYudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlKS5yZW1lbWJlcigpO1xuICAgICAgLy8gY29uc3QgdmFsdWUkID0geHMubWVyZ2UoaW5pdGlhbFZhbHVlJCwgbmV3VmFsdWUkKTtcbiAgICAgIGNvbnN0IHZ0cmVlJCA9IHhzLmNvbWJpbmUocHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZ0cmVlJCxcbiAgICAgICAgRXZlbnRzOiBldnQsXG4gICAgICAgIHZhbHVlJDogbmV3VmFsdWUkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSB0ZXh0Ym94IGNvbXBvbmVudCBmb3IgY2FwdHVyaW5nIHVzZXIgaW5wdXQuXG4gICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAgIGluaXRpYWw/OiBzdHJpbmcgLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgdGV4dGJveC5cbiAgICogICBwbGFjZWhvbGRlcj86IHN0cmluZyAtIFRoZSBwbGFjZWhvbGRlciB0ZXh0IG9mIHRoZSB0ZXh0Ym94LlxuICAgKiAgIGljb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkaXNwbGF5aW5nIGFuIGljb24gaW4gdGhlIHRleHRib3guXG4gICAqICAgbGFiZWxlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggZm9yIGRpc3BsYXlpbmcgYSBsYWJlbCBpbiB0aGUgdGV4dGJveC5cbiAgICogICBhY3Rpb24/OiBib29sZWFuIC0gU3R5bGVzIHRoZSB0ZXh0Ym94IGZvciBkaXNwbGF5aW5nIGFuIGFjdGlvbiBjb21wb25lbnQgaW4gdGhlIHRleHRib3guXG4gICAqICAgbGVmdENvbnRlbnQ/OiBib29sZWFuIC0gQWRkcyBjb250ZW50IHRvIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHRib3guXG4gICAqICAgcmlnaHRDb250ZW50PzogYm9vbGVhbiAtIEFkZHMgY29udGVudCB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dGJveC5cbiAgICogICB0cmFuc3BhcmVudD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHRleHRib3ggdG8gYXBwZWFyIHRyYW5zcGFyZW50LlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCBmb3IgZGFya2VyIGJhY2tncm91bmRzLlxuICAgKiAgIGZvY3VzPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCB0byBzaG93IGl0IGhhcyBmb2N1cy5cbiAgICogICBsb2FkaW5nPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCB3aXRoIGEgbG9hZGluZyBpY29uLlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgdGV4dGJveCB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgdGV4dGJveC5cbiAgICogICBzaXplPzogU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0ZXh0Ym94LlxuICAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50OiBET01Db250ZW50XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzIHwgRE9NQ29udGVudCA9IHt9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7fSA6IHBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgdGV4dGJveCA9IHByb3BzLmxhcmdlXG4gICAgICA/IHRleHRhcmVhKHsgcHJvcHM6IHsgdmFsdWU6IHByb3BzLmluaXRpYWwsIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlciB9IH0pXG4gICAgICA6IGlucHV0KHsgcHJvcHM6IHsgdHlwZTogcHJvcHMudHlwZSA/IHByb3BzLnR5cGUgOiBcInRleHRcIiwgdmFsdWU6IHByb3BzLmluaXRpYWwsIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlciB9IH0pO1xuICAgIHJldHVybiBwcm9wcy5yaWdodENvbnRlbnRcbiAgICAgID8gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH0gfSwgW1xuICAgICAgICB0ZXh0Ym94LFxuICAgICAgICBjb250ZW50XG4gICAgICBdKVxuICAgICAgOiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IGdldENsYXNzbmFtZShwcm9wcykgfSB9LCBbXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIHRleHRib3hcbiAgICAgIF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NuYW1lKHByb3BzOiBQcm9wcyk6IHN0cmluZyB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMubGVmdENvbnRlbnQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsZWZ0XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yaWdodENvbnRlbnQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiByaWdodFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaWNvbikge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGljb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxhYmVsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsYWJlbGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5hY3Rpb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3Rpb25cIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRyYW5zcGFyZW50KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgdHJhbnNwYXJlbnRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZvY3VzKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZm9jdXNcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmxvYWRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBsb2FkaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGRpc2FibGVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gXCIgaW5wdXRcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWxlbWVudHMvdGV4dGJveC9pbmRleC50cyIsImV4cG9ydCBuYW1lc3BhY2UgSWNvblR5cGUge1xuICBleHBvcnQgZnVuY3Rpb24gVG9DbGFzc25hbWUodHlwZTogSWNvblR5cGUpIHtcbiAgICBpZiAodHlwZSA8IDApXG4gICAge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGxldCBuYW1lID0gSWNvblR5cGVbdHlwZV07XG4gICAgcmV0dXJuIFwiIFwiICsgbmFtZS5tYXRjaCgvW0EtWl1bYS16XSsvZykuam9pbihcIiBcIikudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gR2V0TmFtZXMoKSB7XG4gICAgbGV0IG5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvcihsZXQgbiBpbiBJY29uVHlwZSkge1xuICAgICAgaWYodHlwZW9mIEljb25UeXBlW25dID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbiAgfVxufVxuXG5leHBvcnQgZW51bSBJY29uVHlwZSB7XG4gIFNlYXJjaCxcbiAgTWFpbE91dGxpbmUsXG4gIEV4dGVybmFsLFxuICBTaWduYWwsXG4gIFNldHRpbmcsXG4gIEhvbWUsXG4gIEluYm94LFxuICBCcm93c2VyLFxuICBUYWcsXG4gIFRhZ3MsXG4gIENhbGVuZGFyLFxuICBDb21tZW50LFxuICBDb21tZW50cyxcbiAgU2hvcCxcbiAgUHJpdmFjeSxcbiAgU2V0dGluZ3MsXG4gIFRyb3BoeSxcbiAgUGF5bWVudCxcbiAgRmVlZCxcbiAgQWxhcm1PdXRsaW5lLFxuICBUYXNrcyxcbiAgQ2xvdWQsXG4gIExhYixcbiAgTWFpbCxcbiAgSWRlYSxcbiAgRGFzaGJvYXJkLFxuICBTaXRlbWFwLFxuICBBbGFybSxcbiAgVGVybWluYWwsXG4gIENvZGUsXG4gIFByb3RlY3QsXG4gIENhbGVuZGFyT3V0bGluZSxcbiAgVGlja2V0LFxuICBFeHRlcm5hbFNxdWFyZSxcbiAgTWFwLFxuICBCdWcsXG4gIE1haWxTcXVhcmUsXG4gIEhpc3RvcnksXG4gIE9wdGlvbnMsXG4gIENvbW1lbnRPdXRsaW5lLFxuICBDb21tZW50c091dGxpbmUsXG4gIFRleHRUZWxlcGhvbmUsXG4gIEZpbmQsXG4gIFdpZmksXG4gIEFsYXJtU2xhc2gsXG4gIEFsYXJtU2xhc2hPdXRsaW5lLFxuICBDb3B5cmlnaHQsXG4gIEF0LFxuICBFeWVkcm9wcGVyLFxuICBQYWludEJydXNoLFxuICBIZWFydGJlYXQsXG4gIERvd25sb2FkLFxuICBSZXBlYXQsXG4gIFJlZnJlc2gsXG4gIExvY2ssXG4gIEJvb2ttYXJrLFxuICBQcmludCxcbiAgV3JpdGUsXG4gIFRoZW1lLFxuICBBZGp1c3QsXG4gIEVkaXQsXG4gIEV4dGVybmFsU2hhcmUsXG4gIEJhbixcbiAgTWFpbEZvcndhcmQsXG4gIFNoYXJlLFxuICBFeHBhbmQsXG4gIENvbXByZXNzLFxuICBVbmhpZGUsXG4gIEhpZGUsXG4gIFJhbmRvbSxcbiAgUmV0d2VldCxcbiAgU2lnbk91dCxcbiAgUGluLFxuICBTaWduSW4sXG4gIFVwbG9hZCxcbiAgQ2FsbCxcbiAgQ2FsbFNxdWFyZSxcbiAgUmVtb3ZlQm9va21hcmssXG4gIFVubG9jayxcbiAgQ29uZmlndXJlLFxuICBGaWx0ZXIsXG4gIFdpemFyZCxcbiAgVW5kbyxcbiAgRXhjaGFuZ2UsXG4gIENsb3VkRG93bmxvYWQsXG4gIENsb3VkVXBsb2FkLFxuICBSZXBseSxcbiAgUmVwbHlBbGwsXG4gIEVyYXNlLFxuICBVbmxvY2tBbHRlcm5hdGUsXG4gIEFyY2hpdmUsXG4gIFRyYW5zbGF0ZSxcbiAgUmVjeWNsZSxcbiAgU2VuZCxcbiAgU2VuZE91dGxpbmUsXG4gIFNoYXJlQWx0ZXJuYXRlLFxuICBTaGFyZUFsdGVybmF0ZVNxdWFyZSxcbiAgV2FpdCxcbiAgV3JpdGVTcXVhcmUsXG4gIFNoYXJlU3F1YXJlLFxuICBBZGRUb0NhcnQsXG4gIEluQ2FydCxcbiAgQWRkVXNlcixcbiAgUmVtb3ZlVXNlcixcbiAgSGVscENpcmNsZSxcbiAgSW5mb0NpcmNsZSxcbiAgV2FybmluZyxcbiAgV2FybmluZ0NpcmNsZSxcbiAgV2FybmluZ1NpZ24sXG4gIEhlbHAsXG4gIEluZm8sXG4gIEFubm91bmNlbWVudCxcbiAgQmlydGhkYXksXG4gIFVzZXJzLFxuICBEb2N0b3IsXG4gIENoaWxkLFxuICBVc2VyLFxuICBIYW5kaWNhcCxcbiAgU3R1ZGVudCxcbiAgU3B5LFxuICBHcmlkTGF5b3V0LFxuICBMaXN0TGF5b3V0LFxuICBCbG9ja0xheW91dCxcbiAgWm9vbSxcbiAgWm9vbU91dCxcbiAgUmVzaXplVmVydGljYWwsXG4gIFJlc2l6ZUhvcml6b250YWwsXG4gIE1heGltaXplLFxuICBDcm9wLFxuICBGZW1hbGUsXG4gIE1hbGUsXG4gIFdvbWFuLFxuICBNYW4sXG4gIE5vbkJpbmFyeVRyYW5zZ2VuZGVyLFxuICBJbnRlcmdlbmRlcixcbiAgVHJhbnNnZW5kZXIsXG4gIExlc2JpYW4sXG4gIEdheSxcbiAgSGV0ZXJvc2V4dWFsLFxuICBPdGhlckdlbmRlcixcbiAgT3RoZXJHZW5kZXJWZXJ0aWNhbCxcbiAgT3RoZXJHZW5kZXJIb3Jpem9udGFsLFxuICBOZXV0ZXIsXG4gIENvY2t0YWlsLFxuICBSb2FkLFxuICBGbGFnLFxuICBCb29rLFxuICBHaWZ0LFxuICBMZWFmLFxuICBGaXJlLFxuICBQbGFuZSxcbiAgTWFnbmV0LFxuICBMZWdhbCxcbiAgTGVtb24sXG4gIFdvcmxkLFxuICBUcmF2ZWwsXG4gIFNoaXBwaW5nLFxuICBNb25leSxcbiAgTGlnaHRuaW5nLFxuICBSYWluLFxuICBUcmVhdG1lbnQsXG4gIFN1aXRjYXNlLFxuICBCYXIsXG4gIEZsYWdPdXRsaW5lLFxuICBGbGFnQ2hlY2tlcmVkLFxuICBQdXp6bGUsXG4gIEZpcmVFeHRpbmd1aXNoZXIsXG4gIFJvY2tldCxcbiAgQW5jaG9yLFxuICBCdWxsc2V5ZSxcbiAgU3VuLFxuICBNb29uLFxuICBGYXgsXG4gIExpZmVSaW5nLFxuICBCb21iLFxuICBTb2NjZXIsXG4gIENhbGN1bGF0b3IsXG4gIERpYW1vbmQsXG4gIENyb3NzaGFpcnMsXG4gIEFzdGVyaXNrLFxuICBDZXJ0aWZpY2F0ZSxcbiAgQ2lyY2xlLFxuICBRdW90ZUxlZnQsXG4gIFF1b3RlUmlnaHQsXG4gIEVsbGlwc2lzSG9yaXpvbnRhbCxcbiAgRWxsaXBzaXNWZXJ0aWNhbCxcbiAgQ3ViZSxcbiAgQ3ViZXMsXG4gIENpcmNsZU5vdGNoZWQsXG4gIENpcmNsZVRoaW4sXG4gIFNxdWFyZU91dGxpbmUsXG4gIFNxdWFyZSxcbiAgQ2hlY2ttYXJrLFxuICBSZW1vdmUsXG4gIENoZWNrbWFya0JveCxcbiAgTW92ZSxcbiAgQWRkQ2lyY2xlLFxuICBNaW51c0NpcmNsZSxcbiAgUmVtb3ZlQ2lyY2xlLFxuICBDaGVja0NpcmNsZSxcbiAgUmVtb3ZlQ2lyY2xlT3V0bGluZSxcbiAgQ2hlY2tDaXJjbGVPdXRsaW5lLFxuICBQbHVzLFxuICBNaW51cyxcbiAgQWRkU3F1YXJlLFxuICBSYWRpbyxcbiAgU2VsZWN0ZWRSYWRpbyxcbiAgTWludXNTcXVhcmUsXG4gIE1pbnVzU3F1YXJlT3V0bGluZSxcbiAgQ2hlY2tTcXVhcmUsXG4gIFBsdXNTcXVhcmVPdXRsaW5lLFxuICBUb2dnbGVPZmYsXG4gIFRvZ2dsZU9uLFxuICBGaWxtLFxuICBTb3VuZCxcbiAgUGhvdG8sXG4gIEJhckNoYXJ0LFxuICBDYW1lcmFSZXRybyxcbiAgTmV3c3BhcGVyLFxuICBBcmVhQ2hhcnQsXG4gIFBpZUNoYXJ0LFxuICBMaW5lQ2hhcnQsXG4gIEFycm93Q2lyY2xlT3V0bGluZURvd24sXG4gIEFycm93Q2lyY2xlT3V0bGluZVVwLFxuICBDaGV2cm9uTGVmdCxcbiAgQ2hldnJvblJpZ2h0LFxuICBBcnJvd0xlZnQsXG4gIEFycm93UmlnaHQsXG4gIEFycm93VXAsXG4gIEFycm93RG93bixcbiAgQ2hldnJvblVwLFxuICBDaGV2cm9uRG93bixcbiAgUG9pbnRpbmdSaWdodCxcbiAgUG9pbnRpbmdMZWZ0LFxuICBQb2ludGluZ1VwLFxuICBQb2ludGluZ0Rvd24sXG4gIEFycm93Q2lyY2xlTGVmdCxcbiAgQXJyb3dDaXJjbGVSaWdodCxcbiAgQXJyb3dDaXJjbGVVcCxcbiAgQXJyb3dDaXJjbGVEb3duLFxuICBDYXJldERvd24sXG4gIENhcmV0VXAsXG4gIENhcmV0TGVmdCxcbiAgQ2FyZXRSaWdodCxcbiAgQW5nbGVEb3VibGVMZWZ0LFxuICBBbmdsZURvdWJsZVJpZ2h0LFxuICBBbmdsZURvdWJsZVVwLFxuICBBbmdsZURvdWJsZURvd24sXG4gIEFuZ2xlTGVmdCxcbiAgQW5nbGVSaWdodCxcbiAgQW5nbGVVcCxcbiAgQW5nbGVEb3duLFxuICBDaGV2cm9uQ2lyY2xlTGVmdCxcbiAgQ2hldnJvbkNpcmNsZVJpZ2h0LFxuICBDaGV2cm9uQ2lyY2xlVXAsXG4gIENoZXZyb25DaXJjbGVEb3duLFxuICBUb2dnbGVEb3duLFxuICBUb2dnbGVVcCxcbiAgVG9nZ2xlUmlnaHQsXG4gIExvbmdBcnJvd0Rvd24sXG4gIExvbmdBcnJvd1VwLFxuICBMb25nQXJyb3dMZWZ0LFxuICBMb25nQXJyb3dSaWdodCxcbiAgQXJyb3dDaXJjbGVPdXRsaW5lUmlnaHQsXG4gIEFycm93Q2lyY2xlT3V0bGluZUxlZnQsXG4gIFRvZ2dsZUxlZnQsXG4gIFBvd2VyLFxuICBUcmFzaCxcbiAgVHJhc2hPdXRsaW5lLFxuICBEaXNrT3V0bGluZSxcbiAgRGVza3RvcCxcbiAgTGFwdG9wLFxuICBUYWJsZXQsXG4gIE1vYmlsZSxcbiAgR2FtZSxcbiAgS2V5Ym9hcmQsXG4gIFBsdWcsXG4gIEZvbGRlcixcbiAgRm9sZGVyT3BlbixcbiAgTGV2ZWxVcCxcbiAgTGV2ZWxEb3duLFxuICBGaWxlLFxuICBGaWxlT3V0bGluZSxcbiAgRmlsZVRleHQsXG4gIEZpbGVUZXh0T3V0bGluZSxcbiAgRm9sZGVyT3V0bGluZSxcbiAgRm9sZGVyT3Blbk91dGxpbmUsXG4gIEZpbGVQZGZPdXRsaW5lLFxuICBGaWxlV29yZE91dGxpbmUsXG4gIEZpbGVFeGNlbE91dGxpbmUsXG4gIEZpbGVQb3dlcnBvaW50T3V0bGluZSxcbiAgRmlsZUltYWdlT3V0bGluZSxcbiAgRmlsZUFyY2hpdmVPdXRsaW5lLFxuICBGaWxlQXVkaW9PdXRsaW5lLFxuICBGaWxlVmlkZW9PdXRsaW5lLFxuICBGaWxlQ29kZU91dGxpbmUsXG4gIEJhcmNvZGUsXG4gIFFyY29kZSxcbiAgRm9yayxcbiAgSHRtbDUsXG4gIENzczMsXG4gIFJzcyxcbiAgUnNzU3F1YXJlLFxuICBPcGVuaWQsXG4gIERhdGFiYXNlLFxuICBTZXJ2ZXIsXG4gIEhlYXJ0LFxuICBTdGFyLFxuICBFbXB0eVN0YXIsXG4gIFRodW1ic091dGxpbmVVcCxcbiAgVGh1bWJzT3V0bGluZURvd24sXG4gIFN0YXJIYWxmLFxuICBFbXB0eUhlYXJ0LFxuICBTbWlsZSxcbiAgRnJvd24sXG4gIE1laCxcbiAgU3RhckhhbGZFbXB0eSxcbiAgVGh1bWJzVXAsXG4gIFRodW1ic0Rvd24sXG4gIE11c2ljLFxuICBWaWRlb1BsYXlPdXRsaW5lLFxuICBWb2x1bWVPZmYsXG4gIFZvbHVtZURvd24sXG4gIFZvbHVtZVVwLFxuICBSZWNvcmQsXG4gIFN0ZXBCYWNrd2FyZCxcbiAgRmFzdEJhY2t3YXJkLFxuICBCYWNrd2FyZCxcbiAgUGxheSxcbiAgUGF1c2UsXG4gIFN0b3AsXG4gIEZvcndhcmQsXG4gIEZhc3RGb3J3YXJkLFxuICBTdGVwRm9yd2FyZCxcbiAgRWplY3QsXG4gIFVubXV0ZSxcbiAgTXV0ZSxcbiAgVmlkZW9QbGF5LFxuICBDbG9zZWRDYXB0aW9uaW5nLFxuICBNYXJrZXIsXG4gIENvZmZlZSxcbiAgRm9vZCxcbiAgQnVpbGRpbmdPdXRsaW5lLFxuICBIb3NwaXRhbCxcbiAgRW1lcmdlbmN5LFxuICBGaXJzdEFpZCxcbiAgTWlsaXRhcnksXG4gIEgsXG4gIExvY2F0aW9uQXJyb3csXG4gIFNwYWNlU2h1dHRsZSxcbiAgVW5pdmVyc2l0eSxcbiAgQnVpbGRpbmcsXG4gIFBhdyxcbiAgU3Bvb24sXG4gIENhcixcbiAgVGF4aSxcbiAgVHJlZSxcbiAgQmljeWNsZSxcbiAgQnVzLFxuICBTaGlwLFxuICBNb3RvcmN5Y2xlLFxuICBTdHJlZXRWaWV3LFxuICBIb3RlbCxcbiAgVHJhaW4sXG4gIFN1YndheSxcbiAgVGFibGUsXG4gIENvbHVtbnMsXG4gIFNvcnQsXG4gIFNvcnRBc2NlbmRpbmcsXG4gIFNvcnREZXNjZW5kaW5nLFxuICBTb3J0QWxwaGFiZXRBc2NlbmRpbmcsXG4gIFNvcnRBbHBoYWJldERlc2NlbmRpbmcsXG4gIFNvcnRDb250ZW50QXNjZW5kaW5nLFxuICBTb3J0Q29udGVudERlc2NlbmRpbmcsXG4gIFNvcnROdW1lcmljQXNjZW5kaW5nLFxuICBTb3J0TnVtZXJpY0Rlc2NlbmRpbmcsXG4gIEZvbnQsXG4gIEJvbGQsXG4gIEl0YWxpYyxcbiAgVGV4dEhlaWdodCxcbiAgVGV4dFdpZHRoLFxuICBBbGlnbkxlZnQsXG4gIEFsaWduQ2VudGVyLFxuICBBbGlnblJpZ2h0LFxuICBBbGlnbkp1c3RpZnksXG4gIExpc3QsXG4gIE91dGRlbnQsXG4gIEluZGVudCxcbiAgTGlua2lmeSxcbiAgQ3V0LFxuICBDb3B5LFxuICBBdHRhY2gsXG4gIFNhdmUsXG4gIENvbnRlbnQsXG4gIFVub3JkZXJlZExpc3QsXG4gIE9yZGVyZWRMaXN0LFxuICBTdHJpa2V0aHJvdWdoLFxuICBVbmRlcmxpbmUsXG4gIFBhc3RlLFxuICBVbmxpbmssXG4gIFN1cGVyc2NyaXB0LFxuICBTdWJzY3JpcHQsXG4gIEhlYWRlcixcbiAgUGFyYWdyYXBoLFxuICBFdXJvLFxuICBQb3VuZCxcbiAgRG9sbGFyLFxuICBSdXBlZSxcbiAgWWVuLFxuICBSdWJsZSxcbiAgV29uLFxuICBMaXJhLFxuICBTaGVrZWwsXG4gIFBheXBhbCxcbiAgUGF5cGFsQ2FyZCxcbiAgR29vZ2xlV2FsbGV0LFxuICBWaXNhLFxuICBNYXN0ZXJjYXJkLFxuICBEaXNjb3ZlcixcbiAgQW1lcmljYW5FeHByZXNzLFxuICBTdHJpcGUsXG4gIFR3aXR0ZXJTcXVhcmUsXG4gIEZhY2Vib29rU3F1YXJlLFxuICBMaW5rZWRpblNxdWFyZSxcbiAgR2l0aHViU3F1YXJlLFxuICBUd2l0dGVyLFxuICBGYWNlYm9vayxcbiAgR2l0aHViLFxuICBQaW50ZXJlc3QsXG4gIFBpbnRlcmVzdFNxdWFyZSxcbiAgR29vZ2xlUGx1c1NxdWFyZSxcbiAgR29vZ2xlUGx1cyxcbiAgTGlua2VkaW4sXG4gIEdpdGh1YkFsdGVybmF0ZSxcbiAgTWF4Y2RuLFxuICBCaXRjb2luLFxuICBZb3V0dWJlU3F1YXJlLFxuICBZb3V0dWJlLFxuICBYaW5nLFxuICBYaW5nU3F1YXJlLFxuICBZb3V0dWJlUGxheSxcbiAgRHJvcGJveCxcbiAgU3RhY2tPdmVyZmxvdyxcbiAgSW5zdGFncmFtLFxuICBGbGlja3IsXG4gIEFkbixcbiAgQml0YnVja2V0LFxuICBCaXRidWNrZXRTcXVhcmUsXG4gIFR1bWJscixcbiAgVHVtYmxyU3F1YXJlLFxuICBBcHBsZSxcbiAgV2luZG93cyxcbiAgQW5kcm9pZCxcbiAgTGludXgsXG4gIERyaWJiYmxlLFxuICBTa3lwZSxcbiAgRm91cnNxdWFyZSxcbiAgVHJlbGxvLFxuICBHaXR0aXAsXG4gIFZrLFxuICBXZWlibyxcbiAgUmVucmVuLFxuICBQYWdlbGluZXMsXG4gIFN0YWNrRXhjaGFuZ2UsXG4gIFZpbWVvLFxuICBTbGFjayxcbiAgV29yZHByZXNzLFxuICBZYWhvbyxcbiAgR29vZ2xlLFxuICBSZWRkaXQsXG4gIFJlZGRpdFNxdWFyZSxcbiAgU3R1bWJsZXVwb25DaXJjbGUsXG4gIFN0dW1ibGV1cG9uLFxuICBEZWxpY2lvdXMsXG4gIERpZ2csXG4gIFBpZWRQaXBlcixcbiAgUGllZFBpcGVyQWx0ZXJuYXRlLFxuICBEcnVwYWwsXG4gIEpvb21sYSxcbiAgQmVoYW5jZSxcbiAgQmVoYW5jZVNxdWFyZSxcbiAgU3RlYW0sXG4gIFN0ZWFtU3F1YXJlLFxuICBTcG90aWZ5LFxuICBEZXZpYW50YXJ0LFxuICBTb3VuZGNsb3VkLFxuICBWaW5lLFxuICBDb2RlcGVuLFxuICBKc2ZpZGRsZSxcbiAgUmViZWwsXG4gIEVtcGlyZSxcbiAgR2l0U3F1YXJlLFxuICBHaXQsXG4gIEhhY2tlck5ld3MsXG4gIFRlbmNlbnRXZWlibyxcbiAgUXEsXG4gIFdlY2hhdCxcbiAgU2xpZGVzaGFyZSxcbiAgVHdpdGNoLFxuICBZZWxwLFxuICBMYXN0Zm0sXG4gIExhc3RmbVNxdWFyZSxcbiAgSW94aG9zdCxcbiAgQW5nZWxsaXN0LFxuICBNZWFucGF0aCxcbiAgQnV5c2VsbGFkcyxcbiAgQ29ubmVjdGRldmVsb3AsXG4gIERhc2hjdWJlLFxuICBGb3J1bWJlZSxcbiAgTGVhbnB1YixcbiAgU2VsbHN5LFxuICBTaGlydHNpbmJ1bGssXG4gIFNpbXBseWJ1aWx0LFxuICBTa3lhdGxhcyxcbiAgV2hhdHNhcHAsXG4gIFZpYWNvaW4sXG4gIE1lZGl1bSxcbiAgTGlrZSxcbiAgRmF2b3JpdGUsXG4gIFZpZGVvLFxuICBDaGVjayxcbiAgQ2xvc2UsXG4gIENhbmNlbCxcbiAgRGVsZXRlLFxuICBYLFxuICBVc2VyVGltZXMsXG4gIFVzZXJDbG9zZSxcbiAgVXNlckNhbmNlbCxcbiAgVXNlckRlbGV0ZSxcbiAgVXNlclgsXG4gIFpvb21JbixcbiAgTWFnbmlmeSxcbiAgU2h1dGRvd24sXG4gIENsb2NrLFxuICBUaW1lLFxuICBQbGF5Q2lyY2xlT3V0bGluZSxcbiAgSGVhZHBob25lLFxuICBDYW1lcmEsXG4gIFZpZGVvQ2FtZXJhLFxuICBQaWN0dXJlLFxuICBQZW5jaWwsXG4gIENvbXBvc2UsXG4gIFBvaW50LFxuICBUaW50LFxuICBTaWdudXAsXG4gIFBsdXNDaXJjbGUsXG4gIERvbnQsXG4gIE1pbmltaXplLFxuICBBZGQsXG4gIEV5ZSxcbiAgQXR0ZW50aW9uLFxuICBDYXJ0LFxuICBTaHVmZmxlLFxuICBUYWxrLFxuICBDaGF0LFxuICBTaG9wcGluZ0NhcnQsXG4gIEJhckdyYXBoLFxuICBBcmVhR3JhcGgsXG4gIFBpZUdyYXBoLFxuICBMaW5lR3JhcGgsXG4gIEtleSxcbiAgQ29ncyxcbiAgRGlzY3Vzc2lvbnMsXG4gIExpa2VPdXRsaW5lLFxuICBEaXNsaWtlT3V0bGluZSxcbiAgSGVhcnRPdXRsaW5lLFxuICBMb2dPdXQsXG4gIFRodW1iVGFjayxcbiAgV2lubmVyLFxuICBCb29rbWFya091dGxpbmUsXG4gIFBob25lLFxuICBQaG9uZVNxdWFyZSxcbiAgQ3JlZGl0Q2FyZCxcbiAgSGRkT3V0bGluZSxcbiAgQnVsbGhvcm4sXG4gIEJlbGwsXG4gIEJlbGxPdXRsaW5lLFxuICBCZWxsU2xhc2gsXG4gIEJlbGxTbGFzaE91dGxpbmUsXG4gIEhhbmRPdXRsaW5lUmlnaHQsXG4gIEhhbmRPdXRsaW5lTGVmdCxcbiAgSGFuZE91dGxpbmVVcCxcbiAgSGFuZE91dGxpbmVEb3duLFxuICBHbG9iZSxcbiAgV3JlbmNoLFxuICBCcmllZmNhc2UsXG4gIEdyb3VwLFxuICBGbGFzayxcbiAgU2lkZWJhcixcbiAgQmFycyxcbiAgTGlzdFVsLFxuICBMaXN0T2wsXG4gIE51bWJlcmVkTGlzdCxcbiAgTWFnaWMsXG4gIFRydWNrLFxuICBDdXJyZW5jeSxcbiAgVHJpYW5nbGVEb3duLFxuICBEcm9wZG93bixcbiAgVHJpYW5nbGVVcCxcbiAgVHJpYW5nbGVMZWZ0LFxuICBUcmlhbmdsZVJpZ2h0LFxuICBFbnZlbG9wZSxcbiAgQ29udmVyc2F0aW9uLFxuICBVbWJyZWxsYSxcbiAgQ2xpcGJvYXJkLFxuICBMaWdodGJ1bGIsXG4gIEFtYnVsYW5jZSxcbiAgTWVka2l0LFxuICBGaWdodGVySmV0LFxuICBCZWVyLFxuICBQbHVzU3F1YXJlLFxuICBDb21wdXRlcixcbiAgQ2lyY2xlT3V0bGluZSxcbiAgSW50ZXJzZXgsXG4gIEFzZXh1YWwsXG4gIFNwaW5uZXIsXG4gIEdhbWVwYWQsXG4gIFN0YXJIYWxmRnVsbCxcbiAgUXVlc3Rpb24sXG4gIEVyYXNlcixcbiAgTWljcm9waG9uZSxcbiAgTWljcm9waG9uZVNsYXNoLFxuICBTaGllbGQsXG4gIFRhcmdldCxcbiAgUGxheUNpcmNsZSxcbiAgUGVuY2lsU3F1YXJlLFxuICBDb21wYXNzLFxuICBBbWV4LFxuICBFdXIsXG4gIEdicCxcbiAgVXNkLFxuICBJbnIsXG4gIENueSxcbiAgUm1iLFxuICBKcHksXG4gIFJvdWJsZSxcbiAgUnViLFxuICBLcncsXG4gIEJ0YyxcbiAgU2hlcWVsLFxuICBJbHMsXG4gIFRyeSxcbiAgWmlwLFxuICBEb3RDaXJjbGVPdXRsaW5lLFxuICBTbGlkZXJzLFxuICBXaSxcbiAgR3JhZHVhdGlvbixcbiAgV2VpeGluLFxuICBCaW5vY3VsYXJzLFxuICBHcmF0aXBheSxcbiAgR2VuZGVybGVzcyxcbiAgVGVsZXR5cGUsXG4gIFBvd2VyQ29yZCxcbiAgVHR5LFxuICBDYyxcbiAgUGx1c0NhcnQsXG4gIEFycm93RG93bkNhcnQsXG4gIERldGVjdGl2ZSxcbiAgVmVudXMsXG4gIE1hcnMsXG4gIE1lcmN1cnksXG4gIFZlbnVzRG91YmxlLFxuICBGZW1hbGVIb21vc2V4dWFsLFxuICBNYXJzRG91YmxlLFxuICBNYWxlSG9tb3NleHVhbCxcbiAgVmVudXNNYXJzLFxuICBNYXJzU3Ryb2tlLFxuICBNYXJzQWx0ZXJuYXRlLFxuICBNYXJzVmVydGljYWwsXG4gIE1hcnNIb3Jpem9udGFsLFxuICBNYXJzU3Ryb2tlVmVydGljYWwsXG4gIE1hcnNTdHJva2VIb3Jpem9udGFsLFxuICBGYWNlYm9va09mZmljaWFsLFxuICBQaW50ZXJlc3RPZmZpY2lhbCxcbiAgQmVkXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZW51bXMvaWNvblR5cGUudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9jb2xsZWN0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZWxlbWVudHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21vZHVsZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3ZpZXdzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9lbnVtc1wiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlcywgaXNET01Db250ZW50fSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7aW5wdXQsIGxhYmVsLCBkaXYsIFZOb2RlfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIENoZWNrYm94IHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHk/OiBib29sZWFuO1xuICAgIGNoZWNrZWQ/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBmaXR0ZWQ/OiBib29sZWFuO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgcmFkaW8/OiBib29sZWFuO1xuICAgIHRvZ2dsZT86IGJvb2xlYW47XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIGNoZWNrYm94IGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gcHJvcHMkOlxuICAqICAgcmVhZG9ubHk/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgcmVhZC1vbmx5LlxuICAqICAgY2hlY2tlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIGNoZWNrYm94IHRvIGFwcGVhciBjaGVja2VkLlxuICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgZGlzYWJsZWQuXG4gICogICBmaXR0ZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCBmb3IgdGlnaHQgZml0cyB3aXRoIG5lYXJieSBjb250ZW50LlxuICAqICAgcmFkaW8/OiBzdHJpbmcgLSBTdHlsZXMgdGhlIGNoZWNrYm94IHRvIGFwcGVhciBsaWtlIGEgcmFkaW8gYnV0dG9uIGJlbG9uZ2luZyB0byB0aGUgZ3JvdXAuXG4gICogICB0b2dnbGU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgbGlrZSBhIHRvZ2dsZS5cbiAgKiBFeHBlY3RzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBjb250ZW50IGluIGNvbnRlbnQkOiBET01Db250ZW50XG4gICogQHBhcmFtIHtDb21wb25lbnRTb3VyY2VzfSBzb3VyY2VzIFRoZSBkZWZhdWx0IGNvbXBvbmVudCBzb3VyY2VzLlxuICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIERPTUNvbnRlbnQ+KSB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG5cbiAgICAgIGNvbnN0IGV2dCA9ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCJpbnB1dFwiKS5ldmVudHModHlwZSk7XG4gICAgICBjb25zdCBjbGlja2VkJCA9IGV2dChcImNsaWNrXCIpO1xuICAgICAgY29uc3QgcHJvcHMkID0gc291cmNlcy5wcm9wcyQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IGNoZWNrZWQkID0gcHJvcHMkLm1hcChwcm9wcyA9PlxuICAgICAgICBjbGlja2VkJC5mb2xkKChhY2MsIGV2dCkgPT4gKGV2dC5zcmNFbGVtZW50IGFzIGFueSkuY2hlY2tlZCwgcHJvcHMuY2hlY2tlZCA/IHRydWUgOiBmYWxzZSlcbiAgICAgICkuZmxhdHRlbigpLnJlbWVtYmVyKCk7XG4gICAgICAvLyBjb25zdCByZW5kZXJQcm9wcyQgPSAgeHMuY29tYmluZShwcm9wcyQsIGNoZWNrZWQkKS5tYXAoXG4gICAgICAvLyAgIChbcHJvcHMsIGNoZWNrZWRdKSA9PiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge2NoZWNrZWR9KVxuICAgICAgLy8gKTtcbiAgICAgIGNvbnN0IHZUcmVlJCA9IHhzLmNvbWJpbmUocHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBET006IHZUcmVlJCxcbiAgICAgICAgRXZlbnRzOiBldnQsXG4gICAgICAgIHZhbHVlJDogY2hlY2tlZCRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAqIENyZWF0ZXMgYSBjaGVja2JveCBlbGVtZW50IG9uIHRoZSBwYWdlLlxuICAqIEFjY2VwdHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgKiAgIHJlYWRvbmx5PzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIHJlYWQtb25seS5cbiAgKiAgIGNoZWNrZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgY2hlY2tlZC5cbiAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGRpc2FibGVkLlxuICAqICAgZml0dGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggZm9yIHRpZ2h0IGZpdHMgd2l0aCBuZWFyYnkgY29udGVudC5cbiAgKiAgIHJhZGlvPzogc3RyaW5nIC0gU3R5bGVzIHRoZSBjaGVja2JveCB0byBhcHBlYXIgbGlrZSBhIHJhZGlvIGJ1dHRvbiBiZWxvbmdpbmcgdG8gdGhlIGdyb3VwLlxuICAqICAgdG9nZ2xlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgY2hlY2tib3ggdG8gYXBwZWFyIGxpa2UgYSB0b2dnbGUuXG4gICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogRE9NQ29udGVudFxuICAqIEBwYXJhbSB7Q29tcG9uZW50U291cmNlc30gc291cmNlcyBUaGUgZGVmYXVsdCBjb21wb25lbnQgc291cmNlcy5cbiAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wc3xET01Db250ZW50ID0ge30sIGM6IERPTUNvbnRlbnQgPSBcIlwiKSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7Y2xhc3NOYW1lOiBnZXRDbGFzc05hbWUocHJvcHMpIH19LCBbXG4gICAgICBpbnB1dCh7cHJvcHM6IHtcbiAgICAgICAgdHlwZTogcHJvcHMucmFkaW8gPyBcInJhZGlvXCIgOiBcImNoZWNrYm94XCIsXG4gICAgICAgIG5hbWU6cHJvcHMubmFtZSwgXG4gICAgICAgIGNoZWNrZWQ6cHJvcHMuY2hlY2tlZCwgXG4gICAgICAgIGRpc2FibGVkOnByb3BzLnJlYWRvbmx5fHxwcm9wcy5kaXNhYmxlZFxuICAgICAgfX0pLFxuICAgICAgbGFiZWwoe3Byb3BzOiB7Zm9yOnByb3BzLm5hbWV9fSwgcHJvcHMuZml0dGVkID8gXCJcIiA6IGNvbnRlbnQpXG4gICAgXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BzOiBQcm9wcykgOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLnJlYWRvbmx5KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmVhZC1vbmx5XCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaGVja2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY2hlY2tlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZml0dGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZml0dGVkXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5yYWRpbykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHJhZGlvXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy50b2dnbGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB0b2dnbGVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIGNoZWNrYm94XCI7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL2NoZWNrYm94L2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElWYWx1ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IEljb25UeXBlLCBDb2xvciwgU2l6ZSwgQW5pbWF0aW9uLCBEaXJlY3Rpb24gfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGRyb3BSZXBlYXRzIGZyb20gXCJ4c3RyZWFtL2V4dHJhL2Ryb3BSZXBlYXRzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcInhzdHJlYW0vZXh0cmEvZGVib3VuY2VcIjtcbmltcG9ydCBjb25jYXQgZnJvbSBcInhzdHJlYW0vZXh0cmEvY29uY2F0XCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCBkZWxheSBmcm9tIFwieHN0cmVhbS9leHRyYS9kZWxheVwiO1xuaW1wb3J0IHsgZGl2LCBpbnB1dCB9IGZyb20gXCJAY3ljbGUvZG9tXCI7XG5cbmltcG9ydCB7IE1lbnUgfSBmcm9tIFwiLi4vLi4vY29sbGVjdGlvbnMvbWVudVwiO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gXCIuLi8uLi9lbGVtZW50cy9pY29uXCI7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4uLy4uL21vZHVsZXMvdHJhbnNpdGlvblwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIERyb3Bkb3duIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgc3RhdGljPzogc3RyaW5nO1xuICAgIHJpZ2h0QWxpZ25lZD86IGJvb2xlYW47XG4gICAgYWN0aXZlPzogYm9vbGVhbjtcbiAgICBpbml0aWFsPzogYW55O1xuICAgIGRlZmF1bHQ/OiBzdHJpbmc7XG4gICAgc2VsZWN0aW9uPzogYm9vbGVhbjtcbiAgICBpbmxpbmU/OiBib29sZWFuO1xuICAgIGZsb2F0aW5nPzogYm9vbGVhbjtcbiAgICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG4gICAgc2Nyb2xsaW5nPzogYm9vbGVhbjtcbiAgICBjb21wYWN0PzogYm9vbGVhbjtcbiAgICBzZWFyY2g/OiBib29sZWFuO1xuICAgIHBvaW50aW5nPzogYm9vbGVhbjtcbiAgICBzaXplPzogU2l6ZTtcbiAgICBjb2xvcj86IENvbG9yO1xuICB9XG4gIGV4cG9ydCB0eXBlIENvbnRlbnQ8Vj4gPSBBcnJheTxEcm9wZG93bkl0ZW08Vj4+O1xuICBleHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSXRlbTxWPiB7XG4gICAgYm9keTogRE9NQ29udGVudDtcbiAgICB2YWx1ZTogVjtcbiAgICBoZWFkZXI/OiBib29sZWFuO1xuICAgIGZpdHRlZD86IGJvb2xlYW47XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQSBkcm9wZG93biBjb21wb25lbnQgZm9yIGNhcHR1cmluZyB1c2VyIGlucHV0LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICBhY3RpdmU/OiBib29sZWFuLFxuICAgKiAgaW5pdGlhbD86IGFueVxuICAgKiAgZGVmYXVsdD86IHN0cmluZ1xuICAgKiAgc2VsZWN0aW9uPzogYm9vbGVhblxuICAgKiAgaW5saW5lPzogYm9vbGVhblxuICAgKiAgZmxvYXRpbmc/OiBib29sZWFuXG4gICAqICBsb2FkaW5nPzogYm9vbGVhblxuICAgKiAgZGlzYWJsZWQ/OiBib29sZWFuXG4gICAqICBzY3JvbGxpbmc/OiBib29sZWFuXG4gICAqICBzZWFyY2g/OiBib29sZWFuXG4gICAqICBjb21wYWN0PzogYm9vbGVhblxuICAgKiAgc2l6ZT86IFNpemVcbiAgICogIGNvbG9yPzogQ29sb3JcbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDogQXJyYXkgb2Yge1xuICAgKiAgYm9keTogRE9NQ29udGVudCxcbiAgICogIHZhbHVlOiBhbnksXG4gICAqICBoZWFkZXI/OiBib29sZWFuLFxuICAgKiAgZml0dGVkPzogYm9vbGVhbixcbiAgICogIGRpc2FibGVkPzogYm9vbGVhbixcbiAgICogIGFjdGl2ZT86IGJvb2xlYW5cbiAgICogfVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJ1bjxWPihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBDb250ZW50PFY+Pik6IElWYWx1ZUNvbXBvbmVudFNpbmtzPFY+IHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXM8UHJvcHMsIENvbnRlbnQ8Vj4+KSB7XG4gICAgICBjb25zdCBldnQgPSAodHlwZSkgPT4gc291cmNlcy5ET00uc2VsZWN0KFwiLmRyb3Bkb3duXCIpLmV2ZW50cyh0eXBlKTtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHt9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcblxuICAgICAgY29uc3QgcHJvcHMkID0gc291cmNlcy5wcm9wcyQucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IGl0ZW1DbGljayRwcm94eSA9IHhzLmNyZWF0ZSgpO1xuICAgICAgY29uc3QgdmFsdWUkcHJveHkgPSB4cy5jcmVhdGUoKTtcblxuICAgICAgY29uc3QgZHJvcGRvd25DbGljayQgPSBldnQoXCJjbGlja1wiKVxuICAgICAgICAuZmlsdGVyKGV2dCA9PiAhKGV2dC5zcmNFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGVtXCIpKVxuICAgICAgICAubWFwVG8oRGlyZWN0aW9uLkluKTtcbiAgICAgIGNvbnN0IG1vdXNlbGVhdmUkID0geHMubWVyZ2UoZXZ0KFwibW91c2VsZWF2ZVwiKS5maWx0ZXIoXG4gICAgICAgIGV2dCA9PiBldnQuc3JjRWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZihcImljb25cIikgPT09IC0xXG4gICAgICApLCBldnQoXCJtb3VzZWVudGVyXCIpKVxuICAgICAgICAubWFwKGV2dCA9PiAoZXZ0IGFzIE1vdXNlRXZlbnQpLnR5cGUgPT09IFwibW91c2VlbnRlclwiID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dClcbiAgICAgICAgLmNvbXBvc2UoZGVib3VuY2UoMjUwKSlcbiAgICAgICAgLmZpbHRlcihkaXIgPT4gZGlyID09PSBEaXJlY3Rpb24uT3V0KTtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0geHMubWVyZ2UoZHJvcGRvd25DbGljayQsIGl0ZW1DbGljayRwcm94eSwgbW91c2VsZWF2ZSQpXG4gICAgICAgIC5zdGFydFdpdGgoRGlyZWN0aW9uLk91dClcbiAgICAgICAgLm1hcChkaXIgPT4gKHtcbiAgICAgICAgICBhbmltYXRpb246IEFuaW1hdGlvbi5GYWRlLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyXG4gICAgICAgIH0pKVxuICAgICAgICAuY29tcG9zZShkcm9wUmVwZWF0cyhcbiAgICAgICAgICAoYSwgYikgPT4gKGEgYXMgYW55KS5kaXJlY3Rpb24gPT09IChiIGFzIGFueSkuZGlyZWN0aW9uXG4gICAgICAgICAgICAmJiAoYSBhcyBhbnkpLmFuaW1hdGlvbiA9PT0gKGIgYXMgYW55KS5hbmltYXRpb25cbiAgICAgICAgKSlcbiAgICAgICAgLmRyb3AoMSlcbiAgICAgICAgLnN0YXJ0V2l0aCh7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogRGlyZWN0aW9uLk91dCB9KTtcblxuICAgICAgY29uc3QgZmlsdGVyJCA9IHNvdXJjZXMuRE9NLnNlbGVjdChcImlucHV0XCIpLmV2ZW50cyhcImtleXVwXCIpXG4gICAgICAgIC5tYXAoZXYgPT4gKGV2LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSlcbiAgICAgICAgLnN0YXJ0V2l0aChcIlwiKSBhcyBTdHJlYW08c3RyaW5nPjtcbiAgICAgIGNvbnN0IGZpbHRlcmVkQ29udGVudCQgPSB4cy5jb21iaW5lKHNvdXJjZXMuY29udGVudCQsIGZpbHRlciQpLm1hcChcbiAgICAgICAgKFtjb250ZW50LCBmaWx0ZXJdKSA9PiBjb250ZW50LmZpbHRlcihjID0+IGZpbHRlckNvbnRlbnQoYywgZmlsdGVyKSlcbiAgICAgICkucmVtZW1iZXIoKTtcblxuICAgICAgY29uc3QgY29udGVudCQgPSB4cy5jb21iaW5lKGZpbHRlcmVkQ29udGVudCQsIHZhbHVlJHByb3h5KS5tYXAoXG4gICAgICAgIChbY29udGVudCwgdmFsdWVdKSA9PiBjb250ZW50Lm1hcChcbiAgICAgICAgICBpdGVtID0+IGl0ZW0udmFsdWUgPT09IHZhbHVlID8gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyBhY3RpdmU6IHRydWUgfSkgOiBpdGVtXG4gICAgICAgIClcbiAgICAgICkucmVtZW1iZXIoKTtcbiAgICAgIGNvbnN0IG1lbnUgPSBNZW51LnJ1bih7IERPTTogc291cmNlcy5ET00sIGNvbnRlbnQkIH0pO1xuXG4gICAgICBjb25zdCB0cmFuc2l0aW9uZWRNZW51ID0gVHJhbnNpdGlvbi5ydW4oeyBET006IHNvdXJjZXMuRE9NLCB0YXJnZXQkOiBtZW51LkRPTSwgYXJncyQ6IHRyYW5zaXRpb24kIGFzIGFueSB9KTtcblxuICAgICAgbGV0IGl0ZW1DbGljayQgPSBldnQoXCJjbGlja1wiKS5maWx0ZXIoeCA9PiB4LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGVtXCIpKS5yZW1lbWJlcigpO1xuICAgICAgaXRlbUNsaWNrJHByb3h5LmltaXRhdGUoaXRlbUNsaWNrJC5tYXBUbyhEaXJlY3Rpb24uT3V0KSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCBjbGlja2VkSWQkID0gaXRlbUNsaWNrJFxuICAgICAgICAubWFwKGV2ID0+IHBhcnNlSW50KChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmlkKSlcbiAgICAgICAgLmZpbHRlcihuID0+ICFpc05hTihuKSAmJiB0eXBlb2YgKG4pICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICAgIGNvbnN0IGVtaXR0ZWRWYWx1ZSQgPSBjbGlja2VkSWQkLm1hcChpZCA9PiBmaWx0ZXJlZENvbnRlbnQkLm1hcChpdGVtcyA9PiBpdGVtc1tpZF0udmFsdWUpLnRha2UoMSkpLmZsYXR0ZW4oKS5yZW1lbWJlcigpIGFzIGFueTtcbiAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSQgPSBwcm9wcyQubWFwKHByb3BzID0+IHByb3BzLmluaXRpYWwpLnJlbWVtYmVyKCk7XG4gICAgICB2YWx1ZSRwcm94eS5pbWl0YXRlKHhzLm1lcmdlKGluaXRpYWxWYWx1ZSQgYXMgYW55LCBlbWl0dGVkVmFsdWUkKSk7XG5cbiAgICAgIGNvbnN0IGljb24gPSBJY29uLnJlbmRlcih7fSwgSWNvblR5cGUuRHJvcGRvd24pO1xuICAgICAgY29uc3QgYWN0aXZlJCA9IHhzLm1lcmdlKFxuICAgICAgICB0cmFuc2l0aW9uJC5maWx0ZXIoeCA9PiB4LmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLkluKS5tYXBUbyh0cnVlKSxcbiAgICAgICAgdHJhbnNpdGlvbiQuZmlsdGVyKHggPT4geC5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5PdXQpLmNvbXBvc2UoZGVsYXkoMjUwKSkubWFwVG8oZmFsc2UpXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RyZWFtcyA9IHhzLmNvbWJpbmUoXG4gICAgICAgIHByb3BzJCxcbiAgICAgICAgYWN0aXZlJCxcbiAgICAgICAgdHJhbnNpdGlvbmVkTWVudS5ET00sXG4gICAgICAgIGNvbnRlbnQkLm1hcChjb250ZW50ID0+IGNvbnRlbnQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5hY3RpdmUpWzBdKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZ0cmVlJCA9IHN0cmVhbXMubWFwKFxuICAgICAgICAoW3Byb3BzLCBhY3RpdmUsIG1lbnUsIGl0ZW1dKSA9PlxuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKHByb3BzLCBhY3RpdmUpIH0gfSwgW1xuICAgICAgICAgICAgZ2V0VGV4dChpdGVtLCBwcm9wcyksXG4gICAgICAgICAgICBwcm9wcy5zZWFyY2ggPyBpbnB1dCh7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJzZWFyY2hcIiB9IH0pIDogXCJcIixcbiAgICAgICAgICAgIGljb24sIG1lbnVcbiAgICAgICAgICBdKVxuICAgICAgKS5yZW1lbWJlcigpO1xuXG4gICAgICAvL1RvZG8gZmluZCBjbGVhbmVyIHdheSB0byBjbGVhciBpbnB1dCB1c2luZyBzbmFiYmRvbSBob29rcz9cbiAgICAgIGVtaXR0ZWRWYWx1ZSQubWFwKF8gPT4gdnRyZWUkLnRha2UoMSkpLmZsYXR0ZW4oKS5hZGRMaXN0ZW5lcihuZXcgRXhlY3V0ZUxpc3RlbmVyKGZ1bmN0aW9uICh2bm9kZTogVk5vZGUpIHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiAodm5vZGUuZWxtKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IGVsbSA9ICh2bm9kZS5lbG0gYXMgRWxlbWVudCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlmIChlbG1bMF0gJiYgZWxtWzBdLnZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgbmV4dFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbG1bMF0udmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICBmaWx0ZXIkLnNoYW1lZnVsbHlTZW5kTmV4dChcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChjbGVhciwgMTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIoKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2dHJlZSQsXG4gICAgICAgIEV2ZW50czogZXZ0LFxuICAgICAgICB2YWx1ZSQ6IGNvbmNhdChpbml0aWFsVmFsdWUkLCBlbWl0dGVkVmFsdWUkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZHJvcGRvd24gY29tcG9uZW50IGZvciBjYXB0dXJpbmcgdXNlciBpbnB1dC5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICBhY3RpdmU/OiBib29sZWFuLFxuICAgKiAgaW5pdGlhbD86IGFueVxuICAgKiAgZGVmYXVsdD86IHN0cmluZ1xuICAgKiAgc2VsZWN0aW9uPzogYm9vbGVhblxuICAgKiAgaW5saW5lPzogYm9vbGVhblxuICAgKiAgZmxvYXRpbmc/OiBib29sZWFuXG4gICAqICBsb2FkaW5nPzogYm9vbGVhblxuICAgKiAgZGlzYWJsZWQ/OiBib29sZWFuXG4gICAqICBzY3JvbGxpbmc/OiBib29sZWFuXG4gICAqICBzZWFyY2g/OiBib29sZWFuXG4gICAqICBjb21wYWN0PzogYm9vbGVhblxuICAgKiAgc2l6ZT86IFNpemVcbiAgICogIGNvbG9yPzogQ29sb3JcbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogQXJyYXkgb2Yge1xuICAgKiAgYm9keTogRE9NQ29udGVudCxcbiAgICogIHZhbHVlOiBhbnksXG4gICAqICBoZWFkZXI/OiBib29sZWFuLFxuICAgKiAgZml0dGVkPzogYm9vbGVhbixcbiAgICogIGRpc2FibGVkPzogYm9vbGVhbixcbiAgICogIGFjdGl2ZT86IGJvb2xlYW5cbiAgICogfVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IENvbnRlbnQ8YW55PiA9IHt9LCBjOiBDb250ZW50PGFueT4gPSBbXSk6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSAocE9yQyBpbnN0YW5jZW9mIEFycmF5KSA/IHt9IDogcE9yQztcbiAgICBsZXQgY29udGVudCA9IChwT3JDIGluc3RhbmNlb2YgQXJyYXkpID8gcE9yQyA6IGM7XG4gICAgY29uc3QgaWNvbiA9IEljb24ucmVuZGVyKHt9LCBJY29uVHlwZS5Ecm9wZG93bik7XG4gICAgY29uc3QgbWVudSA9IE1lbnUucmVuZGVyKHt9LCBjb250ZW50KTtcbiAgICBjb25zdCBpdGVtID0gY29udGVudC5maWx0ZXIoaXRlbSA9PiBpdGVtLmFjdGl2ZSlbMF07XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKHByb3BzKSB9IH0sIFtcbiAgICAgIGdldFRleHQoaXRlbSwgcHJvcHMpLFxuICAgICAgcHJvcHMuc2VhcmNoID8gaW5wdXQoeyBwcm9wczogeyBjbGFzc05hbWU6IFwic2VhcmNoXCIgfSB9KSA6IFwiXCIsXG4gICAgICBpY29uLCBtZW51XG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcHM6IFByb3BzLCBhY3RpdmU/KSB7XG4gICAgbGV0IGNsYXNzTmFtZSA9IFwidWlcIjtcbiAgICBpZiAocHJvcHMucmlnaHRBbGlnbmVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgcmlnaHRcIjtcblxuICAgIH1cbiAgICBpZiAocHJvcHMuc2VsZWN0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VsZWN0aW9uXCI7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmlubGluZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGlubGluZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmxvYXRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBmbG9hdGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMubG9hZGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGxvYWRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNjcm9sbGluZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHNjcm9sbGluZ1wiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc2VhcmNoKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgc2VhcmNoXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb21wYWN0KSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgY29tcGFjdFwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMucG9pbnRpbmcpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBwb2ludGluZ1wiO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlIHx8IHByb3BzLmFjdGl2ZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIGRyb3Bkb3duXCI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VGV4dDxWPihpdGVtOiBEcm9wZG93bkl0ZW08Vj4sIHByb3BzOiBQcm9wcyk6IFZOb2RlIHtcbiAgICBpZiAodHlwZW9mIChwcm9wcy5zdGF0aWMpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcInRleHRcIiB9IH0sIHByb3BzLnN0YXRpYyk7XG4gICAgfVxuICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImRlZmF1bHQgdGV4dFwiIH0gfSwgcHJvcHMuZGVmYXVsdCk7XG4gICAgfVxuICAgIHJldHVybiBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwidGV4dFwiIH0gfSwgaXRlbS5ib2R5KTtcbiAgfVxuICBmdW5jdGlvbiBmaWx0ZXJDb250ZW50PFY+KGl0ZW06IERyb3Bkb3duSXRlbTxWPiwgZmlsdGVyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBmdW5jdGlvbiBmKG5vZGU6IFZOb2RlKSB7XG4gICAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgIHJldHVybiBub2RlLnRleHQuaW5kZXhPZihmaWx0ZXIpICE9PSAtMSB8fCAhZmlsdGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGMgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChmKGMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIChpdGVtLmJvZHkgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICByZXR1cm4gKGl0ZW0uYm9keSBhcyBzdHJpbmcpLmluZGV4T2YoZmlsdGVyKSAhPT0gLTEgfHwgIWZpbHRlcjtcbiAgICB9XG4gICAgaWYgKCEoaXRlbS5ib2R5IGFzIGFueSkucHVzaCkge1xuICAgICAgcmV0dXJuIGYoaXRlbS5ib2R5IGFzIFZOb2RlKTtcbiAgICB9XG4gICAgZm9yIChsZXQgYyBpbiAoaXRlbS5ib2R5IGFzIFZOb2RlKS5jaGlsZHJlbikge1xuICAgICAgaWYgKGYoYykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjbGFzcyBFeGVjdXRlTGlzdGVuZXIge1xuICAgIGY6IEZ1bmN0aW9uO1xuICAgIGNvbnN0cnVjdG9yKGY6IEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLmYgPSBmO1xuICAgIH1cbiAgICBuZXh0KGkpIHsgdGhpcy5mKGkpOyB9XG4gICAgZXJyb3IoaSkgeyB9XG4gICAgY29tcGxldGUoKSB7IH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvZHJvcGRvd24vaW5kZXgudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9jaGVja2JveFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZGltbWVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9kcm9wZG93blwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbW9kYWxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BvcHVwXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wcm9ncmVzc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNpdGlvblwiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvaW5kZXgudHMiLCJpbXBvcnQgeyBET01Db250ZW50LCBWTm9kZSwgRE9NU291cmNlIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCBpc29sYXRlIGZyb20gXCJAY3ljbGUvaXNvbGF0ZVwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB4cywgeyBTdHJlYW0sIE1lbW9yeVN0cmVhbSB9IGZyb20gXCJ4c3RyZWFtXCI7XG5cbmltcG9ydCB7IEljb25UeXBlLCBEaXJlY3Rpb24sIEFuaW1hdGlvbn0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgeyBEaW1tZXJ9IGZyb20gXCIuLi8uLi9tb2R1bGVzL2RpbW1lclwiO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gXCIuLi8uLi9lbGVtZW50cy9pY29uXCI7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4uLy4uL21vZHVsZXMvdHJhbnNpdGlvblwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1vZGFsIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgaGVhZGVyPzogc3RyaW5nO1xuICAgIGludmVydGVkPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE1vZGFsU291cmNlcyB7XG4gICAgRE9NOiBET01Tb3VyY2U7XG4gICAgb24kOiBTdHJlYW08Ym9vbGVhbj47XG4gICAgcHJvcHMkPzogU3RyZWFtPFByb3BzPjtcbiAgICBjb250ZW50JD86IFN0cmVhbTxET01Db250ZW50PjtcbiAgICBhY3Rpb25zJD86IFN0cmVhbTxET01Db250ZW50PjtcbiAgICB0YXJnZXQkPzogU3RyZWFtPFZOb2RlPjtcbiAgfVxuICAvKipcbiAgICogQSBtb2RhbCBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgY29udGVudCBpbiBhIG1vZGFsLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgdHlwZSBvZiBwcm9wZXJ0aWVzIGluIHByb3BzJDpcbiAgICogICBoZWFkZXI6IFN0cmluZyAtIFRoZSBoZWFkZXIgdGV4dCBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICogICBvbiQ6IFN0cmVhbTxCb29sZWFuPiAtIFdoZW4gdG8gZGlzcGxheSB0aGUgbW9kYWwuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogTW9kYWxTb3VyY2VzKSB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBNb2RhbFNvdXJjZXMpIHtcbiAgICAgIHNvdXJjZXMucHJvcHMkID0gc291cmNlcy5wcm9wcyQgPyBzb3VyY2VzLnByb3BzJCA6IHhzLm9mKHsgb24kOiB4cy5vZihmYWxzZSkgfSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcbiAgICAgIHNvdXJjZXMuYWN0aW9ucyQgPSBzb3VyY2VzLmFjdGlvbnMkID8gc291cmNlcy5hY3Rpb25zJCA6IHhzLm9mKFwiXCIpO1xuICAgICAgc291cmNlcy50YXJnZXQkID0gc291cmNlcy50YXJnZXQkID8gc291cmNlcy50YXJnZXQkIDogeHMub2YoXCJwYWdlXCIpO1xuXG4gICAgICBjb25zdCBjbG9zZUljb24gPSBJY29uLnJ1bih7IERPTTogc291cmNlcy5ET00sIHByb3BzJDogeHMub2YoeyBsaW5rOiB0cnVlIH0pLCBjb250ZW50JDogeHMub2YoSWNvblR5cGUuQ2xvc2UpIH0pO1xuICAgICAgY29uc3QgY2xvc2UkID0gY2xvc2VJY29uLkV2ZW50cyhcImNsaWNrXCIpLm1hcFRvKGZhbHNlKTtcblxuICAgICAgLyoqKiBSZW5kZXIgbW9kYWwgKioqL1xuICAgICAgbGV0IGRpbW1lcmNsaWNrJHByb3h5ID0geHMuY3JlYXRlKCkgYXMgU3RyZWFtPGJvb2xlYW4+O1xuICAgICAgY29uc3Qgb24kID0geHMubWVyZ2Uoc291cmNlcy5vbiQsIGRpbW1lcmNsaWNrJHByb3h5LCBjbG9zZSQpLnJlbWVtYmVyKCkgYXMgTWVtb3J5U3RyZWFtPGJvb2xlYW4+O1xuICAgICAgY29uc3QgY29udGVudCQgPSB4cy5jb21iaW5lKHNvdXJjZXMucHJvcHMkLCBzb3VyY2VzLmNvbnRlbnQkLCBzb3VyY2VzLmFjdGlvbnMkLCBjbG9zZUljb24uRE9NKS5tYXAoXG4gICAgICAgIChbcHJvcHMsIGNvbnRlbnQsIGFjdGlvbnMsIGljb25dKSA9PlxuICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJ1aSBzY3JvbGxpbmcgYWN0aXZlIG1vZGFsXCIgfSB9LCBbXG4gICAgICAgICAgICBpY29uLFxuICAgICAgICAgICAgZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBcImhlYWRlclwiIH0gfSwgcHJvcHMuaGVhZGVyKSxcbiAgICAgICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJjb250ZW50XCIgfSB9LCBjb250ZW50KSxcbiAgICAgICAgICAgIGFjdGlvbnMgPyBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwiYWN0aW9uc1wiIH0gfSwgYWN0aW9ucykgOiBcIlwiXG4gICAgICAgICAgXSlcbiAgICAgICkucmVtZW1iZXIoKTtcblxuICAgICAgLyoqKiBBbmltYXRpb24gKioqL1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiQgPSBvbiRcbiAgICAgICAgLmZvbGQoKHByZXZBbmltLCBhY3RpdmUpID0+IHByZXZBbmltLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5vbmVcbiAgICAgICAgICA/ICh7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogYWN0aXZlID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dCB9KVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiBBbmltYXRpb24uRmFkZSwgZGlyZWN0aW9uOiBhY3RpdmUgPyBEaXJlY3Rpb24uSW4gOiBEaXJlY3Rpb24uT3V0XG4gICAgICAgICAgfVxuICAgICAgICAsICh7IGFuaW1hdGlvbjogQW5pbWF0aW9uLk5vbmUsIGRpcmVjdGlvbjogRGlyZWN0aW9uLk5vbmUgfSkpO1xuICAgICAgY29uc3QgYW5pbWF0ZWRDb250ZW50ID0gVHJhbnNpdGlvbi5ydW4oeyBET006IHNvdXJjZXMuRE9NLCB0YXJnZXQkOiBjb250ZW50JCwgYXJncyQ6IHRyYW5zaXRpb24kIH0pO1xuXG4gICAgICAvKioqIEFjdGl2YXRlIGRpbW1lciAqKiovXG4gICAgICBsZXQgZGltbWVyQ29udGVudCQgPSBhbmltYXRlZENvbnRlbnQuRE9NLm1hcCh4ID0+IFt4XSk7XG4gICAgICBjb25zdCBkaW1tZXIgPSBEaW1tZXIucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgdGFyZ2V0JDogc291cmNlcy50YXJnZXQkLCBhcmdzJDogb24kLCBjb250ZW50JDogZGltbWVyQ29udGVudCQgfSwgc291cmNlcy5wcm9wcyQubWFwKHggPT4geC5pbnZlcnRlZCkpO1xuICAgICAgY29uc3QgZGltbWVyY2xpY2skID0gZGltbWVyLkV2ZW50cyhcIm1vdXNlZG93blwiKVxuICAgICAgICAuZmlsdGVyKGV2dCA9PiBldnQuc3JjRWxlbWVudCA9PT0gKGV2dCBhcyBNb3VzZUV2ZW50KS5jdXJyZW50VGFyZ2V0KVxuICAgICAgICAubWFwVG8oZmFsc2UpO1xuICAgICAgZGltbWVyY2xpY2skcHJveHkuaW1pdGF0ZShkaW1tZXJjbGljayQpO1xuXG4gICAgICBjb25zdCBmYWRlT3V0RW5kJCA9IG9uJC5tYXAoYWN0aXZlID0+ICFhY3RpdmUgPyBkaW1tZXIuRXZlbnRzKFwiYW5pbWF0aW9uZW5kXCIpIDogeHMubmV2ZXIoKSkuZmxhdHRlbigpLm1hcFRvKGZhbHNlKTtcbiAgICAgIC8vIGNvbnN0IGFjdGl2ZSQgPSB4cy5tZXJnZShzb3VyY2VzLm9uJCwgZmFkZU91dEVuZCQpLnJlbWVtYmVyKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmUkOiB4cy5tZXJnZShzb3VyY2VzLm9uJCwgZmFkZU91dEVuZCQpLFxuICAgICAgICBET006IGRpbW1lci5ET00sXG4gICAgICAgIEV2ZW50czogYW5pbWF0ZWRDb250ZW50LkV2ZW50c1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaXNvbGF0ZWRNYWluID0gaXNvbGF0ZShtYWluKTtcbiAgICByZXR1cm4gaXNvbGF0ZWRNYWluKHNvdXJjZXMpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kdWxlcy9tb2RhbC9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJVGFyZ2V0dGluZ0NvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNpemUsIEFuaW1hdGlvbiwgRGlyZWN0aW9uIH0gZnJvbSBcIi4uLy4uL2VudW1zXCI7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSBcIi4uLy4uL21vZHVsZXMvdHJhbnNpdGlvblwiO1xuaW1wb3J0IHsgZGl2IH0gZnJvbSBcIkBjeWNsZS9kb21cIjtcbmltcG9ydCB4cywgeyBTdHJlYW0gfSBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcInhzdHJlYW0vZXh0cmEvZGVib3VuY2VcIjtcbmltcG9ydCBkcm9wUmVwZWF0cyBmcm9tIFwieHN0cmVhbS9leHRyYS9kcm9wUmVwZWF0c1wiO1xuaW1wb3J0IGRlbGF5IGZyb20gXCJ4c3RyZWFtL2V4dHJhL2RlbGF5XCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUG9wdXAge1xuICBleHBvcnQgaW50ZXJmYWNlIEFyZ3Mge1xuICAgIGFjdGl2ZTogYm9vbGVhbjtcbiAgICBhdHRhY2htZW50OiBQb3B1cEF0dGFjaG1lbnQ7XG4gICAgaGVhZGVyPzogc3RyaW5nO1xuICAgIHdpZGU/OiBib29sZWFuO1xuICAgIHZlcnlXaWRlPzogYm9vbGVhbjtcbiAgICBmbG93aW5nPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgc2l6ZT86IFNpemU7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIElUZXRoZXJlZEludGVyYWN0aXZlQ29tcG9uZW50U2lua3MgZXh0ZW5kcyBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgdGV0aGVyOiBhbnk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlczxWTm9kZSwgQXJncywgRE9NQ29udGVudD4pOiBJVGV0aGVyZWRJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzIHtcbiAgICBmdW5jdGlvbiBtYWluKHNvdXJjZXM6IElUYXJnZXR0aW5nQ29tcG9uZW50U291cmNlczxWTm9kZSwgQXJncywgRE9NQ29udGVudD4pIHtcbiAgICAgIHNvdXJjZXMuYXJncyQgPSBzb3VyY2VzLmFyZ3MkID8gc291cmNlcy5hcmdzJCA6IHhzLm9mKHsgYWN0aXZlOiBmYWxzZSwgYXR0YWNobWVudDogUG9wdXBBdHRhY2htZW50LkJvdHRvbUxlZnQgfSk7XG4gICAgICBzb3VyY2VzLmNvbnRlbnQkID0gc291cmNlcy5jb250ZW50JCA/IHNvdXJjZXMuY29udGVudCQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgYXJncyQgPSBzb3VyY2VzLmFyZ3MkLnJlbWVtYmVyKCk7XG4gICAgICBjb25zdCB2VHJlZSQgPSB4cy5jb21iaW5lKGFyZ3MkLCBzb3VyY2VzLmNvbnRlbnQkKS5tYXAoXG4gICAgICAgIChbYXJncywgY29udGVudF0pID0+IHJlbmRlcihhcmdzLCBjb250ZW50KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbW91c2VsZWF2ZSRwcm94eSA9IHhzLmNyZWF0ZSgpO1xuICAgICAgY29uc3QgbW91c2VlbnRlciRwcm94eSA9IHhzLmNyZWF0ZSgpO1xuICAgICAgY29uc3QgYWN0aXZlJCA9IGFyZ3MkLm1hcChhcmcgPT4gYXJnLmFjdGl2ZSA/IERpcmVjdGlvbi5JbiA6IERpcmVjdGlvbi5PdXQpLmRyb3AoMSk7XG4gICAgICBjb25zdCB0aW1lciQgPSBhY3RpdmUkLm1hcChkaXIgPT4gZGlyID09PSBEaXJlY3Rpb24uT3V0ID8geHMub2YoRGlyZWN0aW9uLk91dClcbiAgICAgICAgOiB4cy5vZihEaXJlY3Rpb24uT3V0KS5jb21wb3NlKGRlbGF5KDEwMDApKS5lbmRXaGVuKG1vdXNlZW50ZXIkcHJveHkpXG4gICAgICApLmZsYXR0ZW4oKTtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0geHMubWVyZ2UoYWN0aXZlJCwgbW91c2VsZWF2ZSRwcm94eSwgdGltZXIkKVxuICAgICAgICAubWFwKGRpciA9PiAoe1xuICAgICAgICAgIGFuaW1hdGlvbjogQW5pbWF0aW9uLkZhZGUsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJcbiAgICAgICAgfSkpXG4gICAgICAgIC5jb21wb3NlKGRyb3BSZXBlYXRzKFxuICAgICAgICAgIChhLCBiKSA9PiAoYSBhcyBhbnkpLmRpcmVjdGlvbiA9PT0gKGIgYXMgYW55KS5kaXJlY3Rpb25cbiAgICAgICAgICAgICYmIChhIGFzIGFueSkuYW5pbWF0aW9uID09PSAoYiBhcyBhbnkpLmFuaW1hdGlvblxuICAgICAgICApKVxuICAgICAgICAuc3RhcnRXaXRoKHsgYW5pbWF0aW9uOiBBbmltYXRpb24uTm9uZSwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uT3V0IH0pIGFzIFN0cmVhbTxhbnk+O1xuICAgICAgY29uc3QgYW5pbWF0ZWRQb3B1cCA9IFRyYW5zaXRpb24ucnVuKHsgRE9NOiBzb3VyY2VzLkRPTSwgdGFyZ2V0JDogdlRyZWUkLCBhcmdzJDogdHJhbnNpdGlvbiQgfSk7XG4gICAgICBjb25zdCBtb3VzZWVudGVyJCA9IGFuaW1hdGVkUG9wdXAuRXZlbnRzKFwibW91c2VlbnRlclwiKTtcbiAgICAgIGNvbnN0IG1vdXNlbGVhdmUkID0geHMubWVyZ2UoYW5pbWF0ZWRQb3B1cC5FdmVudHMoXCJtb3VzZWxlYXZlXCIpLCBtb3VzZWVudGVyJClcbiAgICAgICAgLm1hcChldnQgPT4gZXZ0LnR5cGUgPT09IFwibW91c2VlbnRlclwiID8gRGlyZWN0aW9uLkluIDogRGlyZWN0aW9uLk91dClcbiAgICAgICAgLmNvbXBvc2UoZGVib3VuY2UoMjAwKSlcbiAgICAgICAgLmZpbHRlcihkaXIgPT4gZGlyID09PSBEaXJlY3Rpb24uT3V0KTtcbiAgICAgIG1vdXNlbGVhdmUkcHJveHkuaW1pdGF0ZShtb3VzZWxlYXZlJCk7XG4gICAgICBtb3VzZWVudGVyJHByb3h5LmltaXRhdGUobW91c2VlbnRlciQpO1xuXG4gICAgICBjb25zdCBwb3B1cCQgPSBhbmltYXRlZFBvcHVwLkRPTS5yZW1lbWJlcigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiBwb3B1cCQsXG4gICAgICAgIEV2ZW50czogYW5pbWF0ZWRQb3B1cC5FdmVudHMsXG4gICAgICAgIHRldGhlcjogeHMuY29tYmluZShwb3B1cCQsIHNvdXJjZXMudGFyZ2V0JCwgYXJncyQpXG4gICAgICAgICAgLm1hcCgoW2VsZW1lbnQsIHRhcmdldCwgYXJnc10pID0+ICh7IGVsZW1lbnQsIHRhcmdldCwgYXJncyB9KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzb2xhdGVkTWFpbiA9IGlzb2xhdGUobWFpbik7XG4gICAgcmV0dXJuIGlzb2xhdGVkTWFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiByZW5kZXIoYXJnczogQXJncyA9IHsgYWN0aXZlOiB0cnVlLCBhdHRhY2htZW50OiBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTGVmdCB9LCBjb250ZW50OiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUoYXJncykgfSB9LCBbXG4gICAgICBhcmdzLmhlYWRlciA/IGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJoZWFkZXJcIiB9IH0sIGFyZ3MuaGVhZGVyKSA6IFwiXCIsXG4gICAgICBjb250ZW50XG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IEFyZ3MpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc05hbWUgPSBcInVpXCI7XG4gICAgaWYgKHByb3BzLndpZGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiB3aWRlXCI7XG4gICAgfVxuICAgIGlmIChwcm9wcy52ZXJ5V2lkZSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIHZlcnkgd2lkZVwiO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZmxvd2luZykge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIGZsb3dpbmdcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBTaXplLlRvQ2xhc3NuYW1lKHByb3BzLnNpemUpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgKz0gUG9wdXBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpICsgXCIgcG9wdXBcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG4gIGV4cG9ydCBlbnVtIFBvcHVwQXR0YWNobWVudCB7XG4gICAgVG9wTGVmdCwgVG9wTWlkZGxlLCBUb3BSaWdodCwgTGVmdENlbnRlciwgUmlnaHRDZW50ZXIsXG4gICAgQm90dG9tTGVmdCwgQm90dG9tTWlkZGxlLCBCb3R0b21SaWdodCxcbiAgICBDZW50ZXJcbiAgfVxuICBleHBvcnQgbmFtZXNwYWNlIFBvcHVwQXR0YWNobWVudCB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIFRvQ2xhc3NuYW1lKGF0dGFjaG1lbnQ6IFBvcHVwQXR0YWNobWVudCkge1xuICAgICAgc3dpdGNoIChhdHRhY2htZW50KSB7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcExlZnQ6IHJldHVybiBcIiB0b3AgbGVmdFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BNaWRkbGU6IHJldHVybiBcIiB0b3AgY2VudGVyXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcFJpZ2h0OiByZXR1cm4gXCIgdG9wIHJpZ2h0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkxlZnRDZW50ZXI6IHJldHVybiBcIiBsZWZ0IGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5SaWdodENlbnRlcjogcmV0dXJuIFwiIHJpZ2h0IGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21MZWZ0OiByZXR1cm4gXCIgYm90dG9tIGxlZnRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTWlkZGxlOiByZXR1cm4gXCIgYm90dG9tIGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21SaWdodDogcmV0dXJuIFwiIGJvdHRvbSByaWdodFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5DZW50ZXI6IHJldHVybiBcIiBjZW50ZXJcIjtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIFwiIGJvdHRvbSBsZWZ0XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGV4cG9ydCBmdW5jdGlvbiBUb1RldGhlcihhdHRhY2htZW50OiBQb3B1cEF0dGFjaG1lbnQpIHtcbiAgICAgIHN3aXRjaCAoYXR0YWNobWVudCkge1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BMZWZ0OiByZXR1cm4gXCJ0b3AgbGVmdFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BNaWRkbGU6IHJldHVybiBcInRvcCBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wUmlnaHQ6IHJldHVybiBcInRvcCByaWdodFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5MZWZ0Q2VudGVyOiByZXR1cm4gXCJsZWZ0IG1pZGRsZVwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5SaWdodENlbnRlcjogcmV0dXJuIFwicmlnaHQgbWlkZGxlXCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbUxlZnQ6IHJldHVybiBcImJvdHRvbSBsZWZ0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbU1pZGRsZTogcmV0dXJuIFwiYm90dG9tIGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21SaWdodDogcmV0dXJuIFwiYm90dG9tIHJpZ2h0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkNlbnRlcjogcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBcImJvdHRvbSBsZWZ0XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGV4cG9ydCBmdW5jdGlvbiBUb09wcG9zaXRlVGV0aGVyKGF0dGFjaG1lbnQ6IFBvcHVwQXR0YWNobWVudCkge1xuICAgICAgc3dpdGNoIChhdHRhY2htZW50KSB7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LlRvcExlZnQ6IHJldHVybiBcImJvdHRvbSByaWdodFwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Ub3BNaWRkbGU6IHJldHVybiBcImJvdHRvbSBjZW50ZXJcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuVG9wUmlnaHQ6IHJldHVybiBcImJvdHRvbSBsZWZ0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkxlZnRDZW50ZXI6IHJldHVybiBcInJpZ2h0IG1pZGRsZVwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5SaWdodENlbnRlcjogcmV0dXJuIFwibGVmdCBtaWRkbGVcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQm90dG9tTGVmdDogcmV0dXJuIFwidG9wIHJpZ2h0XCI7XG4gICAgICAgIGNhc2UgUG9wdXBBdHRhY2htZW50LkJvdHRvbU1pZGRsZTogcmV0dXJuIFwidG9wIGNlbnRlclwiO1xuICAgICAgICBjYXNlIFBvcHVwQXR0YWNobWVudC5Cb3R0b21SaWdodDogcmV0dXJuIFwidG9wIGxlZnRcIjtcbiAgICAgICAgY2FzZSBQb3B1cEF0dGFjaG1lbnQuQ2VudGVyOiByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIFwiYm90dG9tIGxlZnRcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzL3BvcHVwL2luZGV4LnRzIiwiaW1wb3J0IHsgRE9NQ29udGVudCwgVk5vZGUsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnQgfSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgU2l6ZSwgQXR0YWNobWVudCwgQ29sb3IgfSBmcm9tIFwiLi4vLi4vZW51bXNcIjtcbmltcG9ydCB4cyBmcm9tIFwieHN0cmVhbVwiO1xuaW1wb3J0IGlzb2xhdGUgZnJvbSBcIkBjeWNsZS9pc29sYXRlXCI7XG5pbXBvcnQgeyBkaXYgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIFByb2dyZXNzQmFyIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgICBhY3RpdmU/OiBib29sZWFuO1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgYXR0YWNobWVudD86IEF0dGFjaG1lbnQ7XG4gICAgc2l6ZT86IFNpemU7XG4gICAgY29sb3I/OiBDb2xvcjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIExhYmVsIGNvbXBvbmVudCB0byBhZGQgaW5mb3JtYXRpb24gdG8gY2VydGFpbiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgcHJvZ3Jlc3M6IG51bWJlciAtIFRoZSAlIG9mIHByb2dyZXNzIHRoZSBwcm9ncmVzcyBiYXIgc2hvdWxkIHJlZmxlY3QuXG4gICAqICAgYWN0aXZlPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcHJvZ3Jlc3MgYmFyIHRvIHJlZmxlY3QgYWN0aXZpdGl5LlxuICAgKiAgIGRpc2FibGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcHJvZ3Jlc3MgYmFyIHRvIGFwcGVhciBkaXNhYmxlZC5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHByb2dyZXNzIGJhciBmb3IgZGFyayBiYWNrZ3JvdW5kcy5cbiAgICogICBhdHRhY2htZW50PzogQXR0YWNobWVudCAtIFdoZXJlIHRoZSBwcm9ncmVzcyBiYXIgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICogICBjb2xvcj86IENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIEV4cGVjdHMgdGhlIGZvbGxvd2luZyB0eXBlIG9mIGNvbnRlbnQgaW4gY29udGVudCQ6IERPTUNvbnRlbnRcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBydW4oc291cmNlczogSUludGVyYWN0aXZlQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudD4pOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTaW5rcyB7XG4gICAgZnVuY3Rpb24gbWFpbihzb3VyY2VzOiBJSW50ZXJhY3RpdmVDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2YoeyBwcm9ncmVzczogMCB9KTtcbiAgICAgIHNvdXJjZXMuY29udGVudCQgPSBzb3VyY2VzLmNvbnRlbnQkID8gc291cmNlcy5jb250ZW50JCA6IHhzLm9mKFtdKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLCBjb250ZW50XSkgPT4gcmVuZGVyKHByb3BzLCBjb250ZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIERPTTogdlRyZWUkLFxuICAgICAgICBFdmVudHM6ICh0eXBlKSA9PiBzb3VyY2VzLkRPTS5zZWxlY3QoXCIucHJvZ3Jlc3NcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIExhYmVsIGNvbXBvbmVudCB0byBhZGQgaW5mb3JtYXRpb24gdG8gY2VydGFpbiBjb250ZW50LlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllYTpcbiAgICogICBwcm9ncmVzczogbnVtYmVyIC0gVGhlICUgb2YgcHJvZ3Jlc3MgdGhlIHByb2dyZXNzIGJhciBzaG91bGQgcmVmbGVjdC5cbiAgICogICBhY3RpdmU/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBwcm9ncmVzcyBiYXIgdG8gcmVmbGVjdCBhY3Rpdml0aXkuXG4gICAqICAgZGlzYWJsZWQ/OiBib29sZWFuIC0gU3R5bGVzIHRoZSBwcm9ncmVzcyBiYXIgdG8gYXBwZWFyIGRpc2FibGVkLlxuICAgKiAgIGludmVydGVkPzogYm9vbGVhbiAtIFN0eWxlcyB0aGUgcHJvZ3Jlc3MgYmFyIGZvciBkYXJrIGJhY2tncm91bmRzLlxuICAgKiAgIGF0dGFjaG1lbnQ/OiBBdHRhY2htZW50IC0gV2hlcmUgdGhlIHByb2dyZXNzIGJhciBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqICAgc2l6ZT86IFNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiAgIGNvbG9yPzogQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDogRE9NQ29udGVudFxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihwT3JDOiBQcm9wcyB8IERPTUNvbnRlbnQgPSB7cHJvZ3Jlc3M6IDB9LCBjOiBET01Db250ZW50ID0gXCJcIik6IFZOb2RlIHtcbiAgICBsZXQgcHJvcHMgPSBpc0RPTUNvbnRlbnQocE9yQykgPyB7IHByb2dyZXNzOiAwIH0gOiBwT3JDO1xuICAgIGxldCBjb250ZW50ID0gaXNET01Db250ZW50KHBPckMpID8gcE9yQyA6IGM7XG4gICAgcmV0dXJuIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogZ2V0Q2xhc3NuYW1lKHByb3BzKSB9IH0sIFtcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJiYXJcIiB9IH0sIHsgc3R5bGU6IHsgd2lkdGg6IHByb3BzLnByb2dyZXNzICsgXCIlXCIgfSB9LCBbXG4gICAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJwcm9ncmVzc1wiIH0gfSwgW3Byb3BzLnByb2dyZXNzICsgXCIlXCJdKVxuICAgICAgXSksXG4gICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IFwibGFiZWxcIiB9IH0sIGNvbnRlbnQpXG4gICAgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc25hbWUocHJvcHM6IFByb3BzKTogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aVwiO1xuICAgIGlmIChwcm9wcy5hY3RpdmUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBhY3RpdmVcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgZGlzYWJsZWRcIjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmludmVydGVkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAocHJvcHMuYXR0YWNobWVudCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBBdHRhY2htZW50LlRvQ2xhc3NuYW1lKHByb3BzLmF0dGFjaG1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChwcm9wcy5zaXplKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2xhc3NOYW1lICs9IENvbG9yLlRvQ2xhc3NuYW1lKHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgY2xhc3NOYW1lICs9IFwiIHByb2dyZXNzXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZHVsZXMvcHJvZ3Jlc3MvaW5kZXgudHMiLCJleHBvcnQgKiBmcm9tIFwiLi9zdGF0aXN0aWNcIjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy92aWV3cy9pbmRleC50cyIsImltcG9ydCB7IERPTUNvbnRlbnQsIFZOb2RlLCBJSW50ZXJhY3RpdmVFeHRyYUNvbXBvbmVudFNvdXJjZXMsIElJbnRlcmFjdGl2ZUNvbXBvbmVudFNpbmtzLCBpc0RPTUNvbnRlbnR9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBDb2xvciwgRmxvYXQsIFNpemV9IGZyb20gXCIuLi8uLi9lbnVtc1wiO1xuaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgaXNvbGF0ZSBmcm9tIFwiQGN5Y2xlL2lzb2xhdGVcIjtcbmltcG9ydCB7ZGl2fSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuXG5cbmV4cG9ydCBuYW1lc3BhY2UgU3RhdGlzdGljIHtcbiAgZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gICAgdGV4dD86IGJvb2xlYW47XG4gICAgaG9yaXpvbnRhbD86IGJvb2xlYW47XG4gICAgaW52ZXJ0ZWQ/OiBib29sZWFuO1xuICAgIGNvbG9yPzogQ29sb3I7XG4gICAgc2l6ZT86IFNpemU7XG4gICAgZmxvYXQ/OiBGbG9hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0YXRpc3RpYyBjb21wb25lbnQgdG8gc2hvdyBzdGF0aXN0aWNzLlxuICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbiBwcm9wcyQ6XG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0YXRpc3RpYyB0byBkaXNwbGF5IGhvcml6b250YWxseS5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0YXRpc3RpYyBmb3IgYSBkYXJrIGJhY2tncm91bmQuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgc3RhdGlzdGljLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHN0YXRpc3RpYy5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2hlcmUgdG8gZmxvYXQgdGhlIHN0YXRpc3RpYy5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudCBpbiBjb250ZW50JDoge30gb2ZcbiAgICogICB2YWx1ZTogU3RyaW5nfFZOb2RlIC0gVGhlIHZhbHVlIGZvciB0aGUgc3RhdGlzdGljLlxuICAgKiAgIGxhYmVsOiBTdHJpbmd8Vk5vZGUgLSBUaGUgbGFiZWwgZm9yIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgaXNUZXh0PzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIHN0YXRpc3RpYyB2YWx1ZSBmb3IgdGV4dCBiYXNlZCB2YWx1ZXMuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcnVuKHNvdXJjZXM6IElJbnRlcmFjdGl2ZUV4dHJhQ29tcG9uZW50U291cmNlczxQcm9wcywgRE9NQ29udGVudCwgRE9NQ29udGVudD4pIDogSUludGVyYWN0aXZlQ29tcG9uZW50U2lua3Mge1xuICAgIGZ1bmN0aW9uIG1haW4oc291cmNlczogSUludGVyYWN0aXZlRXh0cmFDb21wb25lbnRTb3VyY2VzPFByb3BzLCBET01Db250ZW50LCBET01Db250ZW50Pikge1xuICAgICAgc291cmNlcy5wcm9wcyQgPSBzb3VyY2VzLnByb3BzJCA/IHNvdXJjZXMucHJvcHMkIDogeHMub2Yoe30pO1xuICAgICAgc291cmNlcy5jb250ZW50JCA9IHNvdXJjZXMuY29udGVudCQgPyBzb3VyY2VzLmNvbnRlbnQkIDogeHMub2YoXCJcIik7XG4gICAgICBzb3VyY2VzLmV4dHJhcyQgPSBzb3VyY2VzLmV4dHJhcyQgPyBzb3VyY2VzLmV4dHJhcyQgOiB4cy5vZihcIlwiKTtcblxuICAgICAgY29uc3QgdlRyZWUkID0geHMuY29tYmluZShzb3VyY2VzLnByb3BzJCwgc291cmNlcy5jb250ZW50JCkubWFwKFxuICAgICAgICAoW3Byb3BzLGNvbnRlbnRdKSA9PiByZW5kZXIocHJvcHMsIGNvbnRlbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRE9NOiB2VHJlZSQsXG4gICAgICAgIEV2ZW50czogKHR5cGUpID0+IHNvdXJjZXMuRE9NLnNlbGVjdChcIi5zdGF0aXN0aWNcIikuZXZlbnRzKHR5cGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpc29sYXRlZE1haW4gPSBpc29sYXRlKG1haW4pO1xuICAgIHJldHVybiBpc29sYXRlZE1haW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzdGF0aXN0aWMgY29tcG9uZW50IHRvIHNob3cgc3RhdGlzdGljcy5cbiAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgaG9yaXpvbnRhbD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0YXRpc3RpYyB0byBkaXNwbGF5IGhvcml6b250YWxseS5cbiAgICogICBpbnZlcnRlZD86IGJvb2xlYW4gLSBTdHlsZXMgdGhlIHN0YXRpc3RpYyBmb3IgYSBkYXJrIGJhY2tncm91bmQuXG4gICAqICAgY29sb3I/OiBDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgc3RhdGlzdGljLlxuICAgKiAgIHNpemU/OiBTaXplIC0gVGhlIHNpemUgb2YgdGhlIHN0YXRpc3RpYy5cbiAgICogICBmbG9hdD86IEZsb2F0IC0gV2hlcmUgdG8gZmxvYXQgdGhlIHN0YXRpc3RpYy5cbiAgICogRXhwZWN0cyB0aGUgZm9sbG93aW5nIHR5cGUgb2YgY29udGVudDoge30gb2ZcbiAgICogICB2YWx1ZTogU3RyaW5nfFZOb2RlIC0gVGhlIHZhbHVlIGZvciB0aGUgc3RhdGlzdGljLlxuICAgKiAgIGxhYmVsOiBTdHJpbmd8Vk5vZGUgLSBUaGUgbGFiZWwgZm9yIHRoZSBzdGF0aXN0aWMuXG4gICAqICAgaXNUZXh0PzogYm9vbGVhbiAtIEZvcm1hdHMgdGhlIHN0YXRpc3RpYyB2YWx1ZSBmb3IgdGV4dCBiYXNlZCB2YWx1ZXMuXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcmVuZGVyKHBPckM6IFByb3BzfERPTUNvbnRlbnQgPSB7fSwgYzpET01Db250ZW50ID0gXCJcIiwgZTpET01Db250ZW50ID0gXCJcIikgOiBWTm9kZSB7XG4gICAgbGV0IHByb3BzID0gaXNET01Db250ZW50KHBPckMpID8ge30gOnBPckM7XG4gICAgbGV0IGNvbnRlbnQgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBwT3JDIDogYztcbiAgICBsZXQgbGFiZWwgPSBpc0RPTUNvbnRlbnQocE9yQykgPyBjIDogZTtcbiAgICByZXR1cm4gZGl2KHsgcHJvcHM6IHsgY2xhc3NOYW1lOiBnZXRDbGFzc25hbWUocHJvcHMpIH19LCBbXG4gICAgICBkaXYoeyBwcm9wczogeyBjbGFzc05hbWU6IHByb3BzLnRleHQgPyBcInRleHQgdmFsdWVcIiA6IFwidmFsdWVcIn19LCBjb250ZW50KSxcbiAgICAgIGRpdih7IHByb3BzOiB7IGNsYXNzTmFtZTogXCJsYWJlbFwiIH19LCBsYWJlbClcbiAgICBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzbmFtZShwcm9wczogUHJvcHMpIDogc3RyaW5nIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJ1aSBcIjtcbiAgICBpZiAocHJvcHMuaG9yaXpvbnRhbCkgeyBcbiAgICAgICBjbGFzc05hbWUgKz0gXCIgaG9yaXpvbnRhbFwiO1xufVxuICAgIGlmIChwcm9wcy5pbnZlcnRlZCkgeyBcbiAgICAgICBjbGFzc05hbWUgKz0gXCIgaW52ZXJ0ZWRcIjtcbn1cbiAgICBpZiAodHlwZW9mKHByb3BzLmNvbG9yKSAhPT0gXCJ1bmRlZmluZWRcIikgeyBcbiAgICAgICBjbGFzc05hbWUgKz0gQ29sb3IuVG9DbGFzc25hbWUocHJvcHMuY29sb3IpO1xufVxuICAgIGlmICh0eXBlb2YocHJvcHMuc2l6ZSkgIT09IFwidW5kZWZpbmVkXCIpIHsgXG4gICAgICAgY2xhc3NOYW1lICs9IFNpemUuVG9DbGFzc25hbWUocHJvcHMuc2l6ZSk7XG59XG4gICAgaWYgKHR5cGVvZihwcm9wcy5mbG9hdCkgIT09IFwidW5kZWZpbmVkXCIpIHsgXG4gICAgICAgY2xhc3NOYW1lICs9IEZsb2F0LlRvQ2xhc3NuYW1lKHByb3BzLmZsb2F0KTtcbn1cbiAgICBjbGFzc05hbWUgKz0gXCIgc3RhdGlzdGljXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZpZXdzL3N0YXRpc3RpYy9pbmRleC50cyIsIlwidXNlIHN0cmljdFwiO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG52YXIgQ29uY2F0UHJvZHVjZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmNhdFByb2R1Y2VyKHN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gc3RyZWFtcztcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbmNhdCc7XG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICB9XG4gICAgQ29uY2F0UHJvZHVjZXIucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMuc3RyZWFtc1t0aGlzLmldLl9hZGQodGhpcyk7XG4gICAgfTtcbiAgICBDb25jYXRQcm9kdWNlci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHJlYW1zID0gdGhpcy5zdHJlYW1zO1xuICAgICAgICBpZiAodGhpcy5pIDwgc3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbXNbdGhpcy5pXS5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMub3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIENvbmNhdFByb2R1Y2VyLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdS5fbih0KTtcbiAgICB9O1xuICAgIENvbmNhdFByb2R1Y2VyLnByb3RvdHlwZS5fZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB1Ll9lKGVycik7XG4gICAgfTtcbiAgICBDb25jYXRQcm9kdWNlci5wcm90b3R5cGUuX2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHN0cmVhbXMgPSB0aGlzLnN0cmVhbXM7XG4gICAgICAgIHN0cmVhbXNbdGhpcy5pXS5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICBpZiAoKyt0aGlzLmkgPCBzdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtc1t0aGlzLmldLl9hZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1Ll9jKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25jYXRQcm9kdWNlcjtcbn0oKSk7XG4vKipcbiAqIFB1dHMgb25lIHN0cmVhbSBhZnRlciB0aGUgb3RoZXIuICpjb25jYXQqIGlzIGEgZmFjdG9yeSB0aGF0IHRha2VzIG11bHRpcGxlXG4gKiBzdHJlYW1zIGFzIGFyZ3VtZW50cywgYW5kIHN0YXJ0cyB0aGUgYG4rMWAtdGggc3RyZWFtIG9ubHkgd2hlbiB0aGUgYG5gLXRoXG4gKiBzdHJlYW0gaGFzIGNvbXBsZXRlZC4gSXQgY29uY2F0ZW5hdGVzIHRob3NlIHN0cmVhbXMgdG9nZXRoZXIuXG4gKlxuICogTWFyYmxlIGRpYWdyYW06XG4gKlxuICogYGBgdGV4dFxuICogLS0xLS0yLS0tMy0tLTQtfFxuICogLi4uLi4uLi4uLi4uLi4uLS1hLWItYy0tZC18XG4gKiAgICAgICAgICAgY29uY2F0XG4gKiAtLTEtLTItLS0zLS0tNC0tLWEtYi1jLS1kLXxcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBjb25jYXQgZnJvbSAneHN0cmVhbS9leHRyYS9jb25jYXQnXG4gKlxuICogY29uc3Qgc3RyZWFtQSA9IHhzLm9mKCdhJywgJ2InLCAnYycpXG4gKiBjb25zdCBzdHJlYW1CID0geHMub2YoMTAsIDIwLCAzMClcbiAqIGNvbnN0IHN0cmVhbUMgPSB4cy5vZignWCcsICdZJywgJ1onKVxuICpcbiAqIGNvbnN0IG91dHB1dFN0cmVhbSA9IGNvbmNhdChzdHJlYW1BLCBzdHJlYW1CLCBzdHJlYW1DKVxuICpcbiAqIG91dHB1dFN0cmVhbS5hZGRMaXN0ZW5lcih7XG4gKiAgIG5leHQ6ICh4KSA9PiBjb25zb2xlLmxvZyh4KSxcbiAqICAgZXJyb3I6IChlcnIpID0+IGNvbnNvbGUuZXJyb3IoZXJyKSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdjb25jYXQgY29tcGxldGVkJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGZhY3RvcnkgdHJ1ZVxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTEgQSBzdHJlYW0gdG8gY29uY2F0ZW5hdGUgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTIgQSBzdHJlYW0gdG8gY29uY2F0ZW5hdGUgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLiBUd29cbiAqIG9yIG1vcmUgc3RyZWFtcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnRzLlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5mdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdmFyIHN0cmVhbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzdHJlYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgaW5kZXhfMS5TdHJlYW0obmV3IENvbmNhdFByb2R1Y2VyKHN0cmVhbXMpKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvbmNhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHN0cmVhbS9leHRyYS9jb25jYXQuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xudmFyIEZDSUwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZDSUwob3V0LCBvcCkge1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICBGQ0lMLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMub3V0Ll9uKHQpO1xuICAgIH07XG4gICAgRkNJTC5wcm90b3R5cGUuX2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMub3V0Ll9lKGVycik7XG4gICAgfTtcbiAgICBGQ0lMLnByb3RvdHlwZS5fYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcC5sZXNzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRkNJTDtcbn0oKSk7XG52YXIgRmxhdHRlbkNvbmNPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxhdHRlbkNvbmNPcGVyYXRvcihpbnMpIHtcbiAgICAgICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmbGF0dGVuQ29uY3VycmVudGx5JztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAxOyAvLyBudW1iZXIgb2Ygb3V0ZXJzIGFuZCBpbm5lcnMgdGhhdCBoYXZlIG5vdCB5ZXQgZW5kZWRcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgIH1cbiAgICBGbGF0dGVuQ29uY09wZXJhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICAgIH07XG4gICAgRmxhdHRlbkNvbmNPcGVyYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMTtcbiAgICAgICAgdGhpcy5vdXQgPSBudWxsO1xuICAgIH07XG4gICAgRmxhdHRlbkNvbmNPcGVyYXRvci5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdS5fYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGbGF0dGVuQ29uY09wZXJhdG9yLnByb3RvdHlwZS5fbiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmICghdSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgcy5fYWRkKG5ldyBGQ0lMKHUsIHRoaXMpKTtcbiAgICB9O1xuICAgIEZsYXR0ZW5Db25jT3BlcmF0b3IucHJvdG90eXBlLl9lID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgdSA9IHRoaXMub3V0O1xuICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHUuX2UoZXJyKTtcbiAgICB9O1xuICAgIEZsYXR0ZW5Db25jT3BlcmF0b3IucHJvdG90eXBlLl9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxlc3MoKTtcbiAgICB9O1xuICAgIHJldHVybiBGbGF0dGVuQ29uY09wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuRmxhdHRlbkNvbmNPcGVyYXRvciA9IEZsYXR0ZW5Db25jT3BlcmF0b3I7XG4vKipcbiAqIEZsYXR0ZW5zIGEgXCJzdHJlYW0gb2Ygc3RyZWFtc1wiLCBoYW5kbGluZyBtdWx0aXBsZSBjb25jdXJyZW50IG5lc3RlZCBzdHJlYW1zXG4gKiBzaW11bHRhbmVvdXNseS5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgc3RyZWFtIGlzIGEgc3RyZWFtIHRoYXQgZW1pdHMgc3RyZWFtcywgdGhlbiB0aGlzIG9wZXJhdG9yIHdpbGxcbiAqIHJldHVybiBhbiBvdXRwdXQgc3RyZWFtIHdoaWNoIGlzIGEgZmxhdCBzdHJlYW06IGVtaXRzIHJlZ3VsYXIgZXZlbnRzLiBUaGVcbiAqIGZsYXR0ZW5pbmcgaGFwcGVucyBjb25jdXJyZW50bHkuIEl0IHdvcmtzIGxpa2UgdGhpczogd2hlbiB0aGUgaW5wdXQgc3RyZWFtXG4gKiBlbWl0cyBhIG5lc3RlZCBzdHJlYW0sICpmbGF0dGVuQ29uY3VycmVudGx5KiB3aWxsIHN0YXJ0IGltaXRhdGluZyB0aGF0XG4gKiBuZXN0ZWQgb25lLiBXaGVuIHRoZSBuZXh0IG5lc3RlZCBzdHJlYW0gaXMgZW1pdHRlZCBvbiB0aGUgaW5wdXQgc3RyZWFtLFxuICogKmZsYXR0ZW5Db25jdXJyZW50bHkqIHdpbGwgYWxzbyBpbWl0YXRlIHRoYXQgbmV3IG9uZSwgYnV0IHdpbGwgY29udGludWUgdG9cbiAqIGltaXRhdGUgdGhlIHByZXZpb3VzIG5lc3RlZCBzdHJlYW1zIGFzIHdlbGwuXG4gKlxuICogTWFyYmxlIGRpYWdyYW06XG4gKlxuICogYGBgdGV4dFxuICogLS0rLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tXG4gKiAgIFxcICAgICAgICBcXFxuICogICAgXFwgICAgICAgLS0tLTEtLS0tMi0tLTMtLVxuICogICAgLS1hLS1iLS0tLWMtLS0tZC0tLS0tLS0tXG4gKiAgICAgZmxhdHRlbkNvbmN1cnJlbnRseVxuICogLS0tLS1hLS1iLS0tLWMtMS0tZC0yLS0tMy0tXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuIHtTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5Db25jdXJyZW50bHkoaW5zKSB7XG4gICAgcmV0dXJuIG5ldyBpbmRleF8xLlN0cmVhbShuZXcgRmxhdHRlbkNvbmNPcGVyYXRvcihpbnMpKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZsYXR0ZW5Db25jdXJyZW50bHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mbGF0dGVuQ29uY3VycmVudGx5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94c3RyZWFtL2V4dHJhL2ZsYXR0ZW5Db25jdXJyZW50bHkuanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9